<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>IV. 宏编程 - Anatomy In First Rust Programming Class 🦀</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust编程第一课的代码为例进行基础代码分析">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="md-favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/pagetoc/pagetoc_style.css">
        <link rel="stylesheet" href="assets/css/mdbook-admonish.css">

        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="anatomy_logic.html"><strong aria-hidden="true">1.</strong> 源码阅读逻辑</a></li><li class="chapter-item expanded "><a href="intro_gdb_lldb.html"><strong aria-hidden="true">2.</strong> gdb/lldb调试或查看内存结构</a></li><li class="chapter-item expanded "><a href="get_hands_dirty.html"><strong aria-hidden="true">3.</strong> get hands dirty</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="httpie.html"><strong aria-hidden="true">3.1.</strong> httpie</a></li><li class="chapter-item expanded "><a href="rgrep.html"><strong aria-hidden="true">3.2.</strong> rgrep</a></li><li class="chapter-item expanded "><a href="thumbor.html"><strong aria-hidden="true">3.3.</strong> thumbor</a></li><li class="chapter-item expanded "><a href="queryer.html"><strong aria-hidden="true">3.4.</strong> queryer</a></li></ol></li><li class="chapter-item expanded "><a href="rust_cores.html"><strong aria-hidden="true">4.</strong> Rust核心深入</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_stack_heap_ownership_lifetime_memory.html"><strong aria-hidden="true">4.1.</strong> I. 从栈堆、所有权、生命周期开始内存管理</a></li><li class="chapter-item expanded "><a href="2_type_system.html"><strong aria-hidden="true">4.2.</strong> II. 类型系统</a></li><li class="chapter-item expanded "><a href="3_data_structure.html"><strong aria-hidden="true">4.3.</strong> III. 数据结构</a></li><li class="chapter-item expanded "><a href="4_macros.html" class="active"><strong aria-hidden="true">4.4.</strong> IV. 宏编程</a></li><li class="chapter-item expanded "><a href="5_concurrency_async.html"><strong aria-hidden="true">4.5.</strong> V. 并发与异步</a></li><li class="chapter-item expanded "><a href="6_unsafe_ffi.html"><strong aria-hidden="true">4.6.</strong> VI. 混合编程</a></li></ol></li><li class="chapter-item expanded "><a href="kv_server_design.html"><strong aria-hidden="true">5.</strong> kv server设计与实现</a></li><li class="chapter-item expanded "><a href="custom_axum_async_web_framework.html"><strong aria-hidden="true">6.</strong> 构建自己的类axum异步Web框架</a></li><li class="chapter-item expanded affix "><a href="checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Anatomy In First Rust Programming Class 🦀</h1>
            <h4 class="menu-bar"><a href="https://kuanhsiaokuo.github.io/think-tool-kit/">保持批判，有所取舍，知行合一, 方见真我</a> -- 练武不练功
                到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/geektime-tyr-rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <style>.extended-markdown-table {
    display: grid;
}

.extended-markdown-table > div {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 3px 20px;
    border-bottom: 1px solid var(--table-border-color);
    border-right: 1px solid var(--table-border-color);
}

.extended-markdown-table > div.extended-markdown-left-border {
    border-left: 1px solid var(--table-border-color);
}

.extended-markdown-table > div.extended-markdown-header {
    text-align: center;
    background: var(--table-header-bg);
    border-bottom: 1px solid var(--table-header-bg);
    border-right: 1px solid var(--table-header-bg);
    font-weight: bold;
}

.extended-markdown-table > div.extended-markdown-header.extended-markdown-left-border {
    border-left: 1px solid var(--table-header-bg);
}
</style>
<h1 id="iv-宏编程"><a class="header" href="#iv-宏编程">IV 宏编程</a></h1>
<!--ts-->
<ul>
<li><a href="#iv-%E5%AE%8F%E7%BC%96%E7%A8%8B">IV 宏编程</a>
<ul>
<li><a href="#%E8%B5%84%E6%96%99">资料</a></li>
<li><a href="#%E5%AE%8F%E7%9A%84%E5%88%86%E7%B1%BB">宏的分类</a></li>
<li><a href="#%E8%A1%A8%E6%A0%BC">表格</a>
<ul>
<li><a href="#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%9A%84%E7%BC%BA%E9%99%B7%E8%80%8C%E5%90%8E%E6%9C%89%E4%BA%86%E8%BF%87%E7%A8%8B%E5%AE%8F">声明宏的缺陷，而后有了过程宏</a></li>
<li><a href="#%E5%A3%B0%E6%98%8E%E5%AE%8Fdeclarative-macros-macro_rulesbang">声明宏(declarative macros): macro_rules!(bang)</a></li>
<li><a href="#%E8%BF%87%E7%A8%8B%E5%AE%8F%E6%B7%B1%E5%BA%A6%E5%AE%9A%E5%88%B6%E4%B8%8E%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81">过程宏：深度定制与生成代码</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%AE%8F">函数宏</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E5%AE%8F">属性宏</a></li>
<li><a href="#%E6%B4%BE%E7%94%9F%E5%AE%8F">派生宏</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A3%B0%E6%98%8E%E5%AE%8F">声明宏</a>
<ul>
<li><a href="#rust%E5%B8%B8%E7%94%A8%E5%A3%B0%E6%98%8E%E5%AE%8F">Rust常用声明宏</a>
<ul>
<li><a href="#println">println!</a></li>
<li><a href="#writeln">writeln!</a></li>
<li><a href="#eprintln">eprintln!</a></li>
</ul>
</li>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a>
<ul>
<li><a href="#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%A4%BA%E6%84%8F%E5%9B%BE">声明宏示意图</a></li>
<li><a href="#macro_rules%E5%AE%9A%E4%B9%89">macro_rules!定义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
</ul>
</li>
<li><a href="#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%94%A8%E5%88%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B">声明宏用到的参数类型</a></li>
</ul>
</li>
<li><a href="#%E8%BF%87%E7%A8%8B%E5%AE%8F%E6%89%8B%E5%B7%A5%E5%AE%9A%E4%B9%89%E5%9B%BE">过程宏手工定义图</a>
<ul>
<li><a href="#cargotoml%E6%B7%BB%E5%8A%A0proc-macro%E5%A3%B0%E6%98%8E">Cargo.toml添加proc-macro声明</a></li>
</ul>
</li>
<li>[过程函数宏: #[proc_macro]](#过程函数宏-proc_macro)
<ul>
<li><a href="#srclibrs%E5%AE%9A%E4%B9%89%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E5%AE%8F">src/lib.rs:定义过程函数宏</a></li>
<li><a href="#examplesqueryrs%E4%BD%BF%E7%94%A8">examples/query.rs:使用</a></li>
</ul>
</li>
<li>[过程派生宏: /#[proc_macro_devive(DeriveMacroName)]](#过程派生宏-proc_macro_devivederivemacroname)
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%B4%BE%E7%94%9F%E5%AE%8F">常用派生宏</a>
<ul>
<li>[#[derive(Debug)]](#derivedebug)</li>
</ul>
</li>
<li><a href="#%E5%8E%9F%E5%A7%8B%E5%AE%9E%E7%8E%B0builder%E6%A8%A1%E5%BC%8F">原始实现builder模式</a>
<ul>
<li><a href="#%E6%83%B3%E5%88%B0%E8%BE%BE%E5%88%B0%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E7%9A%84%E6%95%88%E6%9E%9C">想到达到链式调用的效果</a></li>
<li><a href="#%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E5%AE%9A%E4%B9%89">可以这样定义</a></li>
<li><a href="#%E4%BD%86%E6%98%AF%E6%9C%89%E7%82%B9%E7%B9%81%E7%90%90%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9F%E5%AE%8F%E6%B4%BE%E7%94%9F%E5%87%BA%E8%BF%99%E4%BA%9B%E4%BB%A3%E7%A0%81">但是有点繁琐，可以使用派生宏派生出这些代码</a></li>
</ul>
</li>
<li><a href="#%E6%B4%BE%E7%94%9F%E5%AE%8F%E6%80%9D%E8%B7%AF">派生宏思路</a>
<ul>
<li><a href="#%E8%A6%81%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88">要生成的代码模版</a></li>
<li><a href="#%E6%9E%84%E5%BB%BA%E5%AF%B9%E5%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">构建对应数据结构</a></li>
<li><a href="#srclibrs-%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9F%E5%AE%8F%E4%BB%8Etokenstream%E6%8A%BD%E5%8F%96%E5%87%BA%E6%83%B3%E8%A6%81%E7%9A%84%E4%BF%A1%E6%81%AF">src/lib.rs: 使用派生宏从TokenStream抽取出想要的信息</a></li>
<li><a href="#examplesraw_commandrs-%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%B4%BE%E7%94%9F%E5%AE%8F%E6%8A%BD%E5%8F%96">examples/raw_command.rs: 使用这个派生宏抽取</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C%E6%9F%A5%E7%9C%8B%E8%8E%B7%E5%8F%96%E7%9A%84tokenstream">运行，查看获取的TokenStream</a></li>
<li><a href="#srcraw_builderrs-%E4%BD%BF%E7%94%A8anyhow%E4%B8%8Easkama%E6%8A%BD%E5%8F%96tokenstream%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF">src/raw_builder.rs: 使用anyhow与askama抽取TokenStream中的信息</a></li>
<li><a href="#templatesbuilderj2-%E4%B8%8A%E9%9D%A2askama%E7%94%A8%E5%88%B0%E7%9A%84jinja2%E6%A8%A1%E7%89%88">templates/builder.j2: 上面askama用到的jinja2模版</a></li>
<li><a href="#srcraw_builderrs-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%BA%94%E6%8A%BD%E5%8F%96%E6%96%B9%E6%B3%95">src/raw_builder.rs: 实现对应抽取方法</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8synquote%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E6%A8%A1%E7%89%88">使用syn/quote可以不用自己定义模版</a></li>
</ul>
</li>
<li><a href="#%E8%BF%87%E7%A8%8B%E5%B1%9E%E6%80%A7%E5%AE%8F-proc_macro_derivemacro_name-attributesattr_name">过程属性宏: proc_macro_derive(macro_name, attributes(attr_name))</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8synquote%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AE%8F">使用syn/quote定义属性宏</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Sun Sep 25 13:14:01 UTC 2022 -->
<!--te-->
<h2 id="资料"><a class="header" href="#资料">资料</a></h2>
<ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html">宏 - Rust 程序设计语言 简体中文版</a></li>
<li><a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/reference/macros-by-example.html">Macros By Example - The Rust Reference</a></li>
</ul>
<h2 id="宏的分类"><a class="header" href="#宏的分类">宏的分类</a></h2>
<h2 id="表格"><a class="header" href="#表格">表格</a></h2>
<div class="extended-markdown-table"><div class="extended-markdown-header extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 1; grid-row-end: 2">Macros</div><div class="extended-markdown-header" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2">Define</div><div class="extended-markdown-header" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2">Usage</div><div class="extended-markdown-header" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 1; grid-row-end: 2">note</div><div class="extended-markdown-header" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 1; grid-row-end: 2">Example</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 2; grid-row-end: 3">Declarative Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 2; grid-row-end: 3">#[macro_export]/macro_rules! macro_name{}</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 2; grid-row-end: 3">macro_name!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 2; grid-row-end: 3"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 2; grid-row-end: 3">println!</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 3; grid-row-end: 4">Function Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 3; grid-row-end: 4">#[proc_macros]/pub fn macro_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 3; grid-row-end: 4">macro_name!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 3; grid-row-end: 4">advanced declarative macro</div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 3; grid-row-end: 4"></div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 4; grid-row-end: 5">Derive Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 4; grid-row-end: 5">#[proc_macros_derive(DeriveMacroName)]/pub  fn other_fn_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 4; grid-row-end: 5">DeriveMacroName!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 4; grid-row-end: 5"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 4; grid-row-end: 5">#[derive(Debug)]</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 5; grid-row-end: 6">Attritubte Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 5; grid-row-end: 6">#[proc_macros_derive(AttributeMacroName, attributes(attr_name))]/pub  fn other_fn_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 5; grid-row-end: 6">Only Diff with DeriveMacro when define struct</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 5; grid-row-end: 6"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 5; grid-row-end: 6"></div></div>
<h3 id="声明宏的缺陷而后有了过程宏"><a class="header" href="#声明宏的缺陷而后有了过程宏">声明宏的缺陷，而后有了过程宏</a></h3>
<ul>
<li><a href="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/#limitationsofdeclarativemacros">Macros in Rust: A tutorial with examples - LogRocket Blog</a></li>
</ul>
<div id="admonition-为什么过程宏和声明宏那么像" class="admonition tip">
<div class="admonition-title">
<p>为什么过程宏和声明宏那么像</p>
<p><a class="admonition-anchor-link" href="#admonition-为什么过程宏和声明宏那么像"></a></p>
</div>
<div>
<blockquote>
<p>过程宏的缺陷</p>
</blockquote>
<ol>
<li>缺乏对宏自动完成和扩展的支持 </li>
<li>调试声明性宏很困难 </li>
<li>修改能力有限 </li>
<li>较大的二进制文件 </li>
<li>更长的编译时间（这适用于声明性宏和过程宏）</li>
</ol>
<blockquote>
<p>过程宏是语法树级别的转换
过程宏是宏的更高级版本。过程宏允许你扩展现有的 Rust 语法。它接受任意输入并返回有效的 Rust 代码。 
过程宏是将 TokenStream 作为输入并返回另一个 Token Stream 的函数。过程宏操作输入 TokenStream 以产生输出流。</p>
</blockquote>
</div>
</div>
<h3 id="声明宏declarative-macros-macro_rulesbang"><a class="header" href="#声明宏declarative-macros-macro_rulesbang">声明宏(declarative macros): macro_rules!(bang)</a></h3>
<blockquote>
<p>对代码模版做简单替换
声明宏可以用 macro_rules! 来描述, 如果重复性的代码无法用函数来封装，那么声明宏就是一个好的选择</p>
</blockquote>
<h3 id="过程宏深度定制与生成代码"><a class="header" href="#过程宏深度定制与生成代码">过程宏：深度定制与生成代码</a></h3>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Za411q7LQ">Rust 过程宏(1): 如何硬生生解析和手写过程宏</a></li>
</ul>
<blockquote>
<p>主要以如何使用 function-like macro 在不依赖于 syn / quote 的情况下，把 Json Schema 在编译期转换成 Rust struct。主要目的是让大家熟悉基本的处理 TokenStream 的思路</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Fu411m7W7">Rust 过程宏(2): 使用 syn/quote 撰写过程宏</a></li>
</ul>
<blockquote>
<p>主要通过一个 derive Builder 宏，来展示使用 syn/quote 如何开发过程宏。</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV1dr4y1v74n">Rust 过程宏(3): 使用 darling 处理 attributes</a></li>
</ul>
<blockquote>
<p>做个收尾，对上一讲的 derive macro 支持 attributes。 我们可以直接解析 attributes 相关的 TokenStream，也可以使用 darling 这个很方便的库，直接把 attributes 像
Clap/Structopts 那样收集到一个数据结构中，然后再进一步处理。</p>
</blockquote>
<div id="admonition-总结" class="admonition info">
<div class="admonition-title">
<p>总结</p>
<p><a class="admonition-anchor-link" href="#admonition-总结"></a></p>
</div>
<div>
<p>这三讲的内容虽然简单，但足以应付大家绝大多数宏编程的需求。
其实我们现在对 syn 库的使用还只是一个皮毛，我们还没有深入
去撰写自己的数据结构去实现 Parse trait，像 DeriveInput 
那样可以直接把 TokenStream 转换成我们想要的东西。</p>
<p>大家感兴趣的话，可以自行去看 syn 库的文档。</p>
</div>
</div>
<h4 id="函数宏"><a class="header" href="#函数宏">函数宏</a></h4>
<p>看起来像函数的宏，但在编译期进行处理.</p>
<blockquote>
<p>sqlx 用函数宏来处理SQL query、tokio使用属性宏 #[tokio::main] 来引入 runtime。
它们可以帮助目标代码的实现逻辑变得更加简单， 但一般除非特别必要，否则并不推荐写。
并没有特定的使用场景</p>
</blockquote>
<h4 id="属性宏"><a class="header" href="#属性宏">属性宏</a></h4>
<p>可以在其他代码块上添加属性，为代码块提供更多功能。</p>
<h4 id="派生宏"><a class="header" href="#派生宏">派生宏</a></h4>
<p>为 derive属性添加新的功能。这是我们平时使用最多的宏，比如 #[derive(Debug)].</p>
<blockquote>
<p>如果你定义的 trait 别人实现起来有固定的模式可循，那么可以考虑为其构建派生宏</p>
</blockquote>
<h2 id="声明宏"><a class="header" href="#声明宏">声明宏</a></h2>
<h3 id="rust常用声明宏"><a class="header" href="#rust常用声明宏">Rust常用声明宏</a></h3>
<h4 id="println"><a class="header" href="#println">println!</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.println.html">println in std - Rust</a></li>
<li><a href="https://blog.csdn.net/jiangjkd/article/details/120994956">Rust声明宏println剖析_一线coder的博客-CSDN博客_rust 声明宏</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
#[allow_internal_unstable(print_internals, format_args_nl)]
macro_rules! println {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ({
        $crate::io::_print($crate::format_args_nl!($($arg)*));
    })
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="writeln"><a class="header" href="#writeln">writeln!</a></h4>
<blockquote>
<p>可以将内容输入到指定文件</p>
</blockquote>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.writeln.html">writeln in std - Rust</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/148945862">rust入门笔记—翻译rust write！宏 - 知乎</a></li>
</ul>
<pre><code class="language-shell">cargo run --example raw_command &gt; examples/raw_command_output.txt
</code></pre>
<h4 id="eprintln"><a class="header" href="#eprintln">eprintln!</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.eprintln.html">eprintln in std - Rust</a></li>
</ul>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<h4 id="声明宏示意图"><a class="header" href="#声明宏示意图">声明宏示意图</a></h4>
<figure><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="633px" preserveAspectRatio="none" style="width:474px;height:633px;background:#FFFFFF;" version="1.1" viewBox="0 0 474 633" width="474px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="26.2969" id="_title" style="stroke:none;stroke-width:1.0;" width="136" x="167.5" y="15"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="126" x="172.5" y="32.9951">声明宏定义使用流程</text><ellipse cx="51" cy="57.2969" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><path d="M101,77.2969 L101,389.9531 L462,389.9531 L462,87.2969 L452,77.2969 L101,77.2969 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M452,77.2969 L452,87.2969 L462,87.2969 L452,77.2969 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="12" x="107" y="94.3638">1.</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="99" x="123" y="94.3638">[macro_export]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="149" x="107" y="109.4966">macro_rules! my_vec {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="299" x="123" y="124.6294">// 没带任何参数的 my_vec，我们创建一个空的 vec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="324" x="123" y="139.7622">// 注意，由于宏要在调用的地方展开，我们无法预测调用</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="316" x="123" y="154.895">// 者的环境是否已经 做了相关的 use，所以我们使用的</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="194" x="123" y="170.0278">// 代码最好带着完整的命名空间。</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="48" x="123" y="185.1606">() =&gt; {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="125" x="139" y="200.2935">std::vec::Vec::new()</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="12" x="123" y="215.4263">};</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="162" x="123" y="230.5591">// 处理 my_vec![1, 2, 3, 4]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="133" x="123" y="245.6919">($($el:expr),*) =&gt; ({</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="139" y="260.8247">let mut v = std::vec::Vec::new();</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="100" x="139" y="275.9575">$(v.push($el);)*</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="7" x="139" y="291.0903">v</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="17" x="123" y="306.2231">});</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="138" x="123" y="321.356">// 处理 my_vec![0; 10]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="155" x="123" y="336.4888">($el:expr; $n:expr) =&gt; {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="180" x="139" y="351.6216">std::vec::from_elem($el, $n)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="123" y="366.7544">}</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="107" y="381.8872">}</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="11" y="216.6406"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="21" y="237.7793">定义声明宏</text><path d="M101,399.9531 L101,621.8125 L318,621.8125 L318,409.9531 L308,399.9531 L101,399.9531 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M308,399.9531 L308,409.9531 L318,409.9531 L308,399.9531 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="70" x="107" y="417.02">fn main() {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="144" x="123" y="432.1528">let mut v = my_vec![];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="64" x="123" y="447.2856">v.push(1);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="159" x="123" y="462.4185">// 调用时可以使用 [], (), {}</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="177" x="123" y="477.5513">let _v = my_vec!(1, 2, 3, 4);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="177" x="123" y="492.6841">let _v = my_vec![1, 2, 3, 4];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="180" x="123" y="507.8169">let v = my_vec! {1, 2, 3, 4};</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="522.9497">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="4" x="107" y="538.0825"> </text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="553.2153">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="123" y="568.3481">//</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="146" x="123" y="583.481">let v = my_vec![1; 10];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="598.6138">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="107" y="613.7466">}</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="11" y="493.8984"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="21" y="515.0371">使用声明宏</text><line style="stroke:#181818;stroke-width:1.0;" x1="51" x2="51" y1="67.2969" y2="216.6406"/><polygon fill="#181818" points="47,206.6406,51,216.6406,55,206.6406,51,210.6406" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="51" x2="51" y1="250.6094" y2="493.8984"/><polygon fill="#181818" points="47,483.8984,51,493.8984,55,483.8984,51,487.8984" style="stroke:#181818;stroke-width:1.0;"/></g></svg></figure>
<h4 id="macro_rules定义"><a class="header" href="#macro_rules定义">macro_rules!定义</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">#[macro_export]
macro_rules! my_vec {
    // 没带任何参数的 my_vec，我们创建一个空的 vec
    // 注意，由于宏要在调用的地方展开，我们无法预测调用
    // 者的环境是否已经 做了相关的 use，所以我们使用的
    // 代码最好带着完整的命名空间。
    () =&gt; {
        std::vec::Vec::new()
    };
    // 处理 my_vec![1, 2, 3, 4]
    ($($el:expr),*) =&gt; ({
        let mut v = std::vec::Vec::new();
        $(v.push($el);)*
        v
    });
    // 处理 my_vec![0; 10]
    ($el:expr; $n:expr) =&gt; {
        std::vec::from_elem($el, $n)
    }
}
</code></pre></pre>
<div id="admonition-elexpr-" class="admonition info">
<div class="admonition-title">
<p>$($el:expr), *)</p>
<p><a class="admonition-anchor-link" href="#admonition-elexpr-"></a></p>
</div>
<div>
<ol>
<li>在声明宏中，条件捕获的参数使用 $ 开头的标识符来声明。</li>
<li>每个参数都需要提供类型，这里<code>expr</code>代表表达式，所以 $el:expr 是说把匹配到的表达式命名为 $el。</li>
<li>$(…),* 告诉编译器可以匹配任意多个以逗号分隔的表达式，然后捕获到的每一个表达式可以用 $el 来访问。</li>
<li>由于匹配的时候匹配到一个 $(…)* （我们可以不管分隔符），在执行的代码块中，我们也要相应地使用 $(…)* 展开。</li>
<li>所以这句 $(v.push($el);)* 相当于匹配出多少个 $el就展开多少句 push 语句。</li>
</ol>
</div>
</div>
<h4 id="使用"><a class="header" href="#使用">使用</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let mut v = my_vec![];
    v.push(1);
    // 调用时可以使用 [], (), {}
    let _v = my_vec!(1, 2, 3, 4);
    let _v = my_vec![1, 2, 3, 4];
    let v = my_vec! {1, 2, 3, 4};
    println!(&quot;{:?}&quot;, v);

    println!(&quot;{:?}&quot;, v);
    //
    let v = my_vec![1; 10];
    println!(&quot;{:?}&quot;, v);
}
</code></pre></pre>
<h3 id="声明宏用到的参数类型"><a class="header" href="#声明宏用到的参数类型">声明宏用到的参数类型</a></h3>
<div id="admonition-类型列表" class="admonition info">
<div class="admonition-title">
<p>类型列表</p>
<p><a class="admonition-anchor-link" href="#admonition-类型列表"></a></p>
</div>
<div>
<ol>
<li>item，比如一个函数、结构体、模块等。 </li>
<li>block，代码块。比如一系列由花括号包裹的表达式和语句。 </li>
<li>stmt，语句。比如一个赋值语句。 </li>
<li>pat，模式。 </li>
<li>expr，表达式。刚才的例子使用过了。 </li>
<li>ty，类型。比如 Vec。 </li>
<li>ident，标识符。比如一个变量名。 </li>
<li>path，路径。比如：foo、::std::mem::replace、transmute::&lt;_, int&gt;。 </li>
<li>meta，元数据。一般是在 #[…] 和 #![…] 属性内部的数据。 </li>
<li>tt，单个的 token 树。 </li>
<li>vis，可能为空的一个 Visibility 修饰符。比如 pub、pub(crate)</li>
</ol>
</div>
</div>
<h2 id="过程宏手工定义图"><a class="header" href="#过程宏手工定义图">过程宏手工定义图</a></h2>
<blockquote>
<p>过程宏要比声明宏要复杂很多，不过无论是哪一种过程宏，本质都是一样的，都涉及要把 <code>输入的 TokenStream</code> 处理成<code>输出的 TokenStream</code>。</p>
</blockquote>
<div id="admonition-函数宏与派生宏定义使用区别" class="admonition info">
<div class="admonition-title">
<p>函数宏与派生宏定义使用区别</p>
<p><a class="admonition-anchor-link" href="#admonition-函数宏与派生宏定义使用区别"></a></p>
</div>
<div>
<figure><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="528px" preserveAspectRatio="none" style="width:1956px;height:528px;background:#FFFFFF;" version="1.1" viewBox="0 0 1956 528" width="1956px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="26.2969" id="_title" style="stroke:none;stroke-width:1.0;" width="136" x="908.5" y="15"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="126" x="913.5" y="32.9951">过程宏定义使用流程</text><rect fill="none" height="20.9531" style="stroke:none;stroke-width:1.0;" width="1923" x="15" y="50.042"/><ellipse cx="210" cy="85.9951" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><path d="M20,112.8467 L20,153.1123 L160,153.1123 L160,122.8467 L150,112.8467 L20,112.8467 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M150,112.8467 L150,122.8467 L160,122.8467 L150,112.8467 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="24" x="26" y="129.9136">[lib]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="119" x="26" y="145.0464">proc-macro = true</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="170" y="115.9951"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="180" y="137.1338">打开过程宏</text><line style="stroke:#000000;stroke-width:1.5;" x1="15" x2="15" y1="50.042" y2="516.0732"/><path d="M350,163.1123 L350,294.1748 L709,294.1748 L709,173.1123 L699,163.1123 L350,163.1123 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M699,163.1123 L699,173.1123 L709,173.1123 L699,163.1123 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="12" x="356" y="180.1792">1.</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="86" x="372" y="180.1792">[proc_macro]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="338" x="356" y="195.312">pub fn query(input: TokenStream) -&gt; TokenStream {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="220" x="372" y="210.4448">// 只有修改代码之后再次编译才会执行</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="147" x="372" y="225.5776">println!("{:#?}", input);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="245" x="372" y="240.7104">"fn hello() { println!(\"Hello world!\"); }"</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="50" x="388" y="255.8433">.parse()</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="60" x="388" y="270.9761">.unwrap()</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="356" y="286.1089">}</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="260" y="211.6592"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="270" y="232.7979">定义过程宏</text><line style="stroke:#000000;stroke-width:1.5;" x1="254" x2="254" y1="50.042" y2="516.0732"/><path d="M719,304.1748 L719,420.1045 L1278,420.1045 L1278,314.1748 L1268,304.1748 L719,304.1748 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1268,304.1748 L1268,314.1748 L1278,314.1748 L1268,304.1748 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="123" x="725" y="321.2417">use macros::query;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="4" x="725" y="336.3745"> </text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="70" x="725" y="351.5073">fn main() {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="317" x="741" y="366.6401">// query!(SELECT * FROM users WHERE age &gt; 10);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="522" x="741" y="381.7729">query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="40" x="741" y="396.9058">hello()</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="725" y="412.0386">}</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="1288" y="345.1553"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="1298" y="366.2939">使用过程宏</text><line style="stroke:#000000;stroke-width:1.5;" x1="714" x2="714" y1="50.042" y2="516.0732"/><path d="M1377,444.5225 L1377,469.6553 L1759,469.6553 L1759,454.5225 L1749,444.5225 L1377,444.5225 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1749,444.5225 L1749,454.5225 L1759,454.5225 L1749,444.5225 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="361" x="1383" y="461.5894">cargo run --example query &gt; examples/query_output.txt</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="163" x="1769" y="440.1045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="1779" y="461.2432">查看打印的TokenStream</text><ellipse cx="1850.5" cy="505.0732" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="1850.5" cy="505.0732" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><line style="stroke:#000000;stroke-width:1.5;" x1="1372" x2="1372" y1="50.042" y2="516.0732"/><line style="stroke:#000000;stroke-width:1.5;" x1="1936" x2="1936" y1="50.042" y2="516.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="210" x2="210" y1="95.9951" y2="115.9951"/><polygon fill="#181818" points="206,105.9951,210,115.9951,214,105.9951,210,109.9951" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="1850.5" x2="1850.5" y1="474.0732" y2="494.0732"/><polygon fill="#181818" points="1846.5,484.0732,1850.5,494.0732,1854.5,484.0732,1850.5,488.0732" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="210" x2="210" y1="149.9639" y2="168.3115"/><line style="stroke:#181818;stroke-width:1.0;" x1="210" x2="300" y1="168.3115" y2="168.3115"/><line style="stroke:#181818;stroke-width:1.0;" x1="300" x2="300" y1="168.3115" y2="211.6592"/><polygon fill="#181818" points="296,201.6592,300,211.6592,304,201.6592,300,205.6592" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="300" x2="300" y1="245.6279" y2="299.1748"/><line style="stroke:#181818;stroke-width:1.0;" x1="300" x2="1328" y1="299.1748" y2="299.1748"/><line style="stroke:#181818;stroke-width:1.0;" x1="1328" x2="1328" y1="299.1748" y2="345.1553"/><polygon fill="#181818" points="1324,335.1553,1328,345.1553,1332,335.1553,1328,339.1553" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="1328" x2="1328" y1="379.124" y2="417.1143"/><line style="stroke:#181818;stroke-width:1.0;" x1="1328" x2="1850.5" y1="417.1143" y2="417.1143"/><line style="stroke:#181818;stroke-width:1.0;" x1="1850.5" x2="1850.5" y1="417.1143" y2="440.1045"/><polygon fill="#181818" points="1846.5,430.1045,1850.5,440.1045,1854.5,430.1045,1850.5,434.1045" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="99" x="85" y="66.75">Cargo.toml</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="74" x="447" y="66.75">src/lib.rs</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="162" x="962" y="66.75">examples/调用代码</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="79" x="1614.5" y="66.75">Terminal</text></g></svg></figure>
<hr />
<figure><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="2031px" preserveAspectRatio="none" style="width:1179px;height:2031px;background:#FFFFFF;" version="1.1" viewBox="0 0 1179 2031" width="1179px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="42.5938" id="_title" style="stroke:none;stroke-width:1.0;" width="276" x="450" y="15"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="266" x="455" y="32.9951">过程派生宏两种定义及属性宏对比使用流程</text><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="182" x="497" y="49.292">（具体内容看详细版泳道图）</text><rect fill="none" height="20.9531" style="stroke:none;stroke-width:1.0;" width="1146" x="15" y="66.3389"/><ellipse cx="117.5" cy="102.292" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="155" x="40" y="132.292"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="131" x="54" y="153.4307">手工抽取TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="50" y="167.3994">定义派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="75.5" y="200.2295"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="89.5" y="221.3682">打开过程宏</text><ellipse cx="117.5" cy="795.8115" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="193" x="21" y="825.8115"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="169" x="35" y="846.9502">syn/quote抽取TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="31" y="860.9189">为DeriveInput定义派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="75.5" y="893.749"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="89.5" y="914.8877">打开过程宏</text><ellipse cx="117.5" cy="1357.7256" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="193" x="21" y="1387.7256"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="169" x="35" y="1408.8643">syn/quote抽取TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="31" y="1422.833">为DeriveInput定义属性宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="75.5" y="1455.6631"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="89.5" y="1476.8018">打开过程宏</text><line style="stroke:#000000;stroke-width:1.5;" x1="15" x2="15" y1="66.3389" y2="2019.1553"/><rect fill="#FAEBD7" height="1952.8164" style="stroke:#FAEBD7;stroke-width:1.0;" width="469" x="218" y="66.3389"/><path d="M228,250.4678 L228,305.8662 A0,0 0 0 0 228,305.8662 L488,305.8662 A0,0 0 0 0 488,305.8662 L488,282.167 L508,278.167 L488,274.167 L488,260.4678 L478,250.4678 L228,250.4678 A0,0 0 0 0 228,250.4678 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M478,250.4678 L478,260.4678 L488,260.4678 L478,250.4678 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="190" x="234" y="267.5347">1. 分别定义BuilderContext和Fd</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="239" x="234" y="282.6675">2. BuilderContext处理jinja模版数据结构</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="109" x="234" y="297.8003">3. Fd描述每个field</text><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="175" x="508" y="254.1982"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132" x="518" y="275.3369">使用anyhow与askama</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="155" x="518" y="289.3057">抽取TokenStream中的信息</text><rect fill="#AAAAAA" height="75.875" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="145" x="523" y="325.8662"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="125" x="533" y="347.0049">templates/builder.j2</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="4" x="533" y="360.9736"> </text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="116" x="533" y="374.9424">编写与tokenstream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="93" x="533" y="388.9111">对应的jinja2模版</text><path d="M279.5,411.7412 L279.5,557.9365 A0,0 0 0 0 279.5,557.9365 L517.5,557.9365 A0,0 0 0 0 517.5,557.9365 L517.5,488.8389 L537.5,484.8389 L517.5,480.8389 L517.5,421.7412 L507.5,411.7412 L279.5,411.7412 A0,0 0 0 0 279.5,411.7412 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M507.5,411.7412 L507.5,421.7412 L517.5,421.7412 L507.5,411.7412 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="200" x="285.5" y="428.8081">1. Fd实现new方法处理TokenTree</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="201" x="285.5" y="443.9409">2. BuilderContext实现下列方法：</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="38" x="285.5" y="459.0737">- new:</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="185" x="317.5" y="474.2065">从 TokenStream 中提取信息，</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="124" x="317.5" y="489.3394">构建 BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="55" x="285.5" y="504.4722">- render:</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="176" x="317.5" y="519.605">把jinja2模版渲染成字符串代码</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="148" x="317.5" y="534.7378">&gt; render里面用到split和</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="131" x="333.5" y="549.8706">get_struct_fields方法</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="116" x="537.5" y="467.8545"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="547.5" y="488.9932">实现对应抽取方法</text><path d="M289,959.1201 L289,984.2529 L500,984.2529 L500,969.1201 L490,959.1201 L289,959.1201 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M490,959.1201 L490,969.1201 L500,969.1201 L490,959.1201 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="190" x="295" y="976.187">1. 同样定义BuilderContext和Fd</text><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="151" x="520" y="947.7178"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="118" x="530" y="968.8564">使用syn与quote抽取</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="131" x="530" y="982.8252">TokenStream中的信息</text><path d="M273.5,1005.6553 L273.5,1151.8506 L499.5,1151.8506 L499.5,1015.6553 L489.5,1005.6553 L273.5,1005.6553 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M489.5,1005.6553 L489.5,1015.6553 L499.5,1015.6553 L489.5,1005.6553 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="201" x="279.5" y="1022.7222">1. 比起手动方式，BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="171" x="295.5" y="1037.855">和Fd还需要实现From Trait。</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="200" x="279.5" y="1052.9878">2. 接着Fd就不需要再处理，主要在</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="94" x="295.5" y="1068.1206">BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="188" x="279.5" y="1083.2534">3. BuilderContext实现下列方法</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="127" x="295.5" y="1098.3862">- render: 用到quote!</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="189" x="295.5" y="1113.519">- gen_optionized_fields(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="140" x="295.5" y="1128.6519">- gen_methods(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="131" x="295.5" y="1143.7847">- gen_assigns(&amp;self)</text><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="152" x="519.5" y="1054.7842"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108" x="529.5" y="1075.9229">不需要自己手动定义</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132" x="529.5" y="1089.8916">抽取模版，直接实现方法</text><path d="M223,1513.4678 L223,1553.7334 L500,1553.7334 L500,1523.4678 L490,1513.4678 L223,1513.4678 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M490,1513.4678 L490,1523.4678 L500,1523.4678 L490,1513.4678 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="207" x="229" y="1530.5347">1. 定义Opts、Fd、BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="256" x="229" y="1545.6675">2. 比起派生宏，多了Opts用于捕获Fd的属性</text><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="151" x="520" y="1509.6318"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="118" x="530" y="1530.7705">使用syn与quote抽取</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="131" x="530" y="1544.7393">TokenStream中的信息</text><path d="M236.5,1567.5693 L236.5,1683.499 L499.5,1683.499 L499.5,1577.5693 L489.5,1567.5693 L236.5,1567.5693 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M489.5,1567.5693 L489.5,1577.5693 L499.5,1577.5693 L489.5,1567.5693 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="242" x="242.5" y="1584.6362">1. 和派生宏一样，给Fd、BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="158" x="258.5" y="1599.769">和Fd还需要实现From Trait</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="227" x="242.5" y="1614.9019">2. BuilderContext同样实现下列方法：</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="127" x="258.5" y="1630.0347">- render: 用到quote!</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="189" x="258.5" y="1645.1675">- gen_optionized_fields(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="140" x="258.5" y="1660.3003">- gen_methods(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="131" x="258.5" y="1675.4331">- gen_assigns(&amp;self)</text><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="152" x="519.5" y="1601.5654"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108" x="529.5" y="1622.7041">不需要自己手动定义</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132" x="529.5" y="1636.6729">抽取模版，直接实现方法</text><line style="stroke:#000000;stroke-width:1.5;" x1="218" x2="218" y1="66.3389" y2="2019.1553"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="729" y="577.9365"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="739" y="599.0752">定义过程派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="729" y="1171.8506"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="739" y="1192.9893">定义过程派生宏</text><rect fill="#F1F1F1" height="151.75" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="176" x="693" y="1703.499"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="703" y="1724.6377">定义过程派生宏</text><line style="stroke:#181818;stroke-width:1.0;" x1="693" x2="869" y1="1732.4678" y2="1732.4678"/><line style="stroke:#181818;stroke-width:1.0;" x1="693" x2="869" y1="1734.4678" y2="1734.4678"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="703" y="1748.6064">和派生宏不同的是</text><line style="stroke:#181818;stroke-width:1.0;" x1="693" x2="869" y1="1756.4365" y2="1756.4365"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72" x="703" y="1772.5752">这里多了一个</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="155" x="703" y="1786.5439">attributes(builder) 属性，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="703" y="1800.5127">这是告诉编译器，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108" x="703" y="1814.4814">请允许代码中出现的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="12" x="703" y="1828.4502">1.</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="87" x="719" y="1828.4502">[builder(...)]，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="156" x="703" y="1842.4189">它是我这个宏认识并要处理的</text><line style="stroke:#000000;stroke-width:1.5;" x1="687" x2="687" y1="66.3389" y2="2019.1553"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="909" y="631.9053"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="919" y="653.0439">使用派生宏抽取</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="909" y="1225.8193"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="919" y="1246.958">使用派生宏抽取</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="909" y="1875.249"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="919" y="1896.3877">使用派生宏抽取</text><line style="stroke:#000000;stroke-width:1.5;" x1="874" x2="874" y1="66.3389" y2="2019.1553"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="103" x="1052" y="685.874"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="1062" y="707.0127">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="83" x="1062" y="720.9814">TokenStream</text><ellipse cx="1103.5" cy="764.8115" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="1103.5" cy="764.8115" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="91" x="1058" y="1279.7881"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="1068" y="1300.9268">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="71" x="1068" y="1314.8955">DeriveInput</text><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="91" x="1058" y="1929.2178"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="1068" y="1950.3564">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="71" x="1068" y="1964.3252">DeriveInput</text><ellipse cx="1103.5" cy="2008.1553" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="1103.5" cy="2008.1553" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><line style="stroke:#000000;stroke-width:1.5;" x1="1046" x2="1046" y1="66.3389" y2="2019.1553"/><line style="stroke:#000000;stroke-width:1.5;" x1="1159" x2="1159" y1="66.3389" y2="2019.1553"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="117.5" y1="112.292" y2="132.292"/><polygon fill="#181818" points="113.5,122.292,117.5,132.292,121.5,122.292,117.5,126.292" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="117.5" y1="180.2295" y2="200.2295"/><polygon fill="#181818" points="113.5,190.2295,117.5,200.2295,121.5,190.2295,117.5,194.2295" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="117.5" y1="805.8115" y2="825.8115"/><polygon fill="#181818" points="113.5,815.8115,117.5,825.8115,121.5,815.8115,117.5,819.8115" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="117.5" y1="873.749" y2="893.749"/><polygon fill="#181818" points="113.5,883.749,117.5,893.749,121.5,883.749,117.5,887.749" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="117.5" y1="1367.7256" y2="1387.7256"/><polygon fill="#181818" points="113.5,1377.7256,117.5,1387.7256,121.5,1377.7256,117.5,1381.7256" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="117.5" y1="1435.6631" y2="1455.6631"/><polygon fill="#181818" points="113.5,1445.6631,117.5,1455.6631,121.5,1445.6631,117.5,1449.6631" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="595.5" y1="302.1357" y2="325.8662"/><polygon fill="#181818" points="591.5,315.8662,595.5,325.8662,599.5,315.8662,595.5,319.8662" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="595.5" y1="401.7412" y2="467.8545"/><polygon fill="#181818" points="591.5,457.8545,595.5,467.8545,599.5,457.8545,595.5,461.8545" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="595.5" y1="995.6553" y2="1054.7842"/><polygon fill="#181818" points="591.5,1044.7842,595.5,1054.7842,599.5,1044.7842,595.5,1048.7842" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="595.5" y1="1557.5693" y2="1601.5654"/><polygon fill="#181818" points="591.5,1591.5654,595.5,1601.5654,599.5,1591.5654,595.5,1595.5654" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="1103.5" x2="1103.5" y1="733.8115" y2="753.8115"/><polygon fill="#181818" points="1099.5,743.8115,1103.5,753.8115,1107.5,743.8115,1103.5,747.8115" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="1103.5" x2="1103.5" y1="1977.1553" y2="1997.1553"/><polygon fill="#181818" points="1099.5,1987.1553,1103.5,1997.1553,1107.5,1987.1553,1103.5,1991.1553" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="117.5" y1="234.1982" y2="239.1982"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="595.5" y1="239.1982" y2="239.1982"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="595.5" y1="239.1982" y2="254.1982"/><polygon fill="#181818" points="591.5,244.1982,595.5,254.1982,599.5,244.1982,595.5,248.1982" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="595.5" y1="501.8232" y2="547.3799"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="781" y1="547.3799" y2="547.3799"/><line style="stroke:#181818;stroke-width:1.0;" x1="781" x2="781" y1="547.3799" y2="577.9365"/><polygon fill="#181818" points="777,567.9365,781,577.9365,785,567.9365,781,571.9365" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="781" x2="781" y1="611.9053" y2="616.9053"/><line style="stroke:#181818;stroke-width:1.0;" x1="781" x2="961" y1="616.9053" y2="616.9053"/><line style="stroke:#181818;stroke-width:1.0;" x1="961" x2="961" y1="616.9053" y2="631.9053"/><polygon fill="#181818" points="957,621.9053,961,631.9053,965,621.9053,961,625.9053" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="961" x2="961" y1="665.874" y2="670.874"/><line style="stroke:#181818;stroke-width:1.0;" x1="961" x2="1103.5" y1="670.874" y2="670.874"/><line style="stroke:#181818;stroke-width:1.0;" x1="1103.5" x2="1103.5" y1="670.874" y2="685.874"/><polygon fill="#181818" points="1099.5,675.874,1103.5,685.874,1107.5,675.874,1103.5,679.874" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="117.5" y1="927.7178" y2="932.7178"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="595.5" y1="932.7178" y2="932.7178"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="595.5" y1="932.7178" y2="947.7178"/><polygon fill="#181818" points="591.5,937.7178,595.5,947.7178,599.5,937.7178,595.5,941.7178" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="595.5" y1="1102.7217" y2="1144.7861"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="781" y1="1144.7861" y2="1144.7861"/><line style="stroke:#181818;stroke-width:1.0;" x1="781" x2="781" y1="1144.7861" y2="1171.8506"/><polygon fill="#181818" points="777,1161.8506,781,1171.8506,785,1161.8506,781,1165.8506" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="781" x2="781" y1="1205.8193" y2="1210.8193"/><line style="stroke:#181818;stroke-width:1.0;" x1="781" x2="961" y1="1210.8193" y2="1210.8193"/><line style="stroke:#181818;stroke-width:1.0;" x1="961" x2="961" y1="1210.8193" y2="1225.8193"/><polygon fill="#181818" points="957,1215.8193,961,1225.8193,965,1215.8193,961,1219.8193" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="961" x2="961" y1="1259.7881" y2="1264.7881"/><line style="stroke:#181818;stroke-width:1.0;" x1="961" x2="1103.5" y1="1264.7881" y2="1264.7881"/><line style="stroke:#181818;stroke-width:1.0;" x1="1103.5" x2="1103.5" y1="1264.7881" y2="1279.7881"/><polygon fill="#181818" points="1099.5,1269.7881,1103.5,1279.7881,1107.5,1269.7881,1103.5,1273.7881" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="1103.5" x2="1103.5" y1="1327.7256" y2="1332.7256"/><line style="stroke:#181818;stroke-width:1.0;" x1="1103.5" x2="117.5" y1="1332.7256" y2="1332.7256"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="117.5" y1="1332.7256" y2="1347.7256"/><polygon fill="#181818" points="113.5,1337.7256,117.5,1347.7256,121.5,1337.7256,117.5,1341.7256" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="117.5" y1="1489.6318" y2="1494.6318"/><line style="stroke:#181818;stroke-width:1.0;" x1="117.5" x2="595.5" y1="1494.6318" y2="1494.6318"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="595.5" y1="1494.6318" y2="1509.6318"/><polygon fill="#181818" points="591.5,1499.6318,595.5,1509.6318,599.5,1499.6318,595.5,1503.6318" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="595.5" y1="1649.5029" y2="1684.001"/><line style="stroke:#181818;stroke-width:1.0;" x1="595.5" x2="781" y1="1684.001" y2="1684.001"/><line style="stroke:#181818;stroke-width:1.0;" x1="781" x2="781" y1="1684.001" y2="1703.499"/><polygon fill="#181818" points="777,1693.499,781,1703.499,785,1693.499,781,1697.499" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="781" x2="781" y1="1855.249" y2="1860.249"/><line style="stroke:#181818;stroke-width:1.0;" x1="781" x2="961" y1="1860.249" y2="1860.249"/><line style="stroke:#181818;stroke-width:1.0;" x1="961" x2="961" y1="1860.249" y2="1875.249"/><polygon fill="#181818" points="957,1865.249,961,1875.249,965,1865.249,961,1869.249" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="961" x2="961" y1="1909.2178" y2="1914.2178"/><line style="stroke:#181818;stroke-width:1.0;" x1="961" x2="1103.5" y1="1914.2178" y2="1914.2178"/><line style="stroke:#181818;stroke-width:1.0;" x1="1103.5" x2="1103.5" y1="1914.2178" y2="1929.2178"/><polygon fill="#181818" points="1099.5,1919.2178,1103.5,1929.2178,1107.5,1919.2178,1103.5,1923.2178" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="99" x="70" y="83.0469">Cargo.toml</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="281" x="315" y="83.0469">src/&lt;对应抽取字段与方法定义&gt;.rs</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="74" x="743.5" y="83.0469">src/lib.rs</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="162" x="879" y="83.0469">examples/调用代码</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="79" x="1063" y="83.0469">Terminal</text></g></svg></figure>
</div>
</div>
<h3 id="cargotoml添加proc-macro声明"><a class="header" href="#cargotoml添加proc-macro声明">Cargo.toml添加proc-macro声明</a></h3>
<blockquote>
<p>这样，编译器才允许你使用 #[proc_macro] 相关的宏。</p>
</blockquote>
<pre><code class="language-toml  editable">[lib]
proc-macro = true
</code></pre>
<h2 id="过程函数宏-proc_macro"><a class="header" href="#过程函数宏-proc_macro">过程函数宏: #[proc_macro]</a></h2>
<blockquote>
<p>和macro_rules! 功能类似，但更为强大。</p>
</blockquote>
<h3 id="srclibrs定义过程函数宏"><a class="header" href="#srclibrs定义过程函数宏">src/lib.rs:定义过程函数宏</a></h3>
<blockquote>
<p>可以看到，都是处理TokenStream</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">mod builder;
mod builder_with_attr;
mod raw_builder;

use proc_macro::TokenStream;
use raw_builder::BuilderContext;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro]
pub fn query(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    &quot;fn hello() { println!(\&quot;Hello world!\&quot;); }&quot;
        .parse()
        .unwrap()
}

#[proc_macro_derive(RawBuilder)]
pub fn derive_raw_builder(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    BuilderContext::render(input).unwrap().parse().unwrap()
}

#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    println!(&quot;{:#?}&quot;, input);
    builder::BuilderContext::from(input).render().into()
}

#[proc_macro_derive(BuilderWithAttr, attributes(builder))]
pub fn derive_builder_with_attr(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    println!(&quot;{:#?}&quot;, input);
    builder_with_attr::BuilderContext::from(input)
        .render()
        .into()
}
</code></pre></pre>
<div id="admonition-tokenstream" class="admonition info">
<div class="admonition-title">
<p>TokenStream</p>
<p><a class="admonition-anchor-link" href="#admonition-tokenstream"></a></p>
</div>
<div>
<p>使用者可以通过 query!(…) 来调用。我们打印传入的 TokenStream，
然后把一段包含在字符串中的代码解析成 TokenStream 返回。</p>
<p>这里可以非常方便地用字符串的 parse() 方法来获得 TokenStream，
是因为 TokenStream 实现了  FromStr trait。</p>
</div>
</div>
<h3 id="examplesqueryrs使用"><a class="header" href="#examplesqueryrs使用">examples/query.rs:使用</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use macros::query;

fn main() {
    // query!(SELECT * FROM users WHERE age &gt; 10);
    query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id);
    hello()
}
</code></pre></pre>
<ol>
<li>.parse().unwrap(): 字符串自动转为TokenStream类型</li>
</ol>
<pre><code class="language-shell">cargo run --example query &gt; examples/query_output.txt
</code></pre>
<pre><code class="language-shell">TokenStream [
    Ident {
        ident: &quot;SELECT&quot;,
        span: #0 bytes(94..100),
    },
    Punct {
        ch: '*',
        spacing: Alone,
        span: #0 bytes(101..102),
    },
    Ident {
        ident: &quot;FROM&quot;,
        span: #0 bytes(103..107),
    },
    Ident {
        ident: &quot;users&quot;,
        span: #0 bytes(108..113),
    },
    Ident {
        ident: &quot;u&quot;,
        span: #0 bytes(114..115),
    },
    Ident {
        ident: &quot;JOIN&quot;,
        span: #0 bytes(116..120),
    },
    Group {
        delimiter: Parenthesis,
        stream: TokenStream [
            Ident {
                ident: &quot;SELECT&quot;,
                span: #0 bytes(122..128),
            },
            Punct {
                ch: '*',
                spacing: Alone,
                span: #0 bytes(129..130),
            },
            Ident {
                ident: &quot;from&quot;,
                span: #0 bytes(131..135),
            },
            Ident {
                ident: &quot;profiles&quot;,
                span: #0 bytes(136..144),
            },
            Ident {
                ident: &quot;p&quot;,
                span: #0 bytes(145..146),
            },
        ],
        span: #0 bytes(121..147),
    },
    Ident {
        ident: &quot;WHERE&quot;,
        span: #0 bytes(148..153),
    },
    Ident {
        ident: &quot;u&quot;,
        span: #0 bytes(154..155),
    },
    Punct {
        ch: '.',
        spacing: Alone,
        span: #0 bytes(155..156),
    },
    Ident {
        ident: &quot;id&quot;,
        span: #0 bytes(156..158),
    },
    Punct {
        ch: '=',
        spacing: Alone,
        span: #0 bytes(159..160),
    },
    Ident {
        ident: &quot;p&quot;,
        span: #0 bytes(161..162),
    },
    Punct {
        ch: '.',
        spacing: Alone,
        span: #0 bytes(162..163),
    },
    Ident {
        ident: &quot;id&quot;,
        span: #0 bytes(163..165),
    },
]
Hello world!
</code></pre>
<div id="admonition-tokenstream是一个iterator里面包含一系列的tokentree" class="admonition tip">
<div class="admonition-title">
<p>TokenStream是一个Iterator，里面包含一系列的TokenTree</p>
<p><a class="admonition-anchor-link" href="#admonition-tokenstream是一个iterator里面包含一系列的tokentree"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TokenTree {
    // 组，如果代码中包含括号，比如{} [] &lt;&gt; () ，那么内部的内容会被分析成一个Group（组）
    Group(Group), 
    // 标识符
    Ident(Ident),
    // 标点符号 
    Punct(Punct),
    // 字面量 
    Literal(Literal), 
}
<span class="boring">}
</span></code></pre></pre>
</div>
</div>
<div id="admonition-group-example" class="admonition info">
<div class="admonition-title">
<p>Group Example</p>
<p><a class="admonition-anchor-link" href="#admonition-group-example"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust">use macros::query;

fn main() {
    // query!(SELECT * FROM users WHERE age &gt; 10);
    query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id);
    hello()
}
</code></pre></pre>
</div>
</div>
<h2 id="过程派生宏-proc_macro_devivederivemacroname"><a class="header" href="#过程派生宏-proc_macro_devivederivemacroname">过程派生宏: /#[proc_macro_devive(DeriveMacroName)]</a></h2>
<blockquote>
<p>用于结构体（struct）、枚举（enum）、联合（union）类型，可为其实现函数或特征（Trait）</p>
</blockquote>
<h3 id="常用派生宏"><a class="header" href="#常用派生宏">常用派生宏</a></h3>
<h4 id="derivedebug"><a class="header" href="#derivedebug">#[derive(Debug)]</a></h4>
<h3 id="原始实现builder模式"><a class="header" href="#原始实现builder模式">原始实现builder模式</a></h3>
<h4 id="想到达到链式调用的效果"><a class="header" href="#想到达到链式调用的效果">想到达到链式调用的效果</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .current_dir(&quot;..&quot;.to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
    println!(&quot;{:?}&quot;, command);
}
</code></pre></pre>
<h4 id="可以这样定义"><a class="header" href="#可以这样定义">可以这样定义</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 这是command.rs的派生宏实现的代码样子
#[allow(dead_code)]
#[derive(Debug)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}

#[derive(Debug, Default)]
pub struct CommandBuilder {
    executable: Option&lt;String&gt;,
    args: Option&lt;Vec&lt;String&gt;&gt;,
    env: Option&lt;Vec&lt;String&gt;&gt;,
    current_dir: Option&lt;String&gt;,
}

impl Command {
    pub fn builder() -&gt; CommandBuilder {
        Default::default()
    }
}

impl CommandBuilder {
    pub fn executable(mut self, v: String) -&gt; Self {
        self.executable = Some(v.to_owned());
        self
    }

    pub fn args(mut self, v: Vec&lt;String&gt;) -&gt; Self {
        self.args = Some(v.to_owned());
        self
    }

    pub fn env(mut self, v: Vec&lt;String&gt;) -&gt; Self {
        self.env = Some(v.to_owned());
        self
    }

    pub fn current_dir(mut self, v: String) -&gt; Self {
        self.current_dir = Some(v.to_owned());
        self
    }

    pub fn build(mut self) -&gt; Result&lt;Command, &amp;'static str&gt; {
        Ok(Command {
            executable: self.executable.take().ok_or(&quot;executable must be set&quot;)?,
            args: self.args.take().ok_or(&quot;args must be set&quot;)?,
            env: self.env.take().ok_or(&quot;env must be set&quot;)?,
            current_dir: self.current_dir.take(),
        })
    }
</code></pre></pre>
<h4 id="但是有点繁琐可以使用派生宏派生出这些代码"><a class="header" href="#但是有点繁琐可以使用派生宏派生出这些代码">但是有点繁琐，可以使用派生宏派生出这些代码</a></h4>
<h3 id="派生宏思路"><a class="header" href="#派生宏思路">派生宏思路</a></h3>
<h4 id="要生成的代码模版"><a class="header" href="#要生成的代码模版">要生成的代码模版</a></h4>
<p>把输入的 TokenStream 抽取出来，也就是把在 struct 的定义内部，每个域的名字及其类型都抽出来，然后生成对应的方法代码。</p>
<pre><pre class="playground"><code class="language-rust  editable">impl {{ name }} {
    pub fn builder() -&gt; {{ builder_name }} {
        Default::default()
    }
}

#[derive(Debug, Default)]
pub struct {{ builder_name }} {
    {% for field in fields %}
        {{ field.name }}: Option&lt;{{ field.ty }}&gt;,
    {% endfor %}
}

impl {{ builder_name }} {
    {% for field in fields %}
    pub fn {{ field.name }}(mut self, v: impl Into&lt;{{ field.ty }}&gt;) -&gt; {{ builder_name }} {
        self.{{ field.name }} = Some(v.into());
        self
    }
    {% endfor %}

    pub fn build(self) -&gt; Result&lt;{{ name }}, &amp;'static str&gt; {
        Ok({{ name }} {
            {% for field in fields %}
                {% if field.optional %}
                {{ field.name }}: self.{{ field.name }},
                {% else %}
                {{ field.name }}: self.{{ field.name }}.ok_or(&quot;Build failed: missing {{ field.name }}&quot;)?,
                {% endif %}
            {% endfor %}
        })
    }
}
</code></pre></pre>
<ol>
<li>7-12: 这里的 fileds / builder_name 是我们要传入的参数，每个 field 还需要 name 和 ty 两个 属性，分别对应 field 的名字和类型</li>
<li>25-26: 对于原本是 Option<T> 类型的域，要避免生成 Option<Option>，我们需要把是否是 Option 单独抽取出来，如果是 Option<T>，那么 ty 就是 T。所以，field 还需要一个属 性
optional。</li>
</ol>
<h4 id="构建对应数据结构"><a class="header" href="#构建对应数据结构">构建对应数据结构</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 处理 jinja 模板的数据结构，在模板中我们使用了 name / builder_name / fields
#[derive(Template)]
#[template(path = &quot;builder.j2&quot;, escape = &quot;none&quot;)]
pub struct BuilderContext {
    name: String,
    builder_name: String,
    fields: Vec&lt;Fd&gt;,
}
</code></pre></pre>
<h4 id="srclibrs-使用派生宏从tokenstream抽取出想要的信息"><a class="header" href="#srclibrs-使用派生宏从tokenstream抽取出想要的信息">src/lib.rs: 使用派生宏从TokenStream抽取出想要的信息</a></h4>
<blockquote>
<p>对于 derive macro，要使用 proce_macro_derive 这个宏。我们把这个 derive macro 命名为 Builder。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">#[proc_macro_derive(RawBuilder)]
pub fn derive_raw_builder(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    BuilderContext::render(input).unwrap().parse().unwrap()
}
</code></pre></pre>
<h4 id="examplesraw_commandrs-使用这个派生宏抽取"><a class="header" href="#examplesraw_commandrs-使用这个派生宏抽取">examples/raw_command.rs: 使用这个派生宏抽取</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">use macros::RawBuilder;

#[allow(dead_code)]
#[derive(Debug, RawBuilder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}

fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .current_dir(&quot;..&quot;.to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
    println!(&quot;{:?}&quot;, command);
}
</code></pre></pre>
<h4 id="运行查看获取的tokenstream"><a class="header" href="#运行查看获取的tokenstream">运行，查看获取的TokenStream</a></h4>
<pre><code class="language-shell">cargo run --example raw_command &gt; examples/raw_command_output.txt
</code></pre>
<pre><code class="language-shell">TokenStream [
    Punct {
        ch: '#',
        spacing: Alone,
        span: #0 bytes(25..26),
    },
    Group {
        delimiter: Bracket,
        stream: TokenStream [
            Ident {
                ident: &quot;allow&quot;,
                span: #0 bytes(27..32),
            },
            Group {
                delimiter: Parenthesis,
                stream: TokenStream [
                    Ident {
                        ident: &quot;dead_code&quot;,
                        span: #0 bytes(33..42),
                    },
                ],
                span: #0 bytes(32..43),
            },
        ],
        span: #0 bytes(26..44),
    },
    Ident {
        ident: &quot;pub&quot;,
        span: #0 bytes(74..77),
    },
    Ident {
        ident: &quot;struct&quot;,
        span: #0 bytes(78..84),
    },
    Ident {
        ident: &quot;Command&quot;,
        span: #0 bytes(85..92),
    },
    Group {
        delimiter: Brace,
        stream: TokenStream [
            Ident {
                ident: &quot;executable&quot;,
                span: #0 bytes(99..109),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(109..110),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(111..117),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(117..118),
            },
            Ident {
                ident: &quot;args&quot;,
                span: #0 bytes(123..127),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(127..128),
            },
            Ident {
                ident: &quot;Vec&quot;,
                span: #0 bytes(129..132),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(132..133),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(133..139),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(139..140),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(140..141),
            },
            Ident {
                ident: &quot;env&quot;,
                span: #0 bytes(146..149),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(149..150),
            },
            Ident {
                ident: &quot;Vec&quot;,
                span: #0 bytes(151..154),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(154..155),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(155..161),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(161..162),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(162..163),
            },
            Ident {
                ident: &quot;current_dir&quot;,
                span: #0 bytes(168..179),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(179..180),
            },
            Ident {
                ident: &quot;Option&quot;,
                span: #0 bytes(181..187),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(187..188),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(188..194),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(194..195),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(195..196),
            },
        ],
        span: #0 bytes(93..198),
    },
]
Command { executable: &quot;cargo&quot;, args: [&quot;build&quot;, &quot;--release&quot;], env: [], current_dir: Some(&quot;..&quot;) }
</code></pre>
<div id="admonition-打印信息说明" class="admonition info">
<div class="admonition-title">
<p>打印信息说明</p>
<p><a class="admonition-anchor-link" href="#admonition-打印信息说明"></a></p>
</div>
<div>
<ol>
<li>
<p>首先有一个 Group，包含了 #[allow(dead_code)] 属性的信息。因为我们现在拿到 的 derive 下的信息，所以所有不属于 #[derive(…)] 的属性，都会被放入 TokenStream 中。</p>
</li>
<li>
<p>之后是 pub / struct / Command 三个 ident。</p>
</li>
<li>
<p>随后又是一个 Group，包含了每个 field 的信息。我们看到，field 之间用逗号这个 Punct 分隔，field 的名字和类型又是通过冒号这个 Punct 分隔。而类型，可能是一个 Ident，如 String，或者一系列 Ident / Punct，如 Vec / &lt; / String / &gt;。</p>
</li>
</ol>
</div>
</div>
<h4 id="srcraw_builderrs-使用anyhow与askama抽取tokenstream中的信息"><a class="header" href="#srcraw_builderrs-使用anyhow与askama抽取tokenstream中的信息">src/raw_builder.rs: 使用anyhow与askama抽取TokenStream中的信息</a></h4>
<blockquote>
<p>我们要做的就是，把这个 TokenStream 中的 struct 名字，以及每个 field 的名字和类型拿出来。
如果类型是 Option<T>，那么把 T 拿出来，把 optional 设置为 true。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">use anyhow::Result;
use askama::Template;
use proc_macro::{Ident, TokenStream, TokenTree};
use std::collections::VecDeque;

/// 处理 jinja 模板的数据结构，在模板中我们使用了 name / builder_name / fields
#[derive(Template)]
#[template(path = &quot;builder.j2&quot;, escape = &quot;none&quot;)]
pub struct BuilderContext {
    name: String,
    builder_name: String,
    fields: Vec&lt;Fd&gt;,
}

/// 描述 struct 的每个 field
#[derive(Debug, Default)]
struct Fd {
    name: String,
    ty: String,
    optional: bool,
}
</code></pre></pre>
<h4 id="templatesbuilderj2-上面askama用到的jinja2模版"><a class="header" href="#templatesbuilderj2-上面askama用到的jinja2模版">templates/builder.j2: 上面askama用到的jinja2模版</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">impl {{ name }} {
    pub fn builder() -&gt; {{ builder_name }} {
        Default::default()
    }
}

#[derive(Debug, Default)]
pub struct {{ builder_name }} {
    {% for field in fields %}
        {{ field.name }}: Option&lt;{{ field.ty }}&gt;,
    {% endfor %}
}

impl {{ builder_name }} {
    {% for field in fields %}
    pub fn {{ field.name }}(mut self, v: impl Into&lt;{{ field.ty }}&gt;) -&gt; {{ builder_name }} {
        self.{{ field.name }} = Some(v.into());
        self
    }
    {% endfor %}

    pub fn build(self) -&gt; Result&lt;{{ name }}, &amp;'static str&gt; {
        Ok({{ name }} {
            {% for field in fields %}
                {% if field.optional %}
                {{ field.name }}: self.{{ field.name }},
                {% else %}
                {{ field.name }}: self.{{ field.name }}.ok_or(&quot;Build failed: missing {{ field.name }}&quot;)?,
                {% endif %}
            {% endfor %}
        })
    }
}
</code></pre></pre>
<h4 id="srcraw_builderrs-实现对应抽取方法"><a class="header" href="#srcraw_builderrs-实现对应抽取方法">src/raw_builder.rs: 实现对应抽取方法</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">impl Fd {
    /// name 和 field 都是通过冒号 Punct 切分出来的 TokenTree 切片
    pub fn new(name: &amp;[TokenTree], ty: &amp;[TokenTree]) -&gt; Self {
        // 把类似 Ident(&quot;Option&quot;), Punct('&lt;'), Ident(&quot;String&quot;), Punct('&gt;) 的 ty
        // 收集成一个 String 列表，如 vec![&quot;Option&quot;, &quot;&lt;&quot;, &quot;String&quot;, &quot;&gt;&quot;]
        let ty = ty
            .iter()
            .map(|v| match v {
                TokenTree::Ident(n) =&gt; n.to_string(),
                TokenTree::Punct(p) =&gt; p.as_char().to_string(),
                e =&gt; panic!(&quot;Expect ident, got {:?}&quot;, e),
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();
        // 冒号前最后一个 TokenTree 是 field 的名字
        // 比如：executable: String,
        // 注意这里不应该用 name[0]，因为有可能是 pub executable: String
        // 甚至，带 attributes 的 field，
        // 比如：#[builder(hello = world)] pub executable: String
        match name.last() {
            Some(TokenTree::Ident(name)) =&gt; {
                // 如果 ty 第 0 项是 Option，那么从第二项取到倒数第一项
                // 取完后上面的例子中的 ty 会变成 [&quot;String&quot;]，optiona = true
                let (ty, optional) = if ty[0].as_str() == &quot;Option&quot; {
                    (&amp;ty[2..ty.len() - 1], true)
                } else {
                    (&amp;ty[..], false)
                };
                Self {
                    name: name.to_string(),
                    ty: ty.join(&quot;&quot;), // 把 ty join 成字符串
                    optional,
                }
            }
            e =&gt; panic!(&quot;Expect ident, got {:?}&quot;, e),
        }
    }
}

impl BuilderContext {
    /// 从 TokenStream 中提取信息，构建 BuilderContext
    fn new(input: TokenStream) -&gt; Self {
        let (name, input) = split(input);
        let fields = get_struct_fields(input);
        Self {
            builder_name: format!(&quot;{}Builder&quot;, name),
            name: name.to_string(),
            fields,
        }
    }

    /// 把模板渲染成字符串代码
    pub fn render(input: TokenStream) -&gt; Result&lt;String&gt; {
        let template = Self::new(input);
        Ok(template.render()?)
    }
}

/// 把 TokenStream 分出 struct 的名字，和包含 fields 的 TokenStream
fn split(input: TokenStream) -&gt; (Ident, TokenStream) {
    let mut input = input.into_iter().collect::&lt;VecDeque&lt;_&gt;&gt;();
    // 一直往后找，找到 struct 停下来
    while let Some(item) = input.pop_front() {
        if let TokenTree::Ident(v) = item {
            if v.to_string() == &quot;struct&quot; {
                break;
            }
        }
    }

    // struct 后面，应该是 struct name
    let ident;
    if let Some(TokenTree::Ident(v)) = input.pop_front() {
        ident = v;
    } else {
        panic!(&quot;Didn't find struct name&quot;);
    }

    // struct 后面可能还有若干 TokenTree，我们不管，一路找到第一个 Group
    let mut group = None;
    for item in input {
        if let TokenTree::Group(g) = item {
            group = Some(g);
            break;
        }
    }

    (ident, group.expect(&quot;Didn't find field group&quot;).stream())
}

/// 从包含 fields 的 TokenStream 中切出来一个个 Fd
fn get_struct_fields(input: TokenStream) -&gt; Vec&lt;Fd&gt; {
    let input = input.into_iter().collect::&lt;Vec&lt;_&gt;&gt;();
    input
        .split(|v| match v {
            // 先用 ',' 切出来一个个包含 field 所有信息的 &amp;[TokenTree]
            TokenTree::Punct(p) =&gt; p.as_char() == ',',
            _ =&gt; false,
        })
        .map(|tokens| {
            tokens
                .split(|v| match v {
                    // 再用 ':' 把 &amp;[TokenTree] 切成 [&amp;[TokenTree], &amp;[TokenTree]]
                    // 它们分别对应名字和类型
                    TokenTree::Punct(p) =&gt; p.as_char() == ':',
                    _ =&gt; false,
                })
                .collect::&lt;Vec&lt;_&gt;&gt;()
        })
        // 正常情况下，应该得到 [&amp;[TokenTree], &amp;[TokenTree]]，对于切出来长度不为 2 的统统过滤掉
        .filter(|tokens| tokens.len() == 2)
        // 使用 Fd::new 创建出每个 Fd
        .map(|tokens| Fd::new(tokens[0], tokens[1]))
        .collect()
}
</code></pre></pre>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="#admonition-tip"></a></p>
</div>
<div>
<p>可以对着打印出来的 TokenStream 和刚才的分析进行理解。
核心的就是 get_struct_fields() 方法，如果觉得难懂，
可以想想如果要把一个 a=1,b=2 的字符串切成 [[a, 1], [b, 2]] 该怎么做，就很容易理解了。</p>
</div>
</div>
<h3 id="使用synquote可以不用自己定义模版"><a class="header" href="#使用synquote可以不用自己定义模版">使用syn/quote可以不用自己定义模版</a></h3>
<blockquote>
<p>详见上方对比图</p>
</blockquote>
<h2 id="过程属性宏-proc_macro_derivemacro_name-attributesattr_name"><a class="header" href="#过程属性宏-proc_macro_derivemacro_name-attributesattr_name">过程属性宏: proc_macro_derive(macro_name, attributes(attr_name))</a></h2>
<blockquote>
<p>用于属性宏， 用在结构体、字段、函数等地方，为其指定属性等功能, 类似python的计算属性</p>
</blockquote>
<div id="admonition-定义结构体时在某个字段上方使用对应attr_name" class="admonition tip">
<div class="admonition-title">
<p>定义结构体时在某个字段上方使用对应attr_name</p>
<p><a class="admonition-anchor-link" href="#admonition-定义结构体时在某个字段上方使用对应attr_name"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(dead_code)]
#[derive(Debug, BuilderWithAttr)]
pub struct Command {
    executable: String,
    #[builder(each = &quot;arg&quot;)]
    args: Vec&lt;String&gt;,
    #[builder(each = &quot;env&quot;, default = &quot;vec![]&quot;)]
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</div>
</div>
<h3 id="使用synquote定义属性宏"><a class="header" href="#使用synquote定义属性宏">使用syn/quote定义属性宏</a></h3>
<blockquote>
<p>详见上方对比图</p>
</blockquote>

            </main>

            <!--            <script src="https://utteranc.es/client.js"-->
            <!--                    repo="RustMagazine/rust_magazine_2022"-->
            <!--                    issue-term="title"-->
            <!--                    theme="github-light"-->
            <!--                    crossorigin="anonymous"-->
            <!--                    async></script>-->

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                    <a rel="prev" href="3_data_structure.html" class="mobile-nav-chapters previous"
                       title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="5_concurrency_async.html" class="mobile-nav-chapters next"
                       title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="3_data_structure.html" class="nav-chapters previous" title="Previous chapter"
               aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="5_concurrency_async.html" class="nav-chapters next" title="Next chapter"
               aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
    </nav>

</div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/mermaid/mermaid.min.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid-init.js"></script>
    <script type="text/javascript" src="assets/smart-anchor.js"></script>
    <script type="text/javascript" src="assets/pagetoc/sidebar.js"></script>

</body>
</html>
