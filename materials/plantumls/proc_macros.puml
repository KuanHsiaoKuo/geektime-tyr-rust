@startuml
title 过程宏定义使用流程
|Cargo.toml|
start
:打开过程宏;
floating note
[lib]
proc-macro = true
end note
|src/lib.rs|
:定义过程宏;
floating note right
#[proc_macro]
pub fn query(input: TokenStream) -> TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!("{:#?}", input);
    "fn hello() { println!(\"Hello world!\"); }"
        .parse()
        .unwrap()
}
end note
|examples/调用代码|
:使用过程宏;
floating note
use macros::query;

fn main() {
    // query!(SELECT * FROM users WHERE age > 10);
    query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id);
    hello()
}
end note
|Terminal|
:查看打印的TokenStream;
floating note
cargo run --example query > examples/query_output.txt
end note
stop
|Cargo.toml|
start
: 打开过程宏;
floating note
[lib]
proc-macro = true
end note
|src/lib.rs|
:定义过程派生宏;
floating note right
/#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    builder::BuilderContext::from(input).render().into()
}
end note
|examples/调用代码|
:使用派生宏抽取;
floating note
use macros::Builder;

/#[allow(dead_code)]
/#[derive(Debug, Builder)]
pub struct Command {
    executable: String,
    args: Vec<String>,
    env: Vec<String>,
    current_dir: Option<String>,
}

fn main() {
    let command = Command::builder()
        .executable("cargo".to_owned())
        .args(vec!["build".to_owned(), "--release".to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable("cargo".to_owned())
        .args(vec!["build".to_owned(), "--release".to_owned()])
        .env(vec![])
        .current_dir("..".to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
    println!("{:?}", command);
}
end note
|Terminal|
:查看打印的TokenStream;
floating note
cargo run --example raw_command > examples/raw_command_output.txt
end note
|src/raw_builder.rs|
:使用anyhow与askama抽取TokenStream中的信息;
floating note
use anyhow::Result;
use askama::Template;
use proc_macro::{Ident, TokenStream, TokenTree};
use std::collections::VecDeque;

/// 处理 jinja 模板的数据结构，在模板中我们使用了 name / builder_name / fields
/#[derive(Template)]
/#[template(path = "builder.j2", escape = "none")]
pub struct BuilderContext {
    name: String,
    builder_name: String,
    fields: Vec<Fd>,
}

/// 描述 struct 的每个 field
/#[derive(Debug, Default)]
struct Fd {
    name: String,
    ty: String,
    optional: bool,
}
end note
|templates/builder.j2|
:编写与tokenstream对应的jinja2模版;
|src/raw_builder.rs|
:实现对应抽取方法;
floating note
impl Fd {
    /// name 和 field 都是通过冒号 Punct 切分出来的 TokenTree 切片
    pub fn new(name: &[TokenTree], ty: &[TokenTree]) -> Self {
    }
}
impl BuilderContext {
    /// 从 TokenStream 中提取信息，构建 BuilderContext
    fn new(input: TokenStream) -> Self {
    }
    /// 把模板渲染成字符串代码
    pub fn render(input: TokenStream) -> Result<String> {
    }
}
// 把 TokenStream 分出 struct 的名字，和包含 fields 的 TokenStream
fn split(input: TokenStream) -> (Ident, TokenStream) {
}
/// 从包含 fields 的 TokenStream 中切出来一个个 Fd
fn get_struct_fields(input: TokenStream) -> Vec<Fd> {
}
end note
@enduml