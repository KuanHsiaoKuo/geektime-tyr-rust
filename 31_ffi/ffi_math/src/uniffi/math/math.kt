// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.math

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the detils of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import java.nio.ByteBuffer
import java.nio.ByteOrder

// The Rust Buffer and 3 templated methods (alloc, free, reserve).
// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
	@JvmField var capacity: Int = 0
	@JvmField var len: Int = 0
	@JvmField var data: Pointer? = null

	class ByValue : RustBuffer(), Structure.ByValue
	class ByReference : RustBuffer(), Structure.ByReference

	companion object {
		internal fun alloc(size: Int = 0) = rustCall() { status ->
			_UniFFILib.INSTANCE.ffi_math_6c3d_rustbuffer_alloc(size, status)
		}

		internal fun free(buf: RustBuffer.ByValue) = rustCall() { status ->
			_UniFFILib.INSTANCE.ffi_math_6c3d_rustbuffer_free(buf, status)
		}

		internal fun reserve(buf: RustBuffer.ByValue, additional: Int) = rustCall() { status ->
			_UniFFILib.INSTANCE.ffi_math_6c3d_rustbuffer_reserve(buf, additional, status)
		}
	}

	@Suppress("TooGenericExceptionThrown")
	fun asByteBuffer() =
		this.data?.getByteBuffer(0, this.len.toLong())?.also {
			it.order(ByteOrder.BIG_ENDIAN)
		}
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
open class ForeignBytes : Structure() {
	@JvmField var len: Int = 0
	@JvmField var data: Pointer? = null

	class ByValue : ForeignBytes(), Structure.ByValue
}

// A helper for structured writing of data into a `RustBuffer`.
// This is very similar to `java.nio.ByteBuffer` but it knows how to grow
// the underlying `RustBuffer` on demand.
//
// TODO: we should benchmark writing things into a `RustBuffer` versus building
// up a bytearray and then copying it across.

class RustBufferBuilder() {
	var rbuf = RustBuffer.ByValue()
	var bbuf: ByteBuffer? = null

	init {
		val rbuf = RustBuffer.alloc(16) // Totally arbitrary initial size
		rbuf.writeField("len", 0)
		this.setRustBuffer(rbuf)
	}

	internal fun setRustBuffer(rbuf: RustBuffer.ByValue) {
		this.rbuf = rbuf
		this.bbuf = this.rbuf.data?.getByteBuffer(0, this.rbuf.capacity.toLong())?.also {
			it.order(ByteOrder.BIG_ENDIAN)
			it.position(rbuf.len)
		}
	}

	fun finalize(): RustBuffer.ByValue {
		val rbuf = this.rbuf
		// Ensure that the JVM-level field is written through to native memory
		// before turning the buffer, in case its recipient uses it in a context
		// JNA doesn't apply its automatic synchronization logic.
		rbuf.writeField("len", this.bbuf!!.position())
		this.setRustBuffer(RustBuffer.ByValue())
		return rbuf
	}

	fun discard() {
		if (this.rbuf.data != null) {
			// Free the current `RustBuffer`
			RustBuffer.free(this.rbuf)
			// Replace it with an empty RustBuffer.
			this.setRustBuffer(RustBuffer.ByValue())
		}
	}

	internal fun reserve(size: Int, write: (ByteBuffer) -> Unit) {
		// TODO: this will perform two checks to ensure we're not overflowing the buffer:
		// one here where we check if it needs to grow, and another when we call a write
		// method on the ByteBuffer. It might be cheaper to use exception-driven control-flow
		// here, trying the write and growing if it throws a `BufferOverflowException`.
		// Benchmarking needed.
		if (this.bbuf!!.position() + size > this.rbuf.capacity) {
			rbuf.writeField("len", this.bbuf!!.position())
			this.setRustBuffer(RustBuffer.reserve(this.rbuf, size))
		}
		write(this.bbuf!!)
	}

	fun putByte(v: Byte) {
		this.reserve(1) { bbuf ->
			bbuf.put(v)
		}
	}

	fun putShort(v: Short) {
		this.reserve(2) { bbuf ->
			bbuf.putShort(v)
		}
	}

	fun putInt(v: Int) {
		this.reserve(4) { bbuf ->
			bbuf.putInt(v)
		}
	}

	fun putLong(v: Long) {
		this.reserve(8) { bbuf ->
			bbuf.putLong(v)
		}
	}

	fun putFloat(v: Float) {
		this.reserve(4) { bbuf ->
			bbuf.putFloat(v)
		}
	}

	fun putDouble(v: Double) {
		this.reserve(8) { bbuf ->
			bbuf.putDouble(v)
		}
	}

	fun put(v: ByteArray) {
		this.reserve(v.size) { bbuf ->
			bbuf.put(v)
		}
	}
}

// Helpers for reading primitive data types from a bytebuffer.
internal fun <T> liftFromRustBuffer(rbuf: RustBuffer.ByValue, readItem: (ByteBuffer) -> T): T {
	val buf = rbuf.asByteBuffer()!!
	try {
		val item = readItem(buf)
		if (buf.hasRemaining()) {
			throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
		}
		return item
	} finally {
		RustBuffer.free(rbuf)
	}
}

internal fun <T> lowerIntoRustBuffer(v: T, writeItem: (T, RustBufferBuilder) -> Unit): RustBuffer.ByValue {
	// TODO: maybe we can calculate some sort of initial size hint?
	val buf = RustBufferBuilder()
	try {
		writeItem(v, buf)
		return buf.finalize()
	} catch (e: Throwable) {
		buf.discard()
		throw e
	}
}

// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
@Structure.FieldOrder("code", "error_buf")
internal open class RustCallStatus : Structure() {
	@JvmField var code: Int = 0
	@JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

	fun isSuccess(): Boolean {
		return code == 0
	}

	fun isError(): Boolean {
		return code == 1
	}

	fun isPanic(): Boolean {
		return code == 2
	}
}

class InternalException(message: String) : Exception(message)

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> {
	fun lift(error_buf: RustBuffer.ByValue): E
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E : Exception> rustCallWithError(errorHandler: CallStatusErrorHandler<E>, callback: (RustCallStatus) -> U): U {
	var status = RustCallStatus()
	val return_value = callback(status)
	if (status.isSuccess()) {
		return return_value
	} else if (status.isError()) {
		throw errorHandler.lift(status.error_buf)
	} else if (status.isPanic()) {
		// when the rust code sees a panic, it tries to construct a rustbuffer
		// with the message.  but if that code panics, then it just sends back
		// an empty buffer.
		if (status.error_buf.len > 0) {
			throw InternalException(String.lift(status.error_buf))
		} else {
			throw InternalException("Rust panic")
		}
	} else {
		throw InternalException("Unknown rust call status: $status.code")
	}
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
object NullCallStatusErrorHandler : CallStatusErrorHandler<InternalException> {
	override fun lift(error_buf: RustBuffer.ByValue): InternalException {
		RustBuffer.free(error_buf)
		return InternalException("Unexpected CALL_ERROR")
	}
}

// Call a rust function that returns a plain value
private inline fun <U> rustCall(callback: (RustCallStatus) -> U): U {
	return rustCallWithError(NullCallStatusErrorHandler, callback)
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
	val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
	if (libOverride != null) {
		return libOverride
	}
	return "uniffi_math"
}

private inline fun <reified Lib : Library> loadIndirect(
	componentName: String
): Lib {
	return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface _UniFFILib : Library {
	companion object {
		internal val INSTANCE: _UniFFILib by lazy {
			loadIndirect<_UniFFILib>(componentName = "math")
		}
	}

	fun math_6c3d_add(
		a: Int,
		b: Int,
		uniffi_out_err: RustCallStatus
	): Int

	fun math_6c3d_hello(
		name: RustBuffer.ByValue,
		uniffi_out_err: RustCallStatus
	): RustBuffer.ByValue

	fun ffi_math_6c3d_rustbuffer_alloc(
		size: Int,
		uniffi_out_err: RustCallStatus
	): RustBuffer.ByValue

	fun ffi_math_6c3d_rustbuffer_from_bytes(
		bytes: ForeignBytes.ByValue,
		uniffi_out_err: RustCallStatus
	): RustBuffer.ByValue

	fun ffi_math_6c3d_rustbuffer_free(
		buf: RustBuffer.ByValue,
		uniffi_out_err: RustCallStatus
	): Unit

	fun ffi_math_6c3d_rustbuffer_reserve(
		buf: RustBuffer.ByValue,
		additional: Int,
		uniffi_out_err: RustCallStatus
	): RustBuffer.ByValue
}

// Public interface members begin here.

fun add(a: UInt, b: UInt): UInt {
	val _retval =
		rustCall() { status ->
			_UniFFILib.INSTANCE.math_6c3d_add(a.lower(), b.lower(), status)
		}
	return UInt.lift(_retval)
}

fun hello(name: String): String {
	val _retval =
		rustCall() { status ->
			_UniFFILib.INSTANCE.math_6c3d_hello(name.lower(), status)
		}
	return String.lift(_retval)
}

internal fun UInt.Companion.lift(v: Int): UInt {
	return v.toUInt()
}

internal fun UInt.Companion.read(buf: ByteBuffer): UInt {
	return UInt.lift(buf.getInt())
}

internal fun UInt.lower(): Int {
	return this.toInt()
}

internal fun UInt.write(buf: RustBufferBuilder) {
	buf.putInt(this.toInt())
}
internal fun String.Companion.lift(rbuf: RustBuffer.ByValue): String {
	try {
		val byteArr = ByteArray(rbuf.len)
		rbuf.asByteBuffer()!!.get(byteArr)
		return byteArr.toString(Charsets.UTF_8)
	} finally {
		RustBuffer.free(rbuf)
	}
}

internal fun String.Companion.read(buf: ByteBuffer): String {
	val len = buf.getInt()
	val byteArr = ByteArray(len)
	buf.get(byteArr)
	return byteArr.toString(Charsets.UTF_8)
}

internal fun String.lower(): RustBuffer.ByValue {
	val byteArr = this.toByteArray(Charsets.UTF_8)
	// Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
	// to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
	val rbuf = RustBuffer.alloc(byteArr.size)
	rbuf.asByteBuffer()!!.put(byteArr)
	return rbuf
}

internal fun String.write(buf: RustBufferBuilder) {
	val byteArr = this.toByteArray(Charsets.UTF_8)
	buf.putInt(byteArr.size)
	buf.put(byteArr)
}
