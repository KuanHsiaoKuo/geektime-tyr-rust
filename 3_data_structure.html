<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>III. 数据结构 - Anatomy In First Rust Programming Class 🦀</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust编程第一课的代码为例进行基础代码分析">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="md-favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/pagetoc/pagetoc_style.css">
        <link rel="stylesheet" href="assets/css/mdbook-admonish.css">

        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="anatomy_logic.html"><strong aria-hidden="true">1.</strong> 源码阅读逻辑</a></li><li class="chapter-item expanded "><a href="intro_gdb_lldb.html"><strong aria-hidden="true">2.</strong> gdb/lldb调试或查看内存结构</a></li><li class="chapter-item expanded "><a href="get_hands_dirty.html"><strong aria-hidden="true">3.</strong> get hands dirty</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="httpie.html"><strong aria-hidden="true">3.1.</strong> httpie</a></li><li class="chapter-item expanded "><a href="rgrep.html"><strong aria-hidden="true">3.2.</strong> rgrep</a></li><li class="chapter-item expanded "><a href="thumbor.html"><strong aria-hidden="true">3.3.</strong> thumbor</a></li><li class="chapter-item expanded "><a href="queryer.html"><strong aria-hidden="true">3.4.</strong> queryer</a></li></ol></li><li class="chapter-item expanded "><a href="rust_cores.html"><strong aria-hidden="true">4.</strong> Rust核心深入</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_stack_heap_ownership_lifetime_memory.html"><strong aria-hidden="true">4.1.</strong> I. 从栈堆、所有权、生命周期开始内存管理</a></li><li class="chapter-item expanded "><a href="2_type_system.html"><strong aria-hidden="true">4.2.</strong> II. 类型系统</a></li><li class="chapter-item expanded "><a href="3_data_structure.html" class="active"><strong aria-hidden="true">4.3.</strong> III. 数据结构</a></li><li class="chapter-item expanded "><a href="4_macros.html"><strong aria-hidden="true">4.4.</strong> IV. 宏编程</a></li><li class="chapter-item expanded "><a href="5_concurrency_async.html"><strong aria-hidden="true">4.5.</strong> V. 并发与异步</a></li><li class="chapter-item expanded "><a href="6_unsafe_ffi.html"><strong aria-hidden="true">4.6.</strong> VI. 混合编程</a></li></ol></li><li class="chapter-item expanded "><a href="kv_server_design.html"><strong aria-hidden="true">5.</strong> kv server设计与实现</a></li><li class="chapter-item expanded "><a href="custom_axum_async_web_framework.html"><strong aria-hidden="true">6.</strong> 构建自己的类axum异步Web框架</a></li><li class="chapter-item expanded affix "><a href="checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Anatomy In First Rust Programming Class 🦀</h1>
            <h4 class="menu-bar"><a href="https://kuanhsiaokuo.github.io/think-tool-kit/">保持批判，有所取舍，知行合一, 方见真我</a> -- 练武不练功
                到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/geektime-tyr-rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="iii-数据结构"><a class="header" href="#iii-数据结构">III. 数据结构</a></h1>
<!--ts-->
<ul>
<li><a href="#iii-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">III. 数据结构</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BF%AB%E9%80%9F%E4%B8%80%E8%A7%88">数据结构快速一览</a></li>
<li><a href="#%E5%88%86%E7%B1%BB%E5%9B%BE">分类图</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">一、智能指针</a>
<ul>
<li><a href="#%E6%8C%87%E9%92%88%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8">指针还是引用</a></li>
<li><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8D%E4%BB%85%E6%98%AF%E6%8C%87%E9%92%88">智能指针不仅是指针</a></li>
<li><a href="#box-%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98">Box: 在堆上分配内存</a>
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8">实现内存分配器</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E9%87%8A%E6%94%BE">内存如何释放</a></li>
</ul>
</li>
<li><a href="#cowa-b-%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D">Cow&lt;’a, B&gt;： 写时拷贝</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E4%B8%A4%E4%B8%AAtraittoownedborrowed">两个trait：ToOwned、Borrowed</a></li>
<li><a href="#toowned">ToOwned</a></li>
<li><a href="#%E5%8C%B9%E9%85%8D%E5%88%86%E5%8F%91">匹配分发</a></li>
<li><a href="#cow%E5%9C%A8%E9%9C%80%E8%A6%81%E6%97%B6%E6%89%8D%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%8B%B7%E8%B4%9D">Cow在需要时才进行内存分配拷贝</a></li>
</ul>
</li>
<li><a href="#mutexguard-%E6%95%B0%E6%8D%AE%E5%8A%A0%E9%94%81">MutexGuard： 数据加锁</a>
<ul>
<li><a href="#mutexguard%E4%B8%8Estringboxcowa-b%E7%9A%84%E5%AF%B9%E6%AF%94">MutexGuard与String、Box、Cow&lt;’a, B&gt;的对比</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8mutexlock%E8%8E%B7%E5%8F%96">使用Mutex::lock获取</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E4%B8%8Ederefdrop-trait%E5%AE%9E%E7%8E%B0">定义与Deref、Drop trait实现</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8mutex_mutexguard%E7%9A%84%E4%BE%8B%E5%AD%90">使用Mutex_MutexGuard的例子</a></li>
</ul>
</li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">自定义智能指针</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8">二、集合容器</a>
<ul>
<li><a href="#%E5%AF%B9%E5%AE%B9%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%B9%89">对容器进行定义</a></li>
<li><a href="#%E5%AF%B9%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%B9%89">对集合容器进行定义</a></li>
<li><a href="#%E5%88%87%E7%89%87">切片</a>
<ul>
<li><a href="#array-vs-vector">array vs vector</a></li>
<li>[Vec 和 &amp;[T]](#vec-和-t)</li>
<li><a href="#%E8%A7%A3%E5%BC%95%E7%94%A8">解引用</a></li>
<li><a href="#%E5%88%87%E7%89%87%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator">切片和迭代器 Iterator</a></li>
<li><a href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%88%87%E7%89%87str">特殊的切片：&amp;str</a></li>
<li>[Box&lt;[T]&gt;](#boxt)</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%88%87%E7%89%87%E5%AF%B9%E6%AF%94%E5%9B%BE">常用切片对比图</a></li>
</ul>
</li>
<li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>
<ul>
<li><a href="#hashmap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">HashMap数据结构</a></li>
<li><a href="#hashmap%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">HashMap基本使用方法</a></li>
<li><a href="#hashmap%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">HashMap内存布局</a></li>
<li><a href="#ctrl%E8%A1%A8">ctrl表</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">三、错误处理</a>
<ul>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%BB%E6%B5%81%E6%96%B9%E6%B3%95">错误处理主流方法</a></li>
<li><a href="#rust%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF">Rust如何处理错误</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E9%97%AD%E5%8C%85%E7%BB%93%E6%9E%84">四、闭包结构</a>
<ul>
<li><a href="#%E9%97%AD%E5%8C%85%E5%AE%9A%E4%B9%89">闭包定义</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E6%9C%AC%E8%B4%A8">闭包本质</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E8%AE%BE%E8%AE%A1">闭包设计</a></li>
<li><a href="#rust%E9%97%AD%E5%8C%85%E7%B1%BB%E5%9E%8B">Rust闭包类型</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">闭包使用场景</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Oct  4 07:24:32 UTC 2022 -->
<!--te-->
<h2 id="数据结构快速一览"><a class="header" href="#数据结构快速一览">数据结构快速一览</a></h2>
<div id="admonition-数据结构快速一览" class="admonition tip">
<div class="admonition-title">
<p>数据结构快速一览</p>
<p><a class="admonition-anchor-link" href="#admonition-数据结构快速一览"></a></p>
</div>
<div>
<blockquote>
<p>用40分钟的时间，总结了Rust的主要数据结构的内 存布局。它能厘清“数据是如何在堆和栈上存储“的思路，在这里也推荐给你。
<a href="https://www.youtube.com/watch?v=rDoqT-a6UFg">Visualizing memory layout of Rust’s data types - YouTube</a></p>
</blockquote>
</div>
</div>
<h2 id="分类图"><a class="header" href="#分类图">分类图</a></h2>
<blockquote>
<p>数据结构可以看作对于类型系统的进一步整理，结构化。这其实是进一步抽象，从类型中提取出日常常用的工具并分类。</p>
</blockquote>
<div id="admonition-从系统容器原生三个纬度分类" class="admonition info">
<div class="admonition-title">
<p>从系统/容器/原生三个纬度分类</p>
<p><a class="admonition-anchor-link" href="#admonition-从系统容器原生三个纬度分类"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F.jpg" alt="" /></p>
</div>
</div>
<h1 id="一智能指针"><a class="header" href="#一智能指针">一、智能指针</a></h1>
<h2 id="指针还是引用"><a class="header" href="#指针还是引用">指针还是引用</a></h2>
<details id="admonition-引用是特殊的指针" class="admonition info">
<summary class="admonition-title">
<p>引用是特殊的指针</p>
<p><a class="admonition-anchor-link" href="#admonition-引用是特殊的指针"></a></p>
</summary>
<div>
<ol>
<li>指针是一个持有内存地址的值，可以通过解引用来访问它指向的内存地址，理论上可以解引用到任意数据类型；</li>
<li>引用是一个特殊 的指针，它的解引用访问是受限的，只能解引用到它引用数据的类型，不能用作它用。</li>
</ol>
</div>
</details>
<h2 id="智能指针不仅是指针"><a class="header" href="#智能指针不仅是指针">智能指针不仅是指针</a></h2>
<details id="admonition-智能指针指针额外处理能力" class="admonition info">
<summary class="admonition-title">
<p>智能指针=指针+额外处理能力</p>
<p><a class="admonition-anchor-link" href="#admonition-智能指针指针额外处理能力"></a></p>
</summary>
<div>
<ol>
<li>在指针和引用的基础上，Rust 偷师 C++，提供了智能指针。</li>
<li>智能指针是一个表现行为很 像指针的数据结构，但除了指向数据的指针外，它还有元数据以提供额外的处理能力。</li>
</ol>
</div>
</details>
<details id="admonition-智能指针胖指针所有权" class="admonition info">
<summary class="admonition-title">
<p>智能指针=胖指针+所有权</p>
<p><a class="admonition-anchor-link" href="#admonition-智能指针胖指针所有权"></a></p>
</summary>
<div>
<ol>
<li>智能指针一定是一个胖指针，但胖指针不一定是一个 智能指针。</li>
<li>比如 &amp;str 就只是一个胖指针，它有指向堆内存字符串的指针，同时还有关于字 符串长度的元数据。</li>
</ol>
<h2 id=""><a class="header" href="#"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/15%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F.jpg" alt="" /></a></h2>
<ol>
<li>String 除了多一个 capacity 字段，似乎也没有什么特殊。</li>
<li>但 String 对 堆上的值有所有权，而 &amp;str 是没有所有权的</li>
<li>这是 Rust 中智能指针和普通胖指针的区 别。</li>
</ol>
</div>
</details>
<details id="admonition-智能指针和结构体有什么区别" class="admonition info">
<summary class="admonition-title">
<p>智能指针和结构体有什么区别</p>
<p><a class="admonition-anchor-link" href="#admonition-智能指针和结构体有什么区别"></a></p>
</summary>
<div>
<ol>
<li>String用结构体定义，其实就是Vec<u8></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>和普通的结构体不同的是，<a href="https://doc.rust-lang.org/src/alloc/string.rs.html#2301-2316">String 实现了 Deref 和 DerefMut</a>，这使得它在解引用的时
候，会得到 &amp;str</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl ops::Deref for String {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;str {
        unsafe { str::from_utf8_unchecked(&amp;self.vec) }
    }
}

impl ops::DerefMut for String {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut str {
        unsafe { str::from_utf8_unchecked_mut(&amp;mut *self.vec) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>另外，由于在堆上分配了数据，String 还需要为其分配的资源做相应的回收。而 String 内部使用了
Vec，所以它可以<a href="https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#2710-2720">依赖 Vec 的能力来释放堆内存</a></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>unsafe impl&lt;#[may_dangle] T, A: Allocator&gt; Drop for Vec&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // use drop for [T]
            // use a raw slice to refer to the elements of the vector as weakest necessary type;
            // could avoid questions of validity in certain cases
            ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))
        }
        // RawVec handles deallocation
    }
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-在-rust-中凡是需要做资源回收的数据结构且实现了-derefderefmutdrop都是智能指针" class="admonition info">
<summary class="admonition-title">
<p>在 Rust 中，凡是需要做资源回收的数据结构，且实现了 Deref/DerefMut/Drop，都是智能指针。</p>
<p><a class="admonition-anchor-link" href="#admonition-在-rust-中凡是需要做资源回收的数据结构且实现了-derefderefmutdrop都是智能指针"></a></p>
</summary>
<div>
<p>按照这个定义，除了 String，还有很多智能指针，比如：</p>
<ol>
<li>
<p>用于在堆上 分配内存的 Box<T> 和 Vec<T></p>
</li>
<li>
<p>用于引用计数的 Rc<T> 和 Arc<T> </p>
</li>
<li>
<p>很多其他数据结 构，如 PathBuf、Cow&lt;’a, B&gt;、MutexGuard<T>、RwLockReadGuard<T> 和 RwLockWriteGuard 等也是智能指针。</p>
</li>
</ol>
</div>
</details>
<h2 id="box-在堆上分配内存"><a class="header" href="#box-在堆上分配内存">Box<T>: 在堆上分配内存</a></h2>
<details id="admonition-从cc得到box灵感" class="admonition info">
<summary class="admonition-title">
<p>从c/c++得到Box<T>灵感</p>
<p><a class="admonition-anchor-link" href="#admonition-从cc得到box灵感"></a></p>
</summary>
<div>
<p>我们先看 Box<T>，它是 Rust 中最基本的在堆上分配内存的方式，绝大多数其它包含堆内 存分配的数据类型，内部都是通过 Box<T> 完成的，比如 Vec<T>。</p>
<p>为什么有 Box<T> 的设计，我们得先回忆一下在 C 语言中，堆内存是怎么分配的。</p>
<ol>
<li>
<p>C 需要使用 malloc/calloc/realloc/free 来处理内存的分配，很多时候，被分配出来的内存 在函数调用中来来回回使用，导致谁应该负责释放这件事情很难确定，给开发者造成了极 大的心智负担。</p>
</li>
<li>
<p>C++ 在此基础上改进了一下，提供了一个智能指针  unique_ptr，可以在指针退出作用 域的时候释放堆内存，这样保证了堆内存的单一所有权。这个 unique_ptr 就是 Rust 的 Box<T> 的前身。</p>
</li>
</ol>
<hr />
<p><a href="https://doc.rust-lang.org/src/core/ptr/unique.rs.html#36-44">Box<T> 的定义</a>里，内部就是一个 Unique<T> 用于致敬 C++，Unique<T> 是
一个私有的数据结构，我们不能直接使用，它包裹了一个 *const T 指针，并唯一拥有这个 指针。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Unique&lt;T: ?Sized&gt; {
    pointer: *const T,
    // NOTE: this marker has no consequences for variance, but is necessary
    // for dropck to understand that we logically own a `T`.
    //
    // For details, see:
    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data
    _marker: PhantomData&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-堆上分配内存的-box-其实有一个缺省的泛型参数-a" class="admonition info">
<summary class="admonition-title">
<p>堆上分配内存的 Box<T> 其实有一个缺省的泛型参数 A</p>
<p><a class="admonition-anchor-link" href="#admonition-堆上分配内存的-box-其实有一个缺省的泛型参数-a"></a></p>
</summary>
<div>
<p>设计内存分配器的目的除了保证正确性之外，就是为了有效地利用剩余内存，并控制内存 在分配和释放过程中产生的碎片的数量。
在多核环境下，它还要能够高效地处理并发请 求。（如果你对通用内存分配器感兴趣，可以看参考资料） 堆上分配内存的 Box<T></p>
<p>其实有一个缺省的泛型参数 A，就需要满足 <a href="https://doc.rust-lang.org/std/alloc/trait.Allocator.html">Allocator trait</a>， 并且默认是 Global：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub struct Box&lt;T: ?Sized, A: Allocator = Global&gt;(Unique&lt;T&gt;, A);
<span class="boring">}
</span></code></pre></pre>
<hr />
<p>Allocator trait 提供很多方法：</p>
<ol>
<li>
<p>allocate 是主要方法，用于分配内存，对应 C 的 malloc/calloc；</p>
</li>
<li>
<p>deallocate，用于释放内存，对应 C 的 free；</p>
</li>
<li>
<p>还有 grow / shrink，用来扩大或缩小堆上已分配的内存，对应 C 的 realloc。</p>
</li>
</ol>
</div>
</details>
<details id="admonition-替换默认的内存分配器" class="admonition info">
<summary class="admonition-title">
<p>替换默认的内存分配器</p>
<p><a class="admonition-anchor-link" href="#admonition-替换默认的内存分配器"></a></p>
</summary>
<div>
<p>如果你想替换默认的内存分配器，可以使用 #[global_allocator] 标记宏，定义你自己的全局分配器。下面的代码展示了如何在 Rust
下使用<a href="https://crates.io/crates/jemallocator">jemalloc</a>:</p>
<pre><pre class="playground"><code class="language-rust">
use jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

fn main() {}
</code></pre></pre>
</div>
</details>
<h3 id="实现内存分配器"><a class="header" href="#实现内存分配器">实现内存分配器</a></h3>
<details id="admonition-内存分配器" class="admonition info">
<summary class="admonition-title">
<p>内存分配器</p>
<p><a class="admonition-anchor-link" href="#admonition-内存分配器"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::alloc::{GlobalAlloc, Layout, System};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        let data = System.alloc(layout);
        eprintln!(&quot;ALLOC: {:p}, size {}&quot;, data, layout.size());
        data
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        eprintln!(&quot;FREE: {:p}, size {}&quot;, ptr, layout.size());
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;

#[allow(dead_code)]
struct Matrix {
    // 使用不规则的数字如 505 可以让 dbg! 的打印很容易分辨出来
    data: [u8; 505],
}

impl Default for Matrix {
    fn default() -&gt; Self {
        Self { data: [0; 505] }
    }
}

fn main() {
    // 在这句执行之前已经有一些内存分配和释放
    let data = Box::new(Matrix::default());
    println!(
        &quot;!!! allocated memory: {:p}, len: {}&quot;,
        &amp;*data,
        std::mem::size_of::&lt;Matrix&gt;()
    );

    // data 在这里 drop，可以在打印中看到 FREE
    // 之后还有很多其它内存被释放
}
</code></pre></pre>
<hr />
<ol>
<li>这里 MyAllocator 就用 System allocator，然后加 eprintln!()，和我 们常用的 println!() 不同的是，eprintln!() 将数据打印到 stderr</li>
<li>注意这里不能使用 println!() 。因为 stdout 会打印到一个由 Mutex 互斥锁保护的共享全 局 buffer 中，这个过程中会涉及内存的分配，分配的内存又会触发 println!()，最终造成 程序崩溃。而
eprintln! 直接打印到 stderr，不会 buffer。</li>
<li>在使用 Box 分配堆内存的时候要注意，Box::new() 是一个函数，所以传入它的数据会出现 在栈上，再移动到堆上。所以，如果我们的 Matrix 结构不是 505 个字节，是一个非常大 的结构，就有可能出问题。</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">// #![feature(dropck_eyepatch)]

// struct MyBox&lt;T&gt;(Box&lt;T&gt;);

// unsafe impl&lt;#[may_dangle] T&gt; Drop for MyBox&lt;T&gt; {
//     fn drop(&amp;mut self) {
//         todo!();
//     }
// }

fn main() {
    // 在堆上分配 16M 内存，但它会现在栈上出现，再移动到堆上
    let boxed = Box::new([0u8; 1 &lt;&lt; 24]);
    println!(&quot;len: {}&quot;, boxed.len());
}
</code></pre></pre>
<ul>
<li><code>cargo run --bin box</code>或者在 playground 里运行，直接栈溢出 stack overflow</li>
<li>本地使用 “cargo run –bin box —release” 编译成 release 代码运行，会正常执行！</li>
</ul>
<blockquote>
<p>这是因为 “cargo run” 或者在 playground 下运行，默认是 debug build，它不会做任 何 inline 的优化，而 Box::new() 的实现就一行代码，并注明了要 inline，在 release 模式
下，这个函数调用会被优化掉, 本质是编译器自动调用下列方式:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(not(no_global_oom_handling))]
#[inline(always)]
#[doc(alias = &quot;alloc&quot;)]
#[doc(alias = &quot;malloc&quot;)]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub fn new(x: T) -&gt; Self {
    box x
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这里的关键字 box是 Rust 内部的关键字，用户代码无法调用，它只出现在 Rust 代码中，用于分配堆内存，box 关键字在编译时，会使用内存分配器 分配内存。</p>
</blockquote>
</div>
</details>
<h3 id="内存如何释放"><a class="header" href="#内存如何释放">内存如何释放</a></h3>
<details id="admonition-box默认实现的drop-trait" class="admonition info">
<summary class="admonition-title">
<p>Box<T>默认实现的Drop trait</p>
<p><a class="admonition-anchor-link" href="#admonition-box默认实现的drop-trait"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
unsafe impl&lt;#[may_dangle] T: ?Sized, A: Allocator&gt; Drop for Box&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        // FIXME: Do nothing, drop is currently performed by compiler.
    }
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-先稳定接口再迭代稳定实现" class="admonition info">
<summary class="admonition-title">
<p>先稳定接口，再迭代稳定实现</p>
<p><a class="admonition-anchor-link" href="#admonition-先稳定接口再迭代稳定实现"></a></p>
</summary>
<div>
<p>目前 drop trait 什么都没有做，编译器会自动插入 deallocate 的代码。这是 Rust 语 言的一种策略：在具体实现还没有稳定下来之前，我先把接口稳定，实现随着之后的迭代 慢慢稳定。</p>
</div>
</details>
<h2 id="cowa-b-写时拷贝"><a class="header" href="#cowa-b-写时拷贝">Cow&lt;’a, B&gt;： 写时拷贝</a></h2>
<div id="admonition-写时复制copy-on-write有异曲同工之妙" class="admonition info">
<div class="admonition-title">
<p>写时复制（Copy-on-write）有异曲同工之妙</p>
<p><a class="admonition-anchor-link" href="#admonition-写时复制copy-on-write有异曲同工之妙"></a></p>
</div>
<div>
<p>Cow 是 Rust 下用于提供写时克隆（Clone-on-Write）的一个智能指针，它跟虚拟内存管 理的写时复制（Copy-on-write）有异曲同工之妙：</p>
<blockquote>
<p>包裹一个只读借用，但如果调用者需 要所有权或者需要修改内容，那么它会 clone 借用的数据</p>
</blockquote>
</div>
</div>
<h3 id="定义"><a class="header" href="#定义">定义</a></h3>
<div id="admonition-cow定义" class="admonition info">
<div class="admonition-title">
<p>Cow定义</p>
<p><a class="admonition-anchor-link" href="#admonition-cow定义"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub enum Cow&lt;'a, B&gt; where B: 'a + ToOwned + ?Sized {
    Borrowed(&amp;'a B),
    Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>它是一个 enum，可以包含一个对类型 B 的只读引用，或者包含对类型 B 的拥有所有权的 数据。</p>
</blockquote>
</div>
</div>
<h3 id="两个traittoownedborrowed"><a class="header" href="#两个traittoownedborrowed">两个trait：ToOwned、Borrowed</a></h3>
<div id="admonition-cow定义用到两个traittoowned和borrowed" class="admonition info">
<div class="admonition-title">
<p>Cow定义用到两个trait：ToOwned和Borrowed</p>
<p><a class="admonition-anchor-link" href="#admonition-cow定义用到两个traittoowned和borrowed"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait ToOwned {
    type Owned: Borrow&lt;Self&gt;;
    #[must_use = &quot;cloning is often expensive and is not expected to have side effects&quot;]
    fn to_owned(&amp;self) -&gt; Self::Owned;

    fn clone_into(&amp;self, target: &amp;mut Self::Owned) { ... }
}

pub trait Borrow&lt;Borrowed&gt; where Borrowed: ?Sized {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>它是一个 enum，可以包含一个对类型 B 的只读引用，或者包含对类型 B 的拥有所有权的 数据。</p>
</blockquote>
</div>
</div>
<h3 id="toowned"><a class="header" href="#toowned">ToOwned</a></h3>
<div id="admonition-type-owned-borrow" class="admonition info">
<div class="admonition-title">
<p>type Owned: Borrow<Self></p>
<p><a class="admonition-anchor-link" href="#admonition-type-owned-borrow"></a></p>
</div>
<div>
<ol>
<li>首先，type Owned: Borrow<Self> 是一个带有关联类型的 trait. 这里 Owned 是关联类型，需要使用者定义.</li>
<li>这里 Owned 不能是任意类型，它必须满足 Borrow<T> trait</li>
<li><a href="https://doc.rust-lang.org/src/alloc/str.rs.html#215-227">参考str对ToOwned trait的实现</a>：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl ToOwned for str {
    type Owned = String;
    #[inline]
    fn to_owned(&amp;self) -&gt; String {
        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }
    }

    fn clone_into(&amp;self, target: &amp;mut String) {
        let mut b = mem::take(target).into_bytes();
        self.as_bytes().clone_into(&amp;mut b);
        *target = unsafe { String::from_utf8_unchecked(b) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol start="4">
<li>可以看到关联类型 Owned 被定义为 String，而根据要求，String 必须定义 Borrow，那这里 Borrow 里的泛型变量 T 是谁呢？</li>
<li>ToOwned 要求是 Borrow，而此刻实现 ToOwned 的主体是 str，所以 Borrow 是 Borrow，也就是说 String 要实现 Borrow</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl Borrow&lt;str&gt; for String {
    #[inline]
    fn borrow(&amp;self) -&gt; &amp;str {
        &amp;self[..]
    }
}
<span class="boring">}
</span></code></pre></pre>
</div>
</div>
<div id="admonition-cow-和-toowned--borrow-之间的关系示意图" class="admonition info">
<div class="admonition-title">
<p>Cow 和 ToOwned / Borrow<T> 之间的关系示意图</p>
<p><a class="admonition-anchor-link" href="#admonition-cow-和-toowned--borrow-之间的关系示意图"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/15%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F-4781304.jpg" alt="type Owned: Borrow&lt;Self&gt; " /></p>
</div>
</div>
<h3 id="匹配分发"><a class="header" href="#匹配分发">匹配分发</a></h3>
<div id="admonition-为何-borrow-要定义成一个泛型-trait-呢" class="admonition info">
<div class="admonition-title">
<p>为何 Borrow 要定义成一个泛型 trait 呢？</p>
<p><a class="admonition-anchor-link" href="#admonition-为何-borrow-要定义成一个泛型-trait-呢"></a></p>
</div>
<div>
<ol>
<li>例子1：String不同借用方式</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use std::borrow::Borrow;

fn main() {
    let s = &quot;hello world!&quot;.to_owned();

    // 这里必须声明类型，因为 String 有多个 Borrow&lt;T&gt; 实现
    // 借用为 &amp;String
    let r1: &amp;String = s.borrow();
    // 借用为 &amp;str
    let r2: &amp;str = s.borrow();

    println!(&quot;r1: {:p}, r2: {:p}&quot;, r1, r2);
}
</code></pre></pre>
<blockquote>
<p>String 可以被借用为 &amp;String，也可以被借用为 &amp;str</p>
</blockquote>
<hr />
<ol start="2">
<li>例子2：Cow不同解引用方式</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;B: ?Sized + ToOwned&gt; Deref for Cow&lt;'_, B&gt; {
    type Target = B;

    fn deref(&amp;self) -&gt; &amp;B {
        match *self {
            Borrowed(borrowed) =&gt; borrowed,
            Owned(ref owned) =&gt; owned.borrow(),
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<hr />
<p>实现的原理很简单，根据 self 是 Borrowed 还是 Owned，我们分别取其内容，生成引 用：</p>
<ol>
<li>
<p>对于 Borrowed，直接就是引用；</p>
</li>
<li>
<p>对于 Owned，调用其 borrow() 方法，获得引用。</p>
</li>
</ol>
</div>
</div>
<div id="admonition-匹配分发使用match匹配实现静态动态分发之外的第三种分发" class="admonition info">
<div class="admonition-title">
<p>匹配分发：使用match匹配实现静态、动态分发之外的第三种分发</p>
<p><a class="admonition-anchor-link" href="#admonition-匹配分发使用match匹配实现静态动态分发之外的第三种分发"></a></p>
</div>
<div>
<p>虽然 Cow 是一个 enum，但是通过 Deref 的实现，我们可以获得统一的 体验.
比如 Cow<str>，使用的感觉和 &amp;str / String 是基本一致的。
注意，这种根据 enum 的不同状态来进行统一分发的方法是第三种分发手段，另外还可以使用泛型参数 做静态分发和使用 trait object 做动态分发</p>
</div>
</div>
<h3 id="cow在需要时才进行内存分配拷贝"><a class="header" href="#cow在需要时才进行内存分配拷贝">Cow在需要时才进行内存分配拷贝</a></h3>
<div id="admonition-写时拷贝" class="admonition info">
<div class="admonition-title">
<p>写时拷贝</p>
<p><a class="admonition-anchor-link" href="#admonition-写时拷贝"></a></p>
</div>
<div>
<p>那么 Cow 有什么用呢？</p>
<ol>
<li>显然，它可以在需要的时候才进行内存的分配和拷贝，在很多应用 场合，它可以大大提升系统的效率。</li>
<li>如果 Cow&lt;’a, B&gt; 中的 Owned 数据类型是一个需要 在堆上分配内存的类型，如 String、Vec<T> 等，还能减少堆内存分配的次数。 </li>
<li>相对于栈内存的分配释放来说，堆内存的分配和释放效率要低很多，其内部还 涉及系统调用和锁，减少不必要的堆内存分配是提升系统效率的关键手段。</li>
<li>而 Rust 的 Cow&lt;’a, B&gt;，在帮助你达成这个效果的同时，使用体验还非常简单舒服。</li>
</ol>
</div>
</div>
<details id="admonition-举例使用cow进行url解析" class="admonition info">
<summary class="admonition-title">
<p>举例使用Cow进行URL解析</p>
<p><a class="admonition-anchor-link" href="#admonition-举例使用cow进行url解析"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::borrow::Cow;

use url::Url;
fn main() {
    let url = Url::parse(&quot;https://tyr.com/rust?page=1024&amp;sort=desc&amp;extra=hello%20world&quot;).unwrap();
    let mut pairs = url.query_pairs();

    assert_eq!(pairs.count(), 3);

    let (mut k, v) = pairs.next().unwrap();
    // 因为 k, v 都是 Cow&lt;str&gt; 他们用起来感觉和 &amp;str 或者 String 一样
    // 此刻，他们都是 Borrowed
    println!(&quot;key: {}, v: {}&quot;, k, v);
    // 当修改发生时，k 变成 Owned
    k.to_mut().push_str(&quot;_lala&quot;);

    print_pairs((k, v));

    print_pairs(pairs.next().unwrap());
    print_pairs(pairs.next().unwrap());
}

fn print_pairs(pair: (Cow&lt;str&gt;, Cow&lt;str&gt;)) {
    println!(&quot;key: {}, value: {}&quot;, show_cow(pair.0), show_cow(pair.1));
}

fn show_cow(cow: Cow&lt;str&gt;) -&gt; String {
    match cow {
        Cow::Borrowed(v) =&gt; format!(&quot;Borrowed {}&quot;, v),
        Cow::Owned(v) =&gt; format!(&quot;Owned {}&quot;, v),
    }
}
</code></pre></pre>
<hr />
<blockquote>
<p>在解析 URL 的时候，我们经常需要将 querystring 中的参数，提取成 KV pair 来进一步使 用。
绝大多数语言中，提取出来的 KV 都是新的字符串，在每秒钟处理几十 k 甚至上百 k 请求的系统中，你可以想象这会带来多少次堆内存的分配。 
但在 Rust 中，我们可以用 Cow 类型轻松高效处理它，在读取 URL 的过程中：</p>
</blockquote>
<ol>
<li>每解析出一个 key 或者 value，我们可以用一个 &amp;str 指向 URL 中相应的位置，然后用 Cow 封装它 </li>
<li>而当解析出来的内容不能直接使用，需要 decode 时，比如 “hello%20world”，我们 可以生成一个解析后的 String，同样用 Cow 封装它。</li>
</ol>
</div>
</details>
<details id="admonition-举例serde使用cow进行序列化反序列化" class="admonition info">
<summary class="admonition-title">
<p>举例serde使用Cow进行序列化/反序列化</p>
<p><a class="admonition-anchor-link" href="#admonition-举例serde使用cow进行序列化反序列化"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use serde::Deserialize;
use std::borrow::Cow;

#[allow(dead_code)]
#[derive(Debug, Deserialize)]
struct User&lt;'input&gt; {
    #[serde(borrow)]
    name: Cow&lt;'input, str&gt;,
    age: u8,
}

fn main() {
    let input = r#&quot;{ &quot;name&quot;: &quot;Tyr&quot;, &quot;age&quot;: 18 }&quot;#;
    let user: User = serde_json::from_str(input).unwrap();

    match user.name {
        Cow::Borrowed(x) =&gt; println!(&quot;borrowed {}&quot;, x),
        Cow::Owned(x) =&gt; println!(&quot;owned {}&quot;, x),
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="mutexguard-数据加锁"><a class="header" href="#mutexguard-数据加锁">MutexGuard<T>： 数据加锁</a></h2>
<h3 id="mutexguard与stringboxcowa-b的对比"><a class="header" href="#mutexguard与stringboxcowa-b的对比">MutexGuard与String、Box<T>、Cow&lt;’a, B&gt;的对比</a></h3>
<details id="admonition-derefdrop" class="admonition info">
<summary class="admonition-title">
<p>Deref+Drop</p>
<p><a class="admonition-anchor-link" href="#admonition-derefdrop"></a></p>
</summary>
<div>
<p>String、Box<T>、Cow&lt;’a, B&gt; 等智能指针，都是通过 Deref 来提 供良好的用户体验， 
MutexGuard<T> 是另外一类很有意思的智能指针：</p>
<ol>
<li>它不但通过 Deref 提供良好的用户体验</li>
<li>还通过 Drop trait 来确保，使用到的内存以外的资源在退出 时进行释放。</li>
</ol>
</div>
</details>
<h3 id="使用mutexlock获取"><a class="header" href="#使用mutexlock获取">使用Mutex::lock获取</a></h3>
<details id="admonition-mutexguard这个结构是在调用-mutexlock-时生成的" class="admonition info">
<summary class="admonition-title">
<p>MutexGuard这个结构是在调用 Mutex::lock 时生成的</p>
<p><a class="admonition-anchor-link" href="#admonition-mutexguard这个结构是在调用-mutexlock-时生成的"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
    unsafe {
        self.inner.raw_lock();
        MutexGuard::new(self)
    }
}
</code></pre></pre>
<hr />
<p><a href="https://doc.rust-lang.org/src/std/sync/mutex.rs.html#279-284">rust文档</a></p>
<ol>
<li>首先，它会取得锁资源，如果拿不到，会在这里等待；</li>
<li>如果拿到了，会把 Mutex 结构的引 用传递给 MutexGuard。</li>
</ol>
</div>
</details>
<h3 id="定义与derefdrop-trait实现"><a class="header" href="#定义与derefdrop-trait实现">定义与Deref、Drop trait实现</a></h3>
<details id="admonition-mutexguard-的定义以及它的-deref-和-drop-的实现" class="admonition info">
<summary class="admonition-title">
<p>MutexGuard 的定义以及它的 Deref 和 Drop 的实现</p>
<p><a class="admonition-anchor-link" href="#admonition-mutexguard-的定义以及它的-deref-和-drop-的实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
// 这里用 must_use，当你得到了却不使用 MutexGuard 时会报警
#[must_use = &quot;if unused the Mutex will immediately unlock&quot;]
pub struct MutexGuard&lt;'a, T: ?Sized + 'a&gt; {
    lock: &amp;'a Mutex&lt;T&gt;,
    poison: poison::Guard,
}

impl&lt;T: ?Sized&gt; Deref for MutexGuard&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        unsafe { &amp;*self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; DerefMut for MutexGuard&lt;'_, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        unsafe { &amp;mut *self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    #[inline]
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.poison.done(&amp;self.poison);
            self.lock.inner.raw_unlock();
        }
    }
}
</code></pre></pre>
<hr />
<p>从代码中可以看到:</p>
<ol>
<li>当 MutexGuard 结束时，Mutex 会做 unlock</li>
<li>这样用户在使用 Mutex 时，可以不必关心何时释放这个互斥锁。</li>
<li>因为无论你在调用栈上怎样传递 MutexGuard ，哪怕在错误处理流程上提前退出，Rust 有所有权机制，可以确保只要 MutexGuard 离开作用域，锁就会被释放</li>
</ol>
</div>
</details>
<h3 id="使用mutex_mutexguard的例子"><a class="header" href="#使用mutex_mutexguard的例子">使用Mutex_MutexGuard的例子</a></h3>
<details id="admonition-mutex--mutexguard-example" class="admonition info">
<summary class="admonition-title">
<p>Mutex &amp; MutexGuard example</p>
<p><a class="admonition-anchor-link" href="#admonition-mutex--mutexguard-example"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use lazy_static::lazy_static;
use std::borrow::Cow;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

// lazy_static 宏可以生成复杂的 static 对象
lazy_static! {
    // 一般情况下 Mutex 和 Arc 一起在多线程环境下提供对共享内存的使用
    // 如果你把 Mutex 声明成 static，其生命周期是静态的，不需要 Arc
    static ref METRICS: Mutex&lt;HashMap&lt;Cow&lt;'static, str&gt;, usize&gt;&gt; =
        Mutex::new(HashMap::new());
}

fn main() {
    // 用 Arc 来提供并发环境下的共享所有权（使用引用计数）
    let metrics: Arc&lt;Mutex&lt;HashMap&lt;Cow&lt;'static, str&gt;, usize&gt;&gt;&gt; =
        Arc::new(Mutex::new(HashMap::new()));
    for _ in 0..32 {
        let m = metrics.clone();
        thread::spawn(move || {
            let mut g = m.lock().unwrap();
            // 此时只有拿到 MutexGuard 的线程可以访问 HashMap
            let data = &amp;mut *g;
            // Cow 实现了很多数据结构的 From trait，所以我们可以用 &quot;hello&quot;.into() 生成 Cow
            let entry = data.entry(&quot;hello&quot;.into()).or_insert(0);
            *entry += 1;
            // MutexGuard 被 Drop，锁被释放
        });
    }

    thread::sleep(Duration::from_millis(100));

    println!(&quot;metrics: {:?}&quot;, metrics.lock().unwrap());
}
</code></pre></pre>
<hr />
<blockquote>
<p>在解析 URL 的时候，我们经常需要将 querystring 中的参数，提取成 KV pair 来进一步使 用。
绝大多数语言中，提取出来的 KV 都是新的字符串，在每秒钟处理几十 k 甚至上百 k 请求的系统中，你可以想象这会带来多少次堆内存的分配。 
但在 Rust 中，我们可以用 Cow 类型轻松高效处理它，在读取 URL 的过程中：</p>
</blockquote>
<ol>
<li>每解析出一个 key 或者 value，我们可以用一个 &amp;str 指向 URL 中相应的位置，然后用 Cow 封装它 </li>
<li>而当解析出来的内容不能直接使用，需要 decode 时，比如 “hello%20world”，我们 可以生成一个解析后的 String，同样用 Cow 封装它。</li>
</ol>
</div>
</details>
<details id="admonition-你可以把-mutexguard-的引用传给另一个线程使用但你无法把-mutexguard-整个移动到另一个线程" class="admonition info">
<summary class="admonition-title">
<p>你可以把 MutexGuard 的引用传给另一个线程使用，但你无法把 MutexGuard 整个移动到另一个线程</p>
<p><a class="admonition-anchor-link" href="#admonition-你可以把-mutexguard-的引用传给另一个线程使用但你无法把-mutexguard-整个移动到另一个线程"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::sync::Mutex;

fn main() {
    //
    let m = Mutex::new(Mutex::new(1));
    let g = m.lock().unwrap();
    {
        rayon::join(
            || {
                let mut g1 = g.lock().unwrap();
                *g1 += 1;
                println!(&quot;Thread 1: {:?}&quot;, *g1);
            },
            || {
                let mut g1 = g.lock().unwrap();
                *g1 += 1;
                println!(&quot;Thread 1: {:?}&quot;, *g1);
            },
        );
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-mutexguard-的智能指针有很多用途" class="admonition info">
<summary class="admonition-title">
<p>MutexGuard 的智能指针有很多用途</p>
<p><a class="admonition-anchor-link" href="#admonition-mutexguard-的智能指针有很多用途"></a></p>
</summary>
<div>
<ul>
<li>r2d2类似实现一个数据库连接池：<a href="https://github.com/sfackler/r2d2/blob/master/src/lib.rs#L611-L638">源码</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;M&gt; Drop for PooledConnection&lt;M&gt;
where
    M: ManageConnection,
{
    fn drop(&amp;mut self) {
        self.pool.put_back(self.checkout, self.conn.take().unwrap());
    }
}

impl&lt;M&gt; Deref for PooledConnection&lt;M&gt;
where
    M: ManageConnection,
{
    type Target = M::Connection;

    fn deref(&amp;self) -&gt; &amp;M::Connection {
        &amp;self.conn.as_ref().unwrap().conn
    }
}

impl&lt;M&gt; DerefMut for PooledConnection&lt;M&gt;
where
    M: ManageConnection,
{
    fn deref_mut(&amp;mut self) -&gt; &amp;mut M::Connection {
        &amp;mut self.conn.as_mut().unwrap().conn
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>类似 MutexGuard 的智能指针有很多用途。比如要创建一个连接池，你可以在 Drop trait 中，回收 checkout 出来的连接，将其再放回连接池。</li>
</ul>
</div>
</details>
<h2 id="自定义智能指针"><a class="header" href="#自定义智能指针">自定义智能指针</a></h2>
<details id="admonition-mystring结构示意图" class="admonition info">
<summary class="admonition-title">
<p>MyString结构示意图</p>
<p><a class="admonition-anchor-link" href="#admonition-mystring结构示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/15%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F-4783668.jpg" alt="MyString" /></p>
</div>
</details>
<details id="admonition-mystring实现代码" class="admonition info">
<summary class="admonition-title">
<p>MyString实现代码</p>
<p><a class="admonition-anchor-link" href="#admonition-mystring实现代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::{fmt, ops::Deref, str};

const MINI_STRING_MAX_LEN: usize = 30;

// MyString 里，String 有 3 个 word，供 24 字节，所以它以 8 字节对齐
// 所以 enum 的 tag + padding 最少 8 字节，整个结构占 32 字节。
// MiniString 可以最多有 30 字节（再加上 1 字节长度和 1字节 tag），就是 32 字节.
struct MiniString {
    len: u8,
    data: [u8; MINI_STRING_MAX_LEN],
}

impl MiniString {
    // 这里 new 接口不暴露出去，保证传入的 v 的字节长度小于等于 30
    fn new(v: impl AsRef&lt;str&gt;) -&gt; Self {
        let bytes = v.as_ref().as_bytes();
        // 我们在拷贝内容时一定要要使用字符串的字节长度
        let len = bytes.len();
        let mut data = [0u8; MINI_STRING_MAX_LEN];
        data[..len].copy_from_slice(bytes);
        Self {
            len: len as u8,
            data,
        }
    }
}

impl Deref for MiniString {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        // 由于生成 MiniString 的接口是隐藏的，它只能来自字符串，所以下面这行是安全的
        str::from_utf8(&amp;self.data[..self.len as usize]).unwrap()
        // 也可以直接用 unsafe 版本
        // unsafe { str::from_utf8_unchecked(&amp;self.data[..self.len as usize]) }
    }
}

impl fmt::Debug for MiniString {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        // 这里由于实现了 Deref trait，可以直接得到一个 &amp;str 输出
        write!(f, &quot;{}&quot;, self.deref())
    }
}

#[derive(Debug)]
enum MyString {
    Inline(MiniString),
    Standard(String),
}

// 实现 Deref 接口对两种不同的场景统一得到 &amp;str
impl Deref for MyString {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        match *self {
            MyString::Inline(ref v) =&gt; v.deref(),
            MyString::Standard(ref v) =&gt; v.deref(),
        }
    }
}

// impl From&lt;&amp;str&gt; for MyString {
//     fn from(s: &amp;str) -&gt; Self {
//         match s.len() &gt; MINI_STRING_MAX_LEN {
//             true =&gt; Self::Standard(s.to_owned()),
//             _ =&gt; Self::Inline(MiniString::new(s)),
//         }
//     }
// }

// impl From&lt;String&gt; for MyString {
//     fn from(s: String) -&gt; Self {
//         match s.len() &gt; MINI_STRING_MAX_LEN {
//             true =&gt; Self::Standard(s),
//             _ =&gt; Self::Inline(MiniString::new(s)),
//         }
//     }
// }

impl&lt;T&gt; From&lt;T&gt; for MyString
where
    T: AsRef&lt;str&gt;,
{
    fn from(s: T) -&gt; Self {
        match s.as_ref().len() &gt; MINI_STRING_MAX_LEN {
            true =&gt; Self::Standard(s.as_ref().to_owned()),
            _ =&gt; Self::Inline(MiniString::new(s)),
        }
    }
}

impl fmt::Display for MyString {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.deref())
    }
}

impl MyString {
    pub fn push_str(&amp;mut self, s: &amp;str) {
        match *self {
            MyString::Inline(ref mut v) =&gt; {
                let len = v.len as usize;
                let len1 = s.len();
                if len + len1 &gt; MINI_STRING_MAX_LEN {
                    let mut owned = v.deref().to_string();
                    owned.push_str(s);
                    *self = MyString::Standard(owned);
                } else {
                    let total = len + len1;
                    v.data[len..len + len1].copy_from_slice(s.as_bytes());
                    v.len = total as u8;
                }
            }
            MyString::Standard(ref mut v) =&gt; v.push_str(s),
        }
    }
}

fn main() {
    let len1 = std::mem::size_of::&lt;MyString&gt;();
    let len2 = std::mem::size_of::&lt;MiniString&gt;();
    println!(&quot;Len: MyString {}, MiniString {}&quot;, len1, len2);

    let s1: MyString = &quot;hello world&quot;.into();
    let s2: MyString = &quot;这是一个超过了三十个字节的很长很长的字符串&quot;.into();

    // debug 输出
    println!(&quot;s1: {:?}, s2: {:?}&quot;, s1, s2);
    // display 输出
    println!(
        &quot;s1: {}({} bytes, {} chars), s2: {}({} bytes, {} chars)&quot;,
        s1,
        s1.len(),
        s1.chars().count(),
        s2,
        s2.len(),
        s2.chars().count()
    );

    // MyString 可以使用一切 &amp;str 接口，感谢 Rust 的自动 Deref
    assert!(s1.ends_with(&quot;world&quot;));
    assert!(s2.starts_with('这'));

    let s = String::from(&quot;这是一个超过了三十个字节的很长很长的字符串&quot;);
    println!(&quot;s: {:p}&quot;, &amp;*s);
    // From&lt;T: AsRef&lt;str&gt;&gt; 的实现会导致额外的复制
    let s3: MyString = s.into();
    println!(&quot;s3: {:p}&quot;, &amp;*s3);

    let mut s4: MyString = &quot;Hello Tyr! &quot;.into();
    println!(&quot;s4: {:?}&quot;, s4);
    s4.push_str(&quot;这是一个超过了三十个字节的很长很长的字符串&quot;);
    println!(&quot;s4: {:?}&quot;, s4);
}
</code></pre></pre>
<hr />
<p>为了让 MyString 表现行为和 &amp;str 一致:</p>
<ol>
<li>我们可以通过实现 Deref trait 让 MyString 可以被解引用成 &amp;str。</li>
<li>除此之外，还可以实现 Debug/Display 和 From<T> trait，让 MyString 使用起来更方便。</li>
<li>这个简单实现的 MyString，不管它内部的数据是纯栈上的 MiniString 版本，还是包含堆 上内存的 String 版本，使用的体验和 &amp;str 都一致，仅仅牺牲了一点点效率和内存，就可
以让小容量的字符串，可以高效地存储在栈上并且自如地使用。</li>
<li><a href="https://github.com/bodil/smartstring">smartstring</a> 的第三方库实现类似功能，还做了优化。</li>
</ol>
</div>
</details>
<h1 id="二集合容器"><a class="header" href="#二集合容器">二、集合容器</a></h1>
<h2 id="对容器进行定义"><a class="header" href="#对容器进行定义">对容器进行定义</a></h2>
<details id="admonition-容器数据结构如何理解" class="admonition tip">
<summary class="admonition-title">
<p>容器数据结构如何理解</p>
<p><a class="admonition-anchor-link" href="#admonition-容器数据结构如何理解"></a></p>
</summary>
<div>
<p>提到容器，很可能你首先会想到的就是数组、列表这些可以遍历的容器，但其实只要把某 种特定的数据封装在某个数据结构中，这个数据结构就是一个容器。比如 Option<T>，它 是一个包裹了 T 存在或不存在的容器，而 Cow 是一个封装了内部数据 B 或被借用或拥有 所有权的容器。</p>
</div>
</details>
<h2 id="对集合容器进行定义"><a class="header" href="#对集合容器进行定义">对集合容器进行定义</a></h2>
<details id="admonition-把拥有相同类型对数据放在一起统一处理" class="admonition tip">
<summary class="admonition-title">
<p>把拥有相同类型对数据放在一起，统一处理</p>
<p><a class="admonition-anchor-link" href="#admonition-把拥有相同类型对数据放在一起统一处理"></a></p>
</summary>
<div>
<p>集合容器，顾名思义，就是把一系列拥有相同类型的数据放在一起，统一处理，比如：</p>
<ol>
<li>
<p>我们熟悉的字符串 String、数组 [T; n]、列表 Vec<T> 和哈希表 HashMap&lt;K, V&gt; 等；</p>
</li>
<li>
<p>虽然到处在使用，但还并不熟悉的切片 slice；</p>
</li>
<li>
<p>在其他语言中使用过，但在 Rust 中还没有用过的循环缓冲区 VecDeque<T>、双向列 表 LinkedList<T> 等。</p>
</li>
</ol>
<blockquote>
<p>这些集合容器有很多共性，比如可以被遍历、可以进行 map-reduce 操作、可以从一种类 型转换成另一种类型等等。</p>
</blockquote>
</div>
</details>
<h2 id="切片"><a class="header" href="#切片">切片</a></h2>
<details id="admonition-切片到底是什么" class="admonition tip">
<summary class="admonition-title">
<p>切片到底是什么</p>
<p><a class="admonition-anchor-link" href="#admonition-切片到底是什么"></a></p>
</summary>
<div>
<p>在 Rust 里，切片是描述一组属于同一类型、长度不确定的、在内存中连续存放的数据结 构，用 [T] 来表述。因为长度不确定，所以切片是个 DST（Dynamically Sized Type）。</p>
<p>切片一般只出现在数据结构的定义中，不能直接访问，在使用中主要用以下形式：</p>
<ul>
<li>
<p>&amp;[T]：表示一个只读的切片引用。</p>
</li>
<li>
<p>&amp;mut [T]：表示一个可写的切片引用。</p>
</li>
<li>
<p>Box&lt;[T]&gt;：一个在堆上分配的切片。</p>
</li>
</ul>
</div>
</details>
<details id="admonition-切片与数据的关系" class="admonition tip">
<summary class="admonition-title">
<p>切片与数据的关系</p>
<p><a class="admonition-anchor-link" href="#admonition-切片与数据的关系"></a></p>
</summary>
<div>
<h2 id="怎么理解切片呢我打个比方切片之于具体的数据结构就像数据库中的视图之于表-你可以把它看成一种工具让我们可以统一访问行为相同结构类似但有些许差异的类-型"><a class="header" href="#怎么理解切片呢我打个比方切片之于具体的数据结构就像数据库中的视图之于表-你可以把它看成一种工具让我们可以统一访问行为相同结构类似但有些许差异的类-型">怎么理解切片呢？我打个比方，切片之于具体的数据结构，就像数据库中的视图之于表。 你可以把它看成一种工具，让我们可以统一访问行为相同、结构类似但有些许差异的类 型。</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let arr = [1, 2, 3, 4, 5];
    let vec = vec![1, 2, 3, 4, 5];
    let s1 = &amp;arr[1..3];
    let s2 = &amp;vec[1..3];
    println!(&quot;s1: {:?}, s2: {:?}&quot;, s1, s2);

    // &amp;[T] 和 &amp;[T] 是否相等取决于长度和内容是否相等
    assert_eq!(s1, s2);
    // &amp;[T] 可以和 Vec&lt;T&gt;/[T;n] 比较，也会看长度和内容
    assert_eq!(&amp;arr[..], vec);
    assert_eq!(&amp;vec[..], arr);
}
</code></pre></pre>
<ol>
<li>对于 array 和 vector，虽然是不同的数据结构，一个放在栈上，一个放在堆上，但它们的 切片是类似的；</li>
<li>而且对于相同内容数据的相同切片，比如 &amp;arr[1…3] 和 &amp;vec[1…3]，这 两者是等价的。</li>
<li>除此之外，切片和对应的数据结构也可以直接比较，这是因为它们之间实 现了 PartialEq trait
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4785008.jpg" alt="切片与具体数据的关系" /></li>
</ol>
</div>
</details>
<h3 id="array-vs-vector"><a class="header" href="#array-vs-vector">array vs vector</a></h3>
<details id="admonition-array和vector的区别与联系" class="admonition info">
<summary class="admonition-title">
<p>array和vector的区别与联系</p>
<p><a class="admonition-anchor-link" href="#admonition-array和vector的区别与联系"></a></p>
</summary>
<div>
<p>对于 array 和 vector，虽然是不同的数据结构：</p>
<ul>
<li>一个放在栈上</li>
<li>一个放在堆上</li>
</ul>
<blockquote>
<p>但它们的切片是类似的, 而且对于相同内容数据的相同切片</p>
</blockquote>
<ul>
<li>比如 &amp;arr[1…3] 和 &amp;vec[1…3]，这两者是等价的。</li>
<li>除此之外，切片和对应的数据结构也可以直接比较，这是因为它们之间实现了 PartialEq trait（源码参考资料）。</li>
</ul>
<blockquote>
<p>下图比较清晰地呈现了切片和数据之间的关系：
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4866674.jpg" alt="切片和数据之间的关系" /></p>
</blockquote>
</div>
</details>
<h3 id="vec-和-t"><a class="header" href="#vec-和-t">Vec<T> 和 &amp;[T]</a></h3>
<details id="admonition-t与vect关系" class="admonition tip">
<summary class="admonition-title">
<p>&amp;[T]与&amp;Vec[T]关系</p>
<p><a class="admonition-anchor-link" href="#admonition-t与vect关系"></a></p>
</summary>
<div>
<p>![&amp;[T]和&amp;Vec[T]](https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4785147.jpg)</p>
</div>
</details>
<h3 id="解引用"><a class="header" href="#解引用">解引用</a></h3>
<details id="admonition-支持切片的具体数据类型可以根据需要解引用转换成切片类型" class="admonition info">
<summary class="admonition-title">
<p>支持切片的具体数据类型可以根据需要解引用转换成切片类型</p>
<p><a class="admonition-anchor-link" href="#admonition-支持切片的具体数据类型可以根据需要解引用转换成切片类型"></a></p>
</summary>
<div>
<p>在使用的时候，支持切片的具体数据类型，你可以根据需要，解引用转换成切片类型。</p>
<ul>
<li>比如 Vec<T> 和 [T; n] 会转化成为 &amp;[T]，这是因为 Vec<T> 实现了 Deref trait，而 array 内建了到 &amp;[T] 的解引用。</li>
<li>我们可以写一段代码验证这一行为（代码）：</li>
</ul>
<hr />
<pre><pre class="playground"><code class="language-rust  editable">
use std::fmt;
fn main() {
    let v = vec![1, 2, 3, 4];

    // Vec 实现了 Deref，&amp;Vec&lt;T&gt; 会被自动解引用为 &amp;[T]，符合接口定义
    print_slice(&amp;v);
    // 直接是 &amp;[T]，符合接口定义
    print_slice(&amp;v[..]);

    // &amp;Vec&lt;T&gt; 支持 AsRef&lt;[T]&gt;
    print_slice1(&amp;v);
    // &amp;[T] 支持 AsRef&lt;[T]&gt;
    print_slice1(&amp;v[..]);
    // Vec&lt;T&gt; 也支持 AsRef&lt;[T]&gt;
    print_slice1(v);

    let arr = [1, 2, 3, 4];
    // 数组虽没有实现 Deref，但它的解引用就是 &amp;[T]
    print_slice(&amp;arr);
    print_slice(&amp;arr[..]);
    print_slice1(&amp;arr);
    print_slice1(&amp;arr[..]);
    print_slice1(arr);
}

// 注意下面的泛型函数的使用
fn print_slice&lt;T: fmt::Debug&gt;(s: &amp;[T]) {
    println!(&quot;{:?}&quot;, s);
}

fn print_slice1&lt;T, U&gt;(s: T)
where
    T: AsRef&lt;[U]&gt;,
    U: fmt::Debug,
{
    println!(&quot;{:?}&quot;, s.as_ref());
}
</code></pre></pre>
<hr />
<blockquote>
<p>这也就意味着，通过解引用，这几个和切片有关的数据结构都会获得切片的所有能力，包括：binary_search、chunks、concat、contains、start_with、end_with、group_by、iter、join、sort、split、swap 等一系列丰富的功能，</p>
</blockquote>
</div>
</details>
<h3 id="切片和迭代器-iterator"><a class="header" href="#切片和迭代器-iterator">切片和迭代器 Iterator</a></h3>
<details id="admonition-迭代器可以说是切片的孪生兄弟" class="admonition info">
<summary class="admonition-title">
<p>迭代器可以说是切片的孪生兄弟</p>
<p><a class="admonition-anchor-link" href="#admonition-迭代器可以说是切片的孪生兄弟"></a></p>
</summary>
<div>
<p>迭代器可以说是切片的孪生兄弟。切片是集合数据的视图，而迭代器定义了对集合数据的各种各样的访问操作。</p>
<p>Iterator trait 有大量的方法，但绝大多数情况下，只需要定义它的关联类型 Item 和 next() 方法。</p>
<ul>
<li>Item 定义了每次我们从迭代器中取出的数据类型；</li>
<li>next() 是从迭代器里取下一个值的方法。当一个迭代器的 next() 方法返回 None 时，表明迭代器中没有数据了。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[must_use = &quot;iterators are lazy and do nothing unless consumed&quot;]
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    // 大量缺省的方法，包括 size_hint, count, chain, zip, map, 
    // filter, for_each, skip, take_while, flat_map, flatten
    // collect, partition 等
    ... 
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-对-vec-使用-iter-方法并进行各种-map--filter--take-操作" class="admonition info">
<summary class="admonition-title">
<p>对 Vec<T> 使用 iter() 方法，并进行各种 map / filter / take 操作</p>
<p><a class="admonition-anchor-link" href="#admonition-对-vec-使用-iter-方法并进行各种-map--filter--take-操作"></a></p>
</summary>
<div>
<p>一个例子：对 Vec<T> 使用 iter() 方法，并进行各种 map / filter / take 操作。在函数式编程语言中，这样的写法很常见，代码的可读性很强。Rust 也支持这种写法（代码）：</p>
<pre><pre class="playground"><code class="language-rust">
fn main() {
    // 这里 Vec&lt;T&gt; 在调用 iter() 时被解引用成 &amp;[T]，所以可以访问 iter()
    let result = vec![1, 2, 3, 4]
        .iter()
        .map(|v| v * v)
        .filter(|v| *v &lt; 16)
        .take(1)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;{:?}&quot;, result);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-rust的迭代器是个懒接口这是如何实现的" class="admonition info">
<summary class="admonition-title">
<p>Rust的迭代器是个懒接口，这是如何实现的？</p>
<p><a class="admonition-anchor-link" href="#admonition-rust的迭代器是个懒接口这是如何实现的"></a></p>
</summary>
<div>
<p>需要注意的是 Rust 下的迭代器是个懒接口（lazy interface），也就是说这段代码直到运行到 collect 时才真正开始执行，之前的部分不过是在不断地生成新的结构，来累积处理逻辑而已。你可能好奇，这是怎么做到的呢？</p>
<p>原来，Iterator 大部分方法都返回一个实现了 Iterator 的数据结构，所以可以这样一路链式下去，在 Rust 标准库中，这些数据结构被称为 <a href="https://doc.rust-lang.org/src/core/iter/adapters/mod.rs.html">Iterator Adapter</a>。比如上面的 map 方法，它返回 Map 结构，而 Map 结构实现了 <a href="https://doc.rust-lang.org/src/core/iter/adapters/map.rs.html#93-133">Iterator（源码）</a>。
整个过程是这样的（链接均为源码资料）：</p>
<ol>
<li>在 collect() 执行的时候，它<a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1744-1749">实际试图使用 FromIterator 从迭代器中构建一个集合类型</a>，这会不断调用 next() 获取下一个数据；</li>
<li>此时的 Iterator 是 Take，Take 调自己的 next()，也就是它会<a href="https://doc.rust-lang.org/src/core/iter/adapters/take.rs.html#34-41">调用 Filter 的 next()</a>；</li>
<li>Filter 的 next() 实际上<a href="https://time.geekbang.org/column/article/422975">调用自己内部的 iter 的 find()</a>，此时内部的 iter 是 Map，find() 会使用 <a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2312-2325">try_fold()</a>，它会<a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2382-2406">继续调用 next()</a>，也就是 Map 的 next()；</li>
<li>Map 的 next() 会<a href="https://time.geekbang.org/column/article/422975">调用其内部的 iter 取 next() 然后执行 map 函数</a>。而此时内部的 iter 来自 Vec<i32>。</li>
</ol>
<p>所以，只有在 collect() 时，才触发代码一层层调用下去，并且调用会根据需要随时结束。这段代码中我们使用了 take(1)，整个调用链循环一次，就能满足 take(1) 以及所有中间过程的要求，所以它只会循环一次。</p>
</div>
</details>
<details id="admonition-rust的函数式编程写法性能如何" class="admonition info">
<summary class="admonition-title">
<p>Rust的函数式编程写法性能如何？</p>
<p><a class="admonition-anchor-link" href="#admonition-rust的函数式编程写法性能如何"></a></p>
</summary>
<div>
<p>你可能会有疑惑：这种函数式编程的写法，代码是漂亮了，然而这么多无谓的函数调用，性能肯定很差吧？毕竟，函数式编程语言的一大恶名就是性能差。</p>
<p>这个你完全不用担心， Rust 大量使用了 inline 等优化技巧，这样非常清晰友好的表达方式，性能和 C 语言的 for 循环差别不大。</p>
</div>
</details>
<details id="admonition-rust的iterator除了标准库还有itertools提供更多功能" class="admonition info">
<summary class="admonition-title">
<p>Rust的iterator除了标准库，还有itertools提供更多功能</p>
<p><a class="admonition-anchor-link" href="#admonition-rust的iterator除了标准库还有itertools提供更多功能"></a></p>
</summary>
<div>
<p>如果标准库中的功能还不能满足你的需求，你可以看看 itertools，它是和 Python 下 itertools 同名且功能类似的工具，提供了大量额外的 adapter。可以看一个简单的例子（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use itertools::Itertools;

fn main() {
    let err_str = &quot;bad happened&quot;;
    let input = vec![Ok(21), Err(err_str), Ok(7)];
    let it = input
        .into_iter()
        .filter_map_ok(|i| if i &gt; 10 { Some(i * 2) } else { None });
    // 结果应该是：vec![Ok(42), Err(err_str)]
    println!(&quot;{:?}&quot;, it.collect::&lt;Vec&lt;_&gt;&gt;());
}
</code></pre></pre>
<p>在实际开发中，我们可能从一组 Future 中汇聚出一组结果，里面有成功执行的结果，也有失败的错误信息。如果想对成功的结果进一步做 filter/map，那么标准库就无法帮忙了，就需要用 itertools 里的 filter_map_ok()。</p>
</div>
</details>
<h3 id="特殊的切片str"><a class="header" href="#特殊的切片str">特殊的切片：&amp;str</a></h3>
<details id="admonition-stringstring和str的区别与联系" class="admonition info">
<summary class="admonition-title">
<p>String、&amp;String和&amp;str的区别与联系</p>
<p><a class="admonition-anchor-link" href="#admonition-stringstring和str的区别与联系"></a></p>
</summary>
<div>
<p>我们来看一种特殊的切片：&amp;str。之前讲过，String 是一个特殊的 Vec<u8>，所以在 String 上做切片，也是一个特殊的结构 &amp;str。</p>
<p>对于 String、&amp;String、&amp;str，很多人也经常分不清它们的区别，我们在之前的一篇加餐中简单聊了这个问题，在上一讲智能指针中，也对比过 String 和 &amp;str。对于 &amp;String 和 &amp;str，如果你理解了上文中 &amp;Vec<T> 和 &amp;[T] 的区别，那么它们也是一样的：
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867212.jpg" alt="&amp;String和&amp;str" /></p>
</div>
</details>
<details id="admonition-string在解引用时会转换成str" class="admonition info">
<summary class="admonition-title">
<p>String在解引用时会转换成&amp;str</p>
<p><a class="admonition-anchor-link" href="#admonition-string在解引用时会转换成str"></a></p>
</summary>
<div>
<p>String 在解引用时，会转换成 &amp;str。可以用下面的代码验证（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::fmt;
fn main() {
    let s = String::from(&quot;hello&quot;);
    // &amp;String 会被解引用成 &amp;str
    print_slice(&amp;s);
    // &amp;s[..] 和 s.as_str() 一样，都会得到 &amp;str
    print_slice(&amp;s[..]);

    // String 支持 AsRef&lt;str&gt;
    print_slice1(&amp;s);
    print_slice1(&amp;s[..]);
    print_slice1(s.clone());

    // String 也实现了 AsRef&lt;[u8]&gt;，所以下面的代码成立
    // 打印出来是 [104, 101, 108, 108, 111]
    print_slice2(&amp;s);
    print_slice2(&amp;s[..]);
    print_slice2(s);
}

fn print_slice(s: &amp;str) {
    println!(&quot;{:?}&quot;, s);
}

fn print_slice1&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
    println!(&quot;{:?}&quot;, s.as_ref());
}

fn print_slice2&lt;T, U&gt;(s: T)
where
    T: AsRef&lt;[U]&gt;,
    U: fmt::Debug,
{
    println!(&quot;{:?}&quot;, s.as_ref());
}
</code></pre></pre>
</div>
</details>
<details id="admonition-字符的列表和字符串有什么关系和区别" class="admonition info">
<summary class="admonition-title">
<p>字符的列表和字符串有什么关系和区别</p>
<p><a class="admonition-anchor-link" href="#admonition-字符的列表和字符串有什么关系和区别"></a></p>
</summary>
<div>
<p>那么字符的列表和字符串有什么关系和区别？我们直接写一段代码来看看：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::iter::FromIterator;

fn main() {
    let arr = ['h', 'e', 'l', 'l', 'o'];
    let vec = vec!['h', 'e', 'l', 'l', 'o'];
    let s = String::from(&quot;hello&quot;);
    let s1 = &amp;arr[1..3];
    let s2 = &amp;vec[1..3];
    // &amp;str 本身就是一个特殊的 slice
    let s3 = &amp;s[1..3];
    println!(&quot;s1: {:?}, s2: {:?}, s3: {:?}&quot;, s1, s2, s3);

    // &amp;[char] 和 &amp;[char] 是否相等取决于长度和内容是否相等
    assert_eq!(s1, s2);
    // &amp;[char] 和 &amp;str 不能直接对比，我们把 s3 变成 Vec&lt;char&gt;
    assert_eq!(s2, s3.chars().collect::&lt;Vec&lt;_&gt;&gt;());
    // &amp;[char] 可以通过迭代器转换成 String，String 和 &amp;str 可以直接对比
    assert_eq!(String::from_iter(s2), s3);
}
</code></pre></pre>
<hr />
<blockquote>
<p>可以看到，字符列表可以通过迭代器转换成 String，String 也可以通过 chars() 函数转换成字符列表，如果不转换，二者不能比较。</p>
</blockquote>
<hr />
<p>下图把数组、列表、字符串以及它们的切片放在一起比较，可以更好地理解它们的区别：
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867332.jpg" alt="数组、列表、字符串和各自的切片" /></p>
</div>
</details>
<h3 id="boxt"><a class="header" href="#boxt">Box&lt;[T]&gt;</a></h3>
<details id="admonition-box和vect对比" class="admonition info">
<summary class="admonition-title">
<p>Box&lt;[T]&gt;和Vec<T>&amp;[T]对比</p>
<p><a class="admonition-anchor-link" href="#admonition-box和vect对比"></a></p>
</summary>
<div>
<p>切片主要有三种使用方式：</p>
<ul>
<li>切片的只读引用 &amp;[T]</li>
<li>切片的可变引用 &amp;mut [T]: 和&amp;[T]类似</li>
<li>Box&lt;[T]&gt;</li>
</ul>
<p>现在我们来看看 Box&lt;[T]&gt;。</p>
<p>Box&lt;[T]&gt; 是一个比较有意思的存在，它和 Vec<T> 有一点点差别：</p>
<ul>
<li>Vec<T> 有额外的 capacity，可以增长；</li>
<li>而 Box&lt;[T]&gt; 一旦生成就固定下来，没有 capacity，也无法增长。</li>
</ul>
<p>Box&lt;[T]&gt; 和切片的引用 &amp;[T] 也很类似：</p>
<ol>
<li>它们都是在栈上有一个包含长度的胖指针，指向存储数据的内存位置。</li>
<li>区别是：Box&lt;[T]&gt; 只会指向堆，&amp;[T] 指向的位置可以是栈也可以是堆；</li>
<li>此外，Box&lt;[T]&gt; 对数据具有所有权，而 &amp;[T] 只是一个借用。</li>
</ol>
<hr />
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867436.jpg" alt="" /></p>
</div>
</details>
<details id="admonition-那么如何产生-box-呢" class="admonition info">
<summary class="admonition-title">
<p>那么如何产生 Box&lt;[T]&gt; 呢？</p>
<p><a class="admonition-anchor-link" href="#admonition-那么如何产生-box-呢"></a></p>
</summary>
<div>
<p>那么如何产生 Box&lt;[T]&gt; 呢？
目前可用的接口就只有一个：从已有的 Vec<T> 中转换。我们看代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::ops::Deref;

fn main() {
    let mut v1 = vec![1, 2, 3, 4];
    v1.push(5);
    println!(&quot;cap should be 8: {}&quot;, v1.capacity());

    // 从 Vec&lt;T&gt; 转换成 Box&lt;[T]&gt;，此时会丢弃多余的 capacity
    let b1 = v1.into_boxed_slice();
    let mut b2 = b1.clone();

    let v2 = b1.into_vec();
    println!(&quot;cap should be exactly 5: {}&quot;, v2.capacity());

    assert!(b2.deref() == v2);

    // Box&lt;[T]&gt; 可以更改其内部数据，但无法 push
    b2[0] = 2;
    // b2.push(6);
    println!(&quot;b2: {:?}&quot;, b2);

    // 注意 Box&lt;[T]&gt; 和 Box&lt;[T; n]&gt; 并不相同
    let b3 = Box::new([2, 2, 3, 4, 5]);
    println!(&quot;b3: {:?}&quot;, b3);

    // b2 和 b3 相等，但 b3.deref() 和 v2 无法比较
    assert!(b2 == b3);
    // assert!(b3.deref() == v2);
}
</code></pre></pre>
<hr />
<p>运行代码可以看到:</p>
<ol>
<li>Vec<T> 可以通过 into_boxed_slice() 转换成 Box&lt;[T]&gt;</li>
<li>Box&lt;[T]&gt; 也可以通过 into_vec() 转换回 Vec<T>。</li>
</ol>
<p>这两个转换都是很轻量的转换，只是变换一下结构，不涉及数据的拷贝。</p>
<p>区别是:</p>
<ol>
<li>当 Vec<T> 转换成 Box&lt;[T]&gt; 时，没有使用到的容量就会被丢弃，所以整体占用的内存可能会降低。</li>
<li>而且 Box&lt;[T]&gt; 有一个很好的特性是，不像 Box&lt;[T;n]&gt; 那样在编译时就要确定大小，它可以在运行期生成，以后大小不会再改变。</li>
</ol>
<p>所以，当我们需要在堆上创建固定大小的集合数据，且不希望自动增长，那么，可以先创建 Vec<T>，再转换成 Box&lt;[T]&gt;。</p>
<blockquote>
<p>tokio 在提供 broadcast channel 时，就使用了 Box&lt;[T]&gt; 这个特性，你感兴趣的话，可以自己看看<a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/sync/broadcast.rs#L447">源码</a>。</p>
</blockquote>
</div>
</details>
<h3 id="常用切片对比图"><a class="header" href="#常用切片对比图">常用切片对比图</a></h3>
<div id="admonition-strtnvectmutt的区别与联系图" class="admonition info">
<div class="admonition-title">
<p>&amp;str、[T;n]、Vec<T>、&amp;[T]、&amp;mut[T]的区别与联系图 </p>
<p><a class="admonition-anchor-link" href="#admonition-strtnvectmutt的区别与联系图"></a></p>
</div>
<div>
<p>下图描述了切片和数组 [T;n]、列表 Vec<T>、切片引用 &amp;[T] /&amp;mut [T]，以及在堆上分配的切片 Box&lt;[T]&gt; 之间的关系。</p>
<blockquote>
<p>建议花些时间理解这张图，也可以用相同的方式去总结学到的其他有关联的数据结构。</p>
</blockquote>
<hr />
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867546.jpg" alt="" /></p>
</div>
</div>
<h2 id="哈希表"><a class="header" href="#哈希表">哈希表</a></h2>
<h3 id="hashmap数据结构"><a class="header" href="#hashmap数据结构">HashMap数据结构</a></h3>
<h3 id="hashmap基本使用方法"><a class="header" href="#hashmap基本使用方法">HashMap基本使用方法</a></h3>
<h3 id="hashmap内存布局"><a class="header" href="#hashmap内存布局">HashMap内存布局</a></h3>
<h3 id="ctrl表"><a class="header" href="#ctrl表">ctrl表</a></h3>
<h1 id="三错误处理"><a class="header" href="#三错误处理">三、错误处理</a></h1>
<h2 id="错误处理主流方法"><a class="header" href="#错误处理主流方法">错误处理主流方法</a></h2>
<h2 id="rust如何处理错误"><a class="header" href="#rust如何处理错误">Rust如何处理错误</a></h2>
<h1 id="四闭包结构"><a class="header" href="#四闭包结构">四、闭包结构</a></h1>
<h2 id="闭包定义"><a class="header" href="#闭包定义">闭包定义</a></h2>
<h2 id="闭包本质"><a class="header" href="#闭包本质">闭包本质</a></h2>
<h2 id="闭包设计"><a class="header" href="#闭包设计">闭包设计</a></h2>
<h2 id="rust闭包类型"><a class="header" href="#rust闭包类型">Rust闭包类型</a></h2>
<h2 id="闭包使用场景"><a class="header" href="#闭包使用场景">闭包使用场景</a></h2>

            </main>

            <!--            <script src="https://utteranc.es/client.js"-->
            <!--                    repo="RustMagazine/rust_magazine_2022"-->
            <!--                    issue-term="title"-->
            <!--                    theme="github-light"-->
            <!--                    crossorigin="anonymous"-->
            <!--                    async></script>-->

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                    <a rel="prev" href="2_type_system.html" class="mobile-nav-chapters previous"
                       title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="4_macros.html" class="mobile-nav-chapters next"
                       title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="2_type_system.html" class="nav-chapters previous" title="Previous chapter"
               aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="4_macros.html" class="nav-chapters next" title="Next chapter"
               aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
    </nav>

</div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/mermaid/mermaid.min.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid-init.js"></script>
    <script type="text/javascript" src="assets/smart-anchor.js"></script>
    <script type="text/javascript" src="assets/pagetoc/sidebar.js"></script>

</body>
</html>
