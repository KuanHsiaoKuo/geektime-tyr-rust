<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Anatomy In First Rust Programming Class 🦀</title>
        <meta name="robots" content="noindex"/>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust编程第一课的代码为例进行基础代码分析">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="md-favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/pagetoc/pagetoc_style.css">
        <link rel="stylesheet" href="assets/css/mdbook-admonish.css">

        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="anatomy_logic.html"><strong aria-hidden="true">1.</strong> 源码阅读逻辑</a></li><li class="chapter-item expanded "><a href="intro_gdb_lldb.html"><strong aria-hidden="true">2.</strong> gdb/lldb调试或查看内存结构</a></li><li class="chapter-item expanded "><a href="get_hands_dirty.html"><strong aria-hidden="true">3.</strong> get hands dirty</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="httpie.html"><strong aria-hidden="true">3.1.</strong> httpie</a></li><li class="chapter-item expanded "><a href="rgrep.html"><strong aria-hidden="true">3.2.</strong> rgrep</a></li><li class="chapter-item expanded "><a href="thumbor.html"><strong aria-hidden="true">3.3.</strong> thumbor</a></li><li class="chapter-item expanded "><a href="queryer.html"><strong aria-hidden="true">3.4.</strong> queryer</a></li></ol></li><li class="chapter-item expanded "><a href="rust_cores.html"><strong aria-hidden="true">4.</strong> Rust核心深入</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_stack_heap_ownership_lifetime_memory.html"><strong aria-hidden="true">4.1.</strong> I. 从栈堆、所有权、生命周期开始内存管理</a></li><li class="chapter-item expanded "><a href="2_type_system.html"><strong aria-hidden="true">4.2.</strong> II. 类型系统</a></li><li class="chapter-item expanded "><a href="3_data_structure.html"><strong aria-hidden="true">4.3.</strong> III. 数据结构</a></li><li class="chapter-item expanded "><a href="4_macros.html"><strong aria-hidden="true">4.4.</strong> IV. 宏编程</a></li><li class="chapter-item expanded "><a href="5_concurrency_async.html"><strong aria-hidden="true">4.5.</strong> V. 并发与异步</a></li><li class="chapter-item expanded "><a href="6_unsafe_ffi.html"><strong aria-hidden="true">4.6.</strong> VI. 混合编程</a></li></ol></li><li class="chapter-item expanded "><a href="kv_server_design.html"><strong aria-hidden="true">5.</strong> kv server设计与实现</a></li><li class="chapter-item expanded "><a href="custom_axum_async_web_framework.html"><strong aria-hidden="true">6.</strong> 构建自己的类axum异步Web框架</a></li><li class="chapter-item expanded affix "><a href="checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Anatomy In First Rust Programming Class 🦀</h1>
            <h4 class="menu-bar"><a href="https://kuanhsiaokuo.github.io/think-tool-kit/">保持批判，有所取舍，知行合一, 方见真我</a> -- 练武不练功
                到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/geektime-tyr-rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="源码解析逻辑"><a class="header" href="#源码解析逻辑">源码解析逻辑</a></h1>
<!--ts-->
<ul>
<li><a href="anatomy_logic.html#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E9%80%BB%E8%BE%91">源码解析逻辑</a>
<ul>
<li><a href="anatomy_logic.html#%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3">项目文档</a>
<ul>
<li><a href="anatomy_logic.html#%E6%9D%A5%E6%BA%90">来源</a></li>
<li><a href="anatomy_logic.html#cargo-doc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8">cargo doc命令使用</a>
<ul>
<li><a href="anatomy_logic.html#--open">–open</a></li>
<li><a href="anatomy_logic.html#--no-deps">–no-deps</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB">使用区别</a></li>
<li><a href="anatomy_logic.html#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82">使用细节</a>
<ul>
<li><a href="anatomy_logic.html#crates">Crates</a></li>
<li><a href="anatomy_logic.html#crate%E5%8C%85%E5%90%AB%E6%88%90%E5%91%98">crate包含成员</a></li>
<li><a href="anatomy_logic.html#re-exports">Re-exports</a></li>
<li><a href="anatomy_logic.html#modules">Modules</a></li>
<li><a href="anatomy_logic.html#macros">Macros</a></li>
<li><a href="anatomy_logic.html#derive-macros">Derive Macros</a></li>
<li><a href="anatomy_logic.html#attribute-macros">Attribute Macros</a></li>
<li><a href="anatomy_logic.html#structs">Structs</a>
<ul>
<li><a href="anatomy_logic.html#definition">Definition</a></li>
<li><a href="anatomy_logic.html#associated-types">Associated Types</a></li>
<li><a href="anatomy_logic.html#implementations">Implementations</a></li>
<li><a href="anatomy_logic.html#trait-implementations">Trait Implementations</a></li>
<li><a href="anatomy_logic.html#auto-trait-implementations">Auto Trait Implementations</a></li>
<li><a href="anatomy_logic.html#blanket-implementations">Blanket Implementations</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#enums">Enums</a>
<ul>
<li><a href="anatomy_logic.html#definition-1">Definition</a></li>
<li><a href="anatomy_logic.html#variants">Variants</a></li>
<li><a href="anatomy_logic.html#trait-implementations-1">Trait Implementations</a></li>
<li><a href="anatomy_logic.html#auto-trait-implementations-1">Auto Trait Implementations</a></li>
<li><a href="anatomy_logic.html#blanket-implementations-1">Blanket Implementations</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#constants">Constants</a></li>
<li><a href="anatomy_logic.html#traits">Traits</a>
<ul>
<li><a href="anatomy_logic.html#definition-2">Definition</a></li>
<li><a href="anatomy_logic.html#required-methods">Required methods</a></li>
<li><a href="anatomy_logic.html#implementations-on-foreign-types">Implementations on Foreign Types</a></li>
<li><a href="anatomy_logic.html#implementors">Implementors</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#functions">Functions</a>
<ul>
<li><a href="anatomy_logic.html#definition-3">Definition</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#type-definitions">Type Definitions</a>
<ul>
<li><a href="anatomy_logic.html#definition-4">Definition</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Wed Sep 28 10:55:10 UTC 2022 -->
<!--te-->
<h2 id="项目文档"><a class="header" href="#项目文档">项目文档</a></h2>
<h3 id="来源"><a class="header" href="#来源">来源</a></h3>
<ol>
<li>第三方crate可以在<a href="https://docs.rs/">官方文档</a>上面搜索</li>
<li>本地crate可以使用命令<code>cargo doc --open</code>.</li>
</ol>
<h3 id="cargo-doc命令使用"><a class="header" href="#cargo-doc命令使用">cargo doc命令使用</a></h3>
<blockquote>
<p><a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html">更多内容</a></p>
</blockquote>
<h4 id="open"><a class="header" href="#open">–open</a></h4>
<p>自动生成文档并在浏览器打开</p>
<h4 id="no-deps"><a class="header" href="#no-deps">–no-deps</a></h4>
<p>默认情况下会把项目依赖的包文档也生成，这也是文档左侧Crates的来源之一。
这个参数可以屏蔽掉依赖的crates</p>
<h3 id="使用区别"><a class="header" href="#使用区别">使用区别</a></h3>
<ol>
<li>二者内容没有区别，官方文档也是执行命令生成文档。</li>
<li>官方文档还可以提供很多细节，比如git分支地址</li>
</ol>
<h3 id="使用细节"><a class="header" href="#使用细节">使用细节</a></h3>
<blockquote>
<p>这里按照文档的层级进行递进说明</p>
</blockquote>
<h4 id="crates"><a class="header" href="#crates">Crates</a></h4>
<p>所有文档的首页都会有这一项，列出项目包含的crate</p>
<h4 id="crate包含成员"><a class="header" href="#crate包含成员">crate包含成员</a></h4>
<blockquote>
<p>点击Crates下的某个crate，右侧页面就会显示当前crate包含的元素， 主要有下列内容</p>
</blockquote>
<ul>
<li>Re-exports</li>
<li>Modules</li>
<li>Macros</li>
<li>Derive Macros</li>
<li>Attribute Macros</li>
<li>Structs</li>
<li>Enums</li>
<li>Constants</li>
<li>Traits</li>
<li>Functions</li>
<li>Type Definitions</li>
</ul>
<h4 id="re-exports"><a class="header" href="#re-exports">Re-exports</a></h4>
<blockquote>
<p>futures_util</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use reader::DecompressorCustomIo;
<span class="boring">}
</span></code></pre></pre>
<h4 id="modules"><a class="header" href="#modules">Modules</a></h4>
<p>其实就是mod，点击之后将会列出某个mod里面的成员</p>
<h4 id="macros"><a class="header" href="#macros">Macros</a></h4>
<h4 id="derive-macros"><a class="header" href="#derive-macros">Derive Macros</a></h4>
<blockquote>
<p>darling_macro、clap_derive</p>
</blockquote>
<h4 id="attribute-macros"><a class="header" href="#attribute-macros">Attribute Macros</a></h4>
<blockquote>
<p>tokio_macros、futures_macro</p>
</blockquote>
<h4 id="structs"><a class="header" href="#structs">Structs</a></h4>
<h5 id="definition"><a class="header" href="#definition">Definition</a></h5>
<h5 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h5>
<h5 id="implementations"><a class="header" href="#implementations">Implementations</a></h5>
<h5 id="trait-implementations"><a class="header" href="#trait-implementations">Trait Implementations</a></h5>
<h5 id="auto-trait-implementations"><a class="header" href="#auto-trait-implementations">Auto Trait Implementations</a></h5>
<h5 id="blanket-implementations"><a class="header" href="#blanket-implementations">Blanket Implementations</a></h5>
<h4 id="enums"><a class="header" href="#enums">Enums</a></h4>
<h5 id="definition-1"><a class="header" href="#definition-1">Definition</a></h5>
<h5 id="variants"><a class="header" href="#variants">Variants</a></h5>
<h5 id="trait-implementations-1"><a class="header" href="#trait-implementations-1">Trait Implementations</a></h5>
<h5 id="auto-trait-implementations-1"><a class="header" href="#auto-trait-implementations-1">Auto Trait Implementations</a></h5>
<h5 id="blanket-implementations-1"><a class="header" href="#blanket-implementations-1">Blanket Implementations</a></h5>
<h4 id="constants"><a class="header" href="#constants">Constants</a></h4>
<h4 id="traits"><a class="header" href="#traits">Traits</a></h4>
<h5 id="definition-2"><a class="header" href="#definition-2">Definition</a></h5>
<h5 id="required-methods"><a class="header" href="#required-methods">Required methods</a></h5>
<h5 id="implementations-on-foreign-types"><a class="header" href="#implementations-on-foreign-types">Implementations on Foreign Types</a></h5>
<h5 id="implementors"><a class="header" href="#implementors">Implementors</a></h5>
<h4 id="functions"><a class="header" href="#functions">Functions</a></h4>
<h5 id="definition-3"><a class="header" href="#definition-3">Definition</a></h5>
<h4 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h4>
<h5 id="definition-4"><a class="header" href="#definition-4">Definition</a></h5>
<blockquote>
<p>html2md</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type BoxedError = Box&lt;dyn Error + Send + Sync&gt;;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gdblldb调试或查看内存结构"><a class="header" href="#gdblldb调试或查看内存结构">gdb/lldb调试或查看内存结构</a></h1>
<!--ts-->
<ul>
<li><a href="intro_gdb_lldb.html#gdblldb%E8%B0%83%E8%AF%95%E6%88%96%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">gdb/lldb调试或查看内存结构</a>
<ul>
<li><a href="intro_gdb_lldb.html#%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86">资料整理</a>
<ul>
<li><a href="intro_gdb_lldb.html#%E5%AE%98%E6%96%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84cheat-sheet">官方数据结构cheat sheet</a></li>
</ul>
</li>
<li><a href="intro_gdb_lldb.html#%E6%9F%A5%E7%9C%8Bhashmap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">查看hashmap内存结构</a>
<ul>
<li><a href="intro_gdb_lldb.html#bin%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%BF%90%E8%A1%8C">bin配置与运行</a></li>
<li><a href="intro_gdb_lldb.html#%E7%9B%AE%E6%A0%87%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81">目标调试代码</a></li>
<li><a href="intro_gdb_lldb.html#%E4%BD%BF%E7%94%A8gdblldb%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">使用gdb/lldb进行调试查看内存结构</a>
<ul>
<li><a href="intro_gdb_lldb.html#gdb-%E4%B8%BB%E8%A6%81%E6%98%AFlinux%E7%B3%BB%E7%BB%9F">gdb: 主要是linux系统</a></li>
<li><a href="intro_gdb_lldb.html#lldb-%E4%B8%BB%E8%A6%81osx%E7%B3%BB%E7%BB%9F">lldb: 主要OSX系统</a></li>
<li><a href="intro_gdb_lldb.html#idea">IDEA</a></li>
<li><a href="intro_gdb_lldb.html#gdb%E4%B8%8Elldb%E5%91%BD%E4%BB%A4%E5%AF%B9%E7%85%A7">gdb与lldb命令对照</a></li>
<li><a href="intro_gdb_lldb.html#%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95">开始调试</a></li>
<li><a href="intro_gdb_lldb.html#breakpoint-%E6%B7%BB%E5%8A%A0%E6%96%AD%E7%82%B9">b(reakpoint): 添加断点</a></li>
<li><a href="intro_gdb_lldb.html#run%E8%BF%90%E8%A1%8C%E5%88%B0%E6%96%AD%E7%82%B9">r(un):运行到断点</a></li>
<li><a href="intro_gdb_lldb.html#continue%E7%BB%A7%E7%BB%AD%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C">c(ontinue):继续单步执行</a></li>
<li><a href="intro_gdb_lldb.html#x-%E6%89%93%E5%8D%B0%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80">x: 打印内存地址</a></li>
<li><a href="intro_gdb_lldb.html#continue-%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%E5%88%B0%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%96%AD%E7%82%B9">c(ontinue): 继续执行到下一个断点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="intro_gdb_lldb.html#%E6%9F%A5%E7%9C%8B%E9%97%AD%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84">查看闭包的结构</a>
<ul>
<li><a href="intro_gdb_lldb.html#%E4%BB%A3%E7%A0%81">代码</a></li>
<li><a href="intro_gdb_lldb.html#%E8%BF%90%E8%A1%8C%E8%BF%9B%E5%85%A5lldb">运行进入lldb</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Wed Sep 28 10:55:11 UTC 2022 -->
<!--te-->
<h2 id="资料整理"><a class="header" href="#资料整理">资料整理</a></h2>
<h3 id="官方数据结构cheat-sheet"><a class="header" href="#官方数据结构cheat-sheet">官方数据结构cheat sheet</a></h3>
<ul>
<li><a href="https://cheats.rs/#data-layout">Rust Language Cheat Sheet</a></li>
</ul>
<h2 id="查看hashmap内存结构"><a class="header" href="#查看hashmap内存结构">查看hashmap内存结构</a></h2>
<h3 id="bin配置与运行"><a class="header" href="#bin配置与运行">bin配置与运行</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html?highlight=bin#binaries">Cargo Targets - The Cargo Book</a></li>
</ul>
<pre><code class="language-toml">[package]
name = &quot;hashtable&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[[bin]]
name = &quot;hashmap1&quot;
path = &quot;src/hashmap1.rs&quot;

[[bin]]
name = &quot;hashmap2&quot;
path = &quot;src/hashmap2.rs&quot;

[[bin]]
name = &quot;hash&quot;
path = &quot;src/hash.rs&quot;

[[bin]]
name = &quot;siphasher&quot;
path = &quot;src/siphasher.rs&quot;
doc = false

[[bin]]
name = &quot;hashmap3&quot;
path = &quot;src/hashmap3.rs&quot;

[[bin]]
name = &quot;btreemap1&quot;
path = &quot;src/btreemap1.rs&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<blockquote>
<p>如果要单独运行指定bin文件：</p>
</blockquote>
<pre><code class="language-shell">cargo run --bin hashmap2
</code></pre>
<h3 id="目标调试代码"><a class="header" href="#目标调试代码">目标调试代码</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use std::collections::HashMap;

fn main() {
    let map = HashMap::new();
    let mut map = explain(&quot;empty&quot;, map);

    map.insert('a', 1);
    let mut map = explain(&quot;added 1&quot;, map);
    map.insert('b', 2);
    map.insert('c', 3);

    let mut map = explain(&quot;added 3&quot;, map);

    map.insert('d', 4);

    let mut map = explain(&quot;added 4&quot;, map);

    map.remove(&amp;'a');

    explain(&quot;final&quot;, map);
}

// HashMap 结构有两个 u64 的 RandomState，然后是四个 usize，
// 分别是 bucket_mask, ctrl, growth_left 和 items
// 我们 transmute 打印之后，再 transmute 回去
fn explain&lt;K, V&gt;(name: &amp;str, map: HashMap&lt;K, V&gt;) -&gt; HashMap&lt;K, V&gt; {
    let arr: [usize; 6] = unsafe { std::mem::transmute(map) };
    println!(
        &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
        name, arr[2], arr[3], arr[4], arr[5]
    );
    unsafe { std::mem::transmute(arr) }
}
</code></pre></pre>
<h3 id="使用gdblldb进行调试查看内存结构"><a class="header" href="#使用gdblldb进行调试查看内存结构">使用gdb/lldb进行调试查看内存结构</a></h3>
<h4 id="gdb-主要是linux系统"><a class="header" href="#gdb-主要是linux系统">gdb: 主要是linux系统</a></h4>
<h4 id="lldb-主要osx系统"><a class="header" href="#lldb-主要osx系统">lldb: 主要OSX系统</a></h4>
<h4 id="idea"><a class="header" href="#idea">IDEA</a></h4>
<blockquote>
<p>自带的调试界面同时包含lldb更好的界面功能。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/CleanShot%202022-09-18%20at%2021.24.12%402x.png" alt="CleanShot 2022-09-18 at 21.24.12@2x" /></p>
<h4 id="gdb与lldb命令对照"><a class="header" href="#gdb与lldb命令对照">gdb与lldb命令对照</a></h4>
<ul>
<li><a href="https://lldb.llvm.org/use/map.html">GDB to LLDB command map — The LLDB Debugger</a></li>
</ul>
<h4 id="开始调试"><a class="header" href="#开始调试">开始调试</a></h4>
<pre><code class="language-shell">rust-lldb target/debug/hashmap2                                                                                                                  ─╯
(lldb) command script import &quot;/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_lookup.py&quot;
(lldb) command source -s 0 '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'
Executing commands in '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'.
(lldb) type synthetic add -l lldb_lookup.synthetic_lookup -x &quot;.*&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)String$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?str$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?\\[.+\\]$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::ffi::([a-z_]+::)+)OsString$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Vec&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)VecDeque&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Rc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Arc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Cell&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Ref&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefMut&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefCell&lt;.+&gt;$&quot; --category Rust
(lldb) type category enable Rust
(lldb) target create &quot;target/debug/hashmap2&quot;
Current executable set to '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/hashmap2' (x86_64).
(lldb)
</code></pre>
<h4 id="breakpoint-添加断点"><a class="header" href="#breakpoint-添加断点">b(reakpoint): 添加断点</a></h4>
<blockquote>
<p>在32行打断点，方便看std::mem::transmute(arr)</p>
</blockquote>
<pre><code class="language-shell">(lldb) b hashmap2.rs:32
Breakpoint 1: where = hashmap2`hashmap2::explain::h4091c852f38a0de4 + 406 at hashmap2.rs:32:34, address = 0x0000000100008d16
</code></pre>
<h4 id="run运行到断点"><a class="header" href="#run运行到断点">r(un):运行到断点</a></h4>
<pre><code class="language-shell">(lldb) r
Process 69337 launched: '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/hashmap2' (x86_64)
empty: bucket_mask 0x0, ctrl 0x100043d20, growth_left: 0, items: 0
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;empty&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 最初的状态，哈希表为空
empty: bucket_mask 0x0, ctrl 0x100043d20, growth_left: 0, items: 0
</code></pre>
<h4 id="continue继续单步执行"><a class="header" href="#continue继续单步执行">c(ontinue):继续单步执行</a></h4>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
added 1: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 2, items: 1
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;added 1&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 插入了一个元素后，bucket 有 4 个（0x3+1），堆地址起始位置 0x600001700160 - 4*8(0x20)
added 1: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 2, items: 1
</code></pre>
<h4 id="x-打印内存地址"><a class="header" href="#x-打印内存地址">x: 打印内存地址</a></h4>
<ul>
<li><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/examine-memory.html">打印内存的值 | 100个gdb小技巧</a></li>
</ul>
<pre><code class="language-shell"># 以12进制打印从内存地址开始的值
(lldb) x/12x 0x600001700160
0x600001700160: 0xffff6dff 0xffffffff 0xffffffff 0xffffffff
0x600001700170: 0xffff6dff 0x00000000 0x00000000 0x00000000
0x600001700180: 0x20ec913f 0x00007ff8 0x4e5ef01e 0x00000000
</code></pre>
<h4 id="continue-继续执行到下一个断点"><a class="header" href="#continue-继续执行到下一个断点">c(ontinue): 继续执行到下一个断点</a></h4>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
added 3: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 0, items: 3
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;added 3&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># # 插入了三个元素后，哈希表没有剩余空间，堆地址起始位置不变 0x600001700160 - 4*8(0x20)
added 3: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 0, items: 3
</code></pre>
<pre><code class="language-shell">(lldb) x/12x 0x600001700160
0x600001700160: 0x16ff6d66 0xffffffff 0xffffffff 0xffffffff
0x600001700170: 0x16ff6d66 0x00000000 0x00000000 0x00000000
0x600001700180: 0x20ec913f 0x00007ff8 0x4e5ef01e 0x00000000
</code></pre>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
added 4: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 3, items: 4
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;added 4&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 插入第四个元素后，哈希表扩容，堆地址起始位置变为 0x600002604040 - 8*8(0x40)
added 4: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 3, items: 4
</code></pre>
<pre><code class="language-shell">(lldb) x/12x 0x600002604040
0x600002604040: 0x16446d66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x16446d66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
(lldb) x/20x 0x600002604040
0x600002604040: 0x16446d66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x16446d66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604070: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604080: 0x00000000 0x00000000 0x00000000 0x00000000
</code></pre>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
final: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 4, items: 3
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;final&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 删除 a 后，剩余 4 个位置。注意 ctrl bit 的变化，以及 0x61 0x1 并没有被清除
final: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 4, items: 3
</code></pre>
<pre><code class="language-shell">(lldb) x/12x 0x600002604040
0x600002604040: 0x1644ff66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x1644ff66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
(lldb) x/20x 0x600002604040
0x600002604040: 0x1644ff66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x1644ff66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604070: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604080: 0x00000000 0x00000000 0x00000000 0x00000000
</code></pre>
<h2 id="查看闭包的结构"><a class="header" href="#查看闭包的结构">查看闭包的结构</a></h2>
<h3 id="代码"><a class="header" href="#代码">代码</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use std::{collections::HashMap, mem::size_of_val};
fn main() {
    // 长度为 0
    let c1 = || println!(&quot;hello world!&quot;);
    // 和参数无关，长度也为 0
    let c2 = |i: i32| println!(&quot;hello: {}&quot;, i);
    let name = String::from(&quot;tyr&quot;);
    let name1 = name.clone();
    let mut table = HashMap::new();
    table.insert(&quot;hello&quot;, &quot;world&quot;);
    // 如果捕获一个引用，长度为 8
    let c3 = || println!(&quot;hello: {}&quot;, name);
    // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
    let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
    let name2 = name.clone();
    // 和局部变量无关，捕获了一个 String name2，closure 长度 24
    let c5 = move || {
        let x = 1;
        let name3 = String::from(&quot;lindsey&quot;);
        println!(&quot;hello: {}, {:?}, {:?}&quot;, x, name2, name3);
    };

    println!(
        &quot;c1: {}, c2: {}, c3: {}, c4: {}, c5: {}, main: {}&quot;,
        size_of_val(&amp;c1),
        size_of_val(&amp;c2),
        size_of_val(&amp;c3),
        size_of_val(&amp;c4),
        size_of_val(&amp;c5),
        size_of_val(&amp;main),
    )
}
</code></pre></pre>
<h3 id="运行进入lldb"><a class="header" href="#运行进入lldb">运行进入lldb</a></h3>
<pre><code class="language-shell"># 自动去examples目录找对应名字的代码文件
cargo run --example closure_size
</code></pre>
<pre><code class="language-shell">rust-lldb ../target/debug/examples/closure_size                                                                                                  ─╯
(lldb) command script import &quot;/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_lookup.py&quot;
(lldb) command source -s 0 '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'
Executing commands in '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'.
(lldb) type synthetic add -l lldb_lookup.synthetic_lookup -x &quot;.*&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)String$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?str$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?\\[.+\\]$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::ffi::([a-z_]+::)+)OsString$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Vec&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)VecDeque&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Rc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Arc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Cell&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Ref&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefMut&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefCell&lt;.+&gt;$&quot; --category Rust
(lldb) type category enable Rust
(lldb) target create &quot;../target/debug/examples/closure_size&quot;
Current executable set to '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/closure_size' (x86_64).
(lldb)
</code></pre>
<pre><code class="language-shell">(lldb) b closure_size.rs:14
Breakpoint 1: where = closure_size`closure_size::main::h679d75437a0cd078 + 199 at closure_size.rs:14:14, address = 0x00000001000056b7
</code></pre>
<pre><code class="language-shell">(lldb) r
Process 95084 launched: '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/closure_size' (x86_64)
Process 95084 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x00000001000056b7 closure_size`closure_size::main::h679d75437a0cd078 at closure_size.rs:14:14
   11       // 如果捕获一个引用，长度为 8
   12       let c3 = || println!(&quot;hello: {}&quot;, name);
   13       // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
-&gt; 14       let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
   15       let name2 = name.clone();
   16       // 和局部变量无关，捕获了一个 String name2，closure 长度 24
   17       let c5 = move || {
Target 0: (closure_size) stopped.
</code></pre>
<pre><code class="language-shell">(lldb) frame variable
(closure_size::main::{closure_env#0}) c1 =
(closure_size::main::{closure_env#1}) c2 =
(alloc::string::String) name = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(alloc::string::String) name1 = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(std::collections::hash::map::HashMap&lt;&amp;str, &amp;str, std::collections::hash::map::RandomState&gt;) table = size=1 {
  [0] = {
    0 = &quot;hello&quot; {
      data_ptr = 0x0000000100043daf &quot;helloworld, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
    1 = &quot;world&quot; {
      data_ptr = 0x0000000100043db4 &quot;world, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
  }
}
(lldb) fr v
(closure_size::main::{closure_env#0}) c1 =
(closure_size::main::{closure_env#1}) c2 =
(alloc::string::String) name = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(alloc::string::String) name1 = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(std::collections::hash::map::HashMap&lt;&amp;str, &amp;str, std::collections::hash::map::RandomState&gt;) table = size=1 {
  [0] = {
    0 = &quot;hello&quot; {
      data_ptr = 0x0000000100043daf &quot;helloworld, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
    1 = &quot;world&quot; {
      data_ptr = 0x0000000100043db4 &quot;world, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
  }
}
</code></pre>
<pre><code class="language-shell">(lldb) x/gx c1
error: memory read failed for 0x0
(lldb) x/gx &amp;c1
0x7ff7bfefed20: 0x0000000100266000
(lldb) x/gx &amp;c2
0x7ff7bfefed28: 0x00006000017041c0
(lldb) x/gx &amp;c3
0x7ff7bfefed90: 0x00007ff7bfefed30
(lldb) x/gx 0x00007ff7bfefed30
0x7ff7bfefed30: 0x0000600000008010
(lldb) x/3c  0x0000600000008010
error: reading memory as characters of size 8 is not supported
(lldb) x/gx  0x0000600000008010
0x600000008010: 0x0000000000727974
</code></pre>
<ul>
<li>g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</li>
<li>可以看出：c1是</li>
</ul>
<pre><code class="language-shell">(lldb) n
Process 95084 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
    frame #0: 0x0000000100005744 closure_size`closure_size::main::h679d75437a0cd078 at closure_size.rs:15:17
   12       let c3 = || println!(&quot;hello: {}&quot;, name);
   13       // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
   14       let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
-&gt; 15       let name2 = name.clone();
   16       // 和局部变量无关，捕获了一个 String name2，closure 长度 24
   17       let c5 = move || {
   18           let x = 1;
Target 0: (closure_size) stopped.
(lldb) x/9gx c4
error: memory read failed for 0x0
(lldb) x/9gx &amp;c4
0x7ff7bfefed98: 0x0000600000008020 0x0000000000000003
0x7ff7bfefeda8: 0x0000000000000003 0x3e49f3270a1a0fb0
0x7ff7bfefedb8: 0x79dd9a78e6c327e7 0x0000000000000003
0x7ff7bfefedc8: 0x0000600003304080 0x0000000000000002
0x7ff7bfefedd8: 0x0000000000000001
(lldb) x/3c 0x0000600000008020
error: reading memory as characters of size 8 is not supported
(lldb) x/gx 0x0000600000008020
0x600000008020: 0x0000000000727974
(lldb) x/18gx 0x0000600000008020 - 0x80
error: memory read takes a start address expression with an optional end address expression.
warning: Expressions should be quoted if they contain spaces or other special characters.
(lldb) x/18gx '0x0000600000008020 - 0x80'
0x600000007fa0: 0x0000000000000000 0x0000000000000000
0x600000007fb0: 0x0000000000000000 0x0000000000000000
0x600000007fc0: 0x0000000000000000 0x0000000000000000
0x600000007fd0: 0x0000000000000000 0x0000000000000000
0x600000007fe0: 0x0000000000000000 0x0000000000000000
0x600000007ff0: 0x0000000000000000 0x0000000000000000
0x600000008000: 0x000000006e69616d 0x0000000000000000
0x600000008010: 0x0000000000727974 0x0000000000000000
0x600000008020: 0x0000000000727974 0x0000000000000000
</code></pre>
<ul>
<li>0x: C语言里的0x0和0x1分别表示十六进制的数的0和1。</li>
</ul>
<p>C语言、C++、Shell、Python、Java语言及其他相近的语言使用字首“0x”，例如“0x5A3”。开头的“0”令解析器更易辨认数，而“x”则代表十六进制（就如“O”代表八进制）。在“0x”中的“x”可以大写或小写。对于字符量C语言中则以x+两位十六进制数的方式表示，如xFF。</p>
<p>因此，0x0中“0x”表示的是十六进制数，0是十六进制数值0，0x,1中“0x”表示的是十六进制数，1是十六进制数值1</p>
<ul>
<li>C语言中的相关数值表示法：</li>
</ul>
<p>1、在C语言里，整数有三种表示形式：十进制，八进制，十六进制。其中以数字0开头，由0~7组成的数是八进制。以0X或0x开头，由0~9，A~F或a~f 组成是十六进制。除表示正负的符号外，以1~9开头，由0~9组成是十进制。</p>
<p>2、十进制：除表示正负的符号外，以1~9开头，由0~9组成。如，128，+234，-278。</p>
<p>3、八进制：以0开头，由0~7组成的数。如，0126,050000.</p>
<p>4、十六进制：以0X或0x开头，由0~9，A~F或a~f 组成。如，0x12A,0x5a000。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-hands-dirty"><a class="header" href="#get-hands-dirty">get hands dirty</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="httpie源码剖析"><a class="header" href="#httpie源码剖析">httpie源码剖析</a></h1>
<!--ts-->
<ul>
<li><a href="httpie.html#httpie%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90">httpie源码剖析</a>
<ul>
<li><a href="httpie.html#example%E7%9A%84%E4%BD%BF%E7%94%A8">example的使用</a>
<ul>
<li><a href="httpie.html#cargotoml">Cargo.toml</a></li>
</ul>
</li>
<li><a href="httpie.html#step1%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90">Step1：指令解析</a>
<ul>
<li><a href="httpie.html#clapparser">clap::Parser</a></li>
</ul>
</li>
<li><a href="httpie.html#step2%E6%B7%BB%E5%8A%A0%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E4%B8%8E%E9%94%AE%E5%80%BC%E5%AF%B9%E6%94%B9%E9%80%A0">Step2：添加参数验证与键值对改造</a>
<ul>
<li><a href="httpie.html#%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81">参数验证</a></li>
<li><a href="httpie.html#%E9%94%AE%E5%80%BC%E5%AF%B9%E6%94%B9%E9%80%A0">键值对改造</a></li>
</ul>
</li>
<li><a href="httpie.html#step3%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%94%B9%E9%80%A0">Step3：异步请求改造</a></li>
<li><a href="httpie.html#step4-%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E6%89%93%E5%8D%B0">Step4: 语法高亮打印</a></li>
<li><a href="httpie.html#step5-%E6%B7%BB%E5%8A%A0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">Step5: 添加单元测试</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Wed Sep 28 10:55:11 UTC 2022 -->
<!--te-->
<h2 id="example的使用"><a class="header" href="#example的使用">example的使用</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html?highlight=%5B%5Bexample%5D%5D#examples">Cargo Targets &gt;&gt; Examples - The Cargo Book</a></li>
</ul>
<h3 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h3>
<pre><code class="language-toml">[package]
name = &quot;httpie&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[[example]]
name = &quot;cli&quot;

[[example]]
name = &quot;cli_verify&quot;

[[example]]
name = &quot;cli_get&quot;

[dependencies]
anyhow = &quot;1&quot; # 错误处理
clap = { version = &quot;3&quot;, features = [&quot;derive&quot;] } # 命令行解析
colored = &quot;2&quot; # 命令终端多彩显示
jsonxf = &quot;1.1&quot; # JSON pretty print 格式化
mime = &quot;0.3&quot; # 处理 mime 类型
# reqwest 默认使用 openssl，有些 linux 用户如果没有安装好 openssl 会无法编译，这里我改成了使用 rustls
reqwest = { version = &quot;0.11&quot;, default-features = false, features = [&quot;json&quot;, &quot;rustls-tls&quot;] } # HTTP 客户端
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] } # 异步处理库
syntect = &quot;4&quot;
</code></pre>
<pre><code class="language-toml">[[example]]
name = &quot;cli&quot;

[[example]]
name = &quot;cli_verify&quot;

[[example]]
name = &quot;cli_get&quot;
</code></pre>
<div id="admonition-example使用" class="admonition tip">
<div class="admonition-title">
<p>example使用</p>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-example使用"></a></p>
</div>
<div>
<ol>
<li>示例代码放在根目录的examples文件夹，与src同级</li>
</ol>
<pre><code class="language-shell">tree -L 2                                                                                                       ─╯
.
├── Cargo.toml
├── examples
│   ├── cli.rs
│   ├── cli_get.rs
│   └── cli_verify.rs
└── src
    └── main.rs

2 directories, 5 files
</code></pre>
<ol start="2">
<li>执行指令</li>
</ol>
<pre><code class="language-shell">cargo run --example &lt;example-name-in-cargo&gt;
cargo run --example cli
cargo run --example cli_get
cargo run --example cli_verify
</code></pre>
<ol start="3">
<li>使用示例</li>
</ol>
<pre><code class="language-shell">cargo run --example cli                                                                                                                                                                                                                ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli`
httpie 1.0
Tyr Chen &lt;tyr@chen.com&gt;
A naive httpie implementation with Rust, can you imagine how easy it is?

USAGE:
    cli &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    get     feed get with an url and we will retrieve the response for you
    help    Print this message or the help of the given subcommand(s)
    post    feed post with an url and optional key=value pairs. We will post the data as JSON,
                and retrieve the response for you
</code></pre>
<ul>
<li>Run a binary or example of the local package</li>
<li>SUBCOMMANDS来自代码中的注释</li>
</ul>
</div>
</div>
<h2 id="step1指令解析"><a class="header" href="#step1指令解析">Step1：指令解析</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">use clap::Parser;

// 定义 httpie 的 CLI 的主入口，它包含若干个子命令
// 下面 /// 的注释是文档，clap 会将其作为 CLI 的帮助

/// A naive httpie implementation with Rust, can you imagine how easy it is?
#[derive(Parser, Debug)]
#[clap(version = &quot;1.0&quot;, author = &quot;Tyr Chen &lt;tyr@chen.com&gt;&quot;)]
struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

// 子命令分别对应不同的 HTTP 方法，目前只支持 get / post
#[derive(Parser, Debug)]
enum SubCommand {
    Get(Get),
    Post(Post),
    // 我们暂且不支持其它 HTTP 方法
}

// get 子命令

/// feed get with an url and we will retrieve the response for you
#[derive(Parser, Debug)]
struct Get {
    /// HTTP 请求的 URL
    url: String,
}

// post 子命令。需要输入一个 url，和若干个可选的 key=value，用于提供 json body

/// feed post with an url and optional key=value pairs. We will post the data
/// as JSON, and retrieve the response for you
#[derive(Parser, Debug)]
struct Post {
    /// HTTP 请求的 URL
    url: String,
    /// HTTP 请求的 body
    body: Vec&lt;String&gt;,
}

fn main() {
    let opts: Opts = Opts::parse();
    let opt_subcmd: SubCommand = opts.subcmd;
    // println!(&quot;{:?}&quot;, opts);
    println!(&quot;{:?}&quot;, opt_subcmd);
    // println!(&quot;{:?}&quot;, opts.subcmd);
    // 这里就可以看出，结构体的内在元素使用&quot;.&quot;来获取
    // println!(&quot;{:?}&quot;, opts::subcmd);
}
</code></pre></pre>
<h3 id="clapparser"><a class="header" href="#clapparser">clap::Parser</a></h3>
<div id="admonition-clapparser" class="admonition info">
<div class="admonition-title">
<p>clap::Parser</p>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-clapparser"></a></p>
</div>
<div>
<ul>
<li><a href="https://github.com/clap-rs/clap">clap-rs/clap: A full featured, fast Command Line Argument Parser for Rust</a></li>
<li><a href="https://docs.rs/clap/latest/clap/">clap - Rust</a></li>
<li><a href="https://docs.rs/clap/latest/clap/parser/index.html">clap::parser - Rust</a></li>
</ul>
</div>
</div>
<ol>
<li>clap的parser派生宏会自动实现parse方法来接收指令参数</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

// 子命令分别对应不同的 HTTP 方法，目前只支持 get / post
#[derive(Parser, Debug)]
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let opts: Opts = Opts::parse();
    let opt_subcmd: SubCommand = opts.subcmd;
    // println!(&quot;{:?}&quot;, opts);
</code></pre></pre>
<ol start="2">
<li>运行效果</li>
</ol>
<pre><code class="language-shell">cargo run --example cli get http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                                ─╯
   Compiling httpie v0.1.0 (/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/04_httpie)
    Finished dev [unoptimized + debuginfo] target(s) in 2.31s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli get 'http://jsonplaceholder.typicode.com/posts/2'`
Opts { subcmd: Get(Get { url: &quot;http://jsonplaceholder.typicode.com/posts/2&quot; }) }
</code></pre>
<pre><code class="language-shell">cargo run --example cli post http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                               ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli post 'http://jsonplaceholder.typicode.com/posts/2'`
Opts { subcmd: Post(Post { url: &quot;http://jsonplaceholder.typicode.com/posts/2&quot;, body: [] }) }
</code></pre>
<pre><code class="language-shell">cargo run --example cli delete http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                             ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli delete 'http://jsonplaceholder.typicode.com/posts/2'`
error: Found argument 'delete' which wasn't expected, or isn't valid in this context

USAGE:
    cli &lt;SUBCOMMAND&gt;

For more information try --help

</code></pre>
<ul>
<li>opts的获取：自动以空格分隔，根据<subcommand>模式匹配，之后的参数依次赋值给<subcommand> struct里面的元素</li>
</ul>
<h2 id="step2添加参数验证与键值对改造"><a class="header" href="#step2添加参数验证与键值对改造">Step2：添加参数验证与键值对改造</a></h2>
<h3 id="参数验证"><a class="header" href="#参数验证">参数验证</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// feed get with an url and we will retrieve the response for you
#[derive(Parser, Debug)]
struct Get {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
}

// post 子命令。需要输入一个 url，和若干个可选的 key=value，用于提供 json body

/// feed post with an url and optional key=value pairs. We will post the data
/// as JSON, and retrieve the response for you
#[derive(Parser, Debug)]
struct Post {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
    /// HTTP 请求的 body
    #[clap(parse(try_from_str=parse_kv_pair))]
    body: Vec&lt;KvPair&gt;,
}
</code></pre></pre>
<ol>
<li>clap 允许你为每个解析出来的值添加自定义的解析函数，我们这里定义了parse_url和parse_kv_pair检查一下。</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">/// 因为我们为 KvPair 实现了 FromStr，这里可以直接 s.parse() 得到 KvPair
fn parse_kv_pair(s: &amp;str) -&gt; Result&lt;KvPair&gt; {
    s.parse()
}
fn parse_url(s: &amp;str) -&gt; Result&lt;String&gt; {
    // 这里我们仅仅检查一下 URL 是否合法
    let _url: Url = s.parse()?;

    Ok(s.into())
}
</code></pre></pre>
<ol>
<li>clap 允许你为每个解析出来的值添加自定义的解析函数，我们这里定义了个parse_url检查一下。</li>
</ol>
<h3 id="键值对改造"><a class="header" href="#键值对改造">键值对改造</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// 命令行中的 key=value 可以通过 parse_kv_pair 解析成 KvPair 结构
#[allow(dead_code)]
#[derive(Debug)]
struct KvPair {
    k: String,
    v: String,
}

/// 当我们实现 FromStr trait 后，可以用 str.parse() 方法将字符串解析成 KvPair
impl FromStr for KvPair {
    type Err = anyhow::Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        // 使用 = 进行 split，这会得到一个迭代器
        let mut split = s.split('=');
        let err = || anyhow!(format!(&quot;Failed to parse {}&quot;, s));
        Ok(Self {
            // 从迭代器中取第一个结果作为 key，迭代器返回 Some(T)/None
            // 我们将其转换成 Ok(T)/Err(E)，然后用 ? 处理错误
            k: (split.next().ok_or_else(err)?).to_string(),
            // 从迭代器中取第二个结果作为 value
            v: (split.next().ok_or_else(err)?).to_string(),
        })
    }
}
</code></pre></pre>
<h2 id="step3异步请求改造"><a class="header" href="#step3异步请求改造">Step3：异步请求改造</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let opts: Opts = Opts::parse();
    // 生成一个
    let client = Client::new();
    match opts.subcmd {
        SubCommand::Get(ref args) =&gt; get(client, args).await?,
        SubCommand::Post(ref args) =&gt; post(client, args).await?,
    };

    Ok(())
}

async fn get(client: Client, args: &amp;Get) -&gt; Result&lt;()&gt; {
    let resp = client.get(&amp;args.url).send().await?;
    println!(&quot;{:?}&quot;, resp.text().await?);
    Ok(())
}

async fn post(client: Client, args: &amp;Post) -&gt; Result&lt;()&gt; {
    let mut body = HashMap::new();
    for pair in args.body.iter() {
        body.insert(&amp;pair.k, &amp;pair.v);
    }
    let resp = client.post(&amp;args.url).json(&amp;body).send().await?;
    println!(&quot;{:?}&quot;, resp.text().await?);
    Ok(())
}
</code></pre></pre>
<h2 id="step4-语法高亮打印"><a class="header" href="#step4-语法高亮打印">Step4: 语法高亮打印</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">// 打印服务器版本号 + 状态码
fn print_status(resp: &amp;Response) {
    let status = format!(&quot;{:?} {}&quot;, resp.version(), resp.status()).blue();
    println!(&quot;{}\n&quot;, status);
}

// 打印服务器返回的 HTTP header
fn print_headers(resp: &amp;Response) {
    for (name, value) in resp.headers() {
        println!(&quot;{}: {:?}&quot;, name.to_string().green(), value);
    }

    println!();
}

/// 打印服务器返回的 HTTP body
fn print_body(m: Option&lt;Mime&gt;, body: &amp;str) {
    match m {
        // 对于 &quot;application/json&quot; 我们 pretty print
        Some(v) if v == mime::APPLICATION_JSON =&gt; print_syntect(body, &quot;json&quot;),
        Some(v) if v == mime::TEXT_HTML =&gt; print_syntect(body, &quot;html&quot;),

        // 其它 mime type，我们就直接输出
        _ =&gt; println!(&quot;{}&quot;, body),
    }
}

/// 打印整个响应
async fn print_resp(resp: Response) -&gt; Result&lt;()&gt; {
    print_status(&amp;resp);
    print_headers(&amp;resp);
    let mime = get_content_type(&amp;resp);
    let body = resp.text().await?;
    print_body(mime, &amp;body);
    Ok(())
}

/// 将服务器返回的 content-type 解析成 Mime 类型
fn get_content_type(resp: &amp;Response) -&gt; Option&lt;Mime&gt; {
    resp.headers()
        .get(header::CONTENT_TYPE)
        .map(|v| v.to_str().unwrap().parse().unwrap())
}

fn print_syntect(s: &amp;str, ext: &amp;str) {
    // Load these once at the start of your program
    let ps = SyntaxSet::load_defaults_newlines();
    let ts = ThemeSet::load_defaults();
    let syntax = ps.find_syntax_by_extension(ext).unwrap();
    let mut h = HighlightLines::new(syntax, &amp;ts.themes[&quot;base16-ocean.dark&quot;]);
    for line in LinesWithEndings::from(s) {
        let ranges: Vec&lt;(Style, &amp;str)&gt; = h.highlight(line, &amp;ps);
        let escaped = as_24_bit_terminal_escaped(&amp;ranges[..], true);
        print!(&quot;{}&quot;, escaped);
    }
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">/// 程序的入口函数，因为在 http 请求时我们使用了异步处理，所以这里引入 tokio
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let opts: Opts = Opts::parse();
    let mut headers = header::HeaderMap::new();
    // 为我们的 http 客户端添加一些缺省的 HTTP 头
    headers.insert(&quot;X-POWERED-BY&quot;, &quot;Rust&quot;.parse()?);
    headers.insert(header::USER_AGENT, &quot;Rust Httpie&quot;.parse()?);
    let client = Client::builder()
        .default_headers(headers)
        .build()?;
    let result = match opts.subcmd {
        SubCommand::Get(ref args) =&gt; get(client, args).await?,
        SubCommand::Post(ref args) =&gt; post(client, args).await?,
    };

    Ok(result)
}
</code></pre></pre>
<h2 id="step5-添加单元测试"><a class="header" href="#step5-添加单元测试">Step5: 添加单元测试</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">// 仅在 cargo test 时才编译
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_url_works() {
        assert!(parse_url(&quot;abc&quot;).is_err());
        assert!(parse_url(&quot;http://abc.xyz&quot;).is_ok());
        assert!(parse_url(&quot;https://httpbin.org/post&quot;).is_ok());
    }

    #[test]
    fn parse_kv_pair_works() {
        assert!(parse_kv_pair(&quot;a&quot;).is_err());
        assert_eq!(
            parse_kv_pair(&quot;a=1&quot;).unwrap(),
            KvPair {
                k: &quot;a&quot;.into(),
                v: &quot;1&quot;.into(),
            }
        );

        assert_eq!(
            parse_kv_pair(&quot;b=&quot;).unwrap(),
            KvPair {
                k: &quot;b&quot;.into(),
                v: &quot;&quot;.into(),
            }
        );
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rgrep"><a class="header" href="#rgrep">rgrep</a></h1>
<!--ts-->
<ul>
<li><a href="rgrep.html#rgrep">rgrep</a>
<ul>
<li><a href="rgrep.html#cargotoml">Cargo.toml</a></li>
<li><a href="rgrep.html#srcerrorrs-thiserror%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2">src/error.rs: thiserror会自动转换</a></li>
<li><a href="rgrep.html#srclibrs%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">src/lib.rs：定义结构体+实现方法+单元测试</a>
<ul>
<li><a href="rgrep.html#mod%E5%BC%95%E5%85%A5%E4%B8%8E%E4%BD%BF%E7%94%A8">mod引入与使用</a></li>
<li><a href="rgrep.html#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93">定义结构体</a>
<ul>
<li><a href="rgrep.html#%E4%B8%93%E9%97%A8%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B">专门简化复杂类型</a></li>
<li><a href="rgrep.html#%E4%B8%93%E9%97%A8%E7%9A%84%E7%BB%93%E5%90%88%E7%89%88%E6%9C%ACgrep%E7%BB%93%E6%9E%84%E4%BD%93">专门的结合版本grep结构体</a></li>
</ul>
</li>
<li><a href="rgrep.html#%E7%BB%99%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">给结构体实现方法</a></li>
<li><a href="rgrep.html#%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5-default_strategy">默认策略: default_strategy</a></li>
<li><a href="rgrep.html#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA">格式化输出</a></li>
<li><a href="rgrep.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li>
</ul>
</li>
<li><a href="rgrep.html#srcmainrs">src/main.rs</a>
<ul>
<li><a href="rgrep.html#%E5%BC%95%E5%85%A5librs%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9">引入lib.rs中的内容</a></li>
<li><a href="rgrep.html#%E4%B8%BB%E5%87%BD%E6%95%B0main">主函数：main()</a></li>
</ul>
</li>
<li><a href="rgrep.html#%E4%BD%BF%E7%94%A8">使用</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Wed Sep 28 10:55:12 UTC 2022 -->
<!--te-->
<h2 id="cargotoml-1"><a class="header" href="#cargotoml-1">Cargo.toml</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">[package]
name = &quot;rgrep&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

<span class="boring">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</span>
[dependencies]
anyhow = &quot;1&quot;
clap = { version = &quot;3&quot;, features = [&quot;derive&quot;] }
colored = &quot;2&quot;
glob = &quot;0.3&quot;
itertools = &quot;0.10&quot;
rayon = &quot;1&quot;
regex = &quot;1&quot;
thiserror = &quot;1&quot;
</code></pre></pre>
<h2 id="srcerrorrs-thiserror会自动转换"><a class="header" href="#srcerrorrs-thiserror会自动转换">src/error.rs: thiserror会自动转换</a></h2>
<blockquote>
<p>它们都是需要进行转换的错误。thiserror 能够通过宏帮我们完成错误类型的转换。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">use thiserror::Error;

#[derive(Error, Debug)]
pub enum GrepError {
    #[error(&quot;Glob pattern error&quot;)]
    GlobPatternError(#[from] glob::PatternError),
    #[error(&quot;Regex pattern error&quot;)]
    RegexPatternError(#[from] regex::Error),
    #[error(&quot;I/O error&quot;)]
    IoError(#[from] std::io::Error),
}
</code></pre></pre>
<h2 id="srclibrs定义结构体实现方法单元测试"><a class="header" href="#srclibrs定义结构体实现方法单元测试">src/lib.rs：定义结构体+实现方法+单元测试</a></h2>
<h3 id="mod引入与使用"><a class="header" href="#mod引入与使用">mod引入与使用</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">mod error;
pub use error::GrepError;
</code></pre></pre>
<h3 id="定义结构体"><a class="header" href="#定义结构体">定义结构体</a></h3>
<h4 id="专门简化复杂类型"><a class="header" href="#专门简化复杂类型">专门简化复杂类型</a></h4>
<blockquote>
<p>这里其实就是传入一个指定结构的函数对象</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">/// 定义类型，这样，在使用时可以简化复杂类型的书写
pub type StrategyFn = fn(&amp;Path, &amp;mut dyn BufRead, &amp;Regex, &amp;mut dyn Write) -&gt; Result&lt;(), GrepError&gt;;
</code></pre></pre>
<h4 id="专门的结合版本grep结构体"><a class="header" href="#专门的结合版本grep结构体">专门的结合版本grep结构体</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 简化版本的 grep，支持正则表达式和文件通配符
#[derive(Parser, Debug)]
#[clap(version = &quot;1.0&quot;, author = &quot;Tyr Chen &lt;tyr@chen.com&gt;&quot;)]
pub struct GrepConfig {
    /// 用于查找的正则表达式
    pattern: String,
    /// 文件通配符
    glob: String,
}
</code></pre></pre>
<h3 id="给结构体实现方法"><a class="header" href="#给结构体实现方法">给结构体实现方法</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">impl GrepConfig {
    /// 使用缺省策略来查找匹配
    pub fn match_with_default_strategy(&amp;self) -&gt; Result&lt;(), GrepError&gt; {
        self.match_with(default_strategy)
    }

    /// 使用某个策略函数来查找匹配
    pub fn match_with(&amp;self, strategy: StrategyFn) -&gt; Result&lt;(), GrepError&gt; {
        let regex = Regex::new(&amp;self.pattern)?;
        // 生成所有符合通配符的文件列表
        let files: Vec&lt;_&gt; = glob::glob(&amp;self.glob)?.collect();
        // 并行处理所有文件
        files.into_par_iter().for_each(|v| {
            if let Ok(filename) = v {
                if let Ok(file) = File::open(&amp;filename) {
                    let mut reader = BufReader::new(file);
                    let mut stdout = io::stdout();

                    if let Err(e) = strategy(filename.as_path(), &amp;mut reader, &amp;regex, &amp;mut stdout) {
                        println!(&quot;Internal error: {:?}&quot;, e);
                    }
                }
            }
        });
        Ok(())
    }
}
</code></pre></pre>
<blockquote>
<p>主要实现两种解析策略：</p>
</blockquote>
<ol>
<li>默认策略：match_with_default_strategy, 使用default_strategy</li>
<li>指定策略：match_with, 使用传入的strategy: StrategyFn</li>
</ol>
<h3 id="默认策略-default_strategy"><a class="header" href="#默认策略-default_strategy">默认策略: default_strategy</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// 缺省策略，从头到尾串行查找，最后输出到 writer
pub fn default_strategy(
    path: &amp;Path,
    reader: &amp;mut dyn BufRead,
    pattern: &amp;Regex,
    writer: &amp;mut dyn Write,
) -&gt; Result&lt;(), GrepError&gt; {
    let matches: String = reader
        .lines()
        .enumerate()
        .map(|(lineno, line)| {
            line.ok()
                .map(|line| {
                    pattern
                        .find(&amp;line)
                        .map(|m| format_line(&amp;line, lineno + 1, m.range()))
                })
                .flatten()
        })
        .filter_map(|v| v.ok_or(()).ok())
        .join(&quot;\n&quot;);

    if !matches.is_empty() {
        writer.write_all(path.display().to_string().green().as_bytes())?;
        writer.write_all(b&quot;\n&quot;)?;
        writer.write_all(matches.as_bytes())?;
        writer.write_all(b&quot;\n&quot;)?;
    }

    Ok(())
}
</code></pre></pre>
<h3 id="格式化输出"><a class="header" href="#格式化输出">格式化输出</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// 格式化输出匹配的行，包含行号，列号和带有高亮的第一个匹配项
pub fn format_line(line: &amp;str, lineno: usize, range: Range&lt;usize&gt;) -&gt; String {
    let Range { start, end } = range;
    let prefix = &amp;line[..start];
    format!(
        &quot;{0: &gt;6}:{1: &lt;3} {2}{3}{4}&quot;,
        lineno.to_string().blue(),
        // 找到匹配项的起始位置，注意对汉字等非 ascii 字符，我们不能使用 prefix.len()
        // 这是一个 O(n) 的操作，会拖累效率，这里只是为了演示的效果
        (prefix.chars().count() + 1).to_string().cyan(),
        prefix,
        &amp;line[start..end].red(),
        &amp;line[end..]
    )
}
</code></pre></pre>
<h3 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn format_line_should_work() {
        let result = format_line(&quot;Hello, Tyr~&quot;, 1000, 7..10);
        let expected = format!(
            &quot;{0: &gt;6}:{1: &lt;3} Hello, {2}~&quot;,
            &quot;1000&quot;.blue(),
            &quot;8&quot;.cyan(),
            &quot;Tyr&quot;.red()
        );
        assert_eq!(result, expected);
    }

    #[test]
    fn default_strategy_should_work() {
        let path = Path::new(&quot;src/main.rs&quot;);
        let input = b&quot;hello world!\nhey Tyr!&quot;;
        let mut reader = BufReader::new(&amp;input[..]);
        let pattern = Regex::new(r&quot;he\w+&quot;).unwrap();
        let mut writer = Vec::new();
        default_strategy(path, &amp;mut reader, &amp;pattern, &amp;mut writer).unwrap();
        let result = String::from_utf8(writer).unwrap();
        let expected = [
            String::from(&quot;src/main.rs&quot;),
            format_line(&quot;hello world!&quot;, 1, 0..5),
            format_line(&quot;hey Tyr!\n&quot;, 2, 0..3),
        ];

        assert_eq!(result, expected.join(&quot;\n&quot;));
    }
}
</code></pre></pre>
<h2 id="srcmainrs"><a class="header" href="#srcmainrs">src/main.rs</a></h2>
<h3 id="引入librs中的内容"><a class="header" href="#引入librs中的内容">引入lib.rs中的内容</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use itertools::Itertools;
</code></pre></pre>
<h3 id="主函数main"><a class="header" href="#主函数main">主函数：main()</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use regex::Regex;
use std::{
    fs::File,
    io::{self, BufRead, BufReader, Write},
    ops::Range,
    path::Path,
};
</code></pre></pre>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<pre><code class="language-shell">cargo run --quiet -- &quot;Re[^\\s]+&quot; &quot;src/*.rs&quot;                                                                                                                                                                                            ─╯
src/main.rs
     1:13  use anyhow::Result;
     5:14  fn main() -&gt; Result&lt;()&gt; {
src/error.rs
     7:14      #[error(&quot;Regex pattern error&quot;)]
     8:5       RegexPatternError(#[from] regex::Error),
src/lib.rs
     5:12  use regex::Regex;
     8:19      io::{self, BufRead, BufReader, Write},
    17:45  pub type StrategyFn = fn(&amp;Path, &amp;mut dyn BufRead, &amp;Regex, &amp;mut dyn Write) -&gt; Result&lt;(), GrepError&gt;;
    31:50      pub fn match_with_default_strategy(&amp;self) -&gt; Result&lt;(), GrepError&gt; {
    36:55      pub fn match_with(&amp;self, strategy: StrategyFn) -&gt; Result&lt;(), GrepError&gt; {
    37:21          let regex = Regex::new(&amp;self.pattern)?;
    44:41                      let mut reader = BufReader::new(file);
    60:25      reader: &amp;mut dyn BufRead,
    61:15      pattern: &amp;Regex,
    63:6   ) -&gt; Result&lt;(), GrepError&gt; {
   126:29          let mut reader = BufReader::new(&amp;input[..]);
   127:23          let pattern = Regex::new(r&quot;he\w+&quot;).unwrap();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thumbor图片服务"><a class="header" href="#thumbor图片服务">thumbor图片服务</a></h1>
<!--ts-->
<!--te-->
<h2 id="abiproto"><a class="header" href="#abiproto">abi.proto</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">syntax = &quot;proto3&quot;;

package abi;

// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
message ImageSpec { repeated Spec specs = 1; }

// 处理图片改变大小
message Resize {
  uint32 width = 1;
  uint32 height = 2;

  enum ResizeType {
    NORMAL = 0;
    SEAM_CARVE = 1;
  }

  ResizeType rtype = 3;

  enum SampleFilter {
    UNDEFINED = 0;
    NEAREST = 1;
    TRIANGLE = 2;
    CATMULL_ROM = 3;
    GAUSSIAN = 4;
    LANCZOS3 = 5;
  }

  SampleFilter filter = 4;
}

// 处理图片截取
message Crop {
  uint32 x1 = 1;
  uint32 y1 = 2;
  uint32 x2 = 3;
  uint32 y2 = 4;
}

// 处理水平翻转
message Fliph {}
// 处理垂直翻转
message Flipv {}
// 处理对比度
message Contrast { float contrast = 1; }
// 处理滤镜
message Filter {
  enum Filter {
    UNSPECIFIED = 0;
    OCEANIC = 1;
    ISLANDS = 2;
    MARINE = 3;
    // more: https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html
  }
  Filter filter = 1;
}

// 处理水印
message Watermark {
  uint32 x = 1;
  uint32 y = 2;
}

// 一个 spec 可以包含上述的处理方式之一
message Spec {
  oneof data {
    Resize resize = 1;
    Crop crop = 2;
    Flipv flipv = 3;
    Fliph fliph = 4;
    Contrast contrast = 5;
    Filter filter = 6;
    Watermark watermark = 7;
  }
}
</code></pre></pre>
<h2 id="buildrs"><a class="header" href="#buildrs">build.rs</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">use std::process::Command;

fn main() {
    // 在编译时可选择检查环境变量。
    let build_enabled = option_env!(&quot;BUILD_PROTO&quot;)
        .map(|v| v == &quot;1&quot;)
        .unwrap_or(false);
    // 如果没有找到环境变量的对应值，就直接return，不再进行后续编译
    if !build_enabled {
        println!(&quot;=== Skipped compiling protos ===&quot;);
        return;
    }
    // 使用 prost_build 把 abi.proto 编译到 src/pb 目录下
    prost_build::Config::new()
        .out_dir(&quot;src/pb&quot;)
        .compile_protos(&amp;[&quot;abi.proto&quot;], &amp;[&quot;.&quot;])
        .unwrap();
    Command::new(&quot;cargo&quot;)
        .args(&amp;[&quot;fmt&quot;, &quot;--&quot;, &quot;src/*.rs&quot;])
        .status()
        .expect(&quot;cargo fmt failed&quot;);
}
</code></pre></pre>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.option_env.html">option_env in std - Rust</a></li>
</ul>
<blockquote>
<p>在编译时可选择检查环境变量。</p>
</blockquote>
<h2 id="关于rust的模块"><a class="header" href="#关于rust的模块">关于rust的模块</a></h2>
<blockquote>
<p>可以参考这篇：<a href="https://zhuanlan.zhihu.com/p/443926839">Rust 模块系统理解 - 知乎</a></p>
</blockquote>
<div id="admonition-mod全认识" class="admonition tip">
<div class="admonition-title">
<p>mod全认识</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-mod全认识"></a></p>
</div>
<div>
<ol>
<li>mod(mod.rs或mod关键字)将代码分为多个逻辑模块，并管理这些模块的可见性（public / private）。</li>
<li>模块是项（item）的集合，项可以是：函数，结构体，trait，impl块，甚至其它模块。</li>
<li>一个目录下的所有代码，可以通过 mod.rs 声明</li>
<li>Rust模块有三种形式:
<ul>
<li>mod.rs: 一个目录下的所有代码，可以通过 mod.rs 声明</li>
<li>文件/目录即模块：编译器的机制决定，除了mod.rs外，每一个文件和目录都是一个模块。不允许只分拆文件，但是不声明mod，我们通常使用pub use，在父空间直接调用子空间的函数。</li>
<li>mod关键字: 在文件内部分拆模块</li>
</ul>
</li>
<li>Rust编译器只接受一个源文件，输出一个crate</li>
<li>每一个crate都有一个匿名的根命名空间，命名空间可以无限嵌套</li>
<li>“mod mod-name { … }“ 将大括号中的代码置于命名空间mod-name之下</li>
<li>“use mod-name1::mod-name2;“ 可以打开命名空间，减少无休止的::操作符</li>
<li>“mod mod-name;“ 可以指导编译器将多个文件组装成一个文件</li>
<li>“pub use mod-nam1::mod-name2::item-name;“
语句可以将mod-name2下的item-name提升到这条语句所在的空间，item-name通常是函数或者结构体。Rust社区通常用这个方法来缩短库API的命名空间深度
编译器规定use语句一定要在mod语句之前</li>
</ol>
</div>
</div>
<h2 id="mod文件定义与实现分离"><a class="header" href="#mod文件定义与实现分离">mod文件定义与实现分离</a></h2>
<p>在rust中，一般会在模块的mod.rs文件中对供外部使用的项进行实现, 项可以是：函数，结构体，trait，impl块，甚至其它模块.
这样有个好处，高内聚，可以在代码增长时，将变动局限在服务提供者内部，对外提供的api不变，不会造成破坏性更新。</p>
<h2 id="pb模块-处理protobuf"><a class="header" href="#pb模块-处理protobuf">pb模块: 处理protobuf</a></h2>
<h3 id="pbmodrs声明模块"><a class="header" href="#pbmodrs声明模块">pb/mod.rs声明模块</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">mod abi; // 声明 abi.rs
pub use abi::*;
</code></pre></pre>
<h3 id="pbabirs里面还有子模块"><a class="header" href="#pbabirs里面还有子模块">pb/abi.rs里面还有子模块</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// Nested message and enum types in `Spec`.
pub mod spec {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = &quot;1&quot;)]
        Resize(super::Resize),
        #[prost(message, tag = &quot;2&quot;)]
        Crop(super::Crop),
        #[prost(message, tag = &quot;3&quot;)]
        Flipv(super::Flipv),
        #[prost(message, tag = &quot;4&quot;)]
        Fliph(super::Fliph),
        #[prost(message, tag = &quot;5&quot;)]
        Contrast(super::Contrast),
        #[prost(message, tag = &quot;6&quot;)]
        Filter(super::Filter),
        #[prost(message, tag = &quot;7&quot;)]
        Watermark(super::Watermark),
    }
}
</code></pre></pre>
<h3 id="pbabirs另外定义了specdata里面的各个元素结构体嵌套模块mod"><a class="header" href="#pbabirs另外定义了specdata里面的各个元素结构体嵌套模块mod">pb/abi.rs另外定义了spec::Data里面的各个元素结构体/嵌套模块mod</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSpec {
    #[prost(message, repeated, tag = &quot;1&quot;)]
    pub specs: ::prost::alloc::vec::Vec&lt;Spec&gt;,
}
/// 处理图片改变大小
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resize {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub width: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub height: u32,
    #[prost(enumeration = &quot;resize::ResizeType&quot;, tag = &quot;3&quot;)]
    pub rtype: i32,
    #[prost(enumeration = &quot;resize::SampleFilter&quot;, tag = &quot;4&quot;)]
    pub filter: i32,
}
/// Nested message and enum types in `Resize`.
pub mod resize {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResizeType {
        Normal = 0,
        SeamCarve = 1,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SampleFilter {
        Undefined = 0,
        Nearest = 1,
        Triangle = 2,
        CatmullRom = 3,
        Gaussian = 4,
        Lanczos3 = 5,
    }
}
/// 处理图片截取
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Crop {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub x1: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub y1: u32,
    #[prost(uint32, tag = &quot;3&quot;)]
    pub x2: u32,
    #[prost(uint32, tag = &quot;4&quot;)]
    pub y2: u32,
}
/// 处理水平翻转
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fliph {}
/// 处理垂直翻转
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Flipv {}
/// 处理对比度
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contrast {
    #[prost(float, tag = &quot;1&quot;)]
    pub contrast: f32,
}
/// 处理滤镜
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filter {
    #[prost(enumeration = &quot;filter::Filter&quot;, tag = &quot;1&quot;)]
    pub filter: i32,
}
/// Nested message and enum types in `Filter`.
pub mod filter {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Filter {
        Unspecified = 0,
        Oceanic = 1,
        Islands = 2,
        /// more: &lt;https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html&gt;
        Marine = 3,
    }
}
/// 处理水印
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Watermark {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub x: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub y: u32,
}
</code></pre></pre>
<h3 id="pbabirs有个特殊结构体"><a class="header" href="#pbabirs有个特殊结构体">pb/abi.rs有个特殊结构体</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 spec 可以包含上述的处理方式之一
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    #[prost(oneof = &quot;spec::Data&quot;, tags = &quot;1, 2, 3, 4, 5, 6, 7&quot;)]
    pub data: ::core::option::Option&lt;spec::Data&gt;,
}
</code></pre></pre>
<h3 id="imagespec"><a class="header" href="#imagespec">ImageSpec</a></h3>
<h4 id="定义有序数组"><a class="header" href="#定义有序数组">定义：有序数组</a></h4>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSpec {
    #[prost(message, repeated, tag = &quot;1&quot;)]
    pub specs: ::prost::alloc::vec::Vec&lt;Spec&gt;,
}
</code></pre></pre>
<h4 id="实现new方法fromtryfrom实现类型转化"><a class="header" href="#实现new方法fromtryfrom实现类型转化">实现：new方法、From&amp;TryFrom实现类型转化</a></h4>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">impl ImageSpec {
    pub fn new(specs: Vec&lt;Spec&gt;) -&gt; Self {
        Self { specs }
    }
}

// 让 ImageSpec 可以生成一个字符串
impl From&lt;&amp;ImageSpec&gt; for String {
    fn from(image_spec: &amp;ImageSpec) -&gt; Self {
        let data = image_spec.encode_to_vec();
        encode_config(data, URL_SAFE_NO_PAD)
    }
}

// 让 ImageSpec 可以通过一个字符串创建。比如 s.parse().unwrap()
impl TryFrom&lt;&amp;str&gt; for ImageSpec {
    type Error = anyhow::Error;

    fn try_from(value: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {
        let data = decode_config(value, URL_SAFE_NO_PAD)?;
        Ok(ImageSpec::decode(&amp;data[..])?)
    }
}
</code></pre></pre>
<h3 id="filter"><a class="header" href="#filter">Filter</a></h3>
<h4 id="定义枚举体mod"><a class="header" href="#定义枚举体mod">定义：枚举体mod</a></h4>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// Nested message and enum types in `Filter`.
pub mod filter {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Filter {
        Unspecified = 0,
        Oceanic = 1,
        Islands = 2,
        /// more: &lt;https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html&gt;
        Marine = 3,
    }
}
</code></pre></pre>
<h4 id="实现双引号的使用模式匹配"><a class="header" href="#实现双引号的使用模式匹配">实现：双引号的使用、模式匹配</a></h4>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">// 辅助函数，photon_rs 相应的方法里需要字符串
impl filter::Filter {
    pub fn to_str(self) -&gt; Option&lt;&amp;'static str&gt; {
        match self {
            filter::Filter::Unspecified =&gt; None,
            filter::Filter::Oceanic =&gt; Some(&quot;oceanic&quot;),
            filter::Filter::Islands =&gt; Some(&quot;islands&quot;),
            filter::Filter::Marine =&gt; Some(&quot;marine&quot;),
        }
    }
}
</code></pre></pre>
<h3 id="samplefilter"><a class="header" href="#samplefilter">SampleFilter</a></h3>
<h4 id="定义枚举体mod-1"><a class="header" href="#定义枚举体mod-1">定义：枚举体mod</a></h4>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// Nested message and enum types in `Resize`.
pub mod resize {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResizeType {
        Normal = 0,
        SeamCarve = 1,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SampleFilter {
        Undefined = 0,
        Nearest = 1,
        Triangle = 2,
        CatmullRom = 3,
        Gaussian = 4,
        Lanczos3 = 5,
    }
}
</code></pre></pre>
<h3 id="实现mod使用双引号from转为不同结果"><a class="header" href="#实现mod使用双引号from转为不同结果">实现：mod使用双引号、From转为不同结果</a></h3>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">impl From&lt;resize::SampleFilter&gt; for SamplingFilter {
    fn from(v: resize::SampleFilter) -&gt; Self {
        match v {
            resize::SampleFilter::Undefined =&gt; SamplingFilter::Nearest,
            resize::SampleFilter::Nearest =&gt; SamplingFilter::Nearest,
            resize::SampleFilter::Triangle =&gt; SamplingFilter::Triangle,
            resize::SampleFilter::CatmullRom =&gt; SamplingFilter::CatmullRom,
            resize::SampleFilter::Gaussian =&gt; SamplingFilter::Gaussian,
            resize::SampleFilter::Lanczos3 =&gt; SamplingFilter::Lanczos3,
        }
    }
}
</code></pre></pre>
<h3 id="spec"><a class="header" href="#spec">Spec</a></h3>
<h4 id="定义结构体-1"><a class="header" href="#定义结构体-1">定义：结构体</a></h4>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 spec 可以包含上述的处理方式之一
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    #[prost(oneof = &quot;spec::Data&quot;, tags = &quot;1, 2, 3, 4, 5, 6, 7&quot;)]
    pub data: ::core::option::Option&lt;spec::Data&gt;,
}
</code></pre></pre>
<h4 id="实现类似面向对象中添加类方法self"><a class="header" href="#实现类似面向对象中添加类方法self">实现：类似面向对象中添加类方法Self</a></h4>
<blockquote>
<p>注意区别Self和self的使用：
<a href="https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self">rust - What’s the difference between self and Self? - Stack Overflow</a></p>
</blockquote>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">// 提供一些辅助函数，让创建一个 spec 的过程简单一些
impl Spec {
    pub fn new_resize_seam_carve(width: u32, height: u32) -&gt; Self {
        Self {
            data: Some(spec::Data::Resize(Resize {
                width,
                height,
                rtype: resize::ResizeType::SeamCarve as i32,
                filter: resize::SampleFilter::Undefined as i32,
            })),
        }
    }

    pub fn new_resize(width: u32, height: u32, filter: resize::SampleFilter) -&gt; Self {
        Self {
            data: Some(spec::Data::Resize(Resize {
                width,
                height,
                rtype: resize::ResizeType::Normal as i32,
                filter: filter as i32,
            })),
        }
    }

    pub fn new_filter(filter: filter::Filter) -&gt; Self {
        Self {
            data: Some(spec::Data::Filter(Filter {
                filter: filter as i32,
            })),
        }
    }

    pub fn new_watermark(x: u32, y: u32) -&gt; Self {
        Self {
            data: Some(spec::Data::Watermark(Watermark { x, y })),
        }
    }
}
</code></pre></pre>
<h3 id="单元测试-1"><a class="header" href="#单元测试-1">单元测试</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {
    use super::*;
    use std::borrow::Borrow;

    #[test]
    fn encoded_spec_could_be_decoded() {
        let spec1 = Spec::new_resize(600, 600, resize::SampleFilter::CatmullRom);
        let spec2 = Spec::new_filter(filter::Filter::Marine);
        let image_spec = ImageSpec::new(vec![spec1, spec2]);
        let s: String = image_spec.borrow().into();
        assert_eq!(image_spec, s.as_str().try_into().unwrap());
    }
}
</code></pre></pre>
<h2 id="engine模块-处理图片"><a class="header" href="#engine模块-处理图片">engine模块: 处理图片</a></h2>
<h3 id="modrs-定义统一的引擎trait"><a class="header" href="#modrs-定义统一的引擎trait">mod.rs: 定义统一的引擎trait</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">// Engine trait：未来可以添加更多的 engine，主流程只需要替换 engine
pub trait Engine {
    // 对 engine 按照 specs 进行一系列有序的处理
    fn apply(&amp;mut self, specs: &amp;[Spec]);
    // 从 engine 中生成目标图片，注意这里用的是 self，而非 self 的引用
    fn generate(self, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt;;
}

// SpecTransform：未来如果添加更多的 spec，只需要实现它即可
pub trait SpecTransform&lt;T&gt; {
    // 对图片使用 op 做 transform
    fn transform(&amp;mut self, op: T);
}
</code></pre></pre>
<h3 id="photonrs--静态变量加载"><a class="header" href="#photonrs--静态变量加载">photon.rs &gt; 静态变量加载</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">lazy_static! {
    // 预先把水印文件加载为静态变量
    static ref WATERMARK: PhotonImage = {
        let data = include_bytes!(&quot;../../rust-logo.png&quot;);
        let watermark = open_image_from_bytes(data).unwrap();
        transform::resize(&amp;watermark, 64, 64, transform::SamplingFilter::Nearest)
    };
}
</code></pre></pre>
<h3 id="photonrs--具体引擎photon的定义与转化tryfrom"><a class="header" href="#photonrs--具体引擎photon的定义与转化tryfrom">photon.rs &gt; 具体引擎Photon的定义与转化TryFrom</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">pub struct Photon(PhotonImage);

// 从 Bytes 转换成 Photon 结构
impl TryFrom&lt;Bytes&gt; for Photon {
    type Error = anyhow::Error;

    fn try_from(data: Bytes) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(Self(open_image_from_bytes(&amp;data)?))
    }
}
</code></pre></pre>
<h3 id="photonrs--具体引擎photon的trait实现"><a class="header" href="#photonrs--具体引擎photon的trait实现">photon.rs &gt; 具体引擎Photon的trait实现</a></h3>
<h4 id="engine-trait"><a class="header" href="#engine-trait">Engine Trait</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">impl Engine for Photon {
    fn apply(&amp;mut self, specs: &amp;[Spec]) {
        for spec in specs.iter() {
            match spec.data {
                Some(spec::Data::Crop(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Contrast(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Filter(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Fliph(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Flipv(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Resize(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Watermark(ref v)) =&gt; self.transform(v),
                // 对于目前不认识的 spec，不做任何处理
                _ =&gt; {}
            }
        }
    }
</code></pre></pre>
<h4 id="spectransform-trait"><a class="header" href="#spectransform-trait">SpecTransform Trait</a></h4>
<h5 id="格式语义化"><a class="header" href="#格式语义化">格式语义化</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SpecTransform(&amp;OpreationName) for SpecificEngine {
    fn transform(&amp;mut self, _op: &amp;OperationName) {
        transform::OperationMethod(&amp;mut self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">impl SpecTransform&lt;&amp;Crop&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Crop) {
        let img = transform::crop(&amp;mut self.0, op.x1, op.y1, op.x2, op.y2);
        self.0 = img;
    }
}

impl SpecTransform&lt;&amp;Contrast&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Contrast) {
        effects::adjust_contrast(&amp;mut self.0, op.contrast);
    }
}

impl SpecTransform&lt;&amp;Flipv&gt; for Photon {
    fn transform(&amp;mut self, _op: &amp;Flipv) {
        transform::flipv(&amp;mut self.0)
    }
}

impl SpecTransform&lt;&amp;Fliph&gt; for Photon {
    fn transform(&amp;mut self, _op: &amp;Fliph) {
        transform::fliph(&amp;mut self.0)
    }
}

impl SpecTransform&lt;&amp;Filter&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Filter) {
        match filter::Filter::from_i32(op.filter) {
            Some(filter::Filter::Unspecified) =&gt; {}
            Some(f) =&gt; filters::filter(&amp;mut self.0, f.to_str().unwrap()),
            _ =&gt; {}
        }
    }
}

impl SpecTransform&lt;&amp;Resize&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Resize) {
        let img = match resize::ResizeType::from_i32(op.rtype).unwrap() {
            resize::ResizeType::Normal =&gt; transform::resize(
                &amp;self.0,
                op.width,
                op.height,
                resize::SampleFilter::from_i32(op.filter).unwrap().into(),
            ),
            resize::ResizeType::SeamCarve =&gt; transform::seam_carve(&amp;self.0, op.width, op.height),
        };
        self.0 = img;
    }
}

impl SpecTransform&lt;&amp;Watermark&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Watermark) {
        multiple::watermark(&amp;mut self.0, &amp;WATERMARK, op.x, op.y);
    }
}
</code></pre></pre>
<h3 id="photonrs--在内存中对图片转换格式的方法"><a class="header" href="#photonrs--在内存中对图片转换格式的方法">photon.rs &gt; 在内存中对图片转换格式的方法</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">fn image_to_buf(img: PhotonImage, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt; {
    let raw_pixels = img.get_raw_pixels();
    let width = img.get_width();
    let height = img.get_height();

    let img_buffer = ImageBuffer::from_vec(width, height, raw_pixels).unwrap();
    let dynimage = DynamicImage::ImageRgba8(img_buffer);

    let mut buffer = Vec::with_capacity(32768);
    dynimage.write_to(&amp;mut buffer, format).unwrap();
    buffer
}
</code></pre></pre>
<h2 id="mainrs"><a class="header" href="#mainrs">main.rs</a></h2>
<h3 id="先引入mod再use"><a class="header" href="#先引入mod再use">先引入mod，再use</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">// 参数使用 serde 做 Deserialize，axum 会自动识别并解析
#[derive(Deserialize)]
struct Params {
    spec: String,
    url: String,
}
</code></pre></pre>
<h3 id="图片资源用到lru策略缓存type定义"><a class="header" href="#图片资源用到lru策略缓存type定义">图片资源用到Lru策略缓存type定义</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">type Cache = Arc&lt;Mutex&lt;LruCache&lt;u64, Bytes&gt;&gt;&gt;;
</code></pre></pre>
<h3 id="主流程main函数"><a class="header" href="#主流程main函数">主流程main函数</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">#[tokio::main]
async fn main() {
    // 初始化 tracing
    tracing_subscriber::fmt::init();
    let cache: Cache = Arc::new(Mutex::new(LruCache::new(1024)));
    // 构建路由
    let app = Router::new()
        // `GET /` 会执行
        .route(&quot;/image/:spec/:url&quot;, get(generate))
        .layer(
            ServiceBuilder::new()
                .load_shed()
                .concurrency_limit(1024)
                .timeout(Duration::from_secs(10))
                .layer(TraceLayer::new_for_http())
                .layer(AddExtensionLayer::new(cache))
                .layer(CompressionLayer::new())
                .into_inner(),
        );

    // 运行 web 服务器
    let addr = &quot;127.0.0.1:3000&quot;.parse().unwrap();
    print_test_url(&quot;https://images.pexels.com/photos/1562477/pexels-photo-1562477.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=3&amp;h=750&amp;w=1260&quot;);
    info!(&quot;Listening on {}&quot;, addr);
    axum::Server::bind(&amp;addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
</code></pre></pre>
<h4 id="建造者模式"><a class="header" href="#建造者模式">建造者模式</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">            ServiceBuilder::new()
                .load_shed()
                .concurrency_limit(1024)
                .timeout(Duration::from_secs(10))
                .layer(TraceLayer::new_for_http())
                .layer(AddExtensionLayer::new(cache))
                .layer(CompressionLayer::new())
                .into_inner(),
</code></pre></pre>
<h4 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">    // 运行 web 服务器
    let addr = &quot;127.0.0.1:3000&quot;.parse().unwrap();
</code></pre></pre>
<h5 id="数字与字符串"><a class="header" href="#数字与字符串">数字与字符串</a></h5>
<p>||i32|u32|f64|String*|
|--|---|---|---|-------|
|i32|\|x as u32|x as f64|x.to_string()|
|u32|x as i32|\|x as f64|x.to_string()|
|f64|x as i32|x as u32|\|x.to_string()|
|String*|x.parse().unwrap()|x.parse().unwrap()|x.parse().unwrap()|\|</p>
<h5 id="string-与--str"><a class="header" href="#string-与--str">String 与 &amp; str</a></h5>
<p>|\|String|&amp;str|
|-|------|----|
|String|\|&amp;*x|
|&amp;str|x.to_string()|\|</p>
<h5 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h5>
<p>|\|Vec&lt;T&gt;|&amp;[T]|Box&lt;[T]&gt;|
|-|------|----|--------|
|Vec&lt;T&gt;|\|&amp;x[…]|x.into_boxed_slice()|
|&amp;[T]|x.to_vec()|\|Box::new(*x)|
|Box&lt;[T]&gt;|x.to_vec()|&amp;*x|\|</p>
<h3 id="路由绑定的处理函数handler"><a class="header" href="#路由绑定的处理函数handler">路由绑定的处理函数handler</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">// basic handler that responds with a static string
async fn generate(
    Path(Params { spec, url }): Path&lt;Params&gt;,
    Extension(cache): Extension&lt;Cache&gt;,
) -&gt; Result&lt;(HeaderMap, Vec&lt;u8&gt;), StatusCode&gt; {
    let spec: ImageSpec = spec
        .as_str()
        .try_into()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    let url: &amp;str = &amp;percent_decode_str(&amp;url).decode_utf8_lossy();
    let data = retrieve_image(url, cache)
        .await
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    // 使用 image engine 处理
    let mut engine: Photon = data
        .try_into()
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    engine.apply(&amp;spec.specs);
    // TODO: 这里目前类型写死了，应该使用 content negotiation
    let image = engine.generate(ImageOutputFormat::Jpeg(85));

    info!(&quot;Finished processing: image size {}&quot;, image.len());
    let mut headers = HeaderMap::new();

    headers.insert(&quot;content-type&quot;, HeaderValue::from_static(&quot;image/jpeg&quot;));
    Ok((headers, image))
}
</code></pre></pre>
<h3 id="处理函数用到的图片获取方法"><a class="header" href="#处理函数用到的图片获取方法">处理函数用到的图片获取方法</a></h3>
<blockquote>
<p>对于图片的网络请求，我们先把 URL 做个哈希，在 LRU 缓存中查找，找不到才用 reqwest 发送请求。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">#[instrument(level = &quot;info&quot;, skip(cache))]
async fn retrieve_image(url: &amp;str, cache: Cache) -&gt; Result&lt;Bytes&gt; {
    let mut hasher = DefaultHasher::new();
    url.hash(&amp;mut hasher);
    let key = hasher.finish();

    let g = &amp;mut cache.lock().await;
    let data = match g.get(&amp;key) {
        Some(v) =&gt; {
            info!(&quot;Match cache {}&quot;, key);
            v.to_owned()
        }
        None =&gt; {
            info!(&quot;Retrieve url&quot;);
            let resp = reqwest::get(url).await?;
            let data = resp.bytes().await?;
            g.put(key, data.clone());
            data
        }
    };

    Ok(data)
}
</code></pre></pre>
<h3 id="一个用于调试的辅助函数"><a class="header" href="#一个用于调试的辅助函数">一个用于调试的辅助函数</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">// 调试辅助函数
fn print_test_url(url: &amp;str) {
    use std::borrow::Borrow;
    let spec1 = Spec::new_resize(500, 800, resize::SampleFilter::CatmullRom);
    let spec2 = Spec::new_watermark(20, 20);
    let spec3 = Spec::new_filter(filter::Filter::Marine);
    let image_spec = ImageSpec::new(vec![spec1, spec2, spec3]);
    let s: String = image_spec.borrow().into();
    let test_image = percent_encode(url.as_bytes(), NON_ALPHANUMERIC).to_string();
    println!(&quot;test url: http://localhost:3000/image/{}/{}&quot;, s, test_image);
}
</code></pre></pre>
<h2 id="运行与日志"><a class="header" href="#运行与日志">运行与日志</a></h2>
<blockquote>
<p>将RUST_LOG级别设置为info</p>
</blockquote>
<pre><code class="language-shell">cargo build --release
RUST_LOG=info target/release/thumbor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql查询工具"><a class="header" href="#sql查询工具">SQL查询工具</a></h1>
<!--ts-->
<ul>
<li><a href="queryer.html#sql%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7">SQL查询工具</a>
<ul>
<li><a href="queryer.html#workspace-%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%B8%85%E5%8D%95virtual-manifest%E6%96%B9%E5%BC%8F">workspace: 这里使用虚拟清单(virtual manifest)方式</a>
<ul>
<li><a href="queryer.html#workspace%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">workspace使用方式</a></li>
</ul>
</li>
<li><a href="queryer.html#queryer-package">queryer package</a>
<ul>
<li><a href="queryer.html#cargotoml">cargo.toml</a></li>
<li><a href="queryer.html#%E4%B8%A4%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">两个使用示例</a>
<ul>
<li><a href="queryer.html#dialectrssql%E8%A7%A3%E6%9E%90">dialect.rs:SQL解析</a></li>
<li><a href="queryer.html#covidrs-ast%E8%BD%AC%E6%8D%A2">covid.rs: AST转换</a></li>
</ul>
</li>
<li><a href="queryer.html#srcconvertrs">src/convert.rs</a>
<ul>
<li><a href="queryer.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89sql%E4%B8%8E%E5%AF%B9%E5%BA%94%E9%83%A8%E5%88%86%E7%BB%93%E6%9E%84%E4%BD%93-%E6%B3%A8%E6%84%8F%E9%99%90%E4%BA%8E%E5%AD%A4%E5%84%BF%E5%8E%9F%E5%88%99%E7%9A%84%E5%86%8D%E5%8C%85%E8%A3%85">结构体定义:sql与对应部分结构体, 注意限于孤儿原则的再包装</a></li>
<li><a href="queryer.html#sql%E7%9A%84%E8%BD%AC%E6%8D%A2">sql的转换</a></li>
<li><a href="queryer.html#%E5%AF%B9%E5%BA%94%E9%83%A8%E5%88%86%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%BD%AC%E6%8D%A2">对应部分结构体的转换</a></li>
<li><a href="queryer.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li>
</ul>
</li>
<li><a href="queryer.html#srcdialectrs">src/dialect.rs</a>
<ul>
<li><a href="queryer.html#%E5%AE%9A%E4%B9%89%E6%96%B9%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93">定义方言结构体</a></li>
<li><a href="queryer.html#%E7%BB%99%E6%96%B9%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0trait">给方言结构体实现trait</a></li>
<li><a href="queryer.html#%E6%B7%BB%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E5%87%BD%E6%95%B0">添加测试用函数</a></li>
<li><a href="queryer.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-1">单元测试</a></li>
</ul>
</li>
<li><a href="queryer.html#srcloaderrs">src/loader.rs</a>
<ul>
<li><a href="queryer.html#%E5%AE%9A%E4%B9%89loader%E4%B8%8Ecsvloader">定义Loader与CsvLoader</a></li>
<li><a href="queryer.html#%E5%AE%9A%E4%B9%89trait%E5%B9%B6%E7%BB%99csvloader%E5%AE%9E%E7%8E%B0">定义trait并给CsvLoader实现</a></li>
<li><a href="queryer.html#todo-%E7%BB%99csvloader%E6%B7%BB%E5%8A%A0%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B">todo: 给CsvLoader添加内容检测</a></li>
</ul>
</li>
<li><a href="queryer.html#srcfetcherrs">src/fetcher.rs</a>
<ul>
<li><a href="queryer.html#%E5%AE%9A%E4%B9%89urlfetcher%E4%B8%8Efilefetcher">定义UrlFetcher与FileFetcher</a></li>
<li><a href="queryer.html#%E5%AE%9A%E4%B9%89trait%E5%B9%B6%E7%BB%99fetcher%E4%B8%8Efilefetcher%E5%AE%9E%E7%8E%B0">定义trait并给Fetcher与FileFetcher实现</a></li>
<li><a href="queryer.html#%E6%9C%80%E5%90%8E%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95">最后定义一个获取数据的方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="queryer.html#queryer-js-package-%E4%BD%BF%E7%94%A8neon">queryer-js package: 使用neon</a>
<ul>
<li><a href="queryer.html#cargotoml-1">Cargo.toml</a></li>
<li><a href="queryer.html#build-in-packagejson">build in package.json</a></li>
<li><a href="queryer.html#srclibrs">src/lib.rs</a></li>
</ul>
</li>
<li><a href="queryer.html#queryer-py-package-%E4%BD%BF%E7%94%A8pyo3">queryer-py package: 使用pyo3</a>
<ul>
<li><a href="queryer.html#cargotoml-2">Cargo.toml</a></li>
<li><a href="queryer.html#buildrs">build.rs</a></li>
<li><a href="queryer.html#srclibrs-1">src/lib.rs</a></li>
</ul>
</li>
<li><a href="queryer.html#data-viewer-package-%E4%BD%BF%E7%94%A8tauri">data-viewer package: 使用tauri</a>
<ul>
<li><a href="queryer.html#cargotoml-3">Cargo.toml</a></li>
<li><a href="queryer.html#buildrs-1">build.rs</a></li>
<li><a href="queryer.html#mainrs">main.rs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Wed Sep 28 10:55:11 UTC 2022 -->
<!--te-->
<h2 id="workspace-这里使用虚拟清单virtual-manifest方式"><a class="header" href="#workspace-这里使用虚拟清单virtual-manifest方式">workspace: 这里使用虚拟清单(virtual manifest)方式</a></h2>
<blockquote>
<p><a href="https://course.rs/cargo/reference/workspaces.html">工作空间 Workspace - Rust语言圣经(Rust Course)</a></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">[workspace]

members = [
  &quot;queryer&quot;,
  &quot;queryer-js&quot;,
  &quot;queryer-py&quot;,
  &quot;data-viewer/src-tauri&quot;
]
</code></pre></pre>
<div id="admonition-虚拟清单" class="admonition info">
<div class="admonition-title">
<p>虚拟清单</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-虚拟清单"></a></p>
</div>
<div>
<p>若一个 Cargo.toml 有 [workspace] 但是没有 [package] 部分，则它是虚拟清单类型的工作空间。</p>
<p>对于没有主 package 的场景或你希望将所有的 package 组织在单独的目录中时，这种方式就非常适合。</p>
</div>
</div>
<div id="admonition-workspace关键点" class="admonition tip">
<div class="admonition-title">
<p>workspace关键点</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-workspace关键点"></a></p>
</div>
<div>
<ul>
<li>所有的 package 共享同一个 Cargo.lock 文件，该文件位于工作空间的根目录中</li>
<li>所有的 package 共享同一个输出目录，该目录默认的名称是 target ，位于工作空间根目录下</li>
<li>只有工作空间根目录的 Cargo.toml 才能包含 [patch], [replace] 和 [profile.*]，而成员的 Cargo.toml 中的相应部分将被自动忽略</li>
</ul>
</div>
</div>
<h3 id="workspace使用方式"><a class="header" href="#workspace使用方式">workspace使用方式</a></h3>
<pre><code class="language-shell">cargo run -p &lt;member package&gt;
cargo build -p queryer
</code></pre>
<div id="admonition-使用说明" class="admonition info">
<div class="admonition-title">
<p>使用说明</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-使用说明"></a></p>
</div>
<div>
<ol>
<li>
<p>在工作空间中，package 相关的 Cargo 命令(例如 cargo build )可以使用 -p 、 –package 或 –workspace 命令行参数来指定想要操作的 package。</p>
</li>
<li>
<p>若没有指定任何参数，则 Cargo 将使用当前工作目录的中的 package 。若工作目录是虚拟清单类型的工作空间，则该命令将作用在所有成员上(就好像是使用了 –workspace 命令行参数)。而 default-members 可以在命令行参数没有被提供时，手动指定操作的成员</p>
</li>
</ol>
</div>
</div>
<h2 id="queryer-package"><a class="header" href="#queryer-package">queryer package</a></h2>
<h3 id="cargotoml-2"><a class="header" href="#cargotoml-2">cargo.toml</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">{{#include ../geektime_rust_codes/06_queryer/queryer/cargo.toml}}
</code></pre></pre>
<h3 id="两个使用示例"><a class="header" href="#两个使用示例">两个使用示例</a></h3>
<h4 id="dialectrssql解析"><a class="header" href="#dialectrssql解析">dialect.rs:SQL解析</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">use sqlparser::{dialect::GenericDialect, parser::Parser};

fn main() {
    tracing_subscriber::fmt::init();

    let sql = &quot;SELECT a a1, b, 123, myfunc(b), * \
    FROM data_source \
    WHERE a &gt; b AND b &lt; 100 AND c BETWEEN 10 AND 20 \
    ORDER BY a DESC, b \
    LIMIT 50 OFFSET 10&quot;;

    let ast = Parser::parse_sql(&amp;GenericDialect::default(), sql);
    println!(&quot;{:#?}&quot;, ast);
}
</code></pre></pre>
<h4 id="covidrs-ast转换"><a class="header" href="#covidrs-ast转换">covid.rs: AST转换</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">use anyhow::Result;
use queryer::query;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();

    let url = &quot;https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv&quot;;

    // 使用 sql 从 URL 里获取数据
    let sql = format!(
        &quot;SELECT location name, total_cases, new_cases, total_deaths, new_deaths \
        FROM {} where new_deaths &gt;= 500 ORDER BY new_cases DESC&quot;,
        url
    );
    let df1 = query(sql).await?;
    println!(&quot;{:?}&quot;, df1);

    Ok(())
}
</code></pre></pre>
<h3 id="srcconvertrs"><a class="header" href="#srcconvertrs">src/convert.rs</a></h3>
<h4 id="结构体定义sql与对应部分结构体-注意限于孤儿原则的再包装"><a class="header" href="#结构体定义sql与对应部分结构体-注意限于孤儿原则的再包装">结构体定义:sql与对应部分结构体, 注意限于孤儿原则的再包装</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 解析出来的 SQL
pub struct Sql&lt;'a&gt; {
    pub(crate) selection: Vec&lt;Expr&gt;,
    pub(crate) condition: Option&lt;Expr&gt;,
    pub(crate) source: &amp;'a str,
    pub(crate) order_by: Vec&lt;(String, bool)&gt;,
    pub(crate) offset: Option&lt;i64&gt;,
    pub(crate) limit: Option&lt;usize&gt;,
}

// 因为 Rust trait 的孤儿规则，我们如果要想对已有的类型实现已有的 trait，
// 需要简单包装一下

pub struct Expression(pub(crate) Box&lt;SqlExpr&gt;);
pub struct Operation(pub(crate) SqlBinaryOperator);
pub struct Projection&lt;'a&gt;(pub(crate) &amp;'a SelectItem);
pub struct Source&lt;'a&gt;(pub(crate) &amp;'a [TableWithJoins]);
pub struct Order&lt;'a&gt;(pub(crate) &amp;'a OrderByExpr);
pub struct Offset&lt;'a&gt;(pub(crate) &amp;'a SqlOffset);
pub struct Limit&lt;'a&gt;(pub(crate) &amp;'a SqlExpr);
pub struct Value(pub(crate) SqlValue);
</code></pre></pre>
<h4 id="sql的转换"><a class="header" href="#sql的转换">sql的转换</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 把 SqlParser 解析出来的 Statement 转换成我们需要的结构
impl&lt;'a&gt; TryFrom&lt;&amp;'a Statement&gt; for Sql&lt;'a&gt; {
    type Error = anyhow::Error;

    fn try_from(sql: &amp;'a Statement) -&gt; Result&lt;Self, Self::Error&gt; {
        match sql {
            // 目前我们只关心 query (select ... from ... where ...)
            Statement::Query(q) =&gt; {
                let offset = q.offset.as_ref();
                let limit = q.limit.as_ref();
                let orders = &amp;q.order_by;
                let Select {
                    from: table_with_joins,
                    selection: where_clause,
                    projection,

                    group_by: _,
                    ..
                } = match &amp;q.body {
                    SetExpr::Select(statement) =&gt; statement.as_ref(),
                    _ =&gt; return Err(anyhow!(&quot;We only support Select Query at the moment&quot;)),
                };

                let source = Source(table_with_joins).try_into()?;

                let condition = match where_clause {
                    Some(expr) =&gt; Some(Expression(Box::new(expr.to_owned())).try_into()?),
                    None =&gt; None,
                };

                let mut selection = Vec::with_capacity(8);
                for p in projection {
                    let expr = Projection(p).try_into()?;
                    selection.push(expr);
                }

                let mut order_by = Vec::new();
                for expr in orders {
                    order_by.push(Order(expr).try_into()?);
                }

                let offset = offset.map(|v| Offset(v).into());
                let limit = limit.map(|v| Limit(v).into());

                Ok(Sql {
                    selection,
                    condition,
                    source,
                    order_by,
                    offset,
                    limit,
                })
            }
            _ =&gt; Err(anyhow!(&quot;We only support Query at the moment&quot;)),
        }
    }
}
</code></pre></pre>
<h4 id="对应部分结构体的转换"><a class="header" href="#对应部分结构体的转换">对应部分结构体的转换</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 把 SqlParser 的 Expr 转换成 DataFrame 的 Expr
impl TryFrom&lt;Expression&gt; for Expr {
    type Error = anyhow::Error;

    fn try_from(expr: Expression) -&gt; Result&lt;Self, Self::Error&gt; {
        match *expr.0 {
            SqlExpr::BinaryOp { left, op, right } =&gt; Ok(Expr::BinaryExpr {
                left: Box::new(Expression(left).try_into()?),
                op: Operation(op).try_into()?,
                right: Box::new(Expression(right).try_into()?),
            }),
            SqlExpr::Wildcard =&gt; Ok(Self::Wildcard),
            SqlExpr::IsNull(expr) =&gt; Ok(Self::IsNull(Box::new(Expression(expr).try_into()?))),
            SqlExpr::IsNotNull(expr) =&gt; Ok(Self::IsNotNull(Box::new(Expression(expr).try_into()?))),
            SqlExpr::Identifier(id) =&gt; Ok(Self::Column(Arc::new(id.value))),
            SqlExpr::Value(v) =&gt; Ok(Self::Literal(Value(v).try_into()?)),
            v =&gt; Err(anyhow!(&quot;expr {:#?} is not supported&quot;, v)),
        }
    }
}

/// 把 SqlParser 的 BinaryOperator 转换成 DataFrame 的 Operator
impl TryFrom&lt;Operation&gt; for Operator {
    type Error = anyhow::Error;

    fn try_from(op: Operation) -&gt; Result&lt;Self, Self::Error&gt; {
        match op.0 {
            SqlBinaryOperator::Plus =&gt; Ok(Self::Plus),
            SqlBinaryOperator::Minus =&gt; Ok(Self::Minus),
            SqlBinaryOperator::Multiply =&gt; Ok(Self::Multiply),
            SqlBinaryOperator::Divide =&gt; Ok(Self::Divide),
            SqlBinaryOperator::Modulo =&gt; Ok(Self::Modulus),
            SqlBinaryOperator::Gt =&gt; Ok(Self::Gt),
            SqlBinaryOperator::Lt =&gt; Ok(Self::Lt),
            SqlBinaryOperator::GtEq =&gt; Ok(Self::GtEq),
            SqlBinaryOperator::LtEq =&gt; Ok(Self::LtEq),
            SqlBinaryOperator::Eq =&gt; Ok(Self::Eq),
            SqlBinaryOperator::NotEq =&gt; Ok(Self::NotEq),
            SqlBinaryOperator::And =&gt; Ok(Self::And),
            SqlBinaryOperator::Or =&gt; Ok(Self::Or),
            v =&gt; Err(anyhow!(&quot;Operator {} is not supported&quot;, v)),
        }
    }
}

/// 把 SqlParser 的 SelectItem 转换成 DataFrame 的 Expr
impl&lt;'a&gt; TryFrom&lt;Projection&lt;'a&gt;&gt; for Expr {
    type Error = anyhow::Error;

    fn try_from(p: Projection&lt;'a&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        match p.0 {
            SelectItem::UnnamedExpr(SqlExpr::Identifier(id)) =&gt; Ok(col(&amp;id.to_string())),
            SelectItem::ExprWithAlias {
                expr: SqlExpr::Identifier(id),
                alias,
            } =&gt; Ok(Expr::Alias(
                Box::new(Expr::Column(Arc::new(id.to_string()))),
                Arc::new(alias.to_string()),
            )),
            SelectItem::QualifiedWildcard(v) =&gt; Ok(col(&amp;v.to_string())),
            SelectItem::Wildcard =&gt; Ok(col(&quot;*&quot;)),
            item =&gt; Err(anyhow!(&quot;projection {} not supported&quot;, item)),
        }
    }
}

impl&lt;'a&gt; TryFrom&lt;Source&lt;'a&gt;&gt; for &amp;'a str {
    type Error = anyhow::Error;

    fn try_from(source: Source&lt;'a&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        if source.0.len() != 1 {
            return Err(anyhow!(&quot;We only support single data source at the moment&quot;));
        }

        let table = &amp;source.0[0];
        if !table.joins.is_empty() {
            return Err(anyhow!(&quot;We do not support joint data source at the moment&quot;));
        }

        match &amp;table.relation {
            TableFactor::Table { name, .. } =&gt; Ok(&amp;name.0.first().unwrap().value),
            _ =&gt; Err(anyhow!(&quot;We only support table&quot;)),
        }
    }
}

/// 把 SqlParser 的 order by expr 转换成 (列名, 排序方法)
impl&lt;'a&gt; TryFrom&lt;Order&lt;'a&gt;&gt; for (String, bool) {
    type Error = anyhow::Error;

    fn try_from(o: Order) -&gt; Result&lt;Self, Self::Error&gt; {
        let name = match &amp;o.0.expr {
            SqlExpr::Identifier(id) =&gt; id.to_string(),
            expr =&gt; {
                return Err(anyhow!(
                    &quot;We only support identifier for order by, got {}&quot;,
                    expr
                ))
            }
        };

        Ok((name, !o.0.asc.unwrap_or(true)))
    }
}

/// 把 SqlParser 的 offset expr 转换成 i64
impl&lt;'a&gt; From&lt;Offset&lt;'a&gt;&gt; for i64 {
    fn from(offset: Offset) -&gt; Self {
        match offset.0 {
            SqlOffset {
                value: SqlExpr::Value(SqlValue::Number(v, _b)),
                ..
            } =&gt; v.parse().unwrap_or(0),
            _ =&gt; 0,
        }
    }
}

/// 把 SqlParser 的 Limit expr 转换成 usize
impl&lt;'a&gt; From&lt;Limit&lt;'a&gt;&gt; for usize {
    fn from(l: Limit&lt;'a&gt;) -&gt; Self {
        match l.0 {
            SqlExpr::Value(SqlValue::Number(v, _b)) =&gt; v.parse().unwrap_or(usize::MAX),
            _ =&gt; usize::MAX,
        }
    }
}

/// 把 SqlParser 的 value 转换成 DataFrame 支持的 LiteralValue
impl TryFrom&lt;Value&gt; for LiteralValue {
    type Error = anyhow::Error;
    fn try_from(v: Value) -&gt; Result&lt;Self, Self::Error&gt; {
        match v.0 {
            SqlValue::Number(v, _) =&gt; Ok(LiteralValue::Float64(v.parse().unwrap())),
            SqlValue::Boolean(v) =&gt; Ok(LiteralValue::Boolean(v)),
            SqlValue::Null =&gt; Ok(LiteralValue::Null),
            v =&gt; Err(anyhow!(&quot;Value {} is not supported&quot;, v)),
        }
    }
}
</code></pre></pre>
<h4 id="单元测试-2"><a class="header" href="#单元测试-2">单元测试</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {
    use super::*;
    use crate::TyrDialect;
    use sqlparser::parser::Parser;

    #[test]
    fn parse_sql_works() {
        let url = &quot;http://abc.xyz/abc?a=1&amp;b=2&quot;;
        let sql = format!(
            &quot;select a, b, c from {} where a=1 order by c desc limit 5 offset 10&quot;,
            url
        );
        let statement = &amp;Parser::parse_sql(&amp;TyrDialect::default(), sql.as_ref()).unwrap()[0];
        let sql: Sql = statement.try_into().unwrap();
        assert_eq!(sql.source, url);
        assert_eq!(sql.limit, Some(5));
        assert_eq!(sql.offset, Some(10));
        assert_eq!(sql.order_by, vec![(&quot;c&quot;.into(), true)]);
        assert_eq!(sql.selection, vec![col(&quot;a&quot;), col(&quot;b&quot;), col(&quot;c&quot;)]);
    }
}
</code></pre></pre>
<h3 id="srcdialectrs"><a class="header" href="#srcdialectrs">src/dialect.rs</a></h3>
<h4 id="定义方言结构体"><a class="header" href="#定义方言结构体">定义方言结构体</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">#[derive(Debug, Default)]
pub struct TyrDialect;
</code></pre></pre>
<h4 id="给方言结构体实现trait"><a class="header" href="#给方言结构体实现trait">给方言结构体实现trait</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// 创建自己的 sql 方言。TyrDialect 支持 identifier 可以是简单的 url
impl Dialect for TyrDialect {
    fn is_identifier_start(&amp;self, ch: char) -&gt; bool {
        ('a'..='z').contains(&amp;ch) || ('A'..='Z').contains(&amp;ch) || ch == '_'
    }

    // identifier 可以有 ':', '/', '?', '&amp;', '='
    fn is_identifier_part(&amp;self, ch: char) -&gt; bool {
        ('a'..='z').contains(&amp;ch)
            || ('A'..='Z').contains(&amp;ch)
            || ('0'..='9').contains(&amp;ch)
            || [':', '/', '?', '&amp;', '=', '-', '_', '.'].contains(&amp;ch)
    }
}
</code></pre></pre>
<h4 id="添加测试用函数"><a class="header" href="#添加测试用函数">添加测试用函数</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 测试辅助函数
pub fn example_sql() -&gt; String {
    let url = &quot;https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv&quot;;

    let sql = format!(
        &quot;SELECT location name, total_cases, new_cases, total_deaths, new_deaths \
        FROM {} where new_deaths &gt;= 500 ORDER BY new_cases DESC LIMIT 6 OFFSET 5&quot;,
        url
    );

    sql
}
</code></pre></pre>
<h4 id="单元测试-3"><a class="header" href="#单元测试-3">单元测试</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {
    use super::*;
    use sqlparser::parser::Parser;

    #[test]
    fn it_works() {
        assert!(Parser::parse_sql(&amp;TyrDialect::default(), &amp;example_sql()).is_ok());
    }
}
</code></pre></pre>
<h3 id="srcloaderrs"><a class="header" href="#srcloaderrs">src/loader.rs</a></h3>
<h4 id="定义loader与csvloader"><a class="header" href="#定义loader与csvloader">定义Loader与CsvLoader</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">#[derive(Debug)]
#[non_exhaustive]
pub enum Loader {
    Csv(CsvLoader),
}

#[derive(Default, Debug)]
pub struct CsvLoader(pub(crate) String);
</code></pre></pre>
<h4 id="定义trait并给csvloader实现"><a class="header" href="#定义trait并给csvloader实现">定义trait并给CsvLoader实现</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">
    let sql = format!(
        &quot;SELECT location name, total_cases, new_cases, total_deaths, new_deaths \
        FROM {} where new_deaths &gt;= 500 ORDER BY new_cases DESC LIMIT 6 OFFSET 5&quot;,
        url
    );

    sql
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlparser::parser::Parser;

</code></pre></pre>
<h4 id="todo-给csvloader添加内容检测"><a class="header" href="#todo-给csvloader添加内容检测">todo: 给CsvLoader添加内容检测</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">    fn it_works() {
        assert!(Parser::parse_sql(&amp;TyrDialect::default(), &amp;example_sql()).is_ok());
    }
}
</code></pre></pre>
<h3 id="srcfetcherrs"><a class="header" href="#srcfetcherrs">src/fetcher.rs</a></h3>
<h4 id="定义urlfetcher与filefetcher"><a class="header" href="#定义urlfetcher与filefetcher">定义UrlFetcher与FileFetcher</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">struct UrlFetcher&lt;'a&gt;(pub(crate) &amp;'a str);

struct FileFetcher&lt;'a&gt;(pub(crate) &amp;'a str);
</code></pre></pre>
<h4 id="定义trait并给fetcher与filefetcher实现"><a class="header" href="#定义trait并给fetcher与filefetcher实现">定义trait并给Fetcher与FileFetcher实现</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// Rust 的 async trait 还没有稳定，可以用 async_trait 宏
#[async_trait]
pub trait Fetch {
    type Error;
    async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt;;
}

#[async_trait]
impl&lt;'a&gt; Fetch for UrlFetcher&lt;'a&gt; {
    type Error = anyhow::Error;

    async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt; {
        Ok(reqwest::get(self.0).await?.text().await?)
    }
}

#[async_trait]
impl&lt;'a&gt; Fetch for FileFetcher&lt;'a&gt; {
    type Error = anyhow::Error;

    async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt; {
        Ok(fs::read_to_string(&amp;self.0[7..]).await?)
    }
}
</code></pre></pre>
<h4 id="最后定义一个获取数据的方法"><a class="header" href="#最后定义一个获取数据的方法">最后定义一个获取数据的方法</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 从文件源或者 http 源中获取数据，返回字符串
pub async fn retrieve_data(source: impl AsRef&lt;str&gt;) -&gt; Result&lt;String&gt; {
    let name = source.as_ref();
    match &amp;name[..4] {
        // 包括 http / https
        &quot;http&quot; =&gt; UrlFetcher(name).fetch().await,
        // 处理 file://&lt;filename&gt;
        &quot;file&quot; =&gt; FileFetcher(name).fetch().await,
        _ =&gt; Err(anyhow!(&quot;We only support http/https/file at the moment&quot;)),
    }
}
</code></pre></pre>
<h2 id="queryer-js-package-使用neon"><a class="header" href="#queryer-js-package-使用neon">queryer-js package: 使用neon</a></h2>
<h3 id="cargotoml-3"><a class="header" href="#cargotoml-3">Cargo.toml</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">[package]
name = &quot;queryer-js&quot;
version = &quot;0.1.0&quot;
license = &quot;ISC&quot;
edition = &quot;2021&quot;
exclude = [&quot;index.node&quot;]

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
anyhow = &quot;1&quot;
queryer = { path = &quot;../queryer&quot; }
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }

[dependencies.neon]
version = &quot;0.9&quot;
default-features = false
features = [&quot;napi-6&quot;]
</code></pre></pre>
<h3 id="build-in-packagejson"><a class="header" href="#build-in-packagejson">build in package.json</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">{
  &quot;name&quot;: &quot;queryer-js&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.node&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;cargo-cp-artifact -nc index.node -- cargo build --message-format=json-render-diagnostics&quot;,
    &quot;build-debug&quot;: &quot;npm run build --&quot;,
    &quot;build-release&quot;: &quot;npm run build -- --release&quot;,
    &quot;install&quot;: &quot;npm run build-release&quot;,
    &quot;test&quot;: &quot;cargo test&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;cargo-cp-artifact&quot;: &quot;^0.1&quot;
  }
}
</code></pre></pre>
<h3 id="srclibrs"><a class="header" href="#srclibrs">src/lib.rs</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use neon::prelude::*;

pub fn example_sql(mut cx: FunctionContext) -&gt; JsResult&lt;JsString&gt; {
    Ok(cx.string(queryer::example_sql()))
}

fn query(mut cx: FunctionContext) -&gt; JsResult&lt;JsString&gt; {
    let sql = cx.argument::&lt;JsString&gt;(0)?.value(&amp;mut cx);
    let output = match cx.argument::&lt;JsString&gt;(1) {
        Ok(v) =&gt; v.value(&amp;mut cx),
        Err(_) =&gt; &quot;csv&quot;.to_string(),
    };
    let rt = tokio::runtime::Runtime::new().unwrap();
    let data = rt.block_on(async { queryer::query(sql).await.unwrap() });

    match output.as_str() {
        &quot;csv&quot; =&gt; Ok(cx.string(data.to_csv().unwrap())),
        v =&gt; cx.throw_type_error(format!(&quot;Output type {} not supported&quot;, v)),
    }
}

#[neon::main]
fn main(mut cx: ModuleContext) -&gt; NeonResult&lt;()&gt; {
    cx.export_function(&quot;example_sql&quot;, example_sql)?;
    cx.export_function(&quot;query&quot;, query)?;
    Ok(())
}
</code></pre></pre>
<h2 id="queryer-py-package-使用pyo3"><a class="header" href="#queryer-py-package-使用pyo3">queryer-py package: 使用pyo3</a></h2>
<blockquote>
<p>python调用查询包</p>
</blockquote>
<h3 id="cargotoml-4"><a class="header" href="#cargotoml-4">Cargo.toml</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">[package]
name = &quot;queryer_py&quot; # Python 模块需要用下划线
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;


[lib]
crate-type = [&quot;cdylib&quot;] # 使用 cdylib 类型

[dependencies]
queryer = { path = &quot;../queryer&quot; } # 引入 queryer
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }

[dependencies.pyo3]
version = &quot;0.14&quot;
features = [&quot;extension-module&quot;]

[build-dependencies]
pyo3-build-config = &quot;0.14&quot;
</code></pre></pre>
<h3 id="buildrs-1"><a class="header" href="#buildrs-1">build.rs</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    pyo3_build_config::add_extension_module_link_args();
}
</code></pre></pre>
<h3 id="srclibrs-1"><a class="header" href="#srclibrs-1">src/lib.rs</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">#![allow(clippy::needless_option_as_deref)]
use pyo3::{exceptions, prelude::*};

#[pyfunction]
pub fn example_sql() -&gt; PyResult&lt;String&gt; {
    Ok(queryer::example_sql())
}

#[pyfunction]
pub fn query(sql: &amp;str, output: Option&lt;&amp;str&gt;) -&gt; PyResult&lt;String&gt; {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let data = rt.block_on(async { queryer::query(sql).await.unwrap() });
    match output {
        Some(&quot;csv&quot;) | None =&gt; Ok(data.to_csv().unwrap()),
        Some(v) =&gt; Err(exceptions::PyTypeError::new_err(format!(
            &quot;Output type {} not supported&quot;,
            v
        ))),
    }
}

#[pymodule]
fn queryer_py(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(query, m)?)?;
    m.add_function(wrap_pyfunction!(example_sql, m)?)?;
    Ok(())
}
</code></pre></pre>
<h2 id="data-viewer-package-使用tauri"><a class="header" href="#data-viewer-package-使用tauri">data-viewer package: 使用tauri</a></h2>
<h3 id="cargotoml-5"><a class="header" href="#cargotoml-5">Cargo.toml</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">[package]
name = &quot;app&quot;
version = &quot;0.1.0&quot;
description = &quot;A Tauri App&quot;
authors = [&quot;you&quot;]
license = &quot;&quot;
repository = &quot;&quot;
default-run = &quot;app&quot;
edition = &quot;2021&quot;
build = &quot;src/build.rs&quot;

<span class="boring">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</span>
[build-dependencies]
tauri-build = { version = &quot;1.0.0-beta.4&quot; }

[dependencies]
anyhow = &quot;1&quot;
serde_json = &quot;1&quot;
queryer = { path = &quot;../../queryer&quot; }
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
tauri = { version = &quot;1.0.0-beta.8&quot;, features = [&quot;api-all&quot;] }

[features]
default = [ &quot;custom-protocol&quot; ]
custom-protocol = [ &quot;tauri/custom-protocol&quot; ]
</code></pre></pre>
<h3 id="buildrs-2"><a class="header" href="#buildrs-2">build.rs</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
  tauri_build::build()
}
</code></pre></pre>
<h3 id="mainrs-1"><a class="header" href="#mainrs-1">main.rs</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">#![cfg_attr(
  all(not(debug_assertions), target_os = &quot;windows&quot;),
  windows_subsystem = &quot;windows&quot;
)]

#[tauri::command]
fn example_sql() -&gt; String {
  queryer::example_sql()
}

#[tauri::command]
async fn query(sql: String) -&gt; Result&lt;String, String&gt; {
  let data = queryer::query(&amp;sql).await.map_err(|err| err.to_string())?;
  Ok(data.to_csv().map_err(|err| err.to_string())?)
}

fn main() {
  tauri::Builder::default()
    .invoke_handler(tauri::generate_handler![example_sql, query])
    .run(tauri::generate_context!())
    .expect(&quot;error while running tauri application&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust核心深入"><a class="header" href="#rust核心深入">Rust核心深入</a></h1>
<h2 id="资料推荐"><a class="header" href="#资料推荐">资料推荐</a></h2>
<ul>
<li><a href="https://tyrchen.github.io/rust-training/rust-training-all-in-one-cn.html#1">陈天培训slides</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i-从栈堆所有权生命周期开始内存管理"><a class="header" href="#i-从栈堆所有权生命周期开始内存管理">I. 从栈堆、所有权、生命周期开始内存管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ii-类型系统"><a class="header" href="#ii-类型系统">II. 类型系统</a></h1>
<!--ts-->
<ul>
<li><a href="2_type_system.html#ii-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">II. 类型系统</a>
<ul>
<li><a href="2_type_system.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB%E5%9B%BE">类型系统分类图</a>
<ul>
<li><a href="2_type_system.html#%E4%B8%89%E4%B8%AA%E6%A0%87%E5%87%86">三个标准</a></li>
<li><a href="2_type_system.html#rust%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9">Rust类型系统特点</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">类型分类</a>
<ul>
<li><a href="2_type_system.html#%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B">原生类型</a></li>
<li><a href="2_type_system.html#%E7%BB%84%E5%90%88%E7%B1%BB%E5%9E%8B">组合类型</a></li>
<li><a href="2_type_system.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E5%90%88%E7%B1%BB%E5%9E%8B">自定义组合类型</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E5%B0%8F%E4%BE%8B%E5%AD%90">小例子</a>
<ul>
<li><a href="2_type_system.html#%E5%B8%B8%E9%87%8F">常量</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">类型推导</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E6%B3%9B%E5%9E%8B">泛型</a>
<ul>
<li><a href="2_type_system.html#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a></li>
<li><a href="2_type_system.html#%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">泛型数据结构</a>
<ul>
<li><a href="2_type_system.html#%E9%80%90%E6%AD%A5%E7%BA%A6%E6%9D%9F%E6%8A%8A%E5%86%B3%E7%AD%96%E4%BA%A4%E7%BB%99%E4%BD%BF%E7%94%A8%E8%80%85">逐步约束：把决策交给使用者</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0">泛型参数</a>
<ul>
<li><a href="2_type_system.html#%E5%8F%82%E6%95%B0%E5%A4%9A%E6%80%81">参数多态</a></li>
<li><a href="2_type_system.html#%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">三种使用场景</a>
<ul>
<li><a href="2_type_system.html#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A">延迟绑定</a></li>
<li><a href="2_type_system.html#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A-1">延迟绑定</a></li>
<li><a href="2_type_system.html#%E5%A4%9A%E4%B8%AA%E5%AE%9E%E7%8E%B0">多个实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="2_type_system.html#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0">泛型函数</a>
<ul>
<li><a href="2_type_system.html#%E5%8D%95%E6%80%81%E5%8C%96">单态化</a>
<ul>
<li><a href="2_type_system.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="2_type_system.html#%E4%BC%98%E5%8A%A3">优劣</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E6%90%BA%E5%B8%A6%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0">返回值携带泛型参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="2_type_system.html#trait">Trait</a>
<ul>
<li><a href="2_type_system.html#%E5%9F%BA%E6%9C%AC%E7%BB%83%E4%B9%A0">基本练习</a>
<ul>
<li><a href="2_type_system.html#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F">泛型约束</a>
<ul>
<li><a href="2_type_system.html#%E6%80%9D%E8%80%83%E9%A2%98">思考题</a></li>
<li><a href="2_type_system.html#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">关联类型</a></li>
<li><a href="2_type_system.html#%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B">支持泛型</a></li>
<li><a href="2_type_system.html#%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF">支持继承</a></li>
<li><a href="2_type_system.html#%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%A4%9A%E6%80%81">子类型多态</a></li>
</ul>
</li>
<li><a href="2_type_system.html#trait-object">Trait Object</a>
<ul>
<li><a href="2_type_system.html#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86ptrvtable">实现机理：ptr+vtable</a></li>
<li><a href="2_type_system.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a>
<ul>
<li><a href="2_type_system.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8">在函数中使用</a></li>
<li><a href="2_type_system.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%AD%E4%BD%BF%E7%94%A8">在函数返回值中使用</a>
<ul>
<li><a href="2_type_system.html#%E5%9C%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E4%BD%BF%E7%94%A8">在数据结构中使用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="2_type_system.html#%E5%B8%B8%E7%94%A8trait">常用trait</a>
<ul>
<li><a href="2_type_system.html#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3">内存相关</a></li>
<li><a href="2_type_system.html#%E6%A0%87%E7%AD%BEtrait">标签trait</a></li>
<li><a href="2_type_system.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a></li>
<li><a href="2_type_system.html#%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9B%B8%E5%85%B3">操作符相关</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84">设计架构</a>
<ul>
<li><a href="2_type_system.html#%E9%A1%BA%E6%89%8B%E8%87%AA%E7%84%B6">顺手自然</a></li>
<li><a href="2_type_system.html#%E6%A1%A5%E6%8E%A5">桥接</a></li>
<li><a href="2_type_system.html#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC">控制反转</a></li>
<li><a href="2_type_system.html#solid%E5%8E%9F%E5%88%99">SOLID原则</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Wed Sep 28 10:55:09 UTC 2022 -->
<!--te-->
<h2 id="类型系统分类图"><a class="header" href="#类型系统分类图">类型系统分类图</a></h2>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F.jpg" alt="类型系统分类图" /></p>
<h3 id="三个标准"><a class="header" href="#三个标准">三个标准</a></h3>
<ol>
<li>隐式转换</li>
<li>检查时机</li>
<li>多态支持</li>
</ol>
<h3 id="rust类型系统特点"><a class="header" href="#rust类型系统特点">Rust类型系统特点</a></h3>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F-4257735.jpg" alt="Rust的类型系统有什么特点？" /></p>
<h2 id="类型分类"><a class="header" href="#类型分类">类型分类</a></h2>
<h3 id="原生类型"><a class="header" href="#原生类型">原生类型</a></h3>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F-4257523.jpg" alt="Rust原生类型" /></p>
<h3 id="组合类型"><a class="header" href="#组合类型">组合类型</a></h3>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F-4257587.jpg" alt="Rust组合类型" /></p>
<h3 id="自定义组合类型"><a class="header" href="#自定义组合类型">自定义组合类型</a></h3>
<h2 id="小例子"><a class="header" href="#小例子">小例子</a></h2>
<h3 id="常量"><a class="header" href="#常量">常量</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">const PI: f64 = std::f64::consts::PI;
static E: f32 = std::f32::consts::E;

fn main() {
    const V: u32 = 10;
    static V1: &amp;str = &quot;hello&quot;;
    println!(&quot;PI: {}, E: {}, V {}, V1: {}&quot;, PI, E, V, V1);
}
</code></pre></pre>
<h2 id="类型推导"><a class="header" href="#类型推导">类型推导</a></h2>
<h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<h2 id="实现方式"><a class="header" href="#实现方式">实现方式</a></h2>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F.png" alt="不同语言实现泛型的方式" /></p>
<h2 id="泛型数据结构"><a class="header" href="#泛型数据结构">泛型数据结构</a></h2>
<h3 id="逐步约束把决策交给使用者"><a class="header" href="#逐步约束把决策交给使用者">逐步约束：把决策交给使用者</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use std::fs::File;
use std::io::{BufReader, Read, Result};

struct MyReader&lt;R&gt; {
    reader: R,
    buf: String,
}

impl&lt;R&gt; MyReader&lt;R&gt; {
    pub fn new(reader: R) -&gt; Self {
        Self {
            reader,
            buf: String::with_capacity(1024),
        }
    }
}

impl&lt;R&gt; MyReader&lt;R&gt;
where
    R: Read,
{
    pub fn process(&amp;mut self) -&gt; Result&lt;usize&gt; {
        self.reader.read_to_string(&amp;mut self.buf)
    }
}

fn main() {
    let f = File::open(&quot;/etc/hosts&quot;).unwrap();
    let mut reader = MyReader::new(BufReader::new(f));

    let size = reader.process().unwrap();
    println!(&quot;total size read: {}&quot;, size);
}
</code></pre></pre>
<h2 id="泛型参数"><a class="header" href="#泛型参数">泛型参数</a></h2>
<h3 id="参数多态"><a class="header" href="#参数多态">参数多态</a></h3>
<h3 id="三种使用场景"><a class="header" href="#三种使用场景">三种使用场景</a></h3>
<h4 id="延迟绑定"><a class="header" href="#延迟绑定">延迟绑定</a></h4>
<h4 id="延迟绑定-1"><a class="header" href="#延迟绑定-1">延迟绑定</a></h4>
<h4 id="多个实现"><a class="header" href="#多个实现">多个实现</a></h4>
<h2 id="泛型函数"><a class="header" href="#泛型函数">泛型函数</a></h2>
<h3 id="单态化"><a class="header" href="#单态化">单态化</a></h3>
<blockquote>
<p>对于泛型函数，Rust 会进行单态化（Monomorphization）处理，也就是在编译时，把所有用到的泛型函数的泛型参数展开，生成若干个函数。
所以，下方的 id() 编译后会得到 一个处理后的多个版本</p>
</blockquote>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">fn id&lt;T&gt;(x: T) -&gt; T {
    x
}

fn main() {
    let int = id(42);
    let string = id(&quot;Tyr&quot;);
    println!(&quot;{}, {}&quot;, int, string);
}
</code></pre></pre>
<h4 id="优劣"><a class="header" href="#优劣">优劣</a></h4>
<h3 id="返回值携带泛型参数"><a class="header" href="#返回值携带泛型参数">返回值携带泛型参数</a></h3>
<h1 id="trait"><a class="header" href="#trait">Trait</a></h1>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/13%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F.jpg" alt="trait概览图" /></p>
<h2 id="基本练习"><a class="header" href="#基本练习">基本练习</a></h2>
<h3 id="泛型约束"><a class="header" href="#泛型约束">泛型约束</a></h3>
<h4 id="思考题"><a class="header" href="#思考题">思考题</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">use std::io::{BufWriter, Write};
use std::net::TcpStream;

#[derive(Debug)]
struct MyWriter&lt;W&gt; {
    writer: W,
}

impl&lt;W: Write&gt; MyWriter&lt;W&gt; {
    pub fn new(addr: &amp;str) -&gt; Self {
        let stream = TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap();
        Self {
            writer: BufWriter::new(stream),
        }
    }

    pub fn write(&amp;mut self, buf: &amp;str) -&gt; std::io::Result&lt;()&gt; {
        self.writer.write_all(buf.as_bytes())
    }
}

fn main() {
    let writer = MyWriter::new(&quot;127.0.0.1:8080&quot;);
    writer.write(&quot;hello world!&quot;);
}
</code></pre></pre>
<div id="admonition-分析编译报错原因" class="admonition tip">
<div class="admonition-title">
<p>分析编译报错原因</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-分析编译报错原因"></a></p>
</div>
<div>
<p>主要原因是，实现 new 方法时，对泛型的约束要求要满足 W: Write，而 new 的声明返回值是 Self，也就是说 self.wirter 必须是 W: Write 类型(泛型)，但实际返回值是一个确定的类型 BufWriter<TcpStream>，这不满足要求。</p>
</div>
</div>
<h4 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h4>
<div id="admonition-解决方案梳理" class="admonition info">
<div class="admonition-title">
<p>解决方案梳理</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-解决方案梳理"></a></p>
</div>
<div>
<ol>
<li>修改 new 方法的返回值</li>
<li>对确定的类型 MyWriter&lt;BufWriter<TcpStream>&gt;实现 new 方法</li>
<li>修改 new 方法的实现，使用依赖注入</li>
</ol>
</div>
</div>
<pre><pre class="playground"><code class="language-rust  editable">use std::io::{BufWriter, Write};
use std::net::TcpStream;

#[derive(Debug)]
struct MyWriter&lt;W&gt; {
    writer: W,
}

impl&lt;W: Write&gt; MyWriter&lt;W&gt; {
    pub fn new(writer: W) -&gt; Self {
        Self { writer }
    }

    pub fn write(&amp;mut self, buf: &amp;str) -&gt; std::io::Result&lt;()&gt; {
        self.writer.write_all(buf.as_bytes())
    }
}

fn main() {
    let stream = TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap();

    let mut writer = MyWriter::new(BufWriter::new(stream));
    writer.write(&quot;hello world!&quot;).unwrap();
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">impl MyWriter&lt;BufWriter&lt;TcpStream&gt;&gt; {
    pub fn new(addr: &amp;str) -&gt; Self {
        let stream = TcpStream::connect(addr).unwrap();
        Self {
            writer: BufWriter::new(stream),
        }
    }
}

fn main() {
    let mut writer = MyWriter::new(&quot;127.0.0.1:8080&quot;);
    writer.write(&quot;hello world!&quot;);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;W: Write&gt; MyWriter&lt;W&gt; {
    pub fn new(writer: W) -&gt; Self {
        Self {
            writer,
        }
    }
}

fn main() {
    let stream = TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap();
    let mut writer = MyWriter::new(BufWriter::new(stream));
    writer.write(&quot;hello world!&quot;);
}
</code></pre></pre>
<h3 id="关联类型"><a class="header" href="#关联类型">关联类型</a></h3>
<h3 id="支持泛型"><a class="header" href="#支持泛型">支持泛型</a></h3>
<h3 id="支持继承"><a class="header" href="#支持继承">支持继承</a></h3>
<h3 id="子类型多态"><a class="header" href="#子类型多态">子类型多态</a></h3>
<h2 id="trait-object"><a class="header" href="#trait-object">Trait Object</a></h2>
<h3 id="实现机理ptrvtable"><a class="header" href="#实现机理ptrvtable">实现机理：ptr+vtable</a></h3>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/13%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F-4258625.jpg" alt="13｜类型系统：如何使用trait来定义接口？" /></p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/13%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F-4258661.jpg" alt="13｜类型系统：如何使用trait来定义接口？" /></p>
<h3 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h3>
<h4 id="在函数中使用"><a class="header" href="#在函数中使用">在函数中使用</a></h4>
<h4 id="在函数返回值中使用"><a class="header" href="#在函数返回值中使用">在函数返回值中使用</a></h4>
<h5 id="在数据结构中使用"><a class="header" href="#在数据结构中使用">在数据结构中使用</a></h5>
<h2 id="常用trait"><a class="header" href="#常用trait">常用trait</a></h2>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/14%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84trait%EF%BC%9F.jpg" alt="14｜类型系统：有哪些必须掌握的trait？" /></p>
<h3 id="内存相关"><a class="header" href="#内存相关">内存相关</a></h3>
<h3 id="标签trait"><a class="header" href="#标签trait">标签trait</a></h3>
<h3 id="类型转换-1"><a class="header" href="#类型转换-1">类型转换</a></h3>
<h3 id="操作符相关"><a class="header" href="#操作符相关">操作符相关</a></h3>
<h2 id="设计架构"><a class="header" href="#设计架构">设计架构</a></h2>
<h3 id="顺手自然"><a class="header" href="#顺手自然">顺手自然</a></h3>
<h3 id="桥接"><a class="header" href="#桥接">桥接</a></h3>
<h3 id="控制反转"><a class="header" href="#控制反转">控制反转</a></h3>
<h3 id="solid原则"><a class="header" href="#solid原则">SOLID原则</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iii-数据结构"><a class="header" href="#iii-数据结构">III. 数据结构</a></h1>
<div id="admonition-数据结构快速一览" class="admonition tip">
<div class="admonition-title">
<p>数据结构快速一览</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-数据结构快速一览"></a></p>
</div>
<div>
<blockquote>
<p>用40分钟的时间，总结了Rust的主要数据结构的内 存布局。它能厘清“数据是如何在堆和栈上存储“的思路，在这里也推荐给你。
<a href="https://www.youtube.com/watch?v=rDoqT-a6UFg">Visualizing memory layout of Rust’s data types - YouTube</a></p>
</blockquote>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>.extended-markdown-table {
    display: grid;
}

.extended-markdown-table > div {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 3px 20px;
    border-bottom: 1px solid var(--table-border-color);
    border-right: 1px solid var(--table-border-color);
}

.extended-markdown-table > div.extended-markdown-left-border {
    border-left: 1px solid var(--table-border-color);
}

.extended-markdown-table > div.extended-markdown-header {
    text-align: center;
    background: var(--table-header-bg);
    border-bottom: 1px solid var(--table-header-bg);
    border-right: 1px solid var(--table-header-bg);
    font-weight: bold;
}

.extended-markdown-table > div.extended-markdown-header.extended-markdown-left-border {
    border-left: 1px solid var(--table-header-bg);
}
</style>
<h1 id="iv-宏编程"><a class="header" href="#iv-宏编程">IV 宏编程</a></h1>
<!--ts-->
<ul>
<li><a href="4_macros.html#iv-%E5%AE%8F%E7%BC%96%E7%A8%8B">IV 宏编程</a>
<ul>
<li><a href="4_macros.html#%E8%B5%84%E6%96%99">资料</a></li>
<li><a href="4_macros.html#%E5%AE%8F%E7%9A%84%E5%88%86%E7%B1%BB">宏的分类</a>
<ul>
<li><a href="4_macros.html#%E4%BD%BF%E7%94%A8%E6%B3%B3%E9%81%93%E5%9B%BE">使用泳道图</a></li>
<li><a href="4_macros.html#%E8%A1%A8%E6%A0%BC">表格</a></li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%9A%84%E7%BC%BA%E9%99%B7%E8%80%8C%E5%90%8E%E6%9C%89%E4%BA%86%E8%BF%87%E7%A8%8B%E5%AE%8F">声明宏的缺陷，而后有了过程宏</a></li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8Fdeclarative-macros-macro_rulesbang">声明宏(declarative macros): macro_rules!(bang)</a></li>
<li><a href="4_macros.html#%E8%BF%87%E7%A8%8B%E5%AE%8F%E6%B7%B1%E5%BA%A6%E5%AE%9A%E5%88%B6%E4%B8%8E%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81">过程宏：深度定制与生成代码</a>
<ul>
<li><a href="4_macros.html#%E5%87%BD%E6%95%B0%E5%AE%8F">函数宏</a></li>
<li><a href="4_macros.html#%E5%B1%9E%E6%80%A7%E5%AE%8F">属性宏</a></li>
<li><a href="4_macros.html#%E6%B4%BE%E7%94%9F%E5%AE%8F">派生宏</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F">声明宏</a>
<ul>
<li><a href="4_macros.html#rust%E5%B8%B8%E7%94%A8%E5%A3%B0%E6%98%8E%E5%AE%8F">Rust常用声明宏</a>
<ul>
<li><a href="4_macros.html#println">println!</a></li>
<li><a href="4_macros.html#writeln">writeln!</a></li>
<li><a href="4_macros.html#eprintln">eprintln!</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E7%A4%BA%E4%BE%8B">示例</a>
<ul>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%A4%BA%E6%84%8F%E5%9B%BE">声明宏示意图</a></li>
<li><a href="4_macros.html#macro_rules%E5%AE%9A%E4%B9%89">macro_rules!定义</a></li>
<li><a href="4_macros.html#%E4%BD%BF%E7%94%A8">使用</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%94%A8%E5%88%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B">声明宏用到的参数类型</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E8%BF%87%E7%A8%8B%E5%AE%8F%E6%89%8B%E5%B7%A5%E5%AE%9A%E4%B9%89%E5%9B%BE">过程宏手工定义图</a>
<ul>
<li><a href="4_macros.html#cargotoml%E6%B7%BB%E5%8A%A0proc-macro%E5%A3%B0%E6%98%8E">Cargo.toml添加proc-macro声明</a></li>
</ul>
</li>
<li>[过程函数宏: #[proc_macro]](#过程函数宏-proc_macro)
<ul>
<li><a href="4_macros.html#srclibrs%E5%AE%9A%E4%B9%89%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E5%AE%8F">src/lib.rs:定义过程函数宏</a></li>
<li><a href="4_macros.html#examplesqueryrs%E4%BD%BF%E7%94%A8">examples/query.rs:使用</a></li>
</ul>
</li>
<li>[过程派生宏: /#[proc_macro_devive(DeriveMacroName)]](#过程派生宏-proc_macro_devivederivemacroname)
<ul>
<li><a href="4_macros.html#%E5%B8%B8%E7%94%A8%E6%B4%BE%E7%94%9F%E5%AE%8F">常用派生宏</a>
<ul>
<li>[#[derive(Debug)]](#derivedebug)</li>
</ul>
</li>
<li><a href="4_macros.html#%E5%8E%9F%E5%A7%8B%E5%AE%9E%E7%8E%B0builder%E6%A8%A1%E5%BC%8F">原始实现builder模式</a>
<ul>
<li><a href="4_macros.html#%E6%83%B3%E5%88%B0%E8%BE%BE%E5%88%B0%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E7%9A%84%E6%95%88%E6%9E%9C">想到达到链式调用的效果</a></li>
<li><a href="4_macros.html#%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E5%AE%9A%E4%B9%89">可以这样定义</a></li>
<li><a href="4_macros.html#%E4%BD%86%E6%98%AF%E6%9C%89%E7%82%B9%E7%B9%81%E7%90%90%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9F%E5%AE%8F%E6%B4%BE%E7%94%9F%E5%87%BA%E8%BF%99%E4%BA%9B%E4%BB%A3%E7%A0%81">但是有点繁琐，可以使用派生宏派生出这些代码</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E6%B4%BE%E7%94%9F%E5%AE%8F%E6%80%9D%E8%B7%AF">派生宏思路</a>
<ul>
<li><a href="4_macros.html#%E8%A6%81%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88">要生成的代码模版</a></li>
<li><a href="4_macros.html#%E6%9E%84%E5%BB%BA%E5%AF%B9%E5%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">构建对应数据结构</a></li>
<li><a href="4_macros.html#srclibrs-%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9F%E5%AE%8F%E4%BB%8Etokenstream%E6%8A%BD%E5%8F%96%E5%87%BA%E6%83%B3%E8%A6%81%E7%9A%84%E4%BF%A1%E6%81%AF">src/lib.rs: 使用派生宏从TokenStream抽取出想要的信息</a></li>
<li><a href="4_macros.html#examplesraw_commandrs-%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%B4%BE%E7%94%9F%E5%AE%8F%E6%8A%BD%E5%8F%96">examples/raw_command.rs: 使用这个派生宏抽取</a></li>
<li><a href="4_macros.html#%E8%BF%90%E8%A1%8C%E6%9F%A5%E7%9C%8B%E8%8E%B7%E5%8F%96%E7%9A%84tokenstream">运行，查看获取的TokenStream</a></li>
<li><a href="4_macros.html#srcraw_builderrs-%E4%BD%BF%E7%94%A8anyhow%E4%B8%8Easkama%E6%8A%BD%E5%8F%96tokenstream%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF">src/raw_builder.rs: 使用anyhow与askama抽取TokenStream中的信息</a></li>
<li><a href="4_macros.html#templatesbuilderj2-%E4%B8%8A%E9%9D%A2askama%E7%94%A8%E5%88%B0%E7%9A%84jinja2%E6%A8%A1%E7%89%88">templates/builder.j2: 上面askama用到的jinja2模版</a></li>
<li><a href="4_macros.html#srcraw_builderrs-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%BA%94%E6%8A%BD%E5%8F%96%E6%96%B9%E6%B3%95">src/raw_builder.rs: 实现对应抽取方法</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E4%BD%BF%E7%94%A8synquote%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E6%A8%A1%E7%89%88">使用syn/quote可以不用自己定义模版</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E8%BF%87%E7%A8%8B%E5%B1%9E%E6%80%A7%E5%AE%8F-proc_macro_derivemacro_name-attributesattr_name">过程属性宏: proc_macro_derive(macro_name, attributes(attr_name))</a>
<ul>
<li><a href="4_macros.html#%E4%BD%BF%E7%94%A8synquote%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AE%8F">使用syn/quote定义属性宏</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Wed Sep 28 10:55:09 UTC 2022 -->
<!--te-->
<h2 id="资料"><a class="header" href="#资料">资料</a></h2>
<ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html">宏 - Rust 程序设计语言 简体中文版</a></li>
<li><a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/reference/macros-by-example.html">Macros By Example - The Rust Reference</a></li>
</ul>
<h2 id="宏的分类"><a class="header" href="#宏的分类">宏的分类</a></h2>
<h3 id="使用泳道图"><a class="header" href="#使用泳道图">使用泳道图</a></h3>
<figure><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="2887px" preserveAspectRatio="none" style="width:943px;height:2887px;background:#FFFFFF;" version="1.1" viewBox="0 0 943 2887" width="943px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="42.5938" id="_title" style="stroke:none;stroke-width:1.0;" width="192" x="374" y="15"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="98" x="421" y="32.9951">两类四种宏对比</text><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="182" x="379" y="49.292">（具体内容看详细版泳道图）</text><rect fill="none" height="20.9531" style="stroke:none;stroke-width:1.0;" width="910" x="15" y="66.3389"/><ellipse cx="128.5" cy="320.167" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="131" x="63" y="350.167"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="107" x="77" y="371.3057">基于TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="73" y="385.2744">定义过程函数宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="88.5" y="418.1045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="98.5" y="439.2432">打开过程宏</text><ellipse cx="128.5" cy="699.9482" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="215" x="21" y="729.9482"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="191" x="35" y="751.0869">手工抽取TokenStream定义派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="86.5" y="783.917"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="100.5" y="805.0557">打开过程宏</text><ellipse cx="128.5" cy="1461.167" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="193" x="32" y="1491.167"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="169" x="46" y="1512.3057">syn/quote抽取TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="42" y="1526.2744">为DeriveInput定义派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="86.5" y="1559.1045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="100.5" y="1580.2432">打开过程宏</text><ellipse cx="128.5" cy="2126.5107" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="193" x="32" y="2156.5107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="169" x="46" y="2177.6494">syn/quote抽取TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="42" y="2191.6182">为DeriveInput定义属性宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="86.5" y="2224.4482"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="100.5" y="2245.5869">打开过程宏</text><line style="stroke:#000000;stroke-width:1.5;" x1="15" x2="15" y1="66.3389" y2="2875.667"/><rect fill="#FAEBD7" height="2809.3281" style="stroke:#FAEBD7;stroke-width:1.0;" width="318" x="240" y="66.3389"/><rect fill="#F1F1F1" height="85.875" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="307" x="246" y="837.8857"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="287" x="256" y="859.0244">使用anyhow与askama抽取TokenStream中的信息</text><line style="stroke:#181818;stroke-width:1.0;" x1="246" x2="553" y1="866.8545" y2="866.8545"/><line style="stroke:#181818;stroke-width:1.0;" x1="246" x2="553" y1="868.8545" y2="868.8545"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="182" x="256" y="882.9932">1. 分别定义BuilderContext和Fd</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="228" x="256" y="896.9619">2. BuilderContext处理jinja模版数据结构</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="105" x="256" y="910.9307">3. Fd描述每个field</text><rect fill="#AAAAAA" height="75.875" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="145" x="327" y="943.7607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="125" x="337" y="964.8994">templates/builder.j2</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="4" x="337" y="978.8682"> </text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="116" x="337" y="992.8369">编写与tokenstream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="93" x="337" y="1006.8057">对应的jinja2模版</text><rect fill="#F1F1F1" height="169.6875" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="227" x="286" y="1039.6357"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="296" y="1060.7744">实现对应抽取方法</text><line style="stroke:#181818;stroke-width:1.0;" x1="286" x2="513" y1="1068.6045" y2="1068.6045"/><line style="stroke:#181818;stroke-width:1.0;" x1="286" x2="513" y1="1070.6045" y2="1070.6045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="194" x="296" y="1084.7432">1. Fd实现new方法处理TokenTree</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="191" x="296" y="1098.7119">2. BuilderContext实现下列方法：</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="37" x="296" y="1112.6807">- new:</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="175" x="328" y="1126.6494">从 TokenStream 中提取信息，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="119" x="328" y="1140.6182">构建 BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="54" x="296" y="1154.5869">- render:</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="165" x="328" y="1168.5557">把jinja2模版渲染成字符串代码</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="142" x="328" y="1182.5244">&gt; render里面用到split和</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="127" x="344" y="1196.4932">get_struct_fields方法</text><rect fill="#F1F1F1" height="57.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="273" x="263" y="1613.0732"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="253" x="273" y="1634.2119">使用syn与quote抽取 TokenStream中的信息</text><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="1642.042" y2="1642.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="1644.042" y2="1644.042"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="182" x="273" y="1658.1807">1. 同样定义BuilderContext和Fd</text><rect fill="#F1F1F1" height="183.6563" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="219" x="290" y="1691.0107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108" x="300" y="1712.1494">不需要自己手动定义</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132" x="300" y="1726.1182">抽取模版，直接实现方法</text><line style="stroke:#181818;stroke-width:1.0;" x1="290" x2="509" y1="1733.9482" y2="1733.9482"/><line style="stroke:#181818;stroke-width:1.0;" x1="290" x2="509" y1="1735.9482" y2="1735.9482"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="191" x="300" y="1750.0869">1. 比起手动方式，BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="162" x="316" y="1764.0557">和Fd还需要实现From Trait。</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="187" x="300" y="1778.0244">2. 接着Fd就不需要再处理，主要在</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="91" x="316" y="1791.9932">BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="179" x="300" y="1805.9619">3. BuilderContext实现下列方法</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="124" x="316" y="1819.9307">- render: 用到quote!</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="183" x="316" y="1833.8994">- gen_optionized_fields(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="135" x="316" y="1847.8682">- gen_methods(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="128" x="316" y="1861.8369">- gen_assigns(&amp;self)</text><rect fill="#F1F1F1" height="71.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="273" x="263" y="2278.417"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="253" x="273" y="2299.5557">使用syn与quote抽取 TokenStream中的信息</text><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="2307.3857" y2="2307.3857"/><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="2309.3857" y2="2309.3857"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="199" x="273" y="2323.5244">1. 定义Opts、Fd、BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="240" x="273" y="2337.4932">2. 比起派生宏，多了Opts用于捕获Fd的属性</text><rect fill="#F1F1F1" height="155.7188" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="250" x="274.5" y="2370.3232"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="284.5" y="2391.4619">不需要自己手动定</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132" x="284.5" y="2405.4307">抽取模版，直接实现方法</text><line style="stroke:#181818;stroke-width:1.0;" x1="274.5" x2="524.5" y1="2413.2607" y2="2413.2607"/><line style="stroke:#181818;stroke-width:1.0;" x1="274.5" x2="524.5" y1="2415.2607" y2="2415.2607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="230" x="284.5" y="2429.3994">1. 和派生宏一样，给Fd、BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="150" x="300.5" y="2443.3682">和Fd还需要实现From Trait</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="215" x="284.5" y="2457.3369">2. BuilderContext同样实现下列方法：</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="124" x="300.5" y="2471.3057">- render: 用到quote!</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="183" x="300.5" y="2485.2744">- gen_optionized_fields(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="135" x="300.5" y="2499.2432">- gen_methods(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="128" x="300.5" y="2513.2119">- gen_assigns(&amp;self)</text><line style="stroke:#000000;stroke-width:1.5;" x1="240" x2="240" y1="66.3389" y2="2875.667"/><ellipse cx="652" cy="102.292" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="612" y="132.292"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="622" y="153.4307">定义声明宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="612" y="472.0732"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="622" y="493.2119">定义过程宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="600" y="1229.3232"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="610" y="1250.4619">定义过程派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="600" y="1894.667"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="610" y="1915.8057">定义过程派生宏</text><rect fill="#F1F1F1" height="151.75" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="176" x="564" y="2546.042"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="574" y="2567.1807">定义过程派生宏</text><line style="stroke:#181818;stroke-width:1.0;" x1="564" x2="740" y1="2575.0107" y2="2575.0107"/><line style="stroke:#181818;stroke-width:1.0;" x1="564" x2="740" y1="2577.0107" y2="2577.0107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="574" y="2591.1494">和派生宏不同的是</text><line style="stroke:#181818;stroke-width:1.0;" x1="564" x2="740" y1="2598.9795" y2="2598.9795"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72" x="574" y="2615.1182">这里多了一个</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="155" x="574" y="2629.0869">attributes(builder) 属性，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="574" y="2643.0557">这是告诉编译器，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108" x="574" y="2657.0244">请允许代码中出现的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="12" x="574" y="2670.9932">1.</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="87" x="590" y="2670.9932">[builder(...)]，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="156" x="574" y="2684.9619">它是我这个宏认识并要处理的</text><line style="stroke:#000000;stroke-width:1.5;" x1="558" x2="558" y1="66.3389" y2="2875.667"/><rect fill="#F1F1F1" height="71.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="127" x="771" y="186.2607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="781" y="207.3994">使用声明宏</text><line style="stroke:#181818;stroke-width:1.0;" x1="771" x2="898" y1="215.2295" y2="215.2295"/><line style="stroke:#181818;stroke-width:1.0;" x1="771" x2="898" y1="217.2295" y2="217.2295"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="107" x="781" y="231.3682">没有TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="48" x="781" y="245.3369">难以调试</text><ellipse cx="834.5" cy="289.167" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="289.167" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="794.5" y="526.042"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="804.5" y="547.1807">使用过程宏</text><rect fill="#F1F1F1" height="57.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="163" x="753" y="580.0107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="763" y="601.1494">Terminal</text><line style="stroke:#181818;stroke-width:1.0;" x1="753" x2="916" y1="608.9795" y2="608.9795"/><line style="stroke:#181818;stroke-width:1.0;" x1="753" x2="916" y1="610.9795" y2="610.9795"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="763" y="625.1182">查看打印的TokenStream</text><ellipse cx="834.5" cy="668.9482" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="668.9482" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="782.5" y="1283.292"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="792.5" y="1304.4307">使用派生宏抽取</text><rect fill="#F1F1F1" height="61.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="103" x="783" y="1337.2607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="793" y="1358.3994">Terminal</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="793" y="1372.3682">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="83" x="793" y="1386.3369">TokenStream</text><ellipse cx="834.5" cy="1430.167" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="1430.167" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="782.5" y="1948.6357"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="792.5" y="1969.7744">使用派生宏抽取</text><rect fill="#F1F1F1" height="61.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="91" x="789" y="2002.6045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="799" y="2023.7432">Terminal</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="799" y="2037.7119">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="71" x="799" y="2051.6807">DeriveInput</text><ellipse cx="834.5" cy="2095.5107" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="2095.5107" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="782.5" y="2717.792"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="792.5" y="2738.9307">使用派生宏抽取</text><rect fill="#F1F1F1" height="61.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="91" x="789" y="2771.7607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="799" y="2792.8994">Terminal</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="799" y="2806.8682">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="71" x="799" y="2820.8369">DeriveInput</text><ellipse cx="834.5" cy="2864.667" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="2864.667" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><line style="stroke:#000000;stroke-width:1.5;" x1="745" x2="745" y1="66.3389" y2="2875.667"/><line style="stroke:#000000;stroke-width:1.5;" x1="923" x2="923" y1="66.3389" y2="2875.667"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="330.167" y2="350.167"/><polygon fill="#181818" points="124.5,340.167,128.5,350.167,132.5,340.167,128.5,344.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="398.1045" y2="418.1045"/><polygon fill="#181818" points="124.5,408.1045,128.5,418.1045,132.5,408.1045,128.5,412.1045" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="709.9482" y2="729.9482"/><polygon fill="#181818" points="124.5,719.9482,128.5,729.9482,132.5,719.9482,128.5,723.9482" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="763.917" y2="783.917"/><polygon fill="#181818" points="124.5,773.917,128.5,783.917,132.5,773.917,128.5,777.917" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="1471.167" y2="1491.167"/><polygon fill="#181818" points="124.5,1481.167,128.5,1491.167,132.5,1481.167,128.5,1485.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="1539.1045" y2="1559.1045"/><polygon fill="#181818" points="124.5,1549.1045,128.5,1559.1045,132.5,1549.1045,128.5,1553.1045" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="2136.5107" y2="2156.5107"/><polygon fill="#181818" points="124.5,2146.5107,128.5,2156.5107,132.5,2146.5107,128.5,2150.5107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="2204.4482" y2="2224.4482"/><polygon fill="#181818" points="124.5,2214.4482,128.5,2224.4482,132.5,2214.4482,128.5,2218.4482" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="923.7607" y2="943.7607"/><polygon fill="#181818" points="395.5,933.7607,399.5,943.7607,403.5,933.7607,399.5,937.7607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1019.6357" y2="1039.6357"/><polygon fill="#181818" points="395.5,1029.6357,399.5,1039.6357,403.5,1029.6357,399.5,1033.6357" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1671.0107" y2="1691.0107"/><polygon fill="#181818" points="395.5,1681.0107,399.5,1691.0107,403.5,1681.0107,399.5,1685.0107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="2350.3232" y2="2370.3232"/><polygon fill="#181818" points="395.5,2360.3232,399.5,2370.3232,403.5,2360.3232,399.5,2364.3232" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="112.292" y2="132.292"/><polygon fill="#181818" points="648,122.292,652,132.292,656,122.292,652,126.292" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="258.167" y2="278.167"/><polygon fill="#181818" points="830.5,268.167,834.5,278.167,838.5,268.167,834.5,272.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="560.0107" y2="580.0107"/><polygon fill="#181818" points="830.5,570.0107,834.5,580.0107,838.5,570.0107,834.5,574.0107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="637.9482" y2="657.9482"/><polygon fill="#181818" points="830.5,647.9482,834.5,657.9482,838.5,647.9482,834.5,651.9482" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1317.2607" y2="1337.2607"/><polygon fill="#181818" points="830.5,1327.2607,834.5,1337.2607,838.5,1327.2607,834.5,1331.2607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1399.167" y2="1419.167"/><polygon fill="#181818" points="830.5,1409.167,834.5,1419.167,838.5,1409.167,834.5,1413.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1982.6045" y2="2002.6045"/><polygon fill="#181818" points="830.5,1992.6045,834.5,2002.6045,838.5,1992.6045,834.5,1996.6045" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2064.5107" y2="2084.5107"/><polygon fill="#181818" points="830.5,2074.5107,834.5,2084.5107,838.5,2074.5107,834.5,2078.5107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2751.7607" y2="2771.7607"/><polygon fill="#181818" points="830.5,2761.7607,834.5,2771.7607,838.5,2761.7607,834.5,2765.7607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2833.667" y2="2853.667"/><polygon fill="#181818" points="830.5,2843.667,834.5,2853.667,838.5,2843.667,834.5,2847.667" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="166.2607" y2="171.2607"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="171.2607" y2="171.2607"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="171.2607" y2="186.2607"/><polygon fill="#181818" points="830.5,176.2607,834.5,186.2607,838.5,176.2607,834.5,180.2607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="452.0732" y2="457.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="652" y1="457.0732" y2="457.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="457.0732" y2="472.0732"/><polygon fill="#181818" points="648,462.0732,652,472.0732,656,462.0732,652,466.0732" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="506.042" y2="511.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="511.042" y2="511.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="511.042" y2="526.042"/><polygon fill="#181818" points="830.5,516.042,834.5,526.042,838.5,516.042,834.5,520.042" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="817.8857" y2="822.8857"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="399.5" y1="822.8857" y2="822.8857"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="822.8857" y2="837.8857"/><polygon fill="#181818" points="395.5,827.8857,399.5,837.8857,403.5,827.8857,399.5,831.8857" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1209.3232" y2="1214.3232"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="652" y1="1214.3232" y2="1214.3232"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1214.3232" y2="1229.3232"/><polygon fill="#181818" points="648,1219.3232,652,1229.3232,656,1219.3232,652,1223.3232" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1263.292" y2="1268.292"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="1268.292" y2="1268.292"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1268.292" y2="1283.292"/><polygon fill="#181818" points="830.5,1273.292,834.5,1283.292,838.5,1273.292,834.5,1277.292" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="1593.0732" y2="1598.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="399.5" y1="1598.0732" y2="1598.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1598.0732" y2="1613.0732"/><polygon fill="#181818" points="395.5,1603.0732,399.5,1613.0732,403.5,1603.0732,399.5,1607.0732" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1874.667" y2="1879.667"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="652" y1="1879.667" y2="1879.667"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1879.667" y2="1894.667"/><polygon fill="#181818" points="648,1884.667,652,1894.667,656,1884.667,652,1888.667" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1928.6357" y2="1933.6357"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="1933.6357" y2="1933.6357"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1933.6357" y2="1948.6357"/><polygon fill="#181818" points="830.5,1938.6357,834.5,1948.6357,838.5,1938.6357,834.5,1942.6357" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="2258.417" y2="2263.417"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="399.5" y1="2263.417" y2="2263.417"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="2263.417" y2="2278.417"/><polygon fill="#181818" points="395.5,2268.417,399.5,2278.417,403.5,2268.417,399.5,2272.417" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="2526.042" y2="2531.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="652" y1="2531.042" y2="2531.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="2531.042" y2="2546.042"/><polygon fill="#181818" points="648,2536.042,652,2546.042,656,2536.042,652,2540.042" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="2697.792" y2="2702.792"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="2702.792" y2="2702.792"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2702.792" y2="2717.792"/><polygon fill="#181818" points="830.5,2707.792,834.5,2717.792,838.5,2707.792,834.5,2711.792" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="99" x="81" y="83.0469">Cargo.toml</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="281" x="261.5" y="83.0469">src/&lt;对应抽取字段与方法定义&gt;.rs</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="74" x="617.5" y="83.0469">src/lib.rs</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="162" x="756" y="83.0469">examples/调用代码</text></g></svg></figure>
<h3 id="表格"><a class="header" href="#表格">表格</a></h3>
<div class="extended-markdown-table"><div class="extended-markdown-header extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 1; grid-row-end: 2">Macros</div><div class="extended-markdown-header" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2">Define</div><div class="extended-markdown-header" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2">Usage</div><div class="extended-markdown-header" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 1; grid-row-end: 2">note</div><div class="extended-markdown-header" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 1; grid-row-end: 2">Example</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 2; grid-row-end: 3">Declarative Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 2; grid-row-end: 3">#[macro_export]/macro_rules! macro_name{}</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 2; grid-row-end: 3">macro_name!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 2; grid-row-end: 3"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 2; grid-row-end: 3">println!</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 3; grid-row-end: 4">Function Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 3; grid-row-end: 4">#[proc_macros]/pub fn macro_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 3; grid-row-end: 4">macro_name!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 3; grid-row-end: 4">advanced declarative macro</div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 3; grid-row-end: 4"></div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 4; grid-row-end: 5">Derive Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 4; grid-row-end: 5">#[proc_macros_derive(DeriveMacroName)]/pub  fn other_fn_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 4; grid-row-end: 5">DeriveMacroName!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 4; grid-row-end: 5"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 4; grid-row-end: 5">#[derive(Debug)]</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 5; grid-row-end: 6">Attritubte Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 5; grid-row-end: 6">#[proc_macros_derive(AttributeMacroName, attributes(attr_name))]/pub  fn other_fn_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 5; grid-row-end: 6">Only Diff with DeriveMacro when define struct</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 5; grid-row-end: 6"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 5; grid-row-end: 6"></div></div>
<h3 id="声明宏的缺陷而后有了过程宏"><a class="header" href="#声明宏的缺陷而后有了过程宏">声明宏的缺陷，而后有了过程宏</a></h3>
<ul>
<li><a href="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/#limitationsofdeclarativemacros">Macros in Rust: A tutorial with examples - LogRocket Blog</a></li>
</ul>
<div id="admonition-为什么过程宏和声明宏那么像" class="admonition tip">
<div class="admonition-title">
<p>为什么过程宏和声明宏那么像</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-为什么过程宏和声明宏那么像"></a></p>
</div>
<div>
<blockquote>
<p>过程宏的缺陷</p>
</blockquote>
<ol>
<li>缺乏对宏自动完成和扩展的支持 </li>
<li>调试声明性宏很困难 </li>
<li>修改能力有限 </li>
<li>较大的二进制文件 </li>
<li>更长的编译时间（这适用于声明性宏和过程宏）</li>
</ol>
<blockquote>
<p>过程宏是语法树级别的转换
过程宏是宏的更高级版本。过程宏允许你扩展现有的 Rust 语法。它接受任意输入并返回有效的 Rust 代码。 
过程宏是将 TokenStream 作为输入并返回另一个 Token Stream 的函数。过程宏操作输入 TokenStream 以产生输出流。</p>
</blockquote>
</div>
</div>
<h3 id="声明宏declarative-macros-macro_rulesbang"><a class="header" href="#声明宏declarative-macros-macro_rulesbang">声明宏(declarative macros): macro_rules!(bang)</a></h3>
<blockquote>
<p>对代码模版做简单替换
声明宏可以用 macro_rules! 来描述, 如果重复性的代码无法用函数来封装，那么声明宏就是一个好的选择</p>
</blockquote>
<h3 id="过程宏深度定制与生成代码"><a class="header" href="#过程宏深度定制与生成代码">过程宏：深度定制与生成代码</a></h3>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Za411q7LQ">Rust 过程宏(1): 如何硬生生解析和手写过程宏</a></li>
</ul>
<blockquote>
<p>主要以如何使用 function-like macro 在不依赖于 syn / quote 的情况下，把 Json Schema 在编译期转换成 Rust struct。主要目的是让大家熟悉基本的处理 TokenStream 的思路</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Fu411m7W7">Rust 过程宏(2): 使用 syn/quote 撰写过程宏</a></li>
</ul>
<blockquote>
<p>主要通过一个 derive Builder 宏，来展示使用 syn/quote 如何开发过程宏。</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV1dr4y1v74n">Rust 过程宏(3): 使用 darling 处理 attributes</a></li>
</ul>
<blockquote>
<p>做个收尾，对上一讲的 derive macro 支持 attributes。 我们可以直接解析 attributes 相关的 TokenStream，也可以使用 darling 这个很方便的库，直接把 attributes 像
Clap/Structopts 那样收集到一个数据结构中，然后再进一步处理。</p>
</blockquote>
<div id="admonition-总结" class="admonition info">
<div class="admonition-title">
<p>总结</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-总结"></a></p>
</div>
<div>
<p>这三讲的内容虽然简单，但足以应付大家绝大多数宏编程的需求。
其实我们现在对 syn 库的使用还只是一个皮毛，我们还没有深入
去撰写自己的数据结构去实现 Parse trait，像 DeriveInput 
那样可以直接把 TokenStream 转换成我们想要的东西。</p>
<p>大家感兴趣的话，可以自行去看 syn 库的文档。</p>
</div>
</div>
<h4 id="函数宏"><a class="header" href="#函数宏">函数宏</a></h4>
<p>看起来像函数的宏，但在编译期进行处理.</p>
<blockquote>
<p>sqlx 用函数宏来处理SQL query、tokio使用属性宏 #[tokio::main] 来引入 runtime。
它们可以帮助目标代码的实现逻辑变得更加简单， 但一般除非特别必要，否则并不推荐写。
并没有特定的使用场景</p>
</blockquote>
<h4 id="属性宏"><a class="header" href="#属性宏">属性宏</a></h4>
<p>可以在其他代码块上添加属性，为代码块提供更多功能。</p>
<h4 id="派生宏"><a class="header" href="#派生宏">派生宏</a></h4>
<p>为 derive属性添加新的功能。这是我们平时使用最多的宏，比如 #[derive(Debug)].</p>
<blockquote>
<p>如果你定义的 trait 别人实现起来有固定的模式可循，那么可以考虑为其构建派生宏</p>
</blockquote>
<h2 id="声明宏"><a class="header" href="#声明宏">声明宏</a></h2>
<h3 id="rust常用声明宏"><a class="header" href="#rust常用声明宏">Rust常用声明宏</a></h3>
<h4 id="println"><a class="header" href="#println">println!</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.println.html">println in std - Rust</a></li>
<li><a href="https://blog.csdn.net/jiangjkd/article/details/120994956">Rust声明宏println剖析_一线coder的博客-CSDN博客_rust 声明宏</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
#[allow_internal_unstable(print_internals, format_args_nl)]
macro_rules! println {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ({
        $crate::io::_print($crate::format_args_nl!($($arg)*));
    })
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="writeln"><a class="header" href="#writeln">writeln!</a></h4>
<blockquote>
<p>可以将内容输入到指定文件</p>
</blockquote>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.writeln.html">writeln in std - Rust</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/148945862">rust入门笔记—翻译rust write！宏 - 知乎</a></li>
</ul>
<pre><code class="language-shell">cargo run --example raw_command &gt; examples/raw_command_output.txt
</code></pre>
<h4 id="eprintln"><a class="header" href="#eprintln">eprintln!</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.eprintln.html">eprintln in std - Rust</a></li>
</ul>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<h4 id="声明宏示意图"><a class="header" href="#声明宏示意图">声明宏示意图</a></h4>
<figure><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="633px" preserveAspectRatio="none" style="width:474px;height:633px;background:#FFFFFF;" version="1.1" viewBox="0 0 474 633" width="474px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="26.2969" id="_title" style="stroke:none;stroke-width:1.0;" width="136" x="167.5" y="15"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="126" x="172.5" y="32.9951">声明宏定义使用流程</text><ellipse cx="51" cy="57.2969" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><path d="M101,77.2969 L101,389.9531 L462,389.9531 L462,87.2969 L452,77.2969 L101,77.2969 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M452,77.2969 L452,87.2969 L462,87.2969 L452,77.2969 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="12" x="107" y="94.3638">1.</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="99" x="123" y="94.3638">[macro_export]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="149" x="107" y="109.4966">macro_rules! my_vec {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="299" x="123" y="124.6294">// 没带任何参数的 my_vec，我们创建一个空的 vec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="324" x="123" y="139.7622">// 注意，由于宏要在调用的地方展开，我们无法预测调用</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="316" x="123" y="154.895">// 者的环境是否已经 做了相关的 use，所以我们使用的</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="194" x="123" y="170.0278">// 代码最好带着完整的命名空间。</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="48" x="123" y="185.1606">() =&gt; {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="125" x="139" y="200.2935">std::vec::Vec::new()</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="12" x="123" y="215.4263">};</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="162" x="123" y="230.5591">// 处理 my_vec![1, 2, 3, 4]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="133" x="123" y="245.6919">($($el:expr),*) =&gt; ({</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="139" y="260.8247">let mut v = std::vec::Vec::new();</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="100" x="139" y="275.9575">$(v.push($el);)*</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="7" x="139" y="291.0903">v</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="17" x="123" y="306.2231">});</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="138" x="123" y="321.356">// 处理 my_vec![0; 10]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="155" x="123" y="336.4888">($el:expr; $n:expr) =&gt; {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="180" x="139" y="351.6216">std::vec::from_elem($el, $n)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="123" y="366.7544">}</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="107" y="381.8872">}</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="11" y="216.6406"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="21" y="237.7793">定义声明宏</text><path d="M101,399.9531 L101,621.8125 L318,621.8125 L318,409.9531 L308,399.9531 L101,399.9531 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M308,399.9531 L308,409.9531 L318,409.9531 L308,399.9531 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="70" x="107" y="417.02">fn main() {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="144" x="123" y="432.1528">let mut v = my_vec![];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="64" x="123" y="447.2856">v.push(1);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="159" x="123" y="462.4185">// 调用时可以使用 [], (), {}</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="177" x="123" y="477.5513">let _v = my_vec!(1, 2, 3, 4);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="177" x="123" y="492.6841">let _v = my_vec![1, 2, 3, 4];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="180" x="123" y="507.8169">let v = my_vec! {1, 2, 3, 4};</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="522.9497">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="4" x="107" y="538.0825"> </text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="553.2153">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="123" y="568.3481">//</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="146" x="123" y="583.481">let v = my_vec![1; 10];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="598.6138">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="107" y="613.7466">}</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="11" y="493.8984"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="21" y="515.0371">使用声明宏</text><line style="stroke:#181818;stroke-width:1.0;" x1="51" x2="51" y1="67.2969" y2="216.6406"/><polygon fill="#181818" points="47,206.6406,51,216.6406,55,206.6406,51,210.6406" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="51" x2="51" y1="250.6094" y2="493.8984"/><polygon fill="#181818" points="47,483.8984,51,493.8984,55,483.8984,51,487.8984" style="stroke:#181818;stroke-width:1.0;"/></g></svg></figure>
<h4 id="macro_rules定义"><a class="header" href="#macro_rules定义">macro_rules!定义</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">#[macro_export]
macro_rules! my_vec {
    // 没带任何参数的 my_vec，我们创建一个空的 vec
    // 注意，由于宏要在调用的地方展开，我们无法预测调用
    // 者的环境是否已经 做了相关的 use，所以我们使用的
    // 代码最好带着完整的命名空间。
    () =&gt; {
        std::vec::Vec::new()
    };
    // 处理 my_vec![1, 2, 3, 4]
    ($($el:expr),*) =&gt; ({
        let mut v = std::vec::Vec::new();
        $(v.push($el);)*
        v
    });
    // 处理 my_vec![0; 10]
    ($el:expr; $n:expr) =&gt; {
        std::vec::from_elem($el, $n)
    }
}
</code></pre></pre>
<div id="admonition-elexpr-" class="admonition info">
<div class="admonition-title">
<p>$($el:expr), *)</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-elexpr-"></a></p>
</div>
<div>
<ol>
<li>在声明宏中，条件捕获的参数使用 $ 开头的标识符来声明。</li>
<li>每个参数都需要提供类型，这里<code>expr</code>代表表达式，所以 $el:expr 是说把匹配到的表达式命名为 $el。</li>
<li>$(…),* 告诉编译器可以匹配任意多个以逗号分隔的表达式，然后捕获到的每一个表达式可以用 $el 来访问。</li>
<li>由于匹配的时候匹配到一个 $(…)* （我们可以不管分隔符），在执行的代码块中，我们也要相应地使用 $(…)* 展开。</li>
<li>所以这句 $(v.push($el);)* 相当于匹配出多少个 $el就展开多少句 push 语句。</li>
</ol>
</div>
</div>
<h4 id="使用-1"><a class="header" href="#使用-1">使用</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let mut v = my_vec![];
    v.push(1);
    // 调用时可以使用 [], (), {}
    let _v = my_vec!(1, 2, 3, 4);
    let _v = my_vec![1, 2, 3, 4];
    let v = my_vec! {1, 2, 3, 4};
    println!(&quot;{:?}&quot;, v);

    println!(&quot;{:?}&quot;, v);
    //
    let v = my_vec![1; 10];
    println!(&quot;{:?}&quot;, v);
}
</code></pre></pre>
<h3 id="声明宏用到的参数类型"><a class="header" href="#声明宏用到的参数类型">声明宏用到的参数类型</a></h3>
<div id="admonition-类型列表" class="admonition info">
<div class="admonition-title">
<p>类型列表</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-类型列表"></a></p>
</div>
<div>
<ol>
<li>item，比如一个函数、结构体、模块等。 </li>
<li>block，代码块。比如一系列由花括号包裹的表达式和语句。 </li>
<li>stmt，语句。比如一个赋值语句。 </li>
<li>pat，模式。 </li>
<li>expr，表达式。刚才的例子使用过了。 </li>
<li>ty，类型。比如 Vec。 </li>
<li>ident，标识符。比如一个变量名。 </li>
<li>path，路径。比如：foo、::std::mem::replace、transmute::&lt;_, int&gt;。 </li>
<li>meta，元数据。一般是在 #[…] 和 #![…] 属性内部的数据。 </li>
<li>tt，单个的 token 树。 </li>
<li>vis，可能为空的一个 Visibility 修饰符。比如 pub、pub(crate)</li>
</ol>
</div>
</div>
<h2 id="过程宏手工定义图"><a class="header" href="#过程宏手工定义图">过程宏手工定义图</a></h2>
<blockquote>
<p>过程宏要比声明宏要复杂很多，不过无论是哪一种过程宏，本质都是一样的，都涉及要把 <code>输入的 TokenStream</code> 处理成<code>输出的 TokenStream</code>。</p>
</blockquote>
<h3 id="cargotoml添加proc-macro声明"><a class="header" href="#cargotoml添加proc-macro声明">Cargo.toml添加proc-macro声明</a></h3>
<blockquote>
<p>这样，编译器才允许你使用 #[proc_macro] 相关的宏。</p>
</blockquote>
<pre><code class="language-toml  editable">[lib]
proc-macro = true
</code></pre>
<h2 id="过程函数宏-proc_macro"><a class="header" href="#过程函数宏-proc_macro">过程函数宏: #[proc_macro]</a></h2>
<blockquote>
<p>和macro_rules! 功能类似，但更为强大。</p>
</blockquote>
<h3 id="srclibrs定义过程函数宏"><a class="header" href="#srclibrs定义过程函数宏">src/lib.rs:定义过程函数宏</a></h3>
<blockquote>
<p>可以看到，都是处理TokenStream</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">mod builder;
mod builder_with_attr;
mod raw_builder;

use proc_macro::TokenStream;
use raw_builder::BuilderContext;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro]
pub fn query(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    &quot;fn hello() { println!(\&quot;Hello world!\&quot;); }&quot;
        .parse()
        .unwrap()
}

#[proc_macro_derive(RawBuilder)]
pub fn derive_raw_builder(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    BuilderContext::render(input).unwrap().parse().unwrap()
}

#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    println!(&quot;{:#?}&quot;, input);
    builder::BuilderContext::from(input).render().into()
}

#[proc_macro_derive(BuilderWithAttr, attributes(builder))]
pub fn derive_builder_with_attr(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    println!(&quot;{:#?}&quot;, input);
    builder_with_attr::BuilderContext::from(input)
        .render()
        .into()
}
</code></pre></pre>
<div id="admonition-tokenstream" class="admonition info">
<div class="admonition-title">
<p>TokenStream</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-tokenstream"></a></p>
</div>
<div>
<p>使用者可以通过 query!(…) 来调用。我们打印传入的 TokenStream，
然后把一段包含在字符串中的代码解析成 TokenStream 返回。</p>
<p>这里可以非常方便地用字符串的 parse() 方法来获得 TokenStream，
是因为 TokenStream 实现了  FromStr trait。</p>
</div>
</div>
<h3 id="examplesqueryrs使用"><a class="header" href="#examplesqueryrs使用">examples/query.rs:使用</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use macros::query;

fn main() {
    // query!(SELECT * FROM users WHERE age &gt; 10);
    query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id);
    hello()
}
</code></pre></pre>
<ol>
<li>.parse().unwrap(): 字符串自动转为TokenStream类型</li>
</ol>
<pre><code class="language-shell">cargo run --example query &gt; examples/query_output.txt
</code></pre>
<pre><code class="language-shell">TokenStream [
    Ident {
        ident: &quot;SELECT&quot;,
        span: #0 bytes(94..100),
    },
    Punct {
        ch: '*',
        spacing: Alone,
        span: #0 bytes(101..102),
    },
    Ident {
        ident: &quot;FROM&quot;,
        span: #0 bytes(103..107),
    },
    Ident {
        ident: &quot;users&quot;,
        span: #0 bytes(108..113),
    },
    Ident {
        ident: &quot;u&quot;,
        span: #0 bytes(114..115),
    },
    Ident {
        ident: &quot;JOIN&quot;,
        span: #0 bytes(116..120),
    },
    Group {
        delimiter: Parenthesis,
        stream: TokenStream [
            Ident {
                ident: &quot;SELECT&quot;,
                span: #0 bytes(122..128),
            },
            Punct {
                ch: '*',
                spacing: Alone,
                span: #0 bytes(129..130),
            },
            Ident {
                ident: &quot;from&quot;,
                span: #0 bytes(131..135),
            },
            Ident {
                ident: &quot;profiles&quot;,
                span: #0 bytes(136..144),
            },
            Ident {
                ident: &quot;p&quot;,
                span: #0 bytes(145..146),
            },
        ],
        span: #0 bytes(121..147),
    },
    Ident {
        ident: &quot;WHERE&quot;,
        span: #0 bytes(148..153),
    },
    Ident {
        ident: &quot;u&quot;,
        span: #0 bytes(154..155),
    },
    Punct {
        ch: '.',
        spacing: Alone,
        span: #0 bytes(155..156),
    },
    Ident {
        ident: &quot;id&quot;,
        span: #0 bytes(156..158),
    },
    Punct {
        ch: '=',
        spacing: Alone,
        span: #0 bytes(159..160),
    },
    Ident {
        ident: &quot;p&quot;,
        span: #0 bytes(161..162),
    },
    Punct {
        ch: '.',
        spacing: Alone,
        span: #0 bytes(162..163),
    },
    Ident {
        ident: &quot;id&quot;,
        span: #0 bytes(163..165),
    },
]
Hello world!
</code></pre>
<div id="admonition-tokenstream是一个iterator里面包含一系列的tokentree" class="admonition tip">
<div class="admonition-title">
<p>TokenStream是一个Iterator，里面包含一系列的TokenTree</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-tokenstream是一个iterator里面包含一系列的tokentree"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TokenTree {
    // 组，如果代码中包含括号，比如{} [] &lt;&gt; () ，那么内部的内容会被分析成一个Group（组）
    Group(Group), 
    // 标识符
    Ident(Ident),
    // 标点符号 
    Punct(Punct),
    // 字面量 
    Literal(Literal), 
}
<span class="boring">}
</span></code></pre></pre>
</div>
</div>
<div id="admonition-group-example" class="admonition info">
<div class="admonition-title">
<p>Group Example</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-group-example"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust">use macros::query;

fn main() {
    // query!(SELECT * FROM users WHERE age &gt; 10);
    query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id);
    hello()
}
</code></pre></pre>
</div>
</div>
<h2 id="过程派生宏-proc_macro_devivederivemacroname"><a class="header" href="#过程派生宏-proc_macro_devivederivemacroname">过程派生宏: /#[proc_macro_devive(DeriveMacroName)]</a></h2>
<blockquote>
<p>用于结构体（struct）、枚举（enum）、联合（union）类型，可为其实现函数或特征（Trait）</p>
</blockquote>
<h3 id="常用派生宏"><a class="header" href="#常用派生宏">常用派生宏</a></h3>
<h4 id="derivedebug"><a class="header" href="#derivedebug">#[derive(Debug)]</a></h4>
<h3 id="原始实现builder模式"><a class="header" href="#原始实现builder模式">原始实现builder模式</a></h3>
<h4 id="想到达到链式调用的效果"><a class="header" href="#想到达到链式调用的效果">想到达到链式调用的效果</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .current_dir(&quot;..&quot;.to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
    println!(&quot;{:?}&quot;, command);
}
</code></pre></pre>
<h4 id="可以这样定义"><a class="header" href="#可以这样定义">可以这样定义</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 这是command.rs的派生宏实现的代码样子
#[allow(dead_code)]
#[derive(Debug)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}

#[derive(Debug, Default)]
pub struct CommandBuilder {
    executable: Option&lt;String&gt;,
    args: Option&lt;Vec&lt;String&gt;&gt;,
    env: Option&lt;Vec&lt;String&gt;&gt;,
    current_dir: Option&lt;String&gt;,
}

impl Command {
    pub fn builder() -&gt; CommandBuilder {
        Default::default()
    }
}

impl CommandBuilder {
    pub fn executable(mut self, v: String) -&gt; Self {
        self.executable = Some(v.to_owned());
        self
    }

    pub fn args(mut self, v: Vec&lt;String&gt;) -&gt; Self {
        self.args = Some(v.to_owned());
        self
    }

    pub fn env(mut self, v: Vec&lt;String&gt;) -&gt; Self {
        self.env = Some(v.to_owned());
        self
    }

    pub fn current_dir(mut self, v: String) -&gt; Self {
        self.current_dir = Some(v.to_owned());
        self
    }

    pub fn build(mut self) -&gt; Result&lt;Command, &amp;'static str&gt; {
        Ok(Command {
            executable: self.executable.take().ok_or(&quot;executable must be set&quot;)?,
            args: self.args.take().ok_or(&quot;args must be set&quot;)?,
            env: self.env.take().ok_or(&quot;env must be set&quot;)?,
            current_dir: self.current_dir.take(),
        })
    }
</code></pre></pre>
<h4 id="但是有点繁琐可以使用派生宏派生出这些代码"><a class="header" href="#但是有点繁琐可以使用派生宏派生出这些代码">但是有点繁琐，可以使用派生宏派生出这些代码</a></h4>
<h3 id="派生宏思路"><a class="header" href="#派生宏思路">派生宏思路</a></h3>
<h4 id="要生成的代码模版"><a class="header" href="#要生成的代码模版">要生成的代码模版</a></h4>
<p>把输入的 TokenStream 抽取出来，也就是把在 struct 的定义内部，每个域的名字及其类型都抽出来，然后生成对应的方法代码。</p>
<pre><pre class="playground"><code class="language-rust  editable">impl {{ name }} {
    pub fn builder() -&gt; {{ builder_name }} {
        Default::default()
    }
}

#[derive(Debug, Default)]
pub struct {{ builder_name }} {
    {% for field in fields %}
        {{ field.name }}: Option&lt;{{ field.ty }}&gt;,
    {% endfor %}
}

impl {{ builder_name }} {
    {% for field in fields %}
    pub fn {{ field.name }}(mut self, v: impl Into&lt;{{ field.ty }}&gt;) -&gt; {{ builder_name }} {
        self.{{ field.name }} = Some(v.into());
        self
    }
    {% endfor %}

    pub fn build(self) -&gt; Result&lt;{{ name }}, &amp;'static str&gt; {
        Ok({{ name }} {
            {% for field in fields %}
                {% if field.optional %}
                {{ field.name }}: self.{{ field.name }},
                {% else %}
                {{ field.name }}: self.{{ field.name }}.ok_or(&quot;Build failed: missing {{ field.name }}&quot;)?,
                {% endif %}
            {% endfor %}
        })
    }
}
</code></pre></pre>
<ol>
<li>7-12: 这里的 fileds / builder_name 是我们要传入的参数，每个 field 还需要 name 和 ty 两个 属性，分别对应 field 的名字和类型</li>
<li>25-26: 对于原本是 Option<T> 类型的域，要避免生成 Option<Option>，我们需要把是否是 Option 单独抽取出来，如果是 Option<T>，那么 ty 就是 T。所以，field 还需要一个属 性
optional。</li>
</ol>
<h4 id="构建对应数据结构"><a class="header" href="#构建对应数据结构">构建对应数据结构</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 处理 jinja 模板的数据结构，在模板中我们使用了 name / builder_name / fields
#[derive(Template)]
#[template(path = &quot;builder.j2&quot;, escape = &quot;none&quot;)]
pub struct BuilderContext {
    name: String,
    builder_name: String,
    fields: Vec&lt;Fd&gt;,
}
</code></pre></pre>
<h4 id="srclibrs-使用派生宏从tokenstream抽取出想要的信息"><a class="header" href="#srclibrs-使用派生宏从tokenstream抽取出想要的信息">src/lib.rs: 使用派生宏从TokenStream抽取出想要的信息</a></h4>
<blockquote>
<p>对于 derive macro，要使用 proce_macro_derive 这个宏。我们把这个 derive macro 命名为 Builder。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">#[proc_macro_derive(RawBuilder)]
pub fn derive_raw_builder(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    BuilderContext::render(input).unwrap().parse().unwrap()
}
</code></pre></pre>
<h4 id="examplesraw_commandrs-使用这个派生宏抽取"><a class="header" href="#examplesraw_commandrs-使用这个派生宏抽取">examples/raw_command.rs: 使用这个派生宏抽取</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">use macros::RawBuilder;

#[allow(dead_code)]
#[derive(Debug, RawBuilder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}

fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .current_dir(&quot;..&quot;.to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
    println!(&quot;{:?}&quot;, command);
}
</code></pre></pre>
<h4 id="运行查看获取的tokenstream"><a class="header" href="#运行查看获取的tokenstream">运行，查看获取的TokenStream</a></h4>
<pre><code class="language-shell">cargo run --example raw_command &gt; examples/raw_command_output.txt
</code></pre>
<pre><code class="language-shell">TokenStream [
    Punct {
        ch: '#',
        spacing: Alone,
        span: #0 bytes(25..26),
    },
    Group {
        delimiter: Bracket,
        stream: TokenStream [
            Ident {
                ident: &quot;allow&quot;,
                span: #0 bytes(27..32),
            },
            Group {
                delimiter: Parenthesis,
                stream: TokenStream [
                    Ident {
                        ident: &quot;dead_code&quot;,
                        span: #0 bytes(33..42),
                    },
                ],
                span: #0 bytes(32..43),
            },
        ],
        span: #0 bytes(26..44),
    },
    Ident {
        ident: &quot;pub&quot;,
        span: #0 bytes(74..77),
    },
    Ident {
        ident: &quot;struct&quot;,
        span: #0 bytes(78..84),
    },
    Ident {
        ident: &quot;Command&quot;,
        span: #0 bytes(85..92),
    },
    Group {
        delimiter: Brace,
        stream: TokenStream [
            Ident {
                ident: &quot;executable&quot;,
                span: #0 bytes(99..109),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(109..110),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(111..117),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(117..118),
            },
            Ident {
                ident: &quot;args&quot;,
                span: #0 bytes(123..127),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(127..128),
            },
            Ident {
                ident: &quot;Vec&quot;,
                span: #0 bytes(129..132),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(132..133),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(133..139),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(139..140),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(140..141),
            },
            Ident {
                ident: &quot;env&quot;,
                span: #0 bytes(146..149),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(149..150),
            },
            Ident {
                ident: &quot;Vec&quot;,
                span: #0 bytes(151..154),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(154..155),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(155..161),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(161..162),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(162..163),
            },
            Ident {
                ident: &quot;current_dir&quot;,
                span: #0 bytes(168..179),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(179..180),
            },
            Ident {
                ident: &quot;Option&quot;,
                span: #0 bytes(181..187),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(187..188),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(188..194),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(194..195),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(195..196),
            },
        ],
        span: #0 bytes(93..198),
    },
]
Command { executable: &quot;cargo&quot;, args: [&quot;build&quot;, &quot;--release&quot;], env: [], current_dir: Some(&quot;..&quot;) }
</code></pre>
<div id="admonition-打印信息说明" class="admonition info">
<div class="admonition-title">
<p>打印信息说明</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-打印信息说明"></a></p>
</div>
<div>
<ol>
<li>
<p>首先有一个 Group，包含了 #[allow(dead_code)] 属性的信息。因为我们现在拿到 的 derive 下的信息，所以所有不属于 #[derive(…)] 的属性，都会被放入 TokenStream 中。</p>
</li>
<li>
<p>之后是 pub / struct / Command 三个 ident。</p>
</li>
<li>
<p>随后又是一个 Group，包含了每个 field 的信息。我们看到，field 之间用逗号这个 Punct 分隔，field 的名字和类型又是通过冒号这个 Punct 分隔。而类型，可能是一个 Ident，如 String，或者一系列 Ident / Punct，如 Vec / &lt; / String / &gt;。</p>
</li>
</ol>
</div>
</div>
<h4 id="srcraw_builderrs-使用anyhow与askama抽取tokenstream中的信息"><a class="header" href="#srcraw_builderrs-使用anyhow与askama抽取tokenstream中的信息">src/raw_builder.rs: 使用anyhow与askama抽取TokenStream中的信息</a></h4>
<blockquote>
<p>我们要做的就是，把这个 TokenStream 中的 struct 名字，以及每个 field 的名字和类型拿出来。
如果类型是 Option<T>，那么把 T 拿出来，把 optional 设置为 true。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">use anyhow::Result;
use askama::Template;
use proc_macro::{Ident, TokenStream, TokenTree};
use std::collections::VecDeque;

/// 处理 jinja 模板的数据结构，在模板中我们使用了 name / builder_name / fields
#[derive(Template)]
#[template(path = &quot;builder.j2&quot;, escape = &quot;none&quot;)]
pub struct BuilderContext {
    name: String,
    builder_name: String,
    fields: Vec&lt;Fd&gt;,
}

/// 描述 struct 的每个 field
#[derive(Debug, Default)]
struct Fd {
    name: String,
    ty: String,
    optional: bool,
}
</code></pre></pre>
<h4 id="templatesbuilderj2-上面askama用到的jinja2模版"><a class="header" href="#templatesbuilderj2-上面askama用到的jinja2模版">templates/builder.j2: 上面askama用到的jinja2模版</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">impl {{ name }} {
    pub fn builder() -&gt; {{ builder_name }} {
        Default::default()
    }
}

#[derive(Debug, Default)]
pub struct {{ builder_name }} {
    {% for field in fields %}
        {{ field.name }}: Option&lt;{{ field.ty }}&gt;,
    {% endfor %}
}

impl {{ builder_name }} {
    {% for field in fields %}
    pub fn {{ field.name }}(mut self, v: impl Into&lt;{{ field.ty }}&gt;) -&gt; {{ builder_name }} {
        self.{{ field.name }} = Some(v.into());
        self
    }
    {% endfor %}

    pub fn build(self) -&gt; Result&lt;{{ name }}, &amp;'static str&gt; {
        Ok({{ name }} {
            {% for field in fields %}
                {% if field.optional %}
                {{ field.name }}: self.{{ field.name }},
                {% else %}
                {{ field.name }}: self.{{ field.name }}.ok_or(&quot;Build failed: missing {{ field.name }}&quot;)?,
                {% endif %}
            {% endfor %}
        })
    }
}
</code></pre></pre>
<h4 id="srcraw_builderrs-实现对应抽取方法"><a class="header" href="#srcraw_builderrs-实现对应抽取方法">src/raw_builder.rs: 实现对应抽取方法</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">impl Fd {
    /// name 和 field 都是通过冒号 Punct 切分出来的 TokenTree 切片
    pub fn new(name: &amp;[TokenTree], ty: &amp;[TokenTree]) -&gt; Self {
        // 把类似 Ident(&quot;Option&quot;), Punct('&lt;'), Ident(&quot;String&quot;), Punct('&gt;) 的 ty
        // 收集成一个 String 列表，如 vec![&quot;Option&quot;, &quot;&lt;&quot;, &quot;String&quot;, &quot;&gt;&quot;]
        let ty = ty
            .iter()
            .map(|v| match v {
                TokenTree::Ident(n) =&gt; n.to_string(),
                TokenTree::Punct(p) =&gt; p.as_char().to_string(),
                e =&gt; panic!(&quot;Expect ident, got {:?}&quot;, e),
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();
        // 冒号前最后一个 TokenTree 是 field 的名字
        // 比如：executable: String,
        // 注意这里不应该用 name[0]，因为有可能是 pub executable: String
        // 甚至，带 attributes 的 field，
        // 比如：#[builder(hello = world)] pub executable: String
        match name.last() {
            Some(TokenTree::Ident(name)) =&gt; {
                // 如果 ty 第 0 项是 Option，那么从第二项取到倒数第一项
                // 取完后上面的例子中的 ty 会变成 [&quot;String&quot;]，optiona = true
                let (ty, optional) = if ty[0].as_str() == &quot;Option&quot; {
                    (&amp;ty[2..ty.len() - 1], true)
                } else {
                    (&amp;ty[..], false)
                };
                Self {
                    name: name.to_string(),
                    ty: ty.join(&quot;&quot;), // 把 ty join 成字符串
                    optional,
                }
            }
            e =&gt; panic!(&quot;Expect ident, got {:?}&quot;, e),
        }
    }
}

impl BuilderContext {
    /// 从 TokenStream 中提取信息，构建 BuilderContext
    fn new(input: TokenStream) -&gt; Self {
        let (name, input) = split(input);
        let fields = get_struct_fields(input);
        Self {
            builder_name: format!(&quot;{}Builder&quot;, name),
            name: name.to_string(),
            fields,
        }
    }

    /// 把模板渲染成字符串代码
    pub fn render(input: TokenStream) -&gt; Result&lt;String&gt; {
        let template = Self::new(input);
        Ok(template.render()?)
    }
}

/// 把 TokenStream 分出 struct 的名字，和包含 fields 的 TokenStream
fn split(input: TokenStream) -&gt; (Ident, TokenStream) {
    let mut input = input.into_iter().collect::&lt;VecDeque&lt;_&gt;&gt;();
    // 一直往后找，找到 struct 停下来
    while let Some(item) = input.pop_front() {
        if let TokenTree::Ident(v) = item {
            if v.to_string() == &quot;struct&quot; {
                break;
            }
        }
    }

    // struct 后面，应该是 struct name
    let ident;
    if let Some(TokenTree::Ident(v)) = input.pop_front() {
        ident = v;
    } else {
        panic!(&quot;Didn't find struct name&quot;);
    }

    // struct 后面可能还有若干 TokenTree，我们不管，一路找到第一个 Group
    let mut group = None;
    for item in input {
        if let TokenTree::Group(g) = item {
            group = Some(g);
            break;
        }
    }

    (ident, group.expect(&quot;Didn't find field group&quot;).stream())
}

/// 从包含 fields 的 TokenStream 中切出来一个个 Fd
fn get_struct_fields(input: TokenStream) -&gt; Vec&lt;Fd&gt; {
    let input = input.into_iter().collect::&lt;Vec&lt;_&gt;&gt;();
    input
        .split(|v| match v {
            // 先用 ',' 切出来一个个包含 field 所有信息的 &amp;[TokenTree]
            TokenTree::Punct(p) =&gt; p.as_char() == ',',
            _ =&gt; false,
        })
        .map(|tokens| {
            tokens
                .split(|v| match v {
                    // 再用 ':' 把 &amp;[TokenTree] 切成 [&amp;[TokenTree], &amp;[TokenTree]]
                    // 它们分别对应名字和类型
                    TokenTree::Punct(p) =&gt; p.as_char() == ':',
                    _ =&gt; false,
                })
                .collect::&lt;Vec&lt;_&gt;&gt;()
        })
        // 正常情况下，应该得到 [&amp;[TokenTree], &amp;[TokenTree]]，对于切出来长度不为 2 的统统过滤掉
        .filter(|tokens| tokens.len() == 2)
        // 使用 Fd::new 创建出每个 Fd
        .map(|tokens| Fd::new(tokens[0], tokens[1]))
        .collect()
}
</code></pre></pre>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-tip"></a></p>
</div>
<div>
<p>可以对着打印出来的 TokenStream 和刚才的分析进行理解。
核心的就是 get_struct_fields() 方法，如果觉得难懂，
可以想想如果要把一个 a=1,b=2 的字符串切成 [[a, 1], [b, 2]] 该怎么做，就很容易理解了。</p>
</div>
</div>
<h3 id="使用synquote可以不用自己定义模版"><a class="header" href="#使用synquote可以不用自己定义模版">使用syn/quote可以不用自己定义模版</a></h3>
<blockquote>
<p>详见上方对比图</p>
</blockquote>
<h2 id="过程属性宏-proc_macro_derivemacro_name-attributesattr_name"><a class="header" href="#过程属性宏-proc_macro_derivemacro_name-attributesattr_name">过程属性宏: proc_macro_derive(macro_name, attributes(attr_name))</a></h2>
<blockquote>
<p>用于属性宏， 用在结构体、字段、函数等地方，为其指定属性等功能, 类似python的计算属性</p>
</blockquote>
<div id="admonition-定义结构体时在某个字段上方使用对应attr_name" class="admonition tip">
<div class="admonition-title">
<p>定义结构体时在某个字段上方使用对应attr_name</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-定义结构体时在某个字段上方使用对应attr_name"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(dead_code)]
#[derive(Debug, BuilderWithAttr)]
pub struct Command {
    executable: String,
    #[builder(each = &quot;arg&quot;)]
    args: Vec&lt;String&gt;,
    #[builder(each = &quot;env&quot;, default = &quot;vec![]&quot;)]
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</div>
</div>
<h3 id="使用synquote定义属性宏"><a class="header" href="#使用synquote定义属性宏">使用syn/quote定义属性宏</a></h3>
<blockquote>
<p>详见上方对比图</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v-并发与异步"><a class="header" href="#v-并发与异步">V 并发与异步</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vi-混合编程"><a class="header" href="#vi-混合编程">VI 混合编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kv-server设计与实现"><a class="header" href="#kv-server设计与实现">KV Server设计与实现</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构建自己的类axum异步web框架"><a class="header" href="#构建自己的类axum异步web框架">构建自己的类axum异步Web框架</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checklist"><a class="header" href="#checklist">Checklist</a></h1>

            </main>

            <!--            <script src="https://utteranc.es/client.js"-->
            <!--                    repo="RustMagazine/rust_magazine_2022"-->
            <!--                    issue-term="title"-->
            <!--                    theme="github-light"-->
            <!--                    crossorigin="anonymous"-->
            <!--                    async></script>-->

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->


                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">

    </nav>

</div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/mermaid/mermaid.min.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid-init.js"></script>
    <script type="text/javascript" src="assets/smart-anchor.js"></script>
    <script type="text/javascript" src="assets/pagetoc/sidebar.js"></script>

        <script type="text/javascript">
            window.addEventListener('load', function () {
                MathJax.Hub.Register.StartupHook('End', function () {
                    window.setTimeout(window.print, 100);
                });
            });
        </script>
</body>
</html>
