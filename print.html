<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Anatomy In First Rust Programming Class 🦀</title>
        <meta name="robots" content="noindex"/>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust编程第一课的代码为例进行基础代码分析">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="md-favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/pagetoc/pagetoc_style.css">
        <link rel="stylesheet" href="assets/css/mdbook-admonish.css">

        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="anatomy_logic.html"><strong aria-hidden="true">1.</strong> 源码阅读逻辑</a></li><li class="chapter-item expanded "><a href="intro_gdb_lldb.html"><strong aria-hidden="true">2.</strong> gdb/lldb调试或查看内存结构</a></li><li class="chapter-item expanded "><a href="get_hands_dirty.html"><strong aria-hidden="true">3.</strong> get hands dirty</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="httpie.html"><strong aria-hidden="true">3.1.</strong> httpie</a></li><li class="chapter-item expanded "><a href="rgrep.html"><strong aria-hidden="true">3.2.</strong> rgrep</a></li><li class="chapter-item expanded "><a href="thumbor.html"><strong aria-hidden="true">3.3.</strong> thumbor</a></li><li class="chapter-item expanded "><a href="queryer.html"><strong aria-hidden="true">3.4.</strong> queryer</a></li></ol></li><li class="chapter-item expanded "><a href="rust_cores.html"><strong aria-hidden="true">4.</strong> Rust核心深入</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_stack_heap_ownership_lifetime_memory.html"><strong aria-hidden="true">4.1.</strong> I. 从栈堆、所有权、生命周期开始内存管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="1_1_stack_heap.html"><strong aria-hidden="true">4.1.1.</strong> 从堆栈开始</a></li><li class="chapter-item "><a href="1_2_programming_basic_concepts.html"><strong aria-hidden="true">4.1.2.</strong> 四大编程基础概念</a></li><li class="chapter-item "><a href="1_3_ownership.html"><strong aria-hidden="true">4.1.3.</strong> 所有权</a></li><li class="chapter-item "><a href="1_4_lifetime.html"><strong aria-hidden="true">4.1.4.</strong> 生命周期</a></li><li class="chapter-item "><a href="1_5_go_through.html"><strong aria-hidden="true">4.1.5.</strong> 从创建到消亡</a></li></ol></li><li class="chapter-item expanded "><a href="2_type_system.html"><strong aria-hidden="true">4.2.</strong> II. 类型系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2_1_type_details.html"><strong aria-hidden="true">4.2.1.</strong> 类型系统特点</a></li><li class="chapter-item "><a href="2_2_generic.html"><strong aria-hidden="true">4.2.2.</strong> 泛型</a></li><li class="chapter-item "><a href="2_3_trait.html"><strong aria-hidden="true">4.2.3.</strong> trait</a></li></ol></li><li class="chapter-item expanded "><a href="3_data_structure.html"><strong aria-hidden="true">4.3.</strong> III. 数据结构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="3_1_smart_pointer.html"><strong aria-hidden="true">4.3.1.</strong> 智能指针</a></li><li class="chapter-item "><a href="3_2_containers.html"><strong aria-hidden="true">4.3.2.</strong> 集合容器</a></li><li class="chapter-item "><a href="3_3_error_handling.html"><strong aria-hidden="true">4.3.3.</strong> 错误处理</a></li><li class="chapter-item "><a href="3_4_closure.html"><strong aria-hidden="true">4.3.4.</strong> 闭包</a></li></ol></li><li class="chapter-item expanded "><a href="4_macros.html"><strong aria-hidden="true">4.4.</strong> IV. 宏编程</a></li><li class="chapter-item expanded "><a href="5_concurrency_async.html"><strong aria-hidden="true">4.5.</strong> V. 并发与异步</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="5_1_concurrency_primitives.html"><strong aria-hidden="true">4.5.1.</strong> 并发原语(Concurrency Primitives)</a></li><li class="chapter-item "><a href="5_2_future_async_await.html"><strong aria-hidden="true">4.5.2.</strong> 异步：Future/Async/Await</a></li><li class="chapter-item "><a href="5_3_deepin_async_await.html"><strong aria-hidden="true">4.5.3.</strong> 深入async/await</a></li></ol></li><li class="chapter-item expanded "><a href="6_unsafe_ffi.html"><strong aria-hidden="true">4.6.</strong> VI. 混合编程</a></li></ol></li><li class="chapter-item expanded "><a href="kv_server_design.html"><strong aria-hidden="true">5.</strong> kv server设计与实现</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kv1_basic.html"><strong aria-hidden="true">5.1.</strong> 基本流程</a></li><li class="chapter-item expanded "><a href="kv2_protocols.html"><strong aria-hidden="true">5.2.</strong> 实现并验证协议层</a></li><li class="chapter-item expanded "><a href="kv3_advanced_traits.html"><strong aria-hidden="true">5.3.</strong> 高级trait改造</a></li><li class="chapter-item expanded "><a href="kv4_network.html"><strong aria-hidden="true">5.4.</strong> 网络处理</a></li><li class="chapter-item expanded "><a href="kv5_network_security.html"><strong aria-hidden="true">5.5.</strong> 网络安全</a></li><li class="chapter-item expanded "><a href="kv6_async_refactor.html"><strong aria-hidden="true">5.6.</strong> 异步改造</a></li><li class="chapter-item expanded "><a href="kv7_big_refactor.html"><strong aria-hidden="true">5.7.</strong> 重大重构</a></li><li class="chapter-item expanded "><a href="kv8_config_ci_cd.html"><strong aria-hidden="true">5.8.</strong> 配置、测试、监控、CI/CD</a></li></ol></li><li class="chapter-item expanded "><a href="custom_axum_async_web_framework.html"><strong aria-hidden="true">6.</strong> 构建自己的类axum异步Web框架</a></li><li class="chapter-item expanded affix "><a href="checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Anatomy In First Rust Programming Class 🦀</h1>
            <h4 class="menu-bar"><a href="https://kuanhsiaokuo.github.io/think-tool-kit/">保持批判，有所取舍，知行合一, 方见真我</a> -- 练武不练功
                到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/geektime-tyr-rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="源码解析逻辑"><a class="header" href="#源码解析逻辑">源码解析逻辑</a></h1>
<!--ts-->
<ul>
<li><a href="anatomy_logic.html#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E9%80%BB%E8%BE%91">源码解析逻辑</a>
<ul>
<li><a href="anatomy_logic.html#%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3">项目文档</a>
<ul>
<li><a href="anatomy_logic.html#%E6%9D%A5%E6%BA%90">来源</a></li>
<li><a href="anatomy_logic.html#cargo-doc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8">cargo doc命令使用</a>
<ul>
<li><a href="anatomy_logic.html#--open">–open</a></li>
<li><a href="anatomy_logic.html#--no-deps">–no-deps</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB">使用区别</a></li>
<li><a href="anatomy_logic.html#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82">使用细节</a>
<ul>
<li><a href="anatomy_logic.html#crates">Crates</a></li>
<li><a href="anatomy_logic.html#crate%E5%8C%85%E5%90%AB%E6%88%90%E5%91%98">crate包含成员</a></li>
<li><a href="anatomy_logic.html#re-exports">Re-exports</a></li>
<li><a href="anatomy_logic.html#modules">Modules</a></li>
<li><a href="anatomy_logic.html#macros">Macros</a></li>
<li><a href="anatomy_logic.html#derive-macros">Derive Macros</a></li>
<li><a href="anatomy_logic.html#attribute-macros">Attribute Macros</a></li>
<li><a href="anatomy_logic.html#structs">Structs</a>
<ul>
<li><a href="anatomy_logic.html#definition">Definition</a></li>
<li><a href="anatomy_logic.html#associated-types">Associated Types</a></li>
<li><a href="anatomy_logic.html#implementations">Implementations</a></li>
<li><a href="anatomy_logic.html#trait-implementations">Trait Implementations</a></li>
<li><a href="anatomy_logic.html#auto-trait-implementations">Auto Trait Implementations</a></li>
<li><a href="anatomy_logic.html#blanket-implementations">Blanket Implementations</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#enums">Enums</a>
<ul>
<li><a href="anatomy_logic.html#definition-1">Definition</a></li>
<li><a href="anatomy_logic.html#variants">Variants</a></li>
<li><a href="anatomy_logic.html#trait-implementations-1">Trait Implementations</a></li>
<li><a href="anatomy_logic.html#auto-trait-implementations-1">Auto Trait Implementations</a></li>
<li><a href="anatomy_logic.html#blanket-implementations-1">Blanket Implementations</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#constants">Constants</a></li>
<li><a href="anatomy_logic.html#traits">Traits</a>
<ul>
<li><a href="anatomy_logic.html#definition-2">Definition</a></li>
<li><a href="anatomy_logic.html#required-methods">Required methods</a></li>
<li><a href="anatomy_logic.html#implementations-on-foreign-types">Implementations on Foreign Types</a></li>
<li><a href="anatomy_logic.html#implementors">Implementors</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#functions">Functions</a>
<ul>
<li><a href="anatomy_logic.html#definition-3">Definition</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#type-definitions">Type Definitions</a>
<ul>
<li><a href="anatomy_logic.html#definition-4">Definition</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:25 UTC 2022 -->
<!--te-->
<h2 id="项目文档"><a class="header" href="#项目文档">项目文档</a></h2>
<h3 id="来源"><a class="header" href="#来源">来源</a></h3>
<ol>
<li>第三方crate可以在<a href="https://docs.rs/">官方文档</a>上面搜索</li>
<li>本地crate可以使用命令<code>cargo doc --open</code>.</li>
</ol>
<h3 id="cargo-doc命令使用"><a class="header" href="#cargo-doc命令使用">cargo doc命令使用</a></h3>
<blockquote>
<p><a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html">更多内容</a></p>
</blockquote>
<h4 id="open"><a class="header" href="#open">–open</a></h4>
<p>自动生成文档并在浏览器打开</p>
<h4 id="no-deps"><a class="header" href="#no-deps">–no-deps</a></h4>
<p>默认情况下会把项目依赖的包文档也生成，这也是文档左侧Crates的来源之一。
这个参数可以屏蔽掉依赖的crates</p>
<h3 id="使用区别"><a class="header" href="#使用区别">使用区别</a></h3>
<ol>
<li>二者内容没有区别，官方文档也是执行命令生成文档。</li>
<li>官方文档还可以提供很多细节，比如git分支地址</li>
</ol>
<h3 id="使用细节"><a class="header" href="#使用细节">使用细节</a></h3>
<blockquote>
<p>这里按照文档的层级进行递进说明</p>
</blockquote>
<h4 id="crates"><a class="header" href="#crates">Crates</a></h4>
<p>所有文档的首页都会有这一项，列出项目包含的crate</p>
<h4 id="crate包含成员"><a class="header" href="#crate包含成员">crate包含成员</a></h4>
<blockquote>
<p>点击Crates下的某个crate，右侧页面就会显示当前crate包含的元素， 主要有下列内容</p>
</blockquote>
<ul>
<li>Re-exports</li>
<li>Modules</li>
<li>Macros</li>
<li>Derive Macros</li>
<li>Attribute Macros</li>
<li>Structs</li>
<li>Enums</li>
<li>Constants</li>
<li>Traits</li>
<li>Functions</li>
<li>Type Definitions</li>
</ul>
<h4 id="re-exports"><a class="header" href="#re-exports">Re-exports</a></h4>
<blockquote>
<p>futures_util</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use reader::DecompressorCustomIo;
<span class="boring">}
</span></code></pre></pre>
<h4 id="modules"><a class="header" href="#modules">Modules</a></h4>
<p>其实就是mod，点击之后将会列出某个mod里面的成员</p>
<h4 id="macros"><a class="header" href="#macros">Macros</a></h4>
<h4 id="derive-macros"><a class="header" href="#derive-macros">Derive Macros</a></h4>
<blockquote>
<p>darling_macro、clap_derive</p>
</blockquote>
<h4 id="attribute-macros"><a class="header" href="#attribute-macros">Attribute Macros</a></h4>
<blockquote>
<p>tokio_macros、futures_macro</p>
</blockquote>
<h4 id="structs"><a class="header" href="#structs">Structs</a></h4>
<h5 id="definition"><a class="header" href="#definition">Definition</a></h5>
<h5 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h5>
<h5 id="implementations"><a class="header" href="#implementations">Implementations</a></h5>
<h5 id="trait-implementations"><a class="header" href="#trait-implementations">Trait Implementations</a></h5>
<h5 id="auto-trait-implementations"><a class="header" href="#auto-trait-implementations">Auto Trait Implementations</a></h5>
<h5 id="blanket-implementations"><a class="header" href="#blanket-implementations">Blanket Implementations</a></h5>
<h4 id="enums"><a class="header" href="#enums">Enums</a></h4>
<h5 id="definition-1"><a class="header" href="#definition-1">Definition</a></h5>
<h5 id="variants"><a class="header" href="#variants">Variants</a></h5>
<h5 id="trait-implementations-1"><a class="header" href="#trait-implementations-1">Trait Implementations</a></h5>
<h5 id="auto-trait-implementations-1"><a class="header" href="#auto-trait-implementations-1">Auto Trait Implementations</a></h5>
<h5 id="blanket-implementations-1"><a class="header" href="#blanket-implementations-1">Blanket Implementations</a></h5>
<h4 id="constants"><a class="header" href="#constants">Constants</a></h4>
<h4 id="traits"><a class="header" href="#traits">Traits</a></h4>
<h5 id="definition-2"><a class="header" href="#definition-2">Definition</a></h5>
<h5 id="required-methods"><a class="header" href="#required-methods">Required methods</a></h5>
<h5 id="implementations-on-foreign-types"><a class="header" href="#implementations-on-foreign-types">Implementations on Foreign Types</a></h5>
<h5 id="implementors"><a class="header" href="#implementors">Implementors</a></h5>
<h4 id="functions"><a class="header" href="#functions">Functions</a></h4>
<h5 id="definition-3"><a class="header" href="#definition-3">Definition</a></h5>
<h4 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h4>
<h5 id="definition-4"><a class="header" href="#definition-4">Definition</a></h5>
<blockquote>
<p>html2md</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type BoxedError = Box&lt;dyn Error + Send + Sync&gt;;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gdblldb调试或查看内存结构"><a class="header" href="#gdblldb调试或查看内存结构">gdb/lldb调试或查看内存结构</a></h1>
<!--ts-->
<ul>
<li><a href="intro_gdb_lldb.html#gdblldb%E8%B0%83%E8%AF%95%E6%88%96%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">gdb/lldb调试或查看内存结构</a></li>
<li><a href="intro_gdb_lldb.html#gdblldb">gdb/lldb</a>
<ul>
<li><a href="intro_gdb_lldb.html#%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86">资料整理</a>
<ul>
<li><a href="intro_gdb_lldb.html#%E5%AE%98%E6%96%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84cheat-sheet">官方数据结构cheat sheet</a></li>
<li><a href="intro_gdb_lldb.html#gdb%E5%BC%BA%E5%8C%96%E6%8F%92%E4%BB%B6">gdb强化插件</a></li>
<li><a href="intro_gdb_lldb.html#gdb-%E4%B8%BB%E8%A6%81%E6%98%AFlinux%E7%B3%BB%E7%BB%9F">gdb: 主要是linux系统</a></li>
<li><a href="intro_gdb_lldb.html#lldb-%E4%B8%BB%E8%A6%81osx%E7%B3%BB%E7%BB%9F">lldb: 主要OSX系统</a></li>
<li><a href="intro_gdb_lldb.html#idea">IDEA</a></li>
<li><a href="intro_gdb_lldb.html#gdb%E4%B8%8Elldb%E5%91%BD%E4%BB%A4%E5%AF%B9%E7%85%A7">gdb与lldb命令对照</a></li>
</ul>
</li>
<li><a href="intro_gdb_lldb.html#%E6%9F%A5%E7%9C%8Bhashmap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">查看hashmap内存结构</a>
<ul>
<li><a href="intro_gdb_lldb.html#%E4%BD%BF%E7%94%A8gdblldb%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">使用gdb/lldb进行调试查看内存结构</a></li>
</ul>
</li>
<li><a href="intro_gdb_lldb.html#%E6%9F%A5%E7%9C%8B%E9%97%AD%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84">查看闭包的结构</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:27 UTC 2022 -->
<!--te-->
<h1 id="gdblldb"><a class="header" href="#gdblldb">gdb/lldb</a></h1>
<h2 id="资料整理"><a class="header" href="#资料整理">资料整理</a></h2>
<h3 id="官方数据结构cheat-sheet"><a class="header" href="#官方数据结构cheat-sheet">官方数据结构cheat sheet</a></h3>
<ul>
<li><a href="https://cheats.rs/#data-layout">Rust Language Cheat Sheet</a></li>
</ul>
<h3 id="gdb强化插件"><a class="header" href="#gdb强化插件">gdb强化插件</a></h3>
<details id="admonition-介绍与截图" class="admonition info">
<summary class="admonition-title">
<p>介绍与截图 </p>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-介绍与截图"></a></p>
</summary>
<div>
<ul>
<li><a href="https://github.com/cyrus-and/gdb-dashboard">cyrus-and/gdb-dashboard: Modular visual interface for GDB in Python</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wiki/cyrus-and/gdb-dashboard/Screenshot.png" alt="" /></p>
</div>
</details>
<h3 id="gdb-主要是linux系统"><a class="header" href="#gdb-主要是linux系统">gdb: 主要是linux系统</a></h3>
<h3 id="lldb-主要osx系统"><a class="header" href="#lldb-主要osx系统">lldb: 主要OSX系统</a></h3>
<h3 id="idea"><a class="header" href="#idea">IDEA</a></h3>
<details id="admonition--idea自带的调试界面同时包含lldb更好的界面功能" class="admonition info">
<summary class="admonition-title">
<blockquote>
<p>IDEA自带的调试界面同时包含lldb更好的界面功能。 </p>
</blockquote>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition--idea自带的调试界面同时包含lldb更好的界面功能"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/CleanShot%202022-09-18%20at%2021.24.12%402x.png" alt="CleanShot 2022-09-18 at 21.24.12@2x" /></p>
</div>
</details>
<h3 id="gdb与lldb命令对照"><a class="header" href="#gdb与lldb命令对照">gdb与lldb命令对照</a></h3>
<details id="admonition-gdb与lldb命令对照" class="admonition info">
<summary class="admonition-title">
<p>gdb与lldb命令对照 </p>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-gdb与lldb命令对照"></a></p>
</summary>
<div>
<ul>
<li><a href="https://lldb.llvm.org/use/map.html">GDB to LLDB command map — The LLDB Debugger</a></li>
</ul>
</div>
</details>
<h2 id="查看hashmap内存结构"><a class="header" href="#查看hashmap内存结构">查看hashmap内存结构</a></h2>
<details id="admonition-1-bin配置与运行" class="admonition note">
<summary class="admonition-title">
<ol>
<li>bin配置与运行 </li>
</ol>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-1-bin配置与运行"></a></p>
</summary>
<div>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html?highlight=bin#binaries">Cargo Targets - The Cargo Book</a></li>
</ul>
<pre><code class="language-toml">[package]
name = &quot;hashtable&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[[bin]]
name = &quot;hashmap1&quot;
path = &quot;src/hashmap1.rs&quot;

[[bin]]
name = &quot;hashmap2&quot;
path = &quot;src/hashmap2.rs&quot;

[[bin]]
name = &quot;hash&quot;
path = &quot;src/hash.rs&quot;

[[bin]]
name = &quot;siphasher&quot;
path = &quot;src/siphasher.rs&quot;
doc = false

[[bin]]
name = &quot;hashmap3&quot;
path = &quot;src/hashmap3.rs&quot;

[[bin]]
name = &quot;btreemap1&quot;
path = &quot;src/btreemap1.rs&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<blockquote>
<p>如果要单独运行指定bin文件：</p>
</blockquote>
<pre><code class="language-shell">cargo run --bin hashmap2
</code></pre>
</div>
</details>
<details id="admonition-2-目标调试代码" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>目标调试代码 </li>
</ol>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-2-目标调试代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::collections::HashMap;

fn main() {
    let map = HashMap::new();
    let mut map = explain(&quot;empty&quot;, map);

    map.insert('a', 1);
    let mut map = explain(&quot;added 1&quot;, map);
    map.insert('b', 2);
    map.insert('c', 3);

    let mut map = explain(&quot;added 3&quot;, map);

    map.insert('d', 4);

    let mut map = explain(&quot;added 4&quot;, map);

    map.remove(&amp;'a');

    explain(&quot;final&quot;, map);
}

// HashMap 结构有两个 u64 的 RandomState，然后是四个 usize，
// 分别是 bucket_mask, ctrl, growth_left 和 items
// 我们 transmute 打印之后，再 transmute 回去
fn explain&lt;K, V&gt;(name: &amp;str, map: HashMap&lt;K, V&gt;) -&gt; HashMap&lt;K, V&gt; {
    let arr: [usize; 6] = unsafe { std::mem::transmute(map) };
    println!(
        &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
        name, arr[2], arr[3], arr[4], arr[5]
    );
    unsafe { std::mem::transmute(arr) }
}
</code></pre></pre>
</div>
</details>
<h3 id="使用gdblldb进行调试查看内存结构"><a class="header" href="#使用gdblldb进行调试查看内存结构">使用gdb/lldb进行调试查看内存结构</a></h3>
<details id="admonition-1-开始调试" class="admonition note">
<summary class="admonition-title">
<ol>
<li>开始调试 </li>
</ol>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-1-开始调试"></a></p>
</summary>
<div>
<pre><code class="language-shell">rust-lldb target/debug/hashmap2                                                                                                                  ─╯
(lldb) command script import &quot;/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_lookup.py&quot;
(lldb) command source -s 0 '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'
Executing commands in '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'.
(lldb) type synthetic add -l lldb_lookup.synthetic_lookup -x &quot;.*&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)String$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?str$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?\\[.+\\]$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::ffi::([a-z_]+::)+)OsString$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Vec&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)VecDeque&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Rc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Arc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Cell&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Ref&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefMut&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefCell&lt;.+&gt;$&quot; --category Rust
(lldb) type category enable Rust
(lldb) target create &quot;target/debug/hashmap2&quot;
Current executable set to '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/hashmap2' (x86_64).
(lldb)
</code></pre>
</div>
</details>
<details id="admonition-2-breakpoint-添加断点" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>b(reakpoint): 添加断点 </li>
</ol>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-2-breakpoint-添加断点"></a></p>
</summary>
<div>
<blockquote>
<p>在32行打断点，方便看std::mem::transmute(arr)</p>
</blockquote>
<pre><code class="language-shell">(lldb) b hashmap2.rs:32
Breakpoint 1: where = hashmap2`hashmap2::explain::h4091c852f38a0de4 + 406 at hashmap2.rs:32:34, address = 0x0000000100008d16
</code></pre>
</div>
</details>
<details id="admonition-3-run运行到断点" class="admonition note">
<summary class="admonition-title">
<ol start="3">
<li>r(un):运行到断点 </li>
</ol>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-3-run运行到断点"></a></p>
</summary>
<div>
<pre><code class="language-shell">(lldb) r
Process 69337 launched: '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/hashmap2' (x86_64)
empty: bucket_mask 0x0, ctrl 0x100043d20, growth_left: 0, items: 0
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;empty&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 最初的状态，哈希表为空
empty: bucket_mask 0x0, ctrl 0x100043d20, growth_left: 0, items: 0
</code></pre>
</div>
</details>
<details id="admonition-4-continue继续单步执行" class="admonition note">
<summary class="admonition-title">
<ol start="4">
<li>c(ontinue):继续单步执行 </li>
</ol>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-4-continue继续单步执行"></a></p>
</summary>
<div>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
added 1: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 2, items: 1
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;added 1&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 插入了一个元素后，bucket 有 4 个（0x3+1），堆地址起始位置 0x600001700160 - 4*8(0x20)
added 1: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 2, items: 1
</code></pre>
</div>
</details>
<details id="admonition-5-x-打印内存地址" class="admonition note">
<summary class="admonition-title">
<ol start="5">
<li>x: 打印内存地址</li>
</ol>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-5-x-打印内存地址"></a></p>
</summary>
<div>
<ul>
<li><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/examine-memory.html">打印内存的值 | 100个gdb小技巧</a></li>
</ul>
<pre><code class="language-shell"># 以12进制打印从内存地址开始的值
(lldb) x/12x 0x600001700160
0x600001700160: 0xffff6dff 0xffffffff 0xffffffff 0xffffffff
0x600001700170: 0xffff6dff 0x00000000 0x00000000 0x00000000
0x600001700180: 0x20ec913f 0x00007ff8 0x4e5ef01e 0x00000000
</code></pre>
</div>
</details>
<details id="admonition-5-continue-继续执行到下一个断点" class="admonition note">
<summary class="admonition-title">
<ol start="5">
<li>c(ontinue): 继续执行到下一个断点 </li>
</ol>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-5-continue-继续执行到下一个断点"></a></p>
</summary>
<div>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
added 3: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 0, items: 3
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;added 3&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># # 插入了三个元素后，哈希表没有剩余空间，堆地址起始位置不变 0x600001700160 - 4*8(0x20)
added 3: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 0, items: 3
</code></pre>
<pre><code class="language-shell">(lldb) x/12x 0x600001700160
0x600001700160: 0x16ff6d66 0xffffffff 0xffffffff 0xffffffff
0x600001700170: 0x16ff6d66 0x00000000 0x00000000 0x00000000
0x600001700180: 0x20ec913f 0x00007ff8 0x4e5ef01e 0x00000000
</code></pre>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
added 4: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 3, items: 4
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;added 4&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 插入第四个元素后，哈希表扩容，堆地址起始位置变为 0x600002604040 - 8*8(0x40)
added 4: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 3, items: 4
</code></pre>
<pre><code class="language-shell">(lldb) x/12x 0x600002604040
0x600002604040: 0x16446d66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x16446d66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
(lldb) x/20x 0x600002604040
0x600002604040: 0x16446d66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x16446d66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604070: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604080: 0x00000000 0x00000000 0x00000000 0x00000000
</code></pre>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
final: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 4, items: 3
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;final&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 删除 a 后，剩余 4 个位置。注意 ctrl bit 的变化，以及 0x61 0x1 并没有被清除
final: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 4, items: 3
</code></pre>
<pre><code class="language-shell">(lldb) x/12x 0x600002604040
0x600002604040: 0x1644ff66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x1644ff66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
(lldb) x/20x 0x600002604040
0x600002604040: 0x1644ff66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x1644ff66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604070: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604080: 0x00000000 0x00000000 0x00000000 0x00000000
</code></pre>
</div>
</details>
<h2 id="查看闭包的结构"><a class="header" href="#查看闭包的结构">查看闭包的结构</a></h2>
<details id="admonition-代码" class="admonition note">
<summary class="admonition-title">
<p>代码: </p>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::{collections::HashMap, mem::size_of_val};
fn main() {
    // 长度为 0
    let c1 = || println!(&quot;hello world!&quot;);
    // 和参数无关，长度也为 0
    let c2 = |i: i32| println!(&quot;hello: {}&quot;, i);
    let name = String::from(&quot;tyr&quot;);
    let name1 = name.clone();
    let mut table = HashMap::new();
    table.insert(&quot;hello&quot;, &quot;world&quot;);
    // 如果捕获一个引用，长度为 8
    let c3 = || println!(&quot;hello: {}&quot;, name);
    // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
    let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
    let name2 = name.clone();
    // 和局部变量无关，捕获了一个 String name2，closure 长度 24
    let c5 = move || {
        let x = 1;
        let name3 = String::from(&quot;lindsey&quot;);
        println!(&quot;hello: {}, {:?}, {:?}&quot;, x, name2, name3);
    };

    println!(
        &quot;c1: {}, c2: {}, c3: {}, c4: {}, c5: {}, main: {}&quot;,
        size_of_val(&amp;c1),
        size_of_val(&amp;c2),
        size_of_val(&amp;c3),
        size_of_val(&amp;c4),
        size_of_val(&amp;c5),
        size_of_val(&amp;main),
    )
}
</code></pre></pre>
</div>
</details>
<details id="admonition-运行进入lldb" class="admonition note">
<summary class="admonition-title">
<p>运行进入lldb</p>
<p><a class="admonition-anchor-link" href="intro_gdb_lldb.html#admonition-运行进入lldb"></a></p>
</summary>
<div>
<pre><code class="language-shell"># 自动去examples目录找对应名字的代码文件
cargo run --example closure_size
</code></pre>
<pre><code class="language-shell">rust-lldb ../target/debug/examples/closure_size                                                                                                  ─╯
(lldb) command script import &quot;/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_lookup.py&quot;
(lldb) command source -s 0 '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'
Executing commands in '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'.
(lldb) type synthetic add -l lldb_lookup.synthetic_lookup -x &quot;.*&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)String$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?str$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?\\[.+\\]$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::ffi::([a-z_]+::)+)OsString$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Vec&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)VecDeque&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Rc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Arc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Cell&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Ref&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefMut&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefCell&lt;.+&gt;$&quot; --category Rust
(lldb) type category enable Rust
(lldb) target create &quot;../target/debug/examples/closure_size&quot;
Current executable set to '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/closure_size' (x86_64).
(lldb)
</code></pre>
<pre><code class="language-shell">(lldb) b closure_size.rs:14
Breakpoint 1: where = closure_size`closure_size::main::h679d75437a0cd078 + 199 at closure_size.rs:14:14, address = 0x00000001000056b7
</code></pre>
<pre><code class="language-shell">(lldb) r
Process 95084 launched: '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/closure_size' (x86_64)
Process 95084 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x00000001000056b7 closure_size`closure_size::main::h679d75437a0cd078 at closure_size.rs:14:14
   11       // 如果捕获一个引用，长度为 8
   12       let c3 = || println!(&quot;hello: {}&quot;, name);
   13       // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
-&gt; 14       let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
   15       let name2 = name.clone();
   16       // 和局部变量无关，捕获了一个 String name2，closure 长度 24
   17       let c5 = move || {
Target 0: (closure_size) stopped.
</code></pre>
<pre><code class="language-shell">(lldb) frame variable
(closure_size::main::{closure_env#0}) c1 =
(closure_size::main::{closure_env#1}) c2 =
(alloc::string::String) name = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(alloc::string::String) name1 = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(std::collections::hash::map::HashMap&lt;&amp;str, &amp;str, std::collections::hash::map::RandomState&gt;) table = size=1 {
  [0] = {
    0 = &quot;hello&quot; {
      data_ptr = 0x0000000100043daf &quot;helloworld, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
    1 = &quot;world&quot; {
      data_ptr = 0x0000000100043db4 &quot;world, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
  }
}
(lldb) fr v
(closure_size::main::{closure_env#0}) c1 =
(closure_size::main::{closure_env#1}) c2 =
(alloc::string::String) name = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(alloc::string::String) name1 = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(std::collections::hash::map::HashMap&lt;&amp;str, &amp;str, std::collections::hash::map::RandomState&gt;) table = size=1 {
  [0] = {
    0 = &quot;hello&quot; {
      data_ptr = 0x0000000100043daf &quot;helloworld, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
    1 = &quot;world&quot; {
      data_ptr = 0x0000000100043db4 &quot;world, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
  }
}
</code></pre>
<pre><code class="language-shell">(lldb) x/gx c1
error: memory read failed for 0x0
(lldb) x/gx &amp;c1
0x7ff7bfefed20: 0x0000000100266000
(lldb) x/gx &amp;c2
0x7ff7bfefed28: 0x00006000017041c0
(lldb) x/gx &amp;c3
0x7ff7bfefed90: 0x00007ff7bfefed30
(lldb) x/gx 0x00007ff7bfefed30
0x7ff7bfefed30: 0x0000600000008010
(lldb) x/3c  0x0000600000008010
error: reading memory as characters of size 8 is not supported
(lldb) x/gx  0x0000600000008010
0x600000008010: 0x0000000000727974
</code></pre>
<ul>
<li>g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</li>
<li>可以看出：c1是</li>
</ul>
<pre><code class="language-shell">(lldb) n
Process 95084 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
    frame #0: 0x0000000100005744 closure_size`closure_size::main::h679d75437a0cd078 at closure_size.rs:15:17
   12       let c3 = || println!(&quot;hello: {}&quot;, name);
   13       // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
   14       let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
-&gt; 15       let name2 = name.clone();
   16       // 和局部变量无关，捕获了一个 String name2，closure 长度 24
   17       let c5 = move || {
   18           let x = 1;
Target 0: (closure_size) stopped.
(lldb) x/9gx c4
error: memory read failed for 0x0
(lldb) x/9gx &amp;c4
0x7ff7bfefed98: 0x0000600000008020 0x0000000000000003
0x7ff7bfefeda8: 0x0000000000000003 0x3e49f3270a1a0fb0
0x7ff7bfefedb8: 0x79dd9a78e6c327e7 0x0000000000000003
0x7ff7bfefedc8: 0x0000600003304080 0x0000000000000002
0x7ff7bfefedd8: 0x0000000000000001
(lldb) x/3c 0x0000600000008020
error: reading memory as characters of size 8 is not supported
(lldb) x/gx 0x0000600000008020
0x600000008020: 0x0000000000727974
(lldb) x/18gx 0x0000600000008020 - 0x80
error: memory read takes a start address expression with an optional end address expression.
warning: Expressions should be quoted if they contain spaces or other special characters.
(lldb) x/18gx '0x0000600000008020 - 0x80'
0x600000007fa0: 0x0000000000000000 0x0000000000000000
0x600000007fb0: 0x0000000000000000 0x0000000000000000
0x600000007fc0: 0x0000000000000000 0x0000000000000000
0x600000007fd0: 0x0000000000000000 0x0000000000000000
0x600000007fe0: 0x0000000000000000 0x0000000000000000
0x600000007ff0: 0x0000000000000000 0x0000000000000000
0x600000008000: 0x000000006e69616d 0x0000000000000000
0x600000008010: 0x0000000000727974 0x0000000000000000
0x600000008020: 0x0000000000727974 0x0000000000000000
</code></pre>
<ul>
<li>0x: C语言里的0x0和0x1分别表示十六进制的数的0和1。</li>
</ul>
<p>C语言、C++、Shell、Python、Java语言及其他相近的语言使用字首“0x”，例如“0x5A3”。开头的“0”令解析器更易辨认数，而“x”则代表十六进制（就如“O”代表八进制）。在“0x”中的“x”可以大写或小写。对于字符量C语言中则以x+两位十六进制数的方式表示，如xFF。</p>
<p>因此，0x0中“0x”表示的是十六进制数，0是十六进制数值0，0x,1中“0x”表示的是十六进制数，1是十六进制数值1</p>
<ul>
<li>C语言中的相关数值表示法：</li>
</ul>
<p>1、在C语言里，整数有三种表示形式：十进制，八进制，十六进制。其中以数字0开头，由0~7组成的数是八进制。以0X或0x开头，由0~9，A~F或a~f 组成是十六进制。除表示正负的符号外，以1~9开头，由0~9组成是十进制。</p>
<p>2、十进制：除表示正负的符号外，以1~9开头，由0~9组成。如，128，+234，-278。</p>
<p>3、八进制：以0开头，由0~7组成的数。如，0126,050000.</p>
<p>4、十六进制：以0X或0x开头，由0~9，A~F或a~f 组成。如，0x12A,0x5a000。</p>
</div>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="get-hands-dirty"><a class="header" href="#get-hands-dirty">get hands dirty</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="httpie源码剖析"><a class="header" href="#httpie源码剖析">httpie源码剖析</a></h1>
<!--ts-->
<ul>
<li><a href="httpie.html#httpie%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90">httpie源码剖析</a>
<ul>
<li><a href="httpie.html#example%E7%9A%84%E4%BD%BF%E7%94%A8">example的使用</a></li>
<li><a href="httpie.html#step1%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90">Step1：指令解析</a></li>
<li><a href="httpie.html#step2%E6%B7%BB%E5%8A%A0%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E4%B8%8E%E9%94%AE%E5%80%BC%E5%AF%B9%E6%94%B9%E9%80%A0">Step2：添加参数验证与键值对改造</a></li>
<li><a href="httpie.html#step3%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%94%B9%E9%80%A0">Step3：异步请求改造</a></li>
<li><a href="httpie.html#step4-%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E6%89%93%E5%8D%B0">Step4: 语法高亮打印</a></li>
<li><a href="httpie.html#step5-%E6%B7%BB%E5%8A%A0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">Step5: 添加单元测试</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:26 UTC 2022 -->
<!--te-->
<h2 id="example的使用"><a class="header" href="#example的使用">example的使用</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html?highlight=%5B%5Bexample%5D%5D#examples">Cargo Targets &gt;&gt; Examples - The Cargo Book</a></li>
</ul>
<details id="admonition-cargotoml" class="admonition note">
<summary class="admonition-title">
<p>Cargo.toml </p>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-cargotoml"></a></p>
</summary>
<div>
<pre><code class="language-toml">[package]
name = &quot;httpie&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[[example]]
name = &quot;cli&quot;

[[example]]
name = &quot;cli_verify&quot;

[[example]]
name = &quot;cli_get&quot;

[dependencies]
anyhow = &quot;1&quot; # 错误处理
clap = { version = &quot;3&quot;, features = [&quot;derive&quot;] } # 命令行解析
colored = &quot;2&quot; # 命令终端多彩显示
jsonxf = &quot;1.1&quot; # JSON pretty print 格式化
mime = &quot;0.3&quot; # 处理 mime 类型
# reqwest 默认使用 openssl，有些 linux 用户如果没有安装好 openssl 会无法编译，这里我改成了使用 rustls
reqwest = { version = &quot;0.11&quot;, default-features = false, features = [&quot;json&quot;, &quot;rustls-tls&quot;] } # HTTP 客户端
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] } # 异步处理库
syntect = &quot;4&quot;
</code></pre>
<pre><code class="language-toml">[[example]]
name = &quot;cli&quot;

[[example]]
name = &quot;cli_verify&quot;

[[example]]
name = &quot;cli_get&quot;
</code></pre>
</div>
</details>
<details id="admonition-1-示例代码放在根目录的examples文件夹与src同级" class="admonition note">
<summary class="admonition-title">
<ol>
<li>示例代码放在根目录的examples文件夹，与src同级</li>
</ol>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-1-示例代码放在根目录的examples文件夹与src同级"></a></p>
</summary>
<div>
<pre><code class="language-shell">tree -L 2                                                                                                       ─╯
.
├── Cargo.toml
├── examples
│   ├── cli.rs
│   ├── cli_get.rs
│   └── cli_verify.rs
└── src
    └── main.rs

2 directories, 5 files
</code></pre>
</div>
</details>
<details id="admonition-2-执行指令" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>执行指令 </li>
</ol>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-2-执行指令"></a></p>
</summary>
<div>
<pre><code class="language-shell">cargo run --example &lt;example-name-in-cargo&gt;
cargo run --example cli
cargo run --example cli_get
cargo run --example cli_verify
</code></pre>
</div>
</details>
<details id="admonition-3-使用示例" class="admonition note">
<summary class="admonition-title">
<ol start="3">
<li>使用示例</li>
</ol>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-3-使用示例"></a></p>
</summary>
<div>
<pre><code class="language-shell">cargo run --example cli                                                                                                                                                                                                                ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli`
httpie 1.0
Tyr Chen &lt;tyr@chen.com&gt;
A naive httpie implementation with Rust, can you imagine how easy it is?

USAGE:
    cli &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    get     feed get with an url and we will retrieve the response for you
    help    Print this message or the help of the given subcommand(s)
    post    feed post with an url and optional key=value pairs. We will post the data as JSON,
                and retrieve the response for you
</code></pre>
<ul>
<li>Run a binary or example of the local package</li>
<li>SUBCOMMANDS来自代码中的注释</li>
</ul>
</div>
</details>
<h2 id="step1指令解析"><a class="header" href="#step1指令解析">Step1：指令解析</a></h2>
<details id="admonition-1-源码" class="admonition note">
<summary class="admonition-title">
<ol>
<li>源码 </li>
</ol>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-1-源码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use clap::Parser;

// 定义 httpie 的 CLI 的主入口，它包含若干个子命令
// 下面 /// 的注释是文档，clap 会将其作为 CLI 的帮助

/// A naive httpie implementation with Rust, can you imagine how easy it is?
#[derive(Parser, Debug)]
#[clap(version = &quot;1.0&quot;, author = &quot;Tyr Chen &lt;tyr@chen.com&gt;&quot;)]
struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

// 子命令分别对应不同的 HTTP 方法，目前只支持 get / post
#[derive(Parser, Debug)]
enum SubCommand {
    Get(Get),
    Post(Post),
    // 我们暂且不支持其它 HTTP 方法
}

// get 子命令

/// feed get with an url and we will retrieve the response for you
#[derive(Parser, Debug)]
struct Get {
    /// HTTP 请求的 URL
    url: String,
}

// post 子命令。需要输入一个 url，和若干个可选的 key=value，用于提供 json body

/// feed post with an url and optional key=value pairs. We will post the data
/// as JSON, and retrieve the response for you
#[derive(Parser, Debug)]
struct Post {
    /// HTTP 请求的 URL
    url: String,
    /// HTTP 请求的 body
    body: Vec&lt;String&gt;,
}

fn main() {
    let opts: Opts = Opts::parse();
    let opt_subcmd: SubCommand = opts.subcmd;
    // println!(&quot;{:?}&quot;, opts);
    println!(&quot;{:?}&quot;, opt_subcmd);
    // println!(&quot;{:?}&quot;, opts.subcmd);
    // 这里就可以看出，结构体的内在元素使用&quot;.&quot;来获取
    // println!(&quot;{:?}&quot;, opts::subcmd);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-clapparser相关资料" class="admonition info">
<summary class="admonition-title">
<p>clap::Parser相关资料</p>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-clapparser相关资料"></a></p>
</summary>
<div>
<ul>
<li><a href="https://github.com/clap-rs/clap">clap-rs/clap: A full featured, fast Command Line Argument Parser for Rust</a></li>
<li><a href="https://docs.rs/clap/latest/clap/">clap - Rust</a></li>
<li><a href="https://docs.rs/clap/latest/clap/parser/index.html">clap::parser - Rust</a></li>
</ul>
</div>
</details>
<details id="admonition-1-clap的parser派生宏会自动实现parse方法来接收指令参数" class="admonition note">
<summary class="admonition-title">
<ol>
<li>clap的parser派生宏会自动实现parse方法来接收指令参数</li>
</ol>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-1-clap的parser派生宏会自动实现parse方法来接收指令参数"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

// 子命令分别对应不同的 HTTP 方法，目前只支持 get / post
#[derive(Parser, Debug)]
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let opts: Opts = Opts::parse();
    let opt_subcmd: SubCommand = opts.subcmd;
    // println!(&quot;{:?}&quot;, opts);
</code></pre></pre>
</div>
</details>
<details id="admonition-2-运行效果" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>运行效果</li>
</ol>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-2-运行效果"></a></p>
</summary>
<div>
<pre><code class="language-shell">cargo run --example cli get http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                                ─╯
   Compiling httpie v0.1.0 (/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/04_httpie)
    Finished dev [unoptimized + debuginfo] target(s) in 2.31s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli get 'http://jsonplaceholder.typicode.com/posts/2'`
Opts { subcmd: Get(Get { url: &quot;http://jsonplaceholder.typicode.com/posts/2&quot; }) }
</code></pre>
<pre><code class="language-shell">cargo run --example cli post http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                               ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli post 'http://jsonplaceholder.typicode.com/posts/2'`
Opts { subcmd: Post(Post { url: &quot;http://jsonplaceholder.typicode.com/posts/2&quot;, body: [] }) }
</code></pre>
<pre><code class="language-shell">cargo run --example cli delete http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                             ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli delete 'http://jsonplaceholder.typicode.com/posts/2'`
error: Found argument 'delete' which wasn't expected, or isn't valid in this context

USAGE:
    cli &lt;SUBCOMMAND&gt;

For more information try --help

</code></pre>
<ul>
<li>opts的获取：自动以空格分隔，根据<subcommand>模式匹配，之后的参数依次赋值给<subcommand> struct里面的元素</li>
</ul>
</div>
</details>
<h2 id="step2添加参数验证与键值对改造"><a class="header" href="#step2添加参数验证与键值对改造">Step2：添加参数验证与键值对改造</a></h2>
<details id="admonition-1-参数验证" class="admonition note">
<summary class="admonition-title">
<ol>
<li>参数验证</li>
</ol>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-1-参数验证"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// feed get with an url and we will retrieve the response for you
#[derive(Parser, Debug)]
struct Get {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
}

// post 子命令。需要输入一个 url，和若干个可选的 key=value，用于提供 json body

/// feed post with an url and optional key=value pairs. We will post the data
/// as JSON, and retrieve the response for you
#[derive(Parser, Debug)]
struct Post {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
    /// HTTP 请求的 body
    #[clap(parse(try_from_str=parse_kv_pair))]
    body: Vec&lt;KvPair&gt;,
}
</code></pre></pre>
</div>
</details>
<details id="admonition-clap-允许你为每个解析出来的值添加自定义的解析函数我们这里定义了parse_url和parse_kv_pair检查一下" class="admonition note">
<summary class="admonition-title">
<p>clap 允许你为每个解析出来的值添加自定义的解析函数，我们这里定义了parse_url和parse_kv_pair检查一下。</p>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-clap-允许你为每个解析出来的值添加自定义的解析函数我们这里定义了parse_url和parse_kv_pair检查一下"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 因为我们为 KvPair 实现了 FromStr，这里可以直接 s.parse() 得到 KvPair
fn parse_kv_pair(s: &amp;str) -&gt; Result&lt;KvPair&gt; {
    s.parse()
}
fn parse_url(s: &amp;str) -&gt; Result&lt;String&gt; {
    // 这里我们仅仅检查一下 URL 是否合法
    let _url: Url = s.parse()?;

    Ok(s.into())
}
</code></pre></pre>
</div>
</details>
<details id="admonition-2-键值对改造" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>键值对改造 </li>
</ol>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-2-键值对改造"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 命令行中的 key=value 可以通过 parse_kv_pair 解析成 KvPair 结构
#[allow(dead_code)]
#[derive(Debug)]
struct KvPair {
    k: String,
    v: String,
}

/// 当我们实现 FromStr trait 后，可以用 str.parse() 方法将字符串解析成 KvPair
impl FromStr for KvPair {
    type Err = anyhow::Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        // 使用 = 进行 split，这会得到一个迭代器
        let mut split = s.split('=');
        let err = || anyhow!(format!(&quot;Failed to parse {}&quot;, s));
        Ok(Self {
            // 从迭代器中取第一个结果作为 key，迭代器返回 Some(T)/None
            // 我们将其转换成 Ok(T)/Err(E)，然后用 ? 处理错误
            k: (split.next().ok_or_else(err)?).to_string(),
            // 从迭代器中取第二个结果作为 value
            v: (split.next().ok_or_else(err)?).to_string(),
        })
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="step3异步请求改造"><a class="header" href="#step3异步请求改造">Step3：异步请求改造</a></h2>
<details id="admonition-step3异步请求改造" class="admonition note">
<summary class="admonition-title">
<p>Step3：异步请求改造 </p>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-step3异步请求改造"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let opts: Opts = Opts::parse();
    // 生成一个
    let client = Client::new();
    match opts.subcmd {
        SubCommand::Get(ref args) =&gt; get(client, args).await?,
        SubCommand::Post(ref args) =&gt; post(client, args).await?,
    };

    Ok(())
}

async fn get(client: Client, args: &amp;Get) -&gt; Result&lt;()&gt; {
    let resp = client.get(&amp;args.url).send().await?;
    println!(&quot;{:?}&quot;, resp.text().await?);
    Ok(())
}

async fn post(client: Client, args: &amp;Post) -&gt; Result&lt;()&gt; {
    let mut body = HashMap::new();
    for pair in args.body.iter() {
        body.insert(&amp;pair.k, &amp;pair.v);
    }
    let resp = client.post(&amp;args.url).json(&amp;body).send().await?;
    println!(&quot;{:?}&quot;, resp.text().await?);
    Ok(())
}
</code></pre></pre>
</div>
</details>
<h2 id="step4-语法高亮打印"><a class="header" href="#step4-语法高亮打印">Step4: 语法高亮打印</a></h2>
<details id="admonition-step4-语法高亮打印" class="admonition note">
<summary class="admonition-title">
<p>Step4: 语法高亮打印 </p>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-step4-语法高亮打印"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">// 打印服务器版本号 + 状态码
fn print_status(resp: &amp;Response) {
    let status = format!(&quot;{:?} {}&quot;, resp.version(), resp.status()).blue();
    println!(&quot;{}\n&quot;, status);
}

// 打印服务器返回的 HTTP header
fn print_headers(resp: &amp;Response) {
    for (name, value) in resp.headers() {
        println!(&quot;{}: {:?}&quot;, name.to_string().green(), value);
    }

    println!();
}

/// 打印服务器返回的 HTTP body
fn print_body(m: Option&lt;Mime&gt;, body: &amp;str) {
    match m {
        // 对于 &quot;application/json&quot; 我们 pretty print
        Some(v) if v == mime::APPLICATION_JSON =&gt; print_syntect(body, &quot;json&quot;),
        Some(v) if v == mime::TEXT_HTML =&gt; print_syntect(body, &quot;html&quot;),

        // 其它 mime type，我们就直接输出
        _ =&gt; println!(&quot;{}&quot;, body),
    }
}

/// 打印整个响应
async fn print_resp(resp: Response) -&gt; Result&lt;()&gt; {
    print_status(&amp;resp);
    print_headers(&amp;resp);
    let mime = get_content_type(&amp;resp);
    let body = resp.text().await?;
    print_body(mime, &amp;body);
    Ok(())
}

/// 将服务器返回的 content-type 解析成 Mime 类型
fn get_content_type(resp: &amp;Response) -&gt; Option&lt;Mime&gt; {
    resp.headers()
        .get(header::CONTENT_TYPE)
        .map(|v| v.to_str().unwrap().parse().unwrap())
}

fn print_syntect(s: &amp;str, ext: &amp;str) {
    // Load these once at the start of your program
    let ps = SyntaxSet::load_defaults_newlines();
    let ts = ThemeSet::load_defaults();
    let syntax = ps.find_syntax_by_extension(ext).unwrap();
    let mut h = HighlightLines::new(syntax, &amp;ts.themes[&quot;base16-ocean.dark&quot;]);
    for line in LinesWithEndings::from(s) {
        let ranges: Vec&lt;(Style, &amp;str)&gt; = h.highlight(line, &amp;ps);
        let escaped = as_24_bit_terminal_escaped(&amp;ranges[..], true);
        print!(&quot;{}&quot;, escaped);
    }
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">/// 程序的入口函数，因为在 http 请求时我们使用了异步处理，所以这里引入 tokio
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let opts: Opts = Opts::parse();
    let mut headers = header::HeaderMap::new();
    // 为我们的 http 客户端添加一些缺省的 HTTP 头
    headers.insert(&quot;X-POWERED-BY&quot;, &quot;Rust&quot;.parse()?);
    headers.insert(header::USER_AGENT, &quot;Rust Httpie&quot;.parse()?);
    let client = Client::builder()
        .default_headers(headers)
        .build()?;
    let result = match opts.subcmd {
        SubCommand::Get(ref args) =&gt; get(client, args).await?,
        SubCommand::Post(ref args) =&gt; post(client, args).await?,
    };

    Ok(result)
}
</code></pre></pre>
</div>
</details>
<h2 id="step5-添加单元测试"><a class="header" href="#step5-添加单元测试">Step5: 添加单元测试</a></h2>
<details id="admonition-step5-添加单元测试" class="admonition note">
<summary class="admonition-title">
<p>Step5: 添加单元测试 </p>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-step5-添加单元测试"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">// 仅在 cargo test 时才编译
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_url_works() {
        assert!(parse_url(&quot;abc&quot;).is_err());
        assert!(parse_url(&quot;http://abc.xyz&quot;).is_ok());
        assert!(parse_url(&quot;https://httpbin.org/post&quot;).is_ok());
    }

    #[test]
    fn parse_kv_pair_works() {
        assert!(parse_kv_pair(&quot;a&quot;).is_err());
        assert_eq!(
            parse_kv_pair(&quot;a=1&quot;).unwrap(),
            KvPair {
                k: &quot;a&quot;.into(),
                v: &quot;1&quot;.into(),
            }
        );

        assert_eq!(
            parse_kv_pair(&quot;b=&quot;).unwrap(),
            KvPair {
                k: &quot;b&quot;.into(),
                v: &quot;&quot;.into(),
            }
        );
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rgrep"><a class="header" href="#rgrep">rgrep</a></h1>
<!--ts-->
<ul>
<li><a href="rgrep.html#rgrep">rgrep</a>
<ul>
<li><a href="rgrep.html#cargotoml">Cargo.toml</a></li>
<li><a href="rgrep.html#srcerrorrs-thiserror%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2">src/error.rs: thiserror会自动转换</a></li>
<li><a href="rgrep.html#srclibrs%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">src/lib.rs：定义结构体+实现方法+单元测试</a></li>
<li><a href="rgrep.html#srcmainrs">src/main.rs</a></li>
<li><a href="rgrep.html#%E4%BD%BF%E7%94%A8">使用</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:33 UTC 2022 -->
<!--te-->
<h2 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h2>
<details id="admonition-cargotoml" class="admonition note">
<summary class="admonition-title">
<p>Cargo.toml </p>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition-cargotoml"></a></p>
</summary>
<div>
<pre><code class="language-toml">[package]
name = &quot;rgrep&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
anyhow = &quot;1&quot;
clap = { version = &quot;3&quot;, features = [&quot;derive&quot;] }
colored = &quot;2&quot;
glob = &quot;0.3&quot;
itertools = &quot;0.10&quot;
rayon = &quot;1&quot;
regex = &quot;1&quot;
thiserror = &quot;1&quot;
</code></pre>
</div>
</details>
<h2 id="srcerrorrs-thiserror会自动转换"><a class="header" href="#srcerrorrs-thiserror会自动转换">src/error.rs: thiserror会自动转换</a></h2>
<details id="admonition--它们都是需要进行转换的错误thiserror-能够通过宏帮我们完成错误类型的转换" class="admonition note">
<summary class="admonition-title">
<blockquote>
<p>它们都是需要进行转换的错误。thiserror 能够通过宏帮我们完成错误类型的转换。</p>
</blockquote>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition--它们都是需要进行转换的错误thiserror-能够通过宏帮我们完成错误类型的转换"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use thiserror::Error;

#[derive(Error, Debug)]
pub enum GrepError {
    #[error(&quot;Glob pattern error&quot;)]
    GlobPatternError(#[from] glob::PatternError),
    #[error(&quot;Regex pattern error&quot;)]
    RegexPatternError(#[from] regex::Error),
    #[error(&quot;I/O error&quot;)]
    IoError(#[from] std::io::Error),
}
</code></pre></pre>
</div>
</details>
<h2 id="srclibrs定义结构体实现方法单元测试"><a class="header" href="#srclibrs定义结构体实现方法单元测试">src/lib.rs：定义结构体+实现方法+单元测试</a></h2>
<details id="admonition-mod引入与使用" class="admonition note">
<summary class="admonition-title">
<p>mod引入与使用</p>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition-mod引入与使用"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">mod error;
pub use error::GrepError;
</code></pre></pre>
</div>
</details>
<details id="admonition-定义结构体-专门简化复杂类型" class="admonition note">
<summary class="admonition-title">
<p>定义结构体: 专门简化复杂类型</p>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition-定义结构体-专门简化复杂类型"></a></p>
</summary>
<div>
<blockquote>
<p>这里其实就是传入一个指定结构的函数对象</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">/// 定义类型，这样，在使用时可以简化复杂类型的书写
pub type StrategyFn = fn(&amp;Path, &amp;mut dyn BufRead, &amp;Regex, &amp;mut dyn Write) -&gt; Result&lt;(), GrepError&gt;;
</code></pre></pre>
</div>
</details>
<details id="admonition-专门的结合版本grep结构体" class="admonition note">
<summary class="admonition-title">
<p>专门的结合版本grep结构体</p>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition-专门的结合版本grep结构体"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 简化版本的 grep，支持正则表达式和文件通配符
#[derive(Parser, Debug)]
#[clap(version = &quot;1.0&quot;, author = &quot;Tyr Chen &lt;tyr@chen.com&gt;&quot;)]
pub struct GrepConfig {
    /// 用于查找的正则表达式
    pattern: String,
    /// 文件通配符
    glob: String,
}
</code></pre></pre>
</div>
</details>
<details id="admonition-librs-给结构体实现方法" class="admonition note">
<summary class="admonition-title">
<p>lib.rs: 给结构体实现方法</p>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition-librs-给结构体实现方法"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl GrepConfig {
    /// 使用缺省策略来查找匹配
    pub fn match_with_default_strategy(&amp;self) -&gt; Result&lt;(), GrepError&gt; {
        self.match_with(default_strategy)
    }

    /// 使用某个策略函数来查找匹配
    pub fn match_with(&amp;self, strategy: StrategyFn) -&gt; Result&lt;(), GrepError&gt; {
        let regex = Regex::new(&amp;self.pattern)?;
        // 生成所有符合通配符的文件列表
        let files: Vec&lt;_&gt; = glob::glob(&amp;self.glob)?.collect();
        // 并行处理所有文件
        files.into_par_iter().for_each(|v| {
            if let Ok(filename) = v {
                if let Ok(file) = File::open(&amp;filename) {
                    let mut reader = BufReader::new(file);
                    let mut stdout = io::stdout();

                    if let Err(e) = strategy(filename.as_path(), &amp;mut reader, &amp;regex, &amp;mut stdout) {
                        println!(&quot;Internal error: {:?}&quot;, e);
                    }
                }
            }
        });
        Ok(())
    }
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>主要实现两种解析策略：</p>
</blockquote>
<ol>
<li>默认策略：match_with_default_strategy, 使用default_strategy</li>
<li>指定策略：match_with, 使用传入的strategy: StrategyFn</li>
</ol>
<details id="admonition-默认策略--default_strategy" class="admonition note">
<summary class="admonition-title">
<p>默认策略:  default_strategy</p>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition-默认策略--default_strategy"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 缺省策略，从头到尾串行查找，最后输出到 writer
pub fn default_strategy(
    path: &amp;Path,
    reader: &amp;mut dyn BufRead,
    pattern: &amp;Regex,
    writer: &amp;mut dyn Write,
) -&gt; Result&lt;(), GrepError&gt; {
    let matches: String = reader
        .lines()
        .enumerate()
        .map(|(lineno, line)| {
            line.ok()
                .map(|line| {
                    pattern
                        .find(&amp;line)
                        .map(|m| format_line(&amp;line, lineno + 1, m.range()))
                })
                .flatten()
        })
        .filter_map(|v| v.ok_or(()).ok())
        .join(&quot;\n&quot;);

    if !matches.is_empty() {
        writer.write_all(path.display().to_string().green().as_bytes())?;
        writer.write_all(b&quot;\n&quot;)?;
        writer.write_all(matches.as_bytes())?;
        writer.write_all(b&quot;\n&quot;)?;
    }

    Ok(())
}
</code></pre></pre>
</div>
</details>
<details id="admonition-格式化输出" class="admonition note">
<summary class="admonition-title">
<p>格式化输出</p>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition-格式化输出"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 格式化输出匹配的行，包含行号，列号和带有高亮的第一个匹配项
pub fn format_line(line: &amp;str, lineno: usize, range: Range&lt;usize&gt;) -&gt; String {
    let Range { start, end } = range;
    let prefix = &amp;line[..start];
    format!(
        &quot;{0: &gt;6}:{1: &lt;3} {2}{3}{4}&quot;,
        lineno.to_string().blue(),
        // 找到匹配项的起始位置，注意对汉字等非 ascii 字符，我们不能使用 prefix.len()
        // 这是一个 O(n) 的操作，会拖累效率，这里只是为了演示的效果
        (prefix.chars().count() + 1).to_string().cyan(),
        prefix,
        &amp;line[start..end].red(),
        &amp;line[end..]
    )
}
</code></pre></pre>
</div>
</details>
<details id="admonition-单元测试" class="admonition note">
<summary class="admonition-title">
<p>单元测试 </p>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition-单元测试"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn format_line_should_work() {
        let result = format_line(&quot;Hello, Tyr~&quot;, 1000, 7..10);
        let expected = format!(
            &quot;{0: &gt;6}:{1: &lt;3} Hello, {2}~&quot;,
            &quot;1000&quot;.blue(),
            &quot;8&quot;.cyan(),
            &quot;Tyr&quot;.red()
        );
        assert_eq!(result, expected);
    }

    #[test]
    fn default_strategy_should_work() {
        let path = Path::new(&quot;src/main.rs&quot;);
        let input = b&quot;hello world!\nhey Tyr!&quot;;
        let mut reader = BufReader::new(&amp;input[..]);
        let pattern = Regex::new(r&quot;he\w+&quot;).unwrap();
        let mut writer = Vec::new();
        default_strategy(path, &amp;mut reader, &amp;pattern, &amp;mut writer).unwrap();
        let result = String::from_utf8(writer).unwrap();
        let expected = [
            String::from(&quot;src/main.rs&quot;),
            format_line(&quot;hello world!&quot;, 1, 0..5),
            format_line(&quot;hey Tyr!\n&quot;, 2, 0..3),
        ];

        assert_eq!(result, expected.join(&quot;\n&quot;));
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="srcmainrs"><a class="header" href="#srcmainrs">src/main.rs</a></h2>
<details id="admonition-引入librs中的内容" class="admonition note">
<summary class="admonition-title">
<p>引入lib.rs中的内容</p>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition-引入librs中的内容"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use itertools::Itertools;
</code></pre></pre>
</div>
</details>
<details id="admonition-主函数main" class="admonition note">
<summary class="admonition-title">
<p>主函数：main() </p>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition-主函数main"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use regex::Regex;
use std::{
    fs::File,
    io::{self, BufRead, BufReader, Write},
    ops::Range,
    path::Path,
};
</code></pre></pre>
</div>
</details>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<details id="admonition-示例cargo-run---quiet----正则表达式-srcrs" class="admonition note">
<summary class="admonition-title">
<p>示例：cargo run –quiet – “正则表达式” “src/*.rs”</p>
<p><a class="admonition-anchor-link" href="rgrep.html#admonition-示例cargo-run---quiet----正则表达式-srcrs"></a></p>
</summary>
<div>
<pre><code class="language-shell">cargo run --quiet -- &quot;Re[^\\s]+&quot; &quot;src/*.rs&quot;                                                                                                                                                                                            ─╯
src/main.rs
     1:13  use anyhow::Result;
     5:14  fn main() -&gt; Result&lt;()&gt; {
src/error.rs
     7:14      #[error(&quot;Regex pattern error&quot;)]
     8:5       RegexPatternError(#[from] regex::Error),
src/lib.rs
     5:12  use regex::Regex;
     8:19      io::{self, BufRead, BufReader, Write},
    17:45  pub type StrategyFn = fn(&amp;Path, &amp;mut dyn BufRead, &amp;Regex, &amp;mut dyn Write) -&gt; Result&lt;(), GrepError&gt;;
    31:50      pub fn match_with_default_strategy(&amp;self) -&gt; Result&lt;(), GrepError&gt; {
    36:55      pub fn match_with(&amp;self, strategy: StrategyFn) -&gt; Result&lt;(), GrepError&gt; {
    37:21          let regex = Regex::new(&amp;self.pattern)?;
    44:41                      let mut reader = BufReader::new(file);
    60:25      reader: &amp;mut dyn BufRead,
    61:15      pattern: &amp;Regex,
    63:6   ) -&gt; Result&lt;(), GrepError&gt; {
   126:29          let mut reader = BufReader::new(&amp;input[..]);
   127:23          let pattern = Regex::new(r&quot;he\w+&quot;).unwrap();
</code></pre>
</div>
</details><div style="break-before: page; page-break-before: always;"></div><style>.extended-markdown-table {
    display: grid;
}

.extended-markdown-table > div {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 3px 20px;
    border-bottom: 1px solid var(--table-border-color);
    border-right: 1px solid var(--table-border-color);
}

.extended-markdown-table > div.extended-markdown-left-border {
    border-left: 1px solid var(--table-border-color);
}

.extended-markdown-table > div.extended-markdown-header {
    text-align: center;
    background: var(--table-header-bg);
    border-bottom: 1px solid var(--table-header-bg);
    border-right: 1px solid var(--table-header-bg);
    font-weight: bold;
}

.extended-markdown-table > div.extended-markdown-header.extended-markdown-left-border {
    border-left: 1px solid var(--table-header-bg);
}
</style>
<h1 id="thumbor图片服务"><a class="header" href="#thumbor图片服务">thumbor图片服务</a></h1>
<!--ts-->
<!--te-->
<h2 id="protobuf相关处理"><a class="header" href="#protobuf相关处理">protobuf相关处理</a></h2>
<details id="admonition-abiproto" class="admonition note">
<summary class="admonition-title">
<p>abi.proto</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-abiproto"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">syntax = &quot;proto3&quot;;

package abi;

// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
message ImageSpec { repeated Spec specs = 1; }

// 处理图片改变大小
message Resize {
  uint32 width = 1;
  uint32 height = 2;

  enum ResizeType {
    NORMAL = 0;
    SEAM_CARVE = 1;
  }

  ResizeType rtype = 3;

  enum SampleFilter {
    UNDEFINED = 0;
    NEAREST = 1;
    TRIANGLE = 2;
    CATMULL_ROM = 3;
    GAUSSIAN = 4;
    LANCZOS3 = 5;
  }

  SampleFilter filter = 4;
}

// 处理图片截取
message Crop {
  uint32 x1 = 1;
  uint32 y1 = 2;
  uint32 x2 = 3;
  uint32 y2 = 4;
}

// 处理水平翻转
message Fliph {}
// 处理垂直翻转
message Flipv {}
// 处理对比度
message Contrast { float contrast = 1; }
// 处理滤镜
message Filter {
  enum Filter {
    UNSPECIFIED = 0;
    OCEANIC = 1;
    ISLANDS = 2;
    MARINE = 3;
    // more: https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html
  }
  Filter filter = 1;
}

// 处理水印
message Watermark {
  uint32 x = 1;
  uint32 y = 2;
}

// 一个 spec 可以包含上述的处理方式之一
message Spec {
  oneof data {
    Resize resize = 1;
    Crop crop = 2;
    Flipv flipv = 3;
    Fliph fliph = 4;
    Contrast contrast = 5;
    Filter filter = 6;
    Watermark watermark = 7;
  }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-buildrs" class="admonition note">
<summary class="admonition-title">
<p>build.rs</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-buildrs"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::process::Command;

fn main() {
    // 在编译时可选择检查环境变量。
    let build_enabled = option_env!(&quot;BUILD_PROTO&quot;)
        .map(|v| v == &quot;1&quot;)
        .unwrap_or(false);
    // 如果没有找到环境变量的对应值，就直接return，不再进行后续编译
    if !build_enabled {
        println!(&quot;=== Skipped compiling protos ===&quot;);
        return;
    }
    // 使用 prost_build 把 abi.proto 编译到 src/pb 目录下
    prost_build::Config::new()
        .out_dir(&quot;src/pb&quot;)
        .compile_protos(&amp;[&quot;abi.proto&quot;], &amp;[&quot;.&quot;])
        .unwrap();
    Command::new(&quot;cargo&quot;)
        .args(&amp;[&quot;fmt&quot;, &quot;--&quot;, &quot;src/*.rs&quot;])
        .status()
        .expect(&quot;cargo fmt failed&quot;);
}
</code></pre></pre>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.option_env.html">option_env in std - Rust</a></li>
</ul>
<blockquote>
<p>在编译时可选择检查环境变量。</p>
</blockquote>
</div>
</details>
<h2 id="关于rust的模块"><a class="header" href="#关于rust的模块">关于rust的模块</a></h2>
<blockquote>
<p>可以参考这篇：<a href="https://zhuanlan.zhihu.com/p/443926839">Rust 模块系统理解 - 知乎</a></p>
</blockquote>
<details id="admonition-mod全认识" class="admonition tip">
<summary class="admonition-title">
<p>mod全认识</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-mod全认识"></a></p>
</summary>
<div>
<ol>
<li>mod(mod.rs或mod关键字)将代码分为多个逻辑模块，并管理这些模块的可见性（public / private）。</li>
<li>模块是项（item）的集合，项可以是：函数，结构体，trait，impl块，甚至其它模块。</li>
<li>一个目录下的所有代码，可以通过 mod.rs 声明</li>
<li>Rust模块有三种形式:
<ul>
<li>mod.rs: 一个目录下的所有代码，可以通过 mod.rs 声明</li>
<li>文件/目录即模块：编译器的机制决定，除了mod.rs外，每一个文件和目录都是一个模块。不允许只分拆文件，但是不声明mod，我们通常使用pub use，在父空间直接调用子空间的函数。</li>
<li>mod关键字: 在文件内部分拆模块</li>
</ul>
</li>
<li>Rust编译器只接受一个源文件，输出一个crate</li>
<li>每一个crate都有一个匿名的根命名空间，命名空间可以无限嵌套</li>
<li>“mod mod-name { … }“ 将大括号中的代码置于命名空间mod-name之下</li>
<li>“use mod-name1::mod-name2;“ 可以打开命名空间，减少无休止的::操作符</li>
<li>“mod mod-name;“ 可以指导编译器将多个文件组装成一个文件</li>
<li>“pub use mod-nam1::mod-name2::item-name;“
语句可以将mod-name2下的item-name提升到这条语句所在的空间，item-name通常是函数或者结构体。Rust社区通常用这个方法来缩短库API的命名空间深度
编译器规定use语句一定要在mod语句之前</li>
</ol>
</div>
</details>
<details id="admonition-mod文件定义与实现分离" class="admonition abstract">
<summary class="admonition-title">
<p>mod文件定义与实现分离 </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-mod文件定义与实现分离"></a></p>
</summary>
<div>
<p>在rust中，一般会在模块的mod.rs文件中对供外部使用的项进行实现, 项可以是：函数，结构体，trait，impl块，甚至其它模块.
这样有个好处，高内聚，可以在代码增长时，将变动局限在服务提供者内部，对外提供的api不变，不会造成破坏性更新。</p>
</div>
</details>
<h2 id="pb模块-处理protobuf"><a class="header" href="#pb模块-处理protobuf">pb模块: 处理protobuf</a></h2>
<details id="admonition-pbmodrs声明模块" class="admonition note">
<summary class="admonition-title">
<p>pb/mod.rs声明模块 </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-pbmodrs声明模块"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">mod abi; // 声明 abi.rs
pub use abi::*;
</code></pre></pre>
</div>
</details>
<details id="admonition-pbabirs里面还有子模块" class="admonition note">
<summary class="admonition-title">
<p>pb/abi.rs里面还有子模块 </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-pbabirs里面还有子模块"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// Nested message and enum types in `Spec`.
pub mod spec {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = &quot;1&quot;)]
        Resize(super::Resize),
        #[prost(message, tag = &quot;2&quot;)]
        Crop(super::Crop),
        #[prost(message, tag = &quot;3&quot;)]
        Flipv(super::Flipv),
        #[prost(message, tag = &quot;4&quot;)]
        Fliph(super::Fliph),
        #[prost(message, tag = &quot;5&quot;)]
        Contrast(super::Contrast),
        #[prost(message, tag = &quot;6&quot;)]
        Filter(super::Filter),
        #[prost(message, tag = &quot;7&quot;)]
        Watermark(super::Watermark),
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-pbabirs另外定义了specdata里面的各个元素结构体嵌套模块mod" class="admonition note">
<summary class="admonition-title">
<p>pb/abi.rs另外定义了spec::Data里面的各个元素结构体/嵌套模块mod</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-pbabirs另外定义了specdata里面的各个元素结构体嵌套模块mod"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSpec {
    #[prost(message, repeated, tag = &quot;1&quot;)]
    pub specs: ::prost::alloc::vec::Vec&lt;Spec&gt;,
}
/// 处理图片改变大小
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resize {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub width: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub height: u32,
    #[prost(enumeration = &quot;resize::ResizeType&quot;, tag = &quot;3&quot;)]
    pub rtype: i32,
    #[prost(enumeration = &quot;resize::SampleFilter&quot;, tag = &quot;4&quot;)]
    pub filter: i32,
}
/// Nested message and enum types in `Resize`.
pub mod resize {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResizeType {
        Normal = 0,
        SeamCarve = 1,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SampleFilter {
        Undefined = 0,
        Nearest = 1,
        Triangle = 2,
        CatmullRom = 3,
        Gaussian = 4,
        Lanczos3 = 5,
    }
}
/// 处理图片截取
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Crop {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub x1: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub y1: u32,
    #[prost(uint32, tag = &quot;3&quot;)]
    pub x2: u32,
    #[prost(uint32, tag = &quot;4&quot;)]
    pub y2: u32,
}
/// 处理水平翻转
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fliph {}
/// 处理垂直翻转
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Flipv {}
/// 处理对比度
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contrast {
    #[prost(float, tag = &quot;1&quot;)]
    pub contrast: f32,
}
/// 处理滤镜
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filter {
    #[prost(enumeration = &quot;filter::Filter&quot;, tag = &quot;1&quot;)]
    pub filter: i32,
}
/// Nested message and enum types in `Filter`.
pub mod filter {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Filter {
        Unspecified = 0,
        Oceanic = 1,
        Islands = 2,
        /// more: &lt;https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html&gt;
        Marine = 3,
    }
}
/// 处理水印
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Watermark {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub x: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub y: u32,
}
</code></pre></pre>
</div>
</details>
<details id="admonition-pbabirs有个特殊结构体" class="admonition note">
<summary class="admonition-title">
<p>pb/abi.rs有个特殊结构体</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-pbabirs有个特殊结构体"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 spec 可以包含上述的处理方式之一
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    #[prost(oneof = &quot;spec::Data&quot;, tags = &quot;1, 2, 3, 4, 5, 6, 7&quot;)]
    pub data: ::core::option::Option&lt;spec::Data&gt;,
}
</code></pre></pre>
</div>
</details>
<h3 id="imagespec"><a class="header" href="#imagespec">ImageSpec</a></h3>
<details id="admonition-定义有序数组" class="admonition note">
<summary class="admonition-title">
<p>定义：有序数组 </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-定义有序数组"></a></p>
</summary>
<div>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSpec {
    #[prost(message, repeated, tag = &quot;1&quot;)]
    pub specs: ::prost::alloc::vec::Vec&lt;Spec&gt;,
}
</code></pre></pre>
</div>
</details>
<details id="admonition-实现new方法fromtryfrom实现类型转化" class="admonition note">
<summary class="admonition-title">
<p>实现：new方法、From&amp;TryFrom实现类型转化 </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-实现new方法fromtryfrom实现类型转化"></a></p>
</summary>
<div>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">impl ImageSpec {
    pub fn new(specs: Vec&lt;Spec&gt;) -&gt; Self {
        Self { specs }
    }
}

// 让 ImageSpec 可以生成一个字符串
impl From&lt;&amp;ImageSpec&gt; for String {
    fn from(image_spec: &amp;ImageSpec) -&gt; Self {
        let data = image_spec.encode_to_vec();
        encode_config(data, URL_SAFE_NO_PAD)
    }
}

// 让 ImageSpec 可以通过一个字符串创建。比如 s.parse().unwrap()
impl TryFrom&lt;&amp;str&gt; for ImageSpec {
    type Error = anyhow::Error;

    fn try_from(value: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {
        let data = decode_config(value, URL_SAFE_NO_PAD)?;
        Ok(ImageSpec::decode(&amp;data[..])?)
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="filter"><a class="header" href="#filter">Filter</a></h3>
<details id="admonition-定义枚举体mod" class="admonition note">
<summary class="admonition-title">
<p>定义：枚举体mod </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-定义枚举体mod"></a></p>
</summary>
<div>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// Nested message and enum types in `Filter`.
pub mod filter {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Filter {
        Unspecified = 0,
        Oceanic = 1,
        Islands = 2,
        /// more: &lt;https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html&gt;
        Marine = 3,
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-实现双引号的使用模式匹配" class="admonition note">
<summary class="admonition-title">
<p>实现：双引号的使用、模式匹配 </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-实现双引号的使用模式匹配"></a></p>
</summary>
<div>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">// 辅助函数，photon_rs 相应的方法里需要字符串
impl filter::Filter {
    pub fn to_str(self) -&gt; Option&lt;&amp;'static str&gt; {
        match self {
            filter::Filter::Unspecified =&gt; None,
            filter::Filter::Oceanic =&gt; Some(&quot;oceanic&quot;),
            filter::Filter::Islands =&gt; Some(&quot;islands&quot;),
            filter::Filter::Marine =&gt; Some(&quot;marine&quot;),
        }
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="samplefilter"><a class="header" href="#samplefilter">SampleFilter</a></h3>
<details id="admonition-定义枚举体mod-1" class="admonition note">
<summary class="admonition-title">
<p>定义：枚举体mod </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-定义枚举体mod-1"></a></p>
</summary>
<div>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// Nested message and enum types in `Resize`.
pub mod resize {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResizeType {
        Normal = 0,
        SeamCarve = 1,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SampleFilter {
        Undefined = 0,
        Nearest = 1,
        Triangle = 2,
        CatmullRom = 3,
        Gaussian = 4,
        Lanczos3 = 5,
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-实现mod使用双引号from转为不同结果" class="admonition note">
<summary class="admonition-title">
<p>实现：mod使用双引号、From转为不同结果 </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-实现mod使用双引号from转为不同结果"></a></p>
</summary>
<div>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">impl From&lt;resize::SampleFilter&gt; for SamplingFilter {
    fn from(v: resize::SampleFilter) -&gt; Self {
        match v {
            resize::SampleFilter::Undefined =&gt; SamplingFilter::Nearest,
            resize::SampleFilter::Nearest =&gt; SamplingFilter::Nearest,
            resize::SampleFilter::Triangle =&gt; SamplingFilter::Triangle,
            resize::SampleFilter::CatmullRom =&gt; SamplingFilter::CatmullRom,
            resize::SampleFilter::Gaussian =&gt; SamplingFilter::Gaussian,
            resize::SampleFilter::Lanczos3 =&gt; SamplingFilter::Lanczos3,
        }
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="spec"><a class="header" href="#spec">Spec</a></h3>
<details id="admonition-定义结构体" class="admonition note">
<summary class="admonition-title">
<p>定义：结构体 </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-定义结构体"></a></p>
</summary>
<div>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 spec 可以包含上述的处理方式之一
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    #[prost(oneof = &quot;spec::Data&quot;, tags = &quot;1, 2, 3, 4, 5, 6, 7&quot;)]
    pub data: ::core::option::Option&lt;spec::Data&gt;,
}
</code></pre></pre>
</div>
</details>
<details id="admonition--注意区别self和self的使用" class="admonition note">
<summary class="admonition-title">
<blockquote>
<p>注意区别Self和self的使用：</p>
</blockquote>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition--注意区别self和self的使用"></a></p>
</summary>
<div>
<blockquote>
<p><a href="https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self">rust - What’s the difference between self and Self? - Stack Overflow</a></p>
</blockquote>
</div>
</details>
<details id="admonition-实现类似面向对象中添加类方法self" class="admonition note">
<summary class="admonition-title">
<p>实现：类似面向对象中添加类方法Self</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-实现类似面向对象中添加类方法self"></a></p>
</summary>
<div>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">// 提供一些辅助函数，让创建一个 spec 的过程简单一些
impl Spec {
    pub fn new_resize_seam_carve(width: u32, height: u32) -&gt; Self {
        Self {
            data: Some(spec::Data::Resize(Resize {
                width,
                height,
                rtype: resize::ResizeType::SeamCarve as i32,
                filter: resize::SampleFilter::Undefined as i32,
            })),
        }
    }

    pub fn new_resize(width: u32, height: u32, filter: resize::SampleFilter) -&gt; Self {
        Self {
            data: Some(spec::Data::Resize(Resize {
                width,
                height,
                rtype: resize::ResizeType::Normal as i32,
                filter: filter as i32,
            })),
        }
    }

    pub fn new_filter(filter: filter::Filter) -&gt; Self {
        Self {
            data: Some(spec::Data::Filter(Filter {
                filter: filter as i32,
            })),
        }
    }

    pub fn new_watermark(x: u32, y: u32) -&gt; Self {
        Self {
            data: Some(spec::Data::Watermark(Watermark { x, y })),
        }
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h3>
<details id="admonition-单元测试" class="admonition note">
<summary class="admonition-title">
<p>单元测试</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-单元测试"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {
    use super::*;
    use std::borrow::Borrow;

    #[test]
    fn encoded_spec_could_be_decoded() {
        let spec1 = Spec::new_resize(600, 600, resize::SampleFilter::CatmullRom);
        let spec2 = Spec::new_filter(filter::Filter::Marine);
        let image_spec = ImageSpec::new(vec![spec1, spec2]);
        let s: String = image_spec.borrow().into();
        assert_eq!(image_spec, s.as_str().try_into().unwrap());
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="engine模块-处理图片"><a class="header" href="#engine模块-处理图片">engine模块: 处理图片</a></h2>
<details id="admonition-modrs-定义统一的引擎trait" class="admonition note">
<summary class="admonition-title">
<p>mod.rs: 定义统一的引擎trait </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-modrs-定义统一的引擎trait"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">// Engine trait：未来可以添加更多的 engine，主流程只需要替换 engine
pub trait Engine {
    // 对 engine 按照 specs 进行一系列有序的处理
    fn apply(&amp;mut self, specs: &amp;[Spec]);
    // 从 engine 中生成目标图片，注意这里用的是 self，而非 self 的引用
    fn generate(self, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt;;
}

// SpecTransform：未来如果添加更多的 spec，只需要实现它即可
pub trait SpecTransform&lt;T&gt; {
    // 对图片使用 op 做 transform
    fn transform(&amp;mut self, op: T);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-photonrs--静态变量加载" class="admonition note">
<summary class="admonition-title">
<p>photon.rs &gt; 静态变量加载</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-photonrs--静态变量加载"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">lazy_static! {
    // 预先把水印文件加载为静态变量
    static ref WATERMARK: PhotonImage = {
        let data = include_bytes!(&quot;../../rust-logo.png&quot;);
        let watermark = open_image_from_bytes(data).unwrap();
        transform::resize(&amp;watermark, 64, 64, transform::SamplingFilter::Nearest)
    };
}
</code></pre></pre>
</div>
</details>
<details id="admonition-photonrs--具体引擎photon的定义与转化tryfrom" class="admonition note">
<summary class="admonition-title">
<p>photon.rs &gt; 具体引擎Photon的定义与转化TryFrom</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-photonrs--具体引擎photon的定义与转化tryfrom"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">pub struct Photon(PhotonImage);

// 从 Bytes 转换成 Photon 结构
impl TryFrom&lt;Bytes&gt; for Photon {
    type Error = anyhow::Error;

    fn try_from(data: Bytes) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(Self(open_image_from_bytes(&amp;data)?))
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="photonrs--具体引擎photon的trait实现"><a class="header" href="#photonrs--具体引擎photon的trait实现">photon.rs &gt; 具体引擎Photon的trait实现</a></h3>
<details id="admonition-engine-trait" class="admonition note">
<summary class="admonition-title">
<p>Engine Trait</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-engine-trait"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl Engine for Photon {
    fn apply(&amp;mut self, specs: &amp;[Spec]) {
        for spec in specs.iter() {
            match spec.data {
                Some(spec::Data::Crop(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Contrast(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Filter(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Fliph(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Flipv(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Resize(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Watermark(ref v)) =&gt; self.transform(v),
                // 对于目前不认识的 spec，不做任何处理
                _ =&gt; {}
            }
        }
    }
</code></pre></pre>
</div>
</details>
<h4 id="spectransform-trait"><a class="header" href="#spectransform-trait">SpecTransform Trait</a></h4>
<details id="admonition-格式语义化" class="admonition note">
<summary class="admonition-title">
<p>格式语义化</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-格式语义化"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SpecTransform(&amp;OpreationName) for SpecificEngine {
    fn transform(&amp;mut self, _op: &amp;OperationName) {
        transform::OperationMethod(&amp;mut self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">impl SpecTransform&lt;&amp;Crop&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Crop) {
        let img = transform::crop(&amp;mut self.0, op.x1, op.y1, op.x2, op.y2);
        self.0 = img;
    }
}

impl SpecTransform&lt;&amp;Contrast&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Contrast) {
        effects::adjust_contrast(&amp;mut self.0, op.contrast);
    }
}

impl SpecTransform&lt;&amp;Flipv&gt; for Photon {
    fn transform(&amp;mut self, _op: &amp;Flipv) {
        transform::flipv(&amp;mut self.0)
    }
}

impl SpecTransform&lt;&amp;Fliph&gt; for Photon {
    fn transform(&amp;mut self, _op: &amp;Fliph) {
        transform::fliph(&amp;mut self.0)
    }
}

impl SpecTransform&lt;&amp;Filter&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Filter) {
        match filter::Filter::from_i32(op.filter) {
            Some(filter::Filter::Unspecified) =&gt; {}
            Some(f) =&gt; filters::filter(&amp;mut self.0, f.to_str().unwrap()),
            _ =&gt; {}
        }
    }
}

impl SpecTransform&lt;&amp;Resize&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Resize) {
        let img = match resize::ResizeType::from_i32(op.rtype).unwrap() {
            resize::ResizeType::Normal =&gt; transform::resize(
                &amp;self.0,
                op.width,
                op.height,
                resize::SampleFilter::from_i32(op.filter).unwrap().into(),
            ),
            resize::ResizeType::SeamCarve =&gt; transform::seam_carve(&amp;self.0, op.width, op.height),
        };
        self.0 = img;
    }
}

impl SpecTransform&lt;&amp;Watermark&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Watermark) {
        multiple::watermark(&amp;mut self.0, &amp;WATERMARK, op.x, op.y);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-photonrs--在内存中对图片转换格式的方法" class="admonition note">
<summary class="admonition-title">
<p>photon.rs &gt; 在内存中对图片转换格式的方法</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-photonrs--在内存中对图片转换格式的方法"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn image_to_buf(img: PhotonImage, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt; {
    let raw_pixels = img.get_raw_pixels();
    let width = img.get_width();
    let height = img.get_height();

    let img_buffer = ImageBuffer::from_vec(width, height, raw_pixels).unwrap();
    let dynimage = DynamicImage::ImageRgba8(img_buffer);

    let mut buffer = Vec::with_capacity(32768);
    dynimage.write_to(&amp;mut buffer, format).unwrap();
    buffer
}
</code></pre></pre>
</div>
</details>
<h2 id="mainrs"><a class="header" href="#mainrs">main.rs</a></h2>
<details id="admonition-先引入mod再use" class="admonition note">
<summary class="admonition-title">
<p>先引入mod，再use</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-先引入mod再use"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">// 参数使用 serde 做 Deserialize，axum 会自动识别并解析
#[derive(Deserialize)]
struct Params {
    spec: String,
    url: String,
}
</code></pre></pre>
</div>
</details>
<details id="admonition-图片资源用到lru策略缓存type定义" class="admonition note">
<summary class="admonition-title">
<p>图片资源用到Lru策略缓存type定义</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-图片资源用到lru策略缓存type定义"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">type Cache = Arc&lt;Mutex&lt;LruCache&lt;u64, Bytes&gt;&gt;&gt;;
</code></pre></pre>
</div>
</details>
<h3 id="主流程main函数"><a class="header" href="#主流程main函数">主流程main函数</a></h3>
<details id="admonition-main" class="admonition note">
<summary class="admonition-title">
<p>main()</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-main"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[tokio::main]
async fn main() {
    // 初始化 tracing
    tracing_subscriber::fmt::init();
    let cache: Cache = Arc::new(Mutex::new(LruCache::new(1024)));
    // 构建路由
    let app = Router::new()
        // `GET /` 会执行
        .route(&quot;/image/:spec/:url&quot;, get(generate))
        .layer(
            ServiceBuilder::new()
                .load_shed()
                .concurrency_limit(1024)
                .timeout(Duration::from_secs(10))
                .layer(TraceLayer::new_for_http())
                .layer(AddExtensionLayer::new(cache))
                .layer(CompressionLayer::new())
                .into_inner(),
        );

    // 运行 web 服务器
    let addr = &quot;127.0.0.1:3000&quot;.parse().unwrap();
    print_test_url(&quot;https://images.pexels.com/photos/1562477/pexels-photo-1562477.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=3&amp;h=750&amp;w=1260&quot;);
    info!(&quot;Listening on {}&quot;, addr);
    axum::Server::bind(&amp;addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-建造者模式" class="admonition note">
<summary class="admonition-title">
<p>建造者模式 </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-建造者模式"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">            ServiceBuilder::new()
                .load_shed()
                .concurrency_limit(1024)
                .timeout(Duration::from_secs(10))
                .layer(TraceLayer::new_for_http())
                .layer(AddExtensionLayer::new(cache))
                .layer(CompressionLayer::new())
                .into_inner(),
</code></pre></pre>
</div>
</details>
<details id="admonition-类型转换" class="admonition note">
<summary class="admonition-title">
<p>类型转换 </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-类型转换"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">    // 运行 web 服务器
    let addr = &quot;127.0.0.1:3000&quot;.parse().unwrap();
</code></pre></pre>
</div>
</details>
<details id="admonition-笔记类型转换总结" class="admonition abstract">
<summary class="admonition-title">
<p>笔记：类型转换总结</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-笔记类型转换总结"></a></p>
</summary>
<div>
<ol>
<li>数字与字符串</li>
</ol>
<div class="extended-markdown-table"><div class="extended-markdown-header extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 1; grid-row-end: 2"></div><div class="extended-markdown-header" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2">i32</div><div class="extended-markdown-header" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2">u32</div><div class="extended-markdown-header" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 1; grid-row-end: 2">f64</div><div class="extended-markdown-header" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 1; grid-row-end: 2">String*</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 2; grid-row-end: 3">i32</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 2; grid-row-end: 3">\</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 2; grid-row-end: 3">x as u32</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 2; grid-row-end: 3">x as f64</div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 2; grid-row-end: 3">x.to_string()</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 3; grid-row-end: 4">u32</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 3; grid-row-end: 4">x as i32</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 3; grid-row-end: 4">\</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 3; grid-row-end: 4">x as f64</div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 3; grid-row-end: 4">x.to_string()</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 4; grid-row-end: 5">f64</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 4; grid-row-end: 5">x as i32</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 4; grid-row-end: 5">x as u32</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 4; grid-row-end: 5">\</div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 4; grid-row-end: 5">x.to_string()</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 5; grid-row-end: 6">String*</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 5; grid-row-end: 6">x.parse().unwrap()</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 5; grid-row-end: 6">x.parse().unwrap()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 5; grid-row-end: 6">x.parse().unwrap()</div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 5; grid-row-end: 6">\</div></div>
<ol start="2">
<li>String 与 &amp; str</li>
</ol>
<div class="extended-markdown-table"><div class="extended-markdown-header extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 1; grid-row-end: 2">\</div><div class="extended-markdown-header" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2">String</div><div class="extended-markdown-header" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2">&str</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 2; grid-row-end: 3">String</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 2; grid-row-end: 3">\</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 2; grid-row-end: 3">&*x</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 3; grid-row-end: 4">&str</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 3; grid-row-end: 4">x.to_string()</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 3; grid-row-end: 4">\</div></div>
<ol start="3">
<li>智能指针</li>
</ol>
<div class="extended-markdown-table"><div class="extended-markdown-header extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 1; grid-row-end: 2">\</div><div class="extended-markdown-header" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2">Vec\<T\></div><div class="extended-markdown-header" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2">&[T]</div><div class="extended-markdown-header" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 1; grid-row-end: 2">Box<[T]></div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 2; grid-row-end: 3">Vec\<T\></div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 2; grid-row-end: 3">\</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 2; grid-row-end: 3">&x[...]</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 2; grid-row-end: 3">x.into_boxed_slice()</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 3; grid-row-end: 4">&[T]</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 3; grid-row-end: 4">x.to_vec()</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 3; grid-row-end: 4">\</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 3; grid-row-end: 4">Box::new(\*x)</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 4; grid-row-end: 5">Box<[T]></div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 4; grid-row-end: 5">x.to_vec()</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 4; grid-row-end: 5">&\*x</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 4; grid-row-end: 5">\</div></div>
</div>
</details>
<details id="admonition-路由绑定的处理函数handler" class="admonition note">
<summary class="admonition-title">
<p>路由绑定的处理函数handler </p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-路由绑定的处理函数handler"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">// basic handler that responds with a static string
async fn generate(
    Path(Params { spec, url }): Path&lt;Params&gt;,
    Extension(cache): Extension&lt;Cache&gt;,
) -&gt; Result&lt;(HeaderMap, Vec&lt;u8&gt;), StatusCode&gt; {
    let spec: ImageSpec = spec
        .as_str()
        .try_into()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    let url: &amp;str = &amp;percent_decode_str(&amp;url).decode_utf8_lossy();
    let data = retrieve_image(url, cache)
        .await
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    // 使用 image engine 处理
    let mut engine: Photon = data
        .try_into()
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    engine.apply(&amp;spec.specs);
    // TODO: 这里目前类型写死了，应该使用 content negotiation
    let image = engine.generate(ImageOutputFormat::Jpeg(85));

    info!(&quot;Finished processing: image size {}&quot;, image.len());
    let mut headers = HeaderMap::new();

    headers.insert(&quot;content-type&quot;, HeaderValue::from_static(&quot;image/jpeg&quot;));
    Ok((headers, image))
}
</code></pre></pre>
</div>
</details>
<details id="admonition-处理函数用到的图片获取方法" class="admonition note">
<summary class="admonition-title">
<p>处理函数用到的图片获取方法</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-处理函数用到的图片获取方法"></a></p>
</summary>
<div>
<blockquote>
<p>对于图片的网络请求，我们先把 URL 做个哈希，在 LRU 缓存中查找，找不到才用 reqwest 发送请求。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">#[instrument(level = &quot;info&quot;, skip(cache))]
async fn retrieve_image(url: &amp;str, cache: Cache) -&gt; Result&lt;Bytes&gt; {
    let mut hasher = DefaultHasher::new();
    url.hash(&amp;mut hasher);
    let key = hasher.finish();

    let g = &amp;mut cache.lock().await;
    let data = match g.get(&amp;key) {
        Some(v) =&gt; {
            info!(&quot;Match cache {}&quot;, key);
            v.to_owned()
        }
        None =&gt; {
            info!(&quot;Retrieve url&quot;);
            let resp = reqwest::get(url).await?;
            let data = resp.bytes().await?;
            g.put(key, data.clone());
            data
        }
    };

    Ok(data)
}
</code></pre></pre>
</div>
</details>
<details id="admonition-一个用于调试的辅助函数" class="admonition note">
<summary class="admonition-title">
<p>一个用于调试的辅助函数</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-一个用于调试的辅助函数"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">// 调试辅助函数
fn print_test_url(url: &amp;str) {
    use std::borrow::Borrow;
    let spec1 = Spec::new_resize(500, 800, resize::SampleFilter::CatmullRom);
    let spec2 = Spec::new_watermark(20, 20);
    let spec3 = Spec::new_filter(filter::Filter::Marine);
    let image_spec = ImageSpec::new(vec![spec1, spec2, spec3]);
    let s: String = image_spec.borrow().into();
    let test_image = percent_encode(url.as_bytes(), NON_ALPHANUMERIC).to_string();
    println!(&quot;test url: http://localhost:3000/image/{}/{}&quot;, s, test_image);
}
</code></pre></pre>
</div>
</details>
<h2 id="运行与日志"><a class="header" href="#运行与日志">运行与日志</a></h2>
<details id="admonition--将rust_log级别设置为info" class="admonition note">
<summary class="admonition-title">
<blockquote>
<p>将RUST_LOG级别设置为info</p>
</blockquote>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition--将rust_log级别设置为info"></a></p>
</summary>
<div>
<pre><code class="language-shell">cargo build --release
RUST_LOG=info target/release/thumbor
</code></pre>
</div>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="sql查询工具"><a class="header" href="#sql查询工具">SQL查询工具</a></h1>
<!--ts-->
<ul>
<li><a href="queryer.html#sql%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7">SQL查询工具</a>
<ul>
<li><a href="queryer.html#workspace-%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%B8%85%E5%8D%95virtual-manifest%E6%96%B9%E5%BC%8F">workspace: 这里使用虚拟清单(virtual manifest)方式</a>
<ul>
<li><a href="queryer.html#workspace%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">workspace使用方式</a></li>
</ul>
</li>
<li><a href="queryer.html#queryer-package">queryer package</a>
<ul>
<li><a href="queryer.html#cargotoml">cargo.toml</a></li>
<li><a href="queryer.html#%E4%B8%A4%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">两个使用示例</a></li>
<li><a href="queryer.html#srcconvertrs">src/convert.rs</a></li>
<li><a href="queryer.html#srcdialectrs">src/dialect.rs</a></li>
<li><a href="queryer.html#srcloaderrs">src/loader.rs</a></li>
<li><a href="queryer.html#srcfetcherrs">src/fetcher.rs</a></li>
</ul>
</li>
<li><a href="queryer.html#queryer-js-package-%E4%BD%BF%E7%94%A8neon">queryer-js package: 使用neon</a></li>
<li><a href="queryer.html#queryer-py-package-%E4%BD%BF%E7%94%A8pyo3">queryer-py package: 使用pyo3</a></li>
<li><a href="queryer.html#data-viewer-package-%E4%BD%BF%E7%94%A8tauri">data-viewer package: 使用tauri</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:33 UTC 2022 -->
<!--te-->
<h2 id="workspace-这里使用虚拟清单virtual-manifest方式"><a class="header" href="#workspace-这里使用虚拟清单virtual-manifest方式">workspace: 这里使用虚拟清单(virtual manifest)方式</a></h2>
<blockquote>
<p><a href="https://course.rs/cargo/reference/workspaces.html">工作空间 Workspace - Rust语言圣经(Rust Course)</a></p>
</blockquote>
<details id="admonition-cargotoml" class="admonition note">
<summary class="admonition-title">
<p>Cargo.toml </p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-cargotoml"></a></p>
</summary>
<div>
<pre><code class="language-toml">[workspace]

members = [
  &quot;queryer&quot;,
  &quot;queryer-js&quot;,
  &quot;queryer-py&quot;,
  &quot;data-viewer/src-tauri&quot;
]
</code></pre>
</div>
</details>
<details id="admonition-虚拟清单" class="admonition info">
<summary class="admonition-title">
<p>虚拟清单</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-虚拟清单"></a></p>
</summary>
<div>
<p>若一个 Cargo.toml 有 [workspace] 但是没有 [package] 部分，则它是虚拟清单类型的工作空间。</p>
<p>对于没有主 package 的场景或你希望将所有的 package 组织在单独的目录中时，这种方式就非常适合。</p>
</div>
</details>
<details id="admonition-workspace关键点" class="admonition tip">
<summary class="admonition-title">
<p>workspace关键点</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-workspace关键点"></a></p>
</summary>
<div>
<ul>
<li>所有的 package 共享同一个 Cargo.lock 文件，该文件位于工作空间的根目录中</li>
<li>所有的 package 共享同一个输出目录，该目录默认的名称是 target ，位于工作空间根目录下</li>
<li>只有工作空间根目录的 Cargo.toml 才能包含 [patch], [replace] 和 [profile.*]，而成员的 Cargo.toml 中的相应部分将被自动忽略</li>
</ul>
</div>
</details>
<h3 id="workspace使用方式"><a class="header" href="#workspace使用方式">workspace使用方式</a></h3>
<pre><code class="language-shell">cargo run -p &lt;member package&gt;
cargo build -p queryer
</code></pre>
<details id="admonition-使用说明" class="admonition info">
<summary class="admonition-title">
<p>使用说明</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-使用说明"></a></p>
</summary>
<div>
<ol>
<li>
<p>在工作空间中，package 相关的 Cargo 命令(例如 cargo build )可以使用 -p 、 –package 或 –workspace 命令行参数来指定想要操作的 package。</p>
</li>
<li>
<p>若没有指定任何参数，则 Cargo 将使用当前工作目录的中的 package 。若工作目录是虚拟清单类型的工作空间，则该命令将作用在所有成员上(就好像是使用了 –workspace 命令行参数)。而 default-members 可以在命令行参数没有被提供时，手动指定操作的成员</p>
</li>
</ol>
</div>
</details>
<h2 id="queryer-package"><a class="header" href="#queryer-package">queryer package</a></h2>
<h3 id="cargotoml-1"><a class="header" href="#cargotoml-1">cargo.toml</a></h3>
<details id="admonition-cargotoml-1" class="admonition note">
<summary class="admonition-title">
<p>cargo.toml </p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-cargotoml-1"></a></p>
</summary>
<div>
<pre><code class="language-toml">{{#include ../geektime_rust_codes/06_queryer/queryer/cargo.toml}}
</code></pre>
</div>
</details>
<h3 id="两个使用示例"><a class="header" href="#两个使用示例">两个使用示例</a></h3>
<details id="admonition-1-dialectrssql解析" class="admonition note">
<summary class="admonition-title">
<ol>
<li>dialect.rs:SQL解析</li>
</ol>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-1-dialectrssql解析"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use sqlparser::{dialect::GenericDialect, parser::Parser};

fn main() {
    tracing_subscriber::fmt::init();

    let sql = &quot;SELECT a a1, b, 123, myfunc(b), * \
    FROM data_source \
    WHERE a &gt; b AND b &lt; 100 AND c BETWEEN 10 AND 20 \
    ORDER BY a DESC, b \
    LIMIT 50 OFFSET 10&quot;;

    let ast = Parser::parse_sql(&amp;GenericDialect::default(), sql);
    println!(&quot;{:#?}&quot;, ast);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-2-covidrs-ast转换" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>covid.rs: AST转换 </li>
</ol>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-2-covidrs-ast转换"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use anyhow::Result;
use queryer::query;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();

    let url = &quot;https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv&quot;;

    // 使用 sql 从 URL 里获取数据
    let sql = format!(
        &quot;SELECT location name, total_cases, new_cases, total_deaths, new_deaths \
        FROM {} where new_deaths &gt;= 500 ORDER BY new_cases DESC&quot;,
        url
    );
    let df1 = query(sql).await?;
    println!(&quot;{:?}&quot;, df1);

    Ok(())
}
</code></pre></pre>
</div>
</details>
<h3 id="srcconvertrs"><a class="header" href="#srcconvertrs">src/convert.rs</a></h3>
<details id="admonition-结构体定义sql与对应部分结构体-注意限于孤儿原则的再包装" class="admonition note">
<summary class="admonition-title">
<p>结构体定义:sql与对应部分结构体, 注意限于孤儿原则的再包装</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-结构体定义sql与对应部分结构体-注意限于孤儿原则的再包装"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 解析出来的 SQL
pub struct Sql&lt;'a&gt; {
    pub(crate) selection: Vec&lt;Expr&gt;,
    pub(crate) condition: Option&lt;Expr&gt;,
    pub(crate) source: &amp;'a str,
    pub(crate) order_by: Vec&lt;(String, bool)&gt;,
    pub(crate) offset: Option&lt;i64&gt;,
    pub(crate) limit: Option&lt;usize&gt;,
}

// 因为 Rust trait 的孤儿规则，我们如果要想对已有的类型实现已有的 trait，
// 需要简单包装一下

pub struct Expression(pub(crate) Box&lt;SqlExpr&gt;);
pub struct Operation(pub(crate) SqlBinaryOperator);
pub struct Projection&lt;'a&gt;(pub(crate) &amp;'a SelectItem);
pub struct Source&lt;'a&gt;(pub(crate) &amp;'a [TableWithJoins]);
pub struct Order&lt;'a&gt;(pub(crate) &amp;'a OrderByExpr);
pub struct Offset&lt;'a&gt;(pub(crate) &amp;'a SqlOffset);
pub struct Limit&lt;'a&gt;(pub(crate) &amp;'a SqlExpr);
pub struct Value(pub(crate) SqlValue);
</code></pre></pre>
</div>
</details>
<details id="admonition-sql的转换" class="admonition note">
<summary class="admonition-title">
<p>sql的转换</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-sql的转换"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 把 SqlParser 解析出来的 Statement 转换成我们需要的结构
impl&lt;'a&gt; TryFrom&lt;&amp;'a Statement&gt; for Sql&lt;'a&gt; {
    type Error = anyhow::Error;

    fn try_from(sql: &amp;'a Statement) -&gt; Result&lt;Self, Self::Error&gt; {
        match sql {
            // 目前我们只关心 query (select ... from ... where ...)
            Statement::Query(q) =&gt; {
                let offset = q.offset.as_ref();
                let limit = q.limit.as_ref();
                let orders = &amp;q.order_by;
                let Select {
                    from: table_with_joins,
                    selection: where_clause,
                    projection,

                    group_by: _,
                    ..
                } = match &amp;q.body {
                    SetExpr::Select(statement) =&gt; statement.as_ref(),
                    _ =&gt; return Err(anyhow!(&quot;We only support Select Query at the moment&quot;)),
                };

                let source = Source(table_with_joins).try_into()?;

                let condition = match where_clause {
                    Some(expr) =&gt; Some(Expression(Box::new(expr.to_owned())).try_into()?),
                    None =&gt; None,
                };

                let mut selection = Vec::with_capacity(8);
                for p in projection {
                    let expr = Projection(p).try_into()?;
                    selection.push(expr);
                }

                let mut order_by = Vec::new();
                for expr in orders {
                    order_by.push(Order(expr).try_into()?);
                }

                let offset = offset.map(|v| Offset(v).into());
                let limit = limit.map(|v| Limit(v).into());

                Ok(Sql {
                    selection,
                    condition,
                    source,
                    order_by,
                    offset,
                    limit,
                })
            }
            _ =&gt; Err(anyhow!(&quot;We only support Query at the moment&quot;)),
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-对应部分结构体的转换" class="admonition note">
<summary class="admonition-title">
<p>对应部分结构体的转换</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-对应部分结构体的转换"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 把 SqlParser 的 Expr 转换成 DataFrame 的 Expr
impl TryFrom&lt;Expression&gt; for Expr {
    type Error = anyhow::Error;

    fn try_from(expr: Expression) -&gt; Result&lt;Self, Self::Error&gt; {
        match *expr.0 {
            SqlExpr::BinaryOp { left, op, right } =&gt; Ok(Expr::BinaryExpr {
                left: Box::new(Expression(left).try_into()?),
                op: Operation(op).try_into()?,
                right: Box::new(Expression(right).try_into()?),
            }),
            SqlExpr::Wildcard =&gt; Ok(Self::Wildcard),
            SqlExpr::IsNull(expr) =&gt; Ok(Self::IsNull(Box::new(Expression(expr).try_into()?))),
            SqlExpr::IsNotNull(expr) =&gt; Ok(Self::IsNotNull(Box::new(Expression(expr).try_into()?))),
            SqlExpr::Identifier(id) =&gt; Ok(Self::Column(Arc::new(id.value))),
            SqlExpr::Value(v) =&gt; Ok(Self::Literal(Value(v).try_into()?)),
            v =&gt; Err(anyhow!(&quot;expr {:#?} is not supported&quot;, v)),
        }
    }
}

/// 把 SqlParser 的 BinaryOperator 转换成 DataFrame 的 Operator
impl TryFrom&lt;Operation&gt; for Operator {
    type Error = anyhow::Error;

    fn try_from(op: Operation) -&gt; Result&lt;Self, Self::Error&gt; {
        match op.0 {
            SqlBinaryOperator::Plus =&gt; Ok(Self::Plus),
            SqlBinaryOperator::Minus =&gt; Ok(Self::Minus),
            SqlBinaryOperator::Multiply =&gt; Ok(Self::Multiply),
            SqlBinaryOperator::Divide =&gt; Ok(Self::Divide),
            SqlBinaryOperator::Modulo =&gt; Ok(Self::Modulus),
            SqlBinaryOperator::Gt =&gt; Ok(Self::Gt),
            SqlBinaryOperator::Lt =&gt; Ok(Self::Lt),
            SqlBinaryOperator::GtEq =&gt; Ok(Self::GtEq),
            SqlBinaryOperator::LtEq =&gt; Ok(Self::LtEq),
            SqlBinaryOperator::Eq =&gt; Ok(Self::Eq),
            SqlBinaryOperator::NotEq =&gt; Ok(Self::NotEq),
            SqlBinaryOperator::And =&gt; Ok(Self::And),
            SqlBinaryOperator::Or =&gt; Ok(Self::Or),
            v =&gt; Err(anyhow!(&quot;Operator {} is not supported&quot;, v)),
        }
    }
}

/// 把 SqlParser 的 SelectItem 转换成 DataFrame 的 Expr
impl&lt;'a&gt; TryFrom&lt;Projection&lt;'a&gt;&gt; for Expr {
    type Error = anyhow::Error;

    fn try_from(p: Projection&lt;'a&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        match p.0 {
            SelectItem::UnnamedExpr(SqlExpr::Identifier(id)) =&gt; Ok(col(&amp;id.to_string())),
            SelectItem::ExprWithAlias {
                expr: SqlExpr::Identifier(id),
                alias,
            } =&gt; Ok(Expr::Alias(
                Box::new(Expr::Column(Arc::new(id.to_string()))),
                Arc::new(alias.to_string()),
            )),
            SelectItem::QualifiedWildcard(v) =&gt; Ok(col(&amp;v.to_string())),
            SelectItem::Wildcard =&gt; Ok(col(&quot;*&quot;)),
            item =&gt; Err(anyhow!(&quot;projection {} not supported&quot;, item)),
        }
    }
}

impl&lt;'a&gt; TryFrom&lt;Source&lt;'a&gt;&gt; for &amp;'a str {
    type Error = anyhow::Error;

    fn try_from(source: Source&lt;'a&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        if source.0.len() != 1 {
            return Err(anyhow!(&quot;We only support single data source at the moment&quot;));
        }

        let table = &amp;source.0[0];
        if !table.joins.is_empty() {
            return Err(anyhow!(&quot;We do not support joint data source at the moment&quot;));
        }

        match &amp;table.relation {
            TableFactor::Table { name, .. } =&gt; Ok(&amp;name.0.first().unwrap().value),
            _ =&gt; Err(anyhow!(&quot;We only support table&quot;)),
        }
    }
}

/// 把 SqlParser 的 order by expr 转换成 (列名, 排序方法)
impl&lt;'a&gt; TryFrom&lt;Order&lt;'a&gt;&gt; for (String, bool) {
    type Error = anyhow::Error;

    fn try_from(o: Order) -&gt; Result&lt;Self, Self::Error&gt; {
        let name = match &amp;o.0.expr {
            SqlExpr::Identifier(id) =&gt; id.to_string(),
            expr =&gt; {
                return Err(anyhow!(
                    &quot;We only support identifier for order by, got {}&quot;,
                    expr
                ))
            }
        };

        Ok((name, !o.0.asc.unwrap_or(true)))
    }
}

/// 把 SqlParser 的 offset expr 转换成 i64
impl&lt;'a&gt; From&lt;Offset&lt;'a&gt;&gt; for i64 {
    fn from(offset: Offset) -&gt; Self {
        match offset.0 {
            SqlOffset {
                value: SqlExpr::Value(SqlValue::Number(v, _b)),
                ..
            } =&gt; v.parse().unwrap_or(0),
            _ =&gt; 0,
        }
    }
}

/// 把 SqlParser 的 Limit expr 转换成 usize
impl&lt;'a&gt; From&lt;Limit&lt;'a&gt;&gt; for usize {
    fn from(l: Limit&lt;'a&gt;) -&gt; Self {
        match l.0 {
            SqlExpr::Value(SqlValue::Number(v, _b)) =&gt; v.parse().unwrap_or(usize::MAX),
            _ =&gt; usize::MAX,
        }
    }
}

/// 把 SqlParser 的 value 转换成 DataFrame 支持的 LiteralValue
impl TryFrom&lt;Value&gt; for LiteralValue {
    type Error = anyhow::Error;
    fn try_from(v: Value) -&gt; Result&lt;Self, Self::Error&gt; {
        match v.0 {
            SqlValue::Number(v, _) =&gt; Ok(LiteralValue::Float64(v.parse().unwrap())),
            SqlValue::Boolean(v) =&gt; Ok(LiteralValue::Boolean(v)),
            SqlValue::Null =&gt; Ok(LiteralValue::Null),
            v =&gt; Err(anyhow!(&quot;Value {} is not supported&quot;, v)),
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-单元测试" class="admonition note">
<summary class="admonition-title">
<p>单元测试</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-单元测试"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {
    use super::*;
    use crate::TyrDialect;
    use sqlparser::parser::Parser;

    #[test]
    fn parse_sql_works() {
        let url = &quot;http://abc.xyz/abc?a=1&amp;b=2&quot;;
        let sql = format!(
            &quot;select a, b, c from {} where a=1 order by c desc limit 5 offset 10&quot;,
            url
        );
        let statement = &amp;Parser::parse_sql(&amp;TyrDialect::default(), sql.as_ref()).unwrap()[0];
        let sql: Sql = statement.try_into().unwrap();
        assert_eq!(sql.source, url);
        assert_eq!(sql.limit, Some(5));
        assert_eq!(sql.offset, Some(10));
        assert_eq!(sql.order_by, vec![(&quot;c&quot;.into(), true)]);
        assert_eq!(sql.selection, vec![col(&quot;a&quot;), col(&quot;b&quot;), col(&quot;c&quot;)]);
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="srcdialectrs"><a class="header" href="#srcdialectrs">src/dialect.rs</a></h3>
<details id="admonition-定义方言结构体" class="admonition note">
<summary class="admonition-title">
<p>定义方言结构体</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-定义方言结构体"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[derive(Debug, Default)]
pub struct TyrDialect;
</code></pre></pre>
</div>
</details>
<details id="admonition-给方言结构体实现trait" class="admonition note">
<summary class="admonition-title">
<p>给方言结构体实现trait</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-给方言结构体实现trait"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">// 创建自己的 sql 方言。TyrDialect 支持 identifier 可以是简单的 url
impl Dialect for TyrDialect {
    fn is_identifier_start(&amp;self, ch: char) -&gt; bool {
        ('a'..='z').contains(&amp;ch) || ('A'..='Z').contains(&amp;ch) || ch == '_'
    }

    // identifier 可以有 ':', '/', '?', '&amp;', '='
    fn is_identifier_part(&amp;self, ch: char) -&gt; bool {
        ('a'..='z').contains(&amp;ch)
            || ('A'..='Z').contains(&amp;ch)
            || ('0'..='9').contains(&amp;ch)
            || [':', '/', '?', '&amp;', '=', '-', '_', '.'].contains(&amp;ch)
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-添加测试用函数" class="admonition note">
<summary class="admonition-title">
<p>添加测试用函数</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-添加测试用函数"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 测试辅助函数
pub fn example_sql() -&gt; String {
    let url = &quot;https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv&quot;;

    let sql = format!(
        &quot;SELECT location name, total_cases, new_cases, total_deaths, new_deaths \
        FROM {} where new_deaths &gt;= 500 ORDER BY new_cases DESC LIMIT 6 OFFSET 5&quot;,
        url
    );

    sql
}
</code></pre></pre>
</div>
</details>
<details id="admonition-单元测试-1" class="admonition note">
<summary class="admonition-title">
<p>单元测试 </p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-单元测试-1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {
    use super::*;
    use sqlparser::parser::Parser;

    #[test]
    fn it_works() {
        assert!(Parser::parse_sql(&amp;TyrDialect::default(), &amp;example_sql()).is_ok());
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="srcloaderrs"><a class="header" href="#srcloaderrs">src/loader.rs</a></h3>
<details id="admonition-定义loader与csvloader" class="admonition note">
<summary class="admonition-title">
<p>定义Loader与CsvLoader</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-定义loader与csvloader"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[derive(Debug)]
#[non_exhaustive]
pub enum Loader {
    Csv(CsvLoader),
}

#[derive(Default, Debug)]
pub struct CsvLoader(pub(crate) String);
</code></pre></pre>
</div>
</details>
<details id="admonition-定义trait并给csvloader实现" class="admonition note">
<summary class="admonition-title">
<p>定义trait并给CsvLoader实现</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-定义trait并给csvloader实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
    let sql = format!(
        &quot;SELECT location name, total_cases, new_cases, total_deaths, new_deaths \
        FROM {} where new_deaths &gt;= 500 ORDER BY new_cases DESC LIMIT 6 OFFSET 5&quot;,
        url
    );

    sql
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlparser::parser::Parser;

</code></pre></pre>
</div>
</details>
<details id="admonition-todo-给csvloader添加内容检测" class="admonition note">
<summary class="admonition-title">
<p>todo: 给CsvLoader添加内容检测</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-todo-给csvloader添加内容检测"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">    fn it_works() {
        assert!(Parser::parse_sql(&amp;TyrDialect::default(), &amp;example_sql()).is_ok());
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="srcfetcherrs"><a class="header" href="#srcfetcherrs">src/fetcher.rs</a></h3>
<details id="admonition-定义urlfetcher与filefetcher" class="admonition note">
<summary class="admonition-title">
<p>定义UrlFetcher与FileFetcher</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-定义urlfetcher与filefetcher"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">struct UrlFetcher&lt;'a&gt;(pub(crate) &amp;'a str);

struct FileFetcher&lt;'a&gt;(pub(crate) &amp;'a str);
</code></pre></pre>
</div>
</details>
<details id="admonition-定义trait并给fetcher与filefetcher实现" class="admonition note">
<summary class="admonition-title">
<p>定义trait并给Fetcher与FileFetcher实现 </p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-定义trait并给fetcher与filefetcher实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">// Rust 的 async trait 还没有稳定，可以用 async_trait 宏
#[async_trait]
pub trait Fetch {
    type Error;
    async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt;;
}

#[async_trait]
impl&lt;'a&gt; Fetch for UrlFetcher&lt;'a&gt; {
    type Error = anyhow::Error;

    async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt; {
        Ok(reqwest::get(self.0).await?.text().await?)
    }
}

#[async_trait]
impl&lt;'a&gt; Fetch for FileFetcher&lt;'a&gt; {
    type Error = anyhow::Error;

    async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt; {
        Ok(fs::read_to_string(&amp;self.0[7..]).await?)
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-最后定义一个获取数据的方法" class="admonition note">
<summary class="admonition-title">
<p>最后定义一个获取数据的方法 </p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-最后定义一个获取数据的方法"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 从文件源或者 http 源中获取数据，返回字符串
pub async fn retrieve_data(source: impl AsRef&lt;str&gt;) -&gt; Result&lt;String&gt; {
    let name = source.as_ref();
    match &amp;name[..4] {
        // 包括 http / https
        &quot;http&quot; =&gt; UrlFetcher(name).fetch().await,
        // 处理 file://&lt;filename&gt;
        &quot;file&quot; =&gt; FileFetcher(name).fetch().await,
        _ =&gt; Err(anyhow!(&quot;We only support http/https/file at the moment&quot;)),
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="queryer-js-package-使用neon"><a class="header" href="#queryer-js-package-使用neon">queryer-js package: 使用neon</a></h2>
<details id="admonition-cargotoml-2" class="admonition note">
<summary class="admonition-title">
<p>Cargo.toml </p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-cargotoml-2"></a></p>
</summary>
<div>
<pre><code class="language-toml">[package]
name = &quot;queryer-js&quot;
version = &quot;0.1.0&quot;
license = &quot;ISC&quot;
edition = &quot;2021&quot;
exclude = [&quot;index.node&quot;]

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
anyhow = &quot;1&quot;
queryer = { path = &quot;../queryer&quot; }
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }

[dependencies.neon]
version = &quot;0.9&quot;
default-features = false
features = [&quot;napi-6&quot;]
</code></pre>
</div>
</details>
<details id="admonition-build-in-packagejson" class="admonition note">
<summary class="admonition-title">
<p>build in package.json</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-build-in-packagejson"></a></p>
</summary>
<div>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;queryer-js&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.node&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;cargo-cp-artifact -nc index.node -- cargo build --message-format=json-render-diagnostics&quot;,
    &quot;build-debug&quot;: &quot;npm run build --&quot;,
    &quot;build-release&quot;: &quot;npm run build -- --release&quot;,
    &quot;install&quot;: &quot;npm run build-release&quot;,
    &quot;test&quot;: &quot;cargo test&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;cargo-cp-artifact&quot;: &quot;^0.1&quot;
  }
}
</code></pre>
</div>
</details>
<details id="admonition-srclibrs" class="admonition note">
<summary class="admonition-title">
<p>src/lib.rs </p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-srclibrs"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use neon::prelude::*;

pub fn example_sql(mut cx: FunctionContext) -&gt; JsResult&lt;JsString&gt; {
    Ok(cx.string(queryer::example_sql()))
}

fn query(mut cx: FunctionContext) -&gt; JsResult&lt;JsString&gt; {
    let sql = cx.argument::&lt;JsString&gt;(0)?.value(&amp;mut cx);
    let output = match cx.argument::&lt;JsString&gt;(1) {
        Ok(v) =&gt; v.value(&amp;mut cx),
        Err(_) =&gt; &quot;csv&quot;.to_string(),
    };
    let rt = tokio::runtime::Runtime::new().unwrap();
    let data = rt.block_on(async { queryer::query(sql).await.unwrap() });

    match output.as_str() {
        &quot;csv&quot; =&gt; Ok(cx.string(data.to_csv().unwrap())),
        v =&gt; cx.throw_type_error(format!(&quot;Output type {} not supported&quot;, v)),
    }
}

#[neon::main]
fn main(mut cx: ModuleContext) -&gt; NeonResult&lt;()&gt; {
    cx.export_function(&quot;example_sql&quot;, example_sql)?;
    cx.export_function(&quot;query&quot;, query)?;
    Ok(())
}
</code></pre></pre>
</div>
</details>
<h2 id="queryer-py-package-使用pyo3"><a class="header" href="#queryer-py-package-使用pyo3">queryer-py package: 使用pyo3</a></h2>
<blockquote>
<p>python调用查询包</p>
</blockquote>
<details id="admonition-cargotoml-3" class="admonition note">
<summary class="admonition-title">
<p>Cargo.toml </p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-cargotoml-3"></a></p>
</summary>
<div>
<pre><code class="language-toml">[package]
name = &quot;queryer_py&quot; # Python 模块需要用下划线
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;


[lib]
crate-type = [&quot;cdylib&quot;] # 使用 cdylib 类型

[dependencies]
queryer = { path = &quot;../queryer&quot; } # 引入 queryer
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }

[dependencies.pyo3]
version = &quot;0.14&quot;
features = [&quot;extension-module&quot;]

[build-dependencies]
pyo3-build-config = &quot;0.14&quot;
</code></pre>
</div>
</details>
<details id="admonition-buildrs" class="admonition note">
<summary class="admonition-title">
<p>build.rs </p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-buildrs"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    pyo3_build_config::add_extension_module_link_args();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-srclibrs-1" class="admonition note">
<summary class="admonition-title">
<p>src/lib.rs</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-srclibrs-1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#![allow(clippy::needless_option_as_deref)]
use pyo3::{exceptions, prelude::*};

#[pyfunction]
pub fn example_sql() -&gt; PyResult&lt;String&gt; {
    Ok(queryer::example_sql())
}

#[pyfunction]
pub fn query(sql: &amp;str, output: Option&lt;&amp;str&gt;) -&gt; PyResult&lt;String&gt; {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let data = rt.block_on(async { queryer::query(sql).await.unwrap() });
    match output {
        Some(&quot;csv&quot;) | None =&gt; Ok(data.to_csv().unwrap()),
        Some(v) =&gt; Err(exceptions::PyTypeError::new_err(format!(
            &quot;Output type {} not supported&quot;,
            v
        ))),
    }
}

#[pymodule]
fn queryer_py(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(query, m)?)?;
    m.add_function(wrap_pyfunction!(example_sql, m)?)?;
    Ok(())
}
</code></pre></pre>
</div>
</details>
<h2 id="data-viewer-package-使用tauri"><a class="header" href="#data-viewer-package-使用tauri">data-viewer package: 使用tauri</a></h2>
<details id="admonition-cargotoml-4" class="admonition note">
<summary class="admonition-title">
<p>Cargo.toml</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-cargotoml-4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">[package]
name = &quot;app&quot;
version = &quot;0.1.0&quot;
description = &quot;A Tauri App&quot;
authors = [&quot;you&quot;]
license = &quot;&quot;
repository = &quot;&quot;
default-run = &quot;app&quot;
edition = &quot;2021&quot;
build = &quot;src/build.rs&quot;

<span class="boring">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</span>
[build-dependencies]
tauri-build = { version = &quot;1.0.0-beta.4&quot; }

[dependencies]
anyhow = &quot;1&quot;
serde_json = &quot;1&quot;
queryer = { path = &quot;../../queryer&quot; }
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
tauri = { version = &quot;1.0.0-beta.8&quot;, features = [&quot;api-all&quot;] }

[features]
default = [ &quot;custom-protocol&quot; ]
custom-protocol = [ &quot;tauri/custom-protocol&quot; ]
</code></pre></pre>
</div>
</details>
<details id="admonition-buildrs-1" class="admonition note">
<summary class="admonition-title">
<p>build.rs</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-buildrs-1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
  tauri_build::build()
}
</code></pre></pre>
</div>
</details>
<details id="admonition-mainrs" class="admonition note">
<summary class="admonition-title">
<p>main.rs </p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-mainrs"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#![cfg_attr(
  all(not(debug_assertions), target_os = &quot;windows&quot;),
  windows_subsystem = &quot;windows&quot;
)]

#[tauri::command]
fn example_sql() -&gt; String {
  queryer::example_sql()
}

#[tauri::command]
async fn query(sql: String) -&gt; Result&lt;String, String&gt; {
  let data = queryer::query(&amp;sql).await.map_err(|err| err.to_string())?;
  Ok(data.to_csv().map_err(|err| err.to_string())?)
}

fn main() {
  tauri::Builder::default()
    .invoke_handler(tauri::generate_handler![example_sql, query])
    .run(tauri::generate_context!())
    .expect(&quot;error while running tauri application&quot;);
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust核心深入"><a class="header" href="#rust核心深入">Rust核心深入</a></h1>
<h2 id="资料推荐"><a class="header" href="#资料推荐">资料推荐</a></h2>
<ul>
<li><a href="https://tyrchen.github.io/rust-training/rust-training-all-in-one-cn.html#1">陈天培训slides</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i-从栈堆所有权生命周期开始内存管理"><a class="header" href="#i-从栈堆所有权生命周期开始内存管理">I. 从栈堆、所有权、生命周期开始内存管理</a></h1>
<!--ts-->
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#i-%E4%BB%8E%E6%A0%88%E5%A0%86%E6%89%80%E6%9C%89%E6%9D%83%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BC%80%E5%A7%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">I. 从栈堆、所有权、生命周期开始内存管理</a></li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:16 UTC 2022 -->
<!--te-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存"><a class="header" href="#内存">内存</a></h1>
<!--ts-->
<ul>
<li><a href="1_1_stack_heap.html#%E5%86%85%E5%AD%98">内存</a>
<ul>
<li><a href="1_1_stack_heap.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%9B%BE">字符串内存使用图</a></li>
<li><a href="1_1_stack_heap.html#%E6%A0%88">栈</a>
<ul>
<li><a href="1_1_stack_heap.html#%E6%A0%88%E5%B8%A7%E7%A4%BA%E6%84%8F%E5%9B%BE">栈帧示意图</a></li>
<li><a href="1_1_stack_heap.html#%E8%80%83%E8%99%91%E6%A0%88%E6%BA%A2%E5%87%BA">考虑栈溢出</a></li>
</ul>
</li>
<li><a href="1_1_stack_heap.html#%E5%A0%86">堆</a>
<ul>
<li><a href="1_1_stack_heap.html#%E4%BD%BF%E7%94%A8%E5%A0%86%E5%BC%95%E7%94%A8%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">使用堆引用共享数据</a></li>
<li><a href="1_1_stack_heap.html#%E8%80%83%E8%99%91%E5%A0%86%E6%BA%A2%E5%87%BA">考虑堆溢出</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:14 UTC 2022 -->
<!--te-->
<h2 id="字符串内存使用图"><a class="header" href="#字符串内存使用图">字符串内存使用图</a></h2>
<details id="admonition-字符串内存使用图" class="admonition info">
<summary class="admonition-title">
<p>字符串内存使用图</p>
<p><a class="admonition-anchor-link" href="1_1_stack_heap.html#admonition-字符串内存使用图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/01%EF%BD%9C%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%BC%E6%94%BE%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%94%BE%E6%A0%88%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98.jpg" alt="字符串内存使用图" /></p>
</div>
</details>
<h2 id="栈"><a class="header" href="#栈">栈</a></h2>
<h3 id="栈帧示意图"><a class="header" href="#栈帧示意图">栈帧示意图</a></h3>
<details id="admonition-栈帧示意图" class="admonition info">
<summary class="admonition-title">
<p>栈帧示意图</p>
<p><a class="admonition-anchor-link" href="1_1_stack_heap.html#admonition-栈帧示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/01%EF%BD%9C%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%BC%E6%94%BE%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%94%BE%E6%A0%88%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98-4444135.jpg" alt="栈帧示意图" /></p>
</div>
</details>
<h3 id="考虑栈溢出"><a class="header" href="#考虑栈溢出">考虑栈溢出</a></h3>
<h2 id="堆"><a class="header" href="#堆">堆</a></h2>
<h3 id="使用堆引用共享数据"><a class="header" href="#使用堆引用共享数据">使用堆引用共享数据</a></h3>
<details id="admonition-使用堆引用共享内存数据" class="admonition info">
<summary class="admonition-title">
<p>使用堆引用共享内存数据</p>
<p><a class="admonition-anchor-link" href="1_1_stack_heap.html#admonition-使用堆引用共享内存数据"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/01%EF%BD%9C%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%BC%E6%94%BE%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%94%BE%E6%A0%88%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98-4444274.jpg" alt="使用堆引用共享数据" /></p>
</div>
</details>
<h3 id="考虑堆溢出"><a class="header" href="#考虑堆溢出">考虑堆溢出</a></h3>
<details id="admonition-堆问题示意图" class="admonition info">
<summary class="admonition-title">
<p>堆问题示意图</p>
<p><a class="admonition-anchor-link" href="1_1_stack_heap.html#admonition-堆问题示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/01%EF%BD%9C%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%BC%E6%94%BE%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%94%BE%E6%A0%88%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98.png" alt="堆问题" /></p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编程四大类基本概念"><a class="header" href="#编程四大类基本概念">编程四大类基本概念</a></h1>
<!--ts-->
<ul>
<li><a href="1_2_programming_basic_concepts.html#%E7%BC%96%E7%A8%8B%E5%9B%9B%E5%A4%A7%E7%B1%BB%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">编程四大类基本概念</a>
<ul>
<li><a href="1_2_programming_basic_concepts.html#1-%E6%95%B0%E6%8D%AE">1. 数据</a>
<ul>
<li><a href="1_2_programming_basic_concepts.html#%E5%80%BC%E5%92%8C%E7%B1%BB%E5%9E%8B">值和类型</a></li>
<li><a href="1_2_programming_basic_concepts.html#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8">指针和引用</a></li>
</ul>
</li>
<li><a href="1_2_programming_basic_concepts.html#2-%E4%BB%A3%E7%A0%81">2. 代码</a>
<ul>
<li><a href="1_2_programming_basic_concepts.html#%E5%87%BD%E6%95%B0---%E6%96%B9%E6%B3%95---%E9%97%AD%E5%8C%85">函数 -&gt; 方法 -&gt; 闭包</a>
<ul>
<li><a href="1_2_programming_basic_concepts.html#%E9%97%AD%E5%8C%85%E7%A4%BA%E6%84%8F%E5%9B%BE">闭包示意图</a></li>
</ul>
</li>
<li><a href="1_2_programming_basic_concepts.html#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%99%9A%E8%A1%A8">接口与虚表</a></li>
</ul>
</li>
<li><a href="1_2_programming_basic_concepts.html#3-%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F">3. 运行方式</a>
<ul>
<li><a href="1_2_programming_basic_concepts.html#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C">并发与并行</a></li>
<li><a href="1_2_programming_basic_concepts.html#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5">同步和异步</a></li>
</ul>
</li>
<li><a href="1_2_programming_basic_concepts.html#4-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F">4. 编程范式</a>
<ul>
<li><a href="1_2_programming_basic_concepts.html#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B">泛型编程</a></li>
<li><a href="1_2_programming_basic_concepts.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a></li>
<li><a href="1_2_programming_basic_concepts.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:14 UTC 2022 -->
<!--te-->
<h2 id="1-数据"><a class="header" href="#1-数据">1. 数据</a></h2>
<h3 id="值和类型"><a class="header" href="#值和类型">值和类型</a></h3>
<h3 id="指针和引用"><a class="header" href="#指针和引用">指针和引用</a></h3>
<h2 id="2-代码"><a class="header" href="#2-代码">2. 代码</a></h2>
<h3 id="函数---方法---闭包"><a class="header" href="#函数---方法---闭包">函数 -&gt; 方法 -&gt; 闭包</a></h3>
<h4 id="闭包示意图"><a class="header" href="#闭包示意图">闭包示意图</a></h4>
<details id="admonition-闭包与自由变量" class="admonition info">
<summary class="admonition-title">
<p>闭包与自由变量</p>
<p><a class="admonition-anchor-link" href="1_2_programming_basic_concepts.html#admonition-闭包与自由变量"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/02%EF%BD%9C%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%BA%9B%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpg" alt="闭包与自由变量" /></p>
</div>
</details>
<h3 id="接口与虚表"><a class="header" href="#接口与虚表">接口与虚表</a></h3>
<details id="admonition-虚表示意图" class="admonition info">
<summary class="admonition-title">
<p>虚表示意图</p>
<p><a class="admonition-anchor-link" href="1_2_programming_basic_concepts.html#admonition-虚表示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/02%EF%BD%9C%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%BA%9B%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4444557.jpg" alt="虚表" /></p>
</div>
</details>
<h2 id="3-运行方式"><a class="header" href="#3-运行方式">3. 运行方式</a></h2>
<h3 id="并发与并行"><a class="header" href="#并发与并行">并发与并行</a></h3>
<details id="admonition-并发与并行对比" class="admonition info">
<summary class="admonition-title">
<p>并发与并行对比</p>
<p><a class="admonition-anchor-link" href="1_2_programming_basic_concepts.html#admonition-并发与并行对比"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/02%EF%BD%9C%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%BA%9B%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4444672.jpg" alt="并发与并行" /></p>
</div>
</details>
<h3 id="同步和异步"><a class="header" href="#同步和异步">同步和异步</a></h3>
<h2 id="4-编程范式"><a class="header" href="#4-编程范式">4. 编程范式</a></h2>
<h3 id="泛型编程"><a class="header" href="#泛型编程">泛型编程</a></h3>
<details id="admonition-泛型编程更抽象更通用" class="admonition info">
<summary class="admonition-title">
<p>泛型编程更抽象，更通用</p>
<p><a class="admonition-anchor-link" href="1_2_programming_basic_concepts.html#admonition-泛型编程更抽象更通用"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/02%EF%BD%9C%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%BA%9B%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4444741.jpg" alt="泛型编程更抽象，更通用" /></p>
</div>
</details>
<h3 id="函数式编程"><a class="header" href="#函数式编程">函数式编程</a></h3>
<h3 id="面向对象编程"><a class="header" href="#面向对象编程">面向对象编程</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一所有权-单一共享"><a class="header" href="#一所有权-单一共享">一、所有权: 单一/共享</a></h1>
<!--ts-->
<ul>
<li><a href="1_3_ownership.html#%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83-%E5%8D%95%E4%B8%80%E5%85%B1%E4%BA%AB">一、所有权: 单一/共享</a>
<ul>
<li><a href="1_3_ownership.html#%E5%AF%B9%E6%AF%94%E5%8D%95%E4%B8%80%E5%85%B1%E4%BA%AB%E6%89%80%E6%9C%89%E6%9D%83">对比单一/共享所有权</a></li>
<li><a href="1_3_ownership.html#%E5%8D%95%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83%E6%8E%8C%E6%8E%A7%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83">单一所有权：掌控生杀大权</a>
<ul>
<li><a href="1_3_ownership.html#%E4%BB%8E%E5%A4%9A%E5%BC%95%E7%94%A8%E5%BC%80%E5%A7%8B">从多引用开始</a></li>
<li><a href="1_3_ownership.html#rust%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">Rust如何解决</a>
<ul>
<li><a href="1_3_ownership.html#%E6%96%B9%E6%A1%88%E4%B8%80%E5%8D%95%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83">方案一、单一所有权</a></li>
<li><a href="1_3_ownership.html#%E6%96%B9%E6%A1%88%E4%BA%8Ccopy">方案二、Copy</a></li>
</ul>
</li>
<li><a href="1_3_ownership.html#%E5%8D%95%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86">单一所有权规则整理</a></li>
<li><a href="1_3_ownership.html#%E5%8D%95%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83%E5%80%9F%E7%94%A8">单一所有权借用</a>
<ul>
<li><a href="1_3_ownership.html#%E4%B8%A4%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%E4%BC%A0%E5%80%BC%E4%BC%A0%E5%9D%80">两种传参方式：传值/传址</a></li>
<li><a href="1_3_ownership.html#%E5%8F%AA%E8%AF%BB%E5%80%9F%E7%94%A8%E5%BC%95%E7%94%A8">只读借用/引用</a></li>
<li><a href="1_3_ownership.html#%E5%80%9F%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E7%BA%A6%E6%9D%9F">借用的生命周期与约束</a></li>
<li><a href="1_3_ownership.html#%E5%8F%AF%E5%8F%98%E5%80%9F%E7%94%A8%E5%BC%95%E7%94%A8">可变借用/引用</a></li>
</ul>
</li>
<li><a href="1_3_ownership.html#%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3%E5%8D%95%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99">第一性原理理解单一所有权规则</a></li>
</ul>
</li>
<li><a href="1_3_ownership.html#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">共享内存-多个所有者：引用计数</a>
<ul>
<li><a href="1_3_ownership.html#rc%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-%E5%8F%AA%E8%AF%BB%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">Rc使用说明: 只读引用计数</a>
<ul>
<li><a href="1_3_ownership.html#rc%E4%BD%BF%E7%94%A8boxleak">Rc使用Box::leak()</a></li>
<li><a href="1_3_ownership.html#%E4%BD%BF%E7%94%A8rc%E5%AE%9E%E7%8E%B0dag">使用Rc实现DAG</a></li>
</ul>
</li>
<li><a href="1_3_ownership.html#refcell-%E6%8F%90%E4%BE%9B%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">RefCell: 提供内部可变性，可变引用计数</a>
<ul>
<li><a href="1_3_ownership.html#%E5%A4%96%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B8%8E%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7">外部可变性与内部可变性</a></li>
<li><a href="1_3_ownership.html#refcell%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">RefCell简单使用</a></li>
</ul>
</li>
<li><a href="1_3_ownership.html#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%88%E6%9C%AC%E8%AE%A1%E6%95%B0%E5%99%A8arcrcmutexrwlockrefcell">线程安全版本计数器：Arc(Rc)、Mutex/RwLock(RefCell)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:15 UTC 2022 -->
<!--te-->
<h2 id="对比单一共享所有权"><a class="header" href="#对比单一共享所有权">对比单一/共享所有权</a></h2>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4606985.jpg" alt="单一/共享所有权对比" /></p>
<h2 id="单一所有权掌控生杀大权"><a class="header" href="#单一所有权掌控生杀大权">单一所有权：掌控生杀大权</a></h2>
<h3 id="从多引用开始"><a class="header" href="#从多引用开始">从多引用开始</a></h3>
<details id="admonition-多重堆引用问题" class="admonition info">
<summary class="admonition-title">
<p>多重堆引用问题</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-多重堆引用问题"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/07%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%81%E6%89%8B%E4%B8%8A%EF%BC%9F-4446989.jpg" alt="多重堆引用的问题" /></p>
</div>
</details>
<h3 id="rust如何解决"><a class="header" href="#rust如何解决">Rust如何解决</a></h3>
<h4 id="方案一单一所有权"><a class="header" href="#方案一单一所有权">方案一、单一所有权</a></h4>
<details id="admonition-单一所有权解决多重引用问题" class="admonition info">
<summary class="admonition-title">
<p>单一所有权解决多重引用问题</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-单一所有权解决多重引用问题"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/07%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%81%E6%89%8B%E4%B8%8A%EF%BC%9F-4446891.jpg" alt="rust所有权规则解决多重引用问题" /></p>
</div>
</details>
<h4 id="方案二copy"><a class="header" href="#方案二copy">方案二、Copy</a></h4>
<details id="admonition-使用copy解决多重引用问题" class="admonition info">
<summary class="admonition-title">
<p>使用Copy解决多重引用问题</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-使用copy解决多重引用问题"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/07%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%81%E6%89%8B%E4%B8%8A%EF%BC%9F-4447051.jpg" alt="Copy解决" /></p>
</div>
</details>
<h3 id="单一所有权规则整理"><a class="header" href="#单一所有权规则整理">单一所有权规则整理</a></h3>
<details id="admonition-单一所有权规则整理" class="admonition info">
<summary class="admonition-title">
<p>单一所有权规则整理</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-单一所有权规则整理"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/07%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%81%E6%89%8B%E4%B8%8A%EF%BC%9F-4447111.jpg" alt="所有权规则整理" /></p>
</div>
</details>
<h3 id="单一所有权借用"><a class="header" href="#单一所有权借用">单一所有权借用</a></h3>
<h4 id="两种传参方式传值传址"><a class="header" href="#两种传参方式传值传址">两种传参方式：传值/传址</a></h4>
<details id="admonition-传值-or-传址" class="admonition info">
<summary class="admonition-title">
<p>传值 or 传址</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-传值-or-传址"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/08%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F.jpg" alt="传值/传址" /></p>
</div>
</details>
<h4 id="只读借用引用"><a class="header" href="#只读借用引用">只读借用/引用</a></h4>
<details id="admonition-只读借用引用" class="admonition info">
<summary class="admonition-title">
<p>只读借用/引用</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-只读借用引用"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/08%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F-4447323.jpg" alt="只读" /></p>
</div>
</details>
<h4 id="借用的生命周期与约束"><a class="header" href="#借用的生命周期与约束">借用的生命周期与约束</a></h4>
<details id="admonition-三段生命周期分析" class="admonition info">
<summary class="admonition-title">
<p>三段生命周期分析</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-三段生命周期分析"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/08%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F-4447702.jpg" alt="三段生命周期分析" /></p>
</div>
</details>
<h4 id="可变借用引用"><a class="header" href="#可变借用引用">可变借用/引用</a></h4>
<blockquote>
<p>同一个上下文中多个可变引用是不安全的，那如果同时有一个可变引用和若干个只读引 用就可以</p>
</blockquote>
<h3 id="第一性原理理解单一所有权规则"><a class="header" href="#第一性原理理解单一所有权规则">第一性原理理解单一所有权规则</a></h3>
<details id="admonition-第一性原理理解所有权模型单一所有权共享所有权" class="admonition info">
<summary class="admonition-title">
<p>第一性原理理解所有权模型：单一所有权/共享所有权</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-第一性原理理解所有权模型单一所有权共享所有权"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/08%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F-4447883.jpg" alt="第一性原理" /></p>
</div>
</details>
<h2 id="共享内存-多个所有者引用计数"><a class="header" href="#共享内存-多个所有者引用计数">共享内存-多个所有者：引用计数</a></h2>
<details id="admonition-单一所有权与多个所有者是否有冲突" class="admonition info">
<summary class="admonition-title">
<p>单一所有权与多个所有者是否有冲突？</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-单一所有权与多个所有者是否有冲突"></a></p>
</summary>
<div>
<ol>
<li>静态检查：单一所有权是rust的编译期默认检查内容</li>
<li>动态检查：多个所有者主要是用于共享内存，这是专门提供Rc/Arc、Box::leak()、RefCell/Mutex/RwLock等工具。</li>
</ol>
<hr />
<blockquote>
<p>这里其实可以看出rust如何使用’二八法则’解决问题：</p>
</blockquote>
<ul>
<li>对于常用场景，用编译期静态检查来默认解决</li>
<li>对于特别场景，用专门的语法显式表达出来，提供运行期动态检查来专门解决</li>
</ul>
</div>
</details>
<h3 id="rc使用说明-只读引用计数"><a class="header" href="#rc使用说明-只读引用计数">Rc使用说明: 只读引用计数</a></h3>
<details id="admonition-对一个-rc-结构进行-clone不会将其内部的数据复制只会增加引用计数" class="admonition info">
<summary class="admonition-title">
<p>对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-对一个-rc-结构进行-clone不会将其内部的数据复制只会增加引用计数"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::rc::Rc;
fn main() {
    let a = Rc::new(1);
    let b = a.clone();
    let c = a.clone();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-上方代码rc引用计数示意图共享堆内存" class="admonition info">
<summary class="admonition-title">
<p>上方代码Rc引用计数示意图：共享堆内存</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-上方代码rc引用计数示意图共享堆内存"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4604653.jpg" alt="引用计数示意图" /></p>
</div>
</details>
<details id="admonition-clone源码" class="admonition info">
<summary class="admonition-title">
<p>clone源码</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-clone源码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn clone(&amp;self) -&gt; Rc&lt;T&gt; {
    // 增加引用计数
    self.inner().inc_strong();
    // 通过 self.ptr 生成一个新的 Rc 结构
    Self::from_inner(self.ptr)
}
</code></pre></pre>
</div>
</details>
<h4 id="rc使用boxleak"><a class="header" href="#rc使用boxleak">Rc使用Box::leak()</a></h4>
<details id="admonition-使用boxleak创建不受栈内存控制堆堆内存示意图" class="admonition info">
<summary class="admonition-title">
<p>使用Box::leak()创建不受栈内存控制堆堆内存示意图</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-使用boxleak创建不受栈内存控制堆堆内存示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4605420.jpg" alt="使用Box::leak()创建不受栈内存控制堆堆内存示意图" /></p>
</div>
</details>
<details id="admonition-有了-boxleak我们就可以跳出-rust-编译器的静态检查" class="admonition info">
<summary class="admonition-title">
<p>有了 Box::leak()，我们就可以跳出 Rust 编译器的静态检查</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-有了-boxleak我们就可以跳出-rust-编译器的静态检查"></a></p>
</summary>
<div>
<p>保证 Rc 指向的堆内存，有最大的生命周期，然后我们再通过引用计数，在合适的时机，结束这段内存的生命周期。如果你对此感兴趣，可以看 <a href="https://doc.rust-lang.org/src/alloc/rc.rs.html#342-350">Rc::new() 的源码</a>。</p>
</div>
</details>
<h4 id="使用rc实现dag"><a class="header" href="#使用rc实现dag">使用Rc实现DAG</a></h4>
<details id="admonition-dag数据结构示意图" class="admonition info">
<summary class="admonition-title">
<p>DAG数据结构示意图</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-dag数据结构示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4607216.jpg" alt="DAG数据结构" /></p>
</div>
</details>
<details id="admonition-不可修改版本" class="admonition info">
<summary class="admonition-title">
<p>不可修改版本</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-不可修改版本"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::rc::Rc;

#[allow(dead_code)]
#[derive(Debug)]
struct Node {
    id: usize,
    downstream: Option&lt;Rc&lt;Node&gt;&gt;,
}

impl Node {
    pub fn new(id: usize) -&gt; Self {
        Self {
            id,
            downstream: None,
        }
    }

    pub fn update_downstream(&amp;mut self, downstream: Rc&lt;Node&gt;) {
        self.downstream = Some(downstream);
    }

    pub fn get_downstream(&amp;self) -&gt; Option&lt;Rc&lt;Node&gt;&gt; {
        self.downstream.as_ref().cloned()
    }
}

fn main() {
    let mut node1 = Node::new(1);
    let mut node2 = Node::new(2);
    let mut node3 = Node::new(3);
    let node4 = Node::new(4);
    node3.update_downstream(Rc::new(node4));

    node1.update_downstream(Rc::new(node3));
    node2.update_downstream(node1.get_downstream().unwrap());
    println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);

    // 无法编译通过: cannot borrow as mutable
    // let node5 = Node::new(5);
    // let node3 = node1.get_downstream().unwrap();
    // node3.update_downstream(Rc::new(node5));

    // println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);
}
</code></pre></pre>
<ul>
<li>new()：建立一个新的 Node。</li>
<li>update_downstream()：设置 Node 的 downstream。</li>
<li>get_downstream()：clone 一份 Node 里的 downstream。</li>
</ul>
</div>
</details>
<h3 id="refcell-提供内部可变性可变引用计数"><a class="header" href="#refcell-提供内部可变性可变引用计数">RefCell: 提供内部可变性，可变引用计数</a></h3>
<h4 id="外部可变性与内部可变性"><a class="header" href="#外部可变性与内部可变性">外部可变性与内部可变性</a></h4>
<details id="admonition-外部可变性与内部可变性对比图" class="admonition info">
<summary class="admonition-title">
<p>外部可变性与内部可变性对比图</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-外部可变性与内部可变性对比图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4606188-4606221.jpg" alt="外部可变性与内部可变性" /></p>
</div>
</details>
<details id="admonition-refcell内部可变性示意图" class="admonition info">
<summary class="admonition-title">
<p>RefCell内部可变性示意图</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-refcell内部可变性示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4606429.jpg" alt="使用RefCell实现可修改版本DAG" /></p>
</div>
</details>
<h4 id="refcell简单使用"><a class="header" href="#refcell简单使用">RefCell简单使用</a></h4>
<details id="admonition-获得-refcell-内部数据的可变借用" class="admonition info">
<summary class="admonition-title">
<p>获得 RefCell 内部数据的可变借用</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-获得-refcell-内部数据的可变借用"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::cell::RefCell;

fn main() {
    let data = RefCell::new(1);
    {
        // 获得 RefCell 内部数据的可变借用
        let mut v = data.borrow_mut();
        *v += 1;
    }
    println!(&quot;data: {:?}&quot;, data.borrow());
}
</code></pre></pre>
</div>
</details>
<details id="admonition-使用refcell实现可修改版本dag" class="admonition info">
<summary class="admonition-title">
<p>使用RefCell实现可修改版本DAG</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-使用refcell实现可修改版本dag"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::cell::RefCell;
use std::rc::Rc;

#[allow(dead_code)]
#[derive(Debug)]
struct Node {
    id: usize,
    // 使用 Rc&lt;RefCell&lt;T&gt;&gt; 让节点可以被修改
    downstream: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

impl Node {
    pub fn new(id: usize) -&gt; Self {
        Self {
            id,
            downstream: None,
        }
    }

    pub fn update_downstream(&amp;mut self, downstream: Rc&lt;RefCell&lt;Node&gt;&gt;) {
        self.downstream = Some(downstream);
    }

    pub fn get_downstream(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt; {
        self.downstream.as_ref().cloned()
    }
}

fn main() {
    let mut node1 = Node::new(1);
    let mut node2 = Node::new(2);
    let mut node3 = Node::new(3);
    let node4 = Node::new(4);

    node3.update_downstream(Rc::new(RefCell::new(node4)));
    node1.update_downstream(Rc::new(RefCell::new(node3)));
    node2.update_downstream(node1.get_downstream().unwrap());
    println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);

    let node5 = Node::new(5);
    let node3 = node1.get_downstream().unwrap();
    // 获得可变引用，来修改 downstream
    node3.borrow_mut().downstream = Some(Rc::new(RefCell::new(node5)));

    println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);
}
</code></pre></pre>
<hr />
<ol>
<li>首先数据结构的 downstream 需要 Rc 内部嵌套一个 RefCell</li>
<li>这样，就可以利用 RefCell 的内部可变性，来获得数据的可变借用</li>
<li>同时 Rc 还允许值有多个所有者。</li>
</ol>
</div>
</details>
<h3 id="线程安全版本计数器arcrcmutexrwlockrefcell"><a class="header" href="#线程安全版本计数器arcrcmutexrwlockrefcell">线程安全版本计数器：Arc(Rc)、Mutex/RwLock(RefCell)</a></h3>
<details id="admonition-rust实现两套不同的引用计数数据结构" class="admonition info">
<summary class="admonition-title">
<p>Rust实现两套不同的引用计数数据结构</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-rust实现两套不同的引用计数数据结构"></a></p>
</summary>
<div>
<blockquote>
<p>Arc 内部的引用计数使用了 <a href="https://doc.rust-lang.org/src/alloc/sync.rs.html#303-312">Atomic Usize</a> ，而非普通的 usize。
从名称上也可以感觉出来，Atomic Usize 是 usize 的原子类型，它使用了 CPU 的特殊指令，来保证多线程下的安全。
如果你对原子类型感兴趣，可以看 <a href="https://doc.rust-lang.org/std/sync/atomic/index.html">std::sync::atomic</a> 的文档。</p>
</blockquote>
<p>Rust 实现两套不同的引用计数数据结构，完全是为了性能考虑，从这里我们也可以感受到 Rust 对性能的极致渴求:</p>
<ul>
<li>如果不用跨线程访问，可以用效率非常高的 Rc； 如果要跨线程访问，那么必须用 Arc。</li>
<li>同样的，RefCell 也不是线程安全的，如果我们要在多线程中，使用内部可变性，Rust 提供了 Mutex 和 RwLock。</li>
</ul>
</div>
</details>
<details id="admonition-mutexrwlock其实是并发的两个方案" class="admonition info">
<summary class="admonition-title">
<p>Mutex/RwLock其实是并发的两个方案</p>
<p><a class="admonition-anchor-link" href="1_3_ownership.html#admonition-mutexrwlock其实是并发的两个方案"></a></p>
</summary>
<div>
<p>这两个数据结构你应该都不陌生:</p>
<ol>
<li>Mutex 是互斥量，获得互斥量的线程对数据独占访问.</li>
<li>RwLock 是读写锁，获得写锁的线程对数据独占访问，但当没有写锁的时候，允许有多个读锁。 </li>
<li>读写锁的规则和 Rust 的借用规则非常类似，我们可以类比着学。</li>
<li>Mutex 和 RwLock 都用在多线程环境下，对共享数据访问的保护上。</li>
<li>前面构建的 DAG 如果要用在多线程环境下，需要把 Rc&gt; 替换为 Arc&gt; 或者 Arc&gt;。</li>
</ol>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二生命周期"><a class="header" href="#二生命周期">二、生命周期</a></h1>
<!--ts-->
<ul>
<li><a href="1_4_lifetime.html#%E4%BA%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">二、生命周期</a>
<ul>
<li><a href="1_4_lifetime.html#%E5%8A%A8%E6%80%81%E8%BF%98%E6%98%AF%E9%9D%99%E6%80%81">动态还是静态？</a></li>
<li><a href="1_4_lifetime.html#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">如何识别生命周期</a>
<ul>
<li><a href="1_4_lifetime.html#%E4%B8%A4%E4%B8%AA%E5%B0%8F%E4%BE%8B%E5%AD%90">两个小例子</a></li>
<li><a href="1_4_lifetime.html#%E9%9C%80%E8%A6%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E7%9A%84%E6%83%85%E5%86%B5">需要生命周期标注的情况</a></li>
<li><a href="1_4_lifetime.html#%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B6%E5%AE%9E%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8">编译器其实会自动进行生命周期标注</a></li>
<li><a href="1_4_lifetime.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E7%BB%83%E4%B9%A0">生命周期标注练习</a></li>
<li><a href="1_4_lifetime.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E7%9A%84%E7%9B%AE%E7%9A%84">生命周期标注的目的</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:15 UTC 2022 -->
<!--te-->
<h2 id="动态还是静态"><a class="header" href="#动态还是静态">动态还是静态？</a></h2>
<details id="admonition-动态静态生命周期定义与表示方式" class="admonition info">
<summary class="admonition-title">
<p>动态/静态生命周期定义与表示方式</p>
<p><a class="admonition-anchor-link" href="1_4_lifetime.html#admonition-动态静态生命周期定义与表示方式"></a></p>
</summary>
<div>
<ol>
<li>静态生命周期: ’static str</li>
</ol>
<ul>
<li>如果一个值的生命周期贯穿整个进程的生命周期，那么我们就称这种生命周期为静态生命周期。</li>
<li>当值拥有静态生命周期，其引用也具有静态生命周期。</li>
<li>我们在表述这种引用的时候，可以用 ’static 来表示。比如： &amp;’static str 代表这是一个具有静态生命周期的字符串引用。</li>
<li>一般来说，全局变量、静态变量、字符串字面量（string literal (字面) ）等，都拥有静态生命周期。</li>
<li>堆内存，如果使用了 Box::leak 后，也具有静态生命周期。</li>
</ul>
<ol start="2">
<li>动态生命周期: ’a 、’b 或者 ’hello 这样的小写字符或者字符串来表述</li>
</ol>
<ul>
<li>如果一个值是在某个作用域中定义的，也就是说它被创建在栈上或者堆上，那么其生命周期是动态的。</li>
<li>当这个值的作用域结束时，值的生命周期也随之结束。</li>
<li>对于动态生命周期，我们约定用 ’a 、’b 或者 ’hello 这样的小写字符或者字符串来表述。 </li>
<li>’ 后面具体是什么名字不重要，它代表某一段动态的生命周期</li>
<li>其中， &amp;’a str 和 &amp;’b str 表示这两个字符串引用的生命周期可能不一致。</li>
</ul>
</div>
</details>
<details id="admonition-动静态生命周期示意图" class="admonition info">
<summary class="admonition-title">
<p>动静态生命周期示意图</p>
<p><a class="admonition-anchor-link" href="1_4_lifetime.html#admonition-动静态生命周期示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/10%EF%BD%9C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%BD%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%80%BC%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%B4%BB%E5%A4%9A%E4%B9%85%EF%BC%9F.jpg" alt="动静态生命周期示意图" /></p>
<ol>
<li>分配在堆和栈上的内存有其各自的作用域，它们的生命周期是动态的。</li>
<li>全局变量、静态变量、字符串字面量、代码等内容，在编译时，会被编译到可执行文件中的 BSS/Data/RoData/Text 段，然后在加载时，装入内存。</li>
<li>因而，它们的生命周期和进程的生命周期一致，所以是静态的。</li>
<li>所以，函数指针的生命周期也是静态的，因为函数在 Text 段中，只要进程活着，其内存一直存在。</li>
</ol>
</div>
</details>
<h2 id="如何识别生命周期"><a class="header" href="#如何识别生命周期">如何识别生命周期</a></h2>
<h3 id="两个小例子"><a class="header" href="#两个小例子">两个小例子</a></h3>
<details id="admonition-两个小例子" class="admonition info">
<summary class="admonition-title">
<p>两个小例子</p>
<p><a class="admonition-anchor-link" href="1_4_lifetime.html#admonition-两个小例子"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/10%EF%BD%9C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%BD%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%80%BC%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%B4%BB%E5%A4%9A%E4%B9%85%EF%BC%9F-4607802.jpg" alt="识别生命周期的两个小例子" /></p>
<ol>
<li>x 引用了在内层作用域中创建出来的变量 y。由于，变量从开始定义到其作用域结束的这段时间，是它的生命周期，所以 x 的生命周期 ’a 大于 y 的生命周期 ’b，当 x 引用 y 时，编译器报错。</li>
</ol>
<hr />
<ol start="2">
<li>y 和 x 处在同一个作用域下， x 引用了 y，我们可以看到 x 的生命周期 ’a 和 y 的生命周期 ’b 几乎同时结束，或者说 ’a 小于等于 ’b，所以，x 引用 y 是可行的。</li>
</ol>
</div>
</details>
<h3 id="需要生命周期标注的情况"><a class="header" href="#需要生命周期标注的情况">需要生命周期标注的情况</a></h3>
<details id="admonition-missing-lifetime-specifier" class="admonition info">
<summary class="admonition-title">
<p>missing lifetime specifier</p>
<p><a class="admonition-anchor-link" href="1_4_lifetime.html#admonition-missing-lifetime-specifier"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let s1 = String::from(&quot;Lindsey&quot;);
    let s2 = String::from(&quot;Rosie&quot;);

    let result = max(&amp;s1, &amp;s2);

    println!(&quot;bigger one: {}&quot;, result);

    let result = get_max(s1);
    println!(&quot;bigger one: {}&quot;, result);
}

fn get_max(s1: &amp;str) -&gt; &amp;str {
    // 字符串字面量的生命周期是静态的，而 s1 是动态的，它们的生命周期显然不一致
    max(s1, &quot;Cynthia&quot;)
}

// 这段代码无法编译通过
fn max(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {
    if s1 &gt; s2 {
        s1
    } else {
        s2
    }
}
</code></pre></pre>
<ol>
<li>编译器在编译 max() 函数时，无法判断 s1、s2 和返回值的生命周期。</li>
<li>函数本身携带的信息，就是编译器在编译时使用的全部信息。</li>
<li>这里函数本身提供的信息就告诉编译期，生命周期不一致</li>
</ol>
</div>
</details>
<details id="admonition-添加生命周期标注即可编译通过" class="admonition info">
<summary class="admonition-title">
<p>添加生命周期标注即可编译通过</p>
<p><a class="admonition-anchor-link" href="1_4_lifetime.html#admonition-添加生命周期标注即可编译通过"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let s1 = String::from(&quot;Lindsey&quot;);
    let s2 = String::from(&quot;Rosie&quot;);

    let result = max(&amp;s1, &amp;s2);

    println!(&quot;bigger one: {}&quot;, result);

    let result = get_max(&amp;s1);
    println!(&quot;bigger one: {}&quot;, result);
}

fn get_max(s1: &amp;str) -&gt; &amp;str {
    max(s1, &quot;Cynthia&quot;)
}

fn max&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {
    if s1 &gt; s2 {
        s1
    } else {
        s2
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="编译器其实会自动进行生命周期标注"><a class="header" href="#编译器其实会自动进行生命周期标注">编译器其实会自动进行生命周期标注</a></h3>
<blockquote>
<p>编译器希望尽可能减轻开发者的负担，其实所有使用了引用的函数，都需要生命周期的标注，只不过编译器会自动做这件事，省却了开发者的麻烦</p>
</blockquote>
<details id="admonition-编译器自动进行生命周期标注" class="admonition info">
<summary class="admonition-title">
<p>编译器自动进行生命周期标注</p>
<p><a class="admonition-anchor-link" href="1_4_lifetime.html#admonition-编译器自动进行生命周期标注"></a></p>
</summary>
<div>
<ol>
<li>无标注版本</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let s1 = &quot;Hello world&quot;;

    println!(&quot;first word of s1: {}&quot;, first(s1));
}

// 如果你用 clippy，多余的 lifetime 会提醒你不需要
// fn first&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
fn first(s: &amp;str) -&gt; &amp;str {
    let trimmed = s.trim();
    match trimmed.find(' ') {
        None =&gt; &quot;&quot;,
        Some(pos) =&gt; &amp;trimmed[..pos],
    }
}
</code></pre></pre>
<hr />
<ol start="2">
<li>自动标注</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let s1 = &quot;Lindsey&quot;;
    let s2 = String::from(&quot;Rosie&quot;);

    let result = max(s1, &amp;s2);

    println!(&quot;bigger one: {}&quot;, result);
}

fn max&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {
    if s1 &gt; s2 {
        s1
    } else {
        s2
    }
}
</code></pre></pre>
<blockquote>
<p>返回值如何标注？是 ’a 还是’b 呢？这里的冲突，编译器无能为力。</p>
</blockquote>
</div>
</details>
<details id="admonition-自动标注规则" class="admonition info">
<summary class="admonition-title">
<p>自动标注规则</p>
<p><a class="admonition-anchor-link" href="1_4_lifetime.html#admonition-自动标注规则"></a></p>
</summary>
<div>
<ol>
<li>所有引用类型的参数都有独立的生命周期 ’a 、’b 等。</li>
<li>如果只有一个引用型输入，它的生命周期会赋给所有输出。</li>
<li>如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出。</li>
</ol>
</div>
</details>
<h3 id="生命周期标注练习"><a class="header" href="#生命周期标注练习">生命周期标注练习</a></h3>
<details id="admonition-标注练习题" class="admonition info">
<summary class="admonition-title">
<p>标注练习题</p>
<p><a class="admonition-anchor-link" href="1_4_lifetime.html#admonition-标注练习题"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn strtok(s: &amp;mut &amp;str, delimiter: char) -&gt; &amp;str {
    if let Some(i) = s.find(delimiter) {
        let prefix = &amp;s[..i];
        // 由于 delimiter 可以是 utf8，所以我们需要获得其 utf8 长度，
        // 直接使用 len 返回的是字节长度，会有问题
        let suffix = &amp;s[(i + delimiter.len_utf8())..];
        *s = suffix;
        prefix
    } else { // 如果没找到，返回整个字符串，把原字符串指针 s 指向空串
        let prefix = *s;
        *s = &quot;&quot;;
        prefix
    }
}

fn main() {
    let s = &quot;hello world&quot;.to_owned();
    let mut s1 = s.as_str();
    let hello = strtok(&amp;mut s1, ' ');
    println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);
}
</code></pre></pre>
<ol>
<li>按照编译器的规则， &amp;mut &amp;str 添加生命周期后变成 &amp;’b mut &amp;’a str</li>
<li>这将导致返回的 ’&amp;str 无法选择一个合适的生命周期。</li>
</ol>
</div>
</details>
<details id="admonition-标注练习题参考" class="admonition info">
<summary class="admonition-title">
<p>标注练习题参考</p>
<p><a class="admonition-anchor-link" href="1_4_lifetime.html#admonition-标注练习题参考"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">pub fn strtok&lt;'a&gt;(s: &amp;mut &amp;'a str, delimiter: char) -&gt; &amp;'a str {
    if let Some(i) = s.find(delimiter) {
        let prefix = &amp;s[..i];
        let suffix = &amp;s[(i + delimiter.len_utf8())..];
        *s = suffix;
        prefix
    } else {
        let prefix = *s;
        *s = &quot;&quot;;
        prefix
    }
}

fn main() {
    let s = &quot;hello world&quot;.to_owned();
    let mut s1 = s.as_str();
    let hello = strtok(&amp;mut s1, ' ');
    println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);
}
</code></pre></pre>
<hr />
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/10%EF%BD%9C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%BD%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%80%BC%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%B4%BB%E5%A4%9A%E4%B9%85%EF%BC%9F-4609161.jpg" alt="标注练习示意图" /></p>
</div>
</details>
<h3 id="生命周期标注的目的"><a class="header" href="#生命周期标注的目的">生命周期标注的目的</a></h3>
<details id="admonition-生命周期标注的目的是在参数和返回值之间建立联系或者约束" class="admonition info">
<summary class="admonition-title">
<p>生命周期标注的目的是，在参数和返回值之间建立联系或者约束</p>
<p><a class="admonition-anchor-link" href="1_4_lifetime.html#admonition-生命周期标注的目的是在参数和返回值之间建立联系或者约束"></a></p>
</summary>
<div>
<p>生命周期标注的目的是，在参数和返回值之间建立联系或者约束:</p>
<ol>
<li>调用函数时，传入的参数的生命周期需要大于等于标注的生命周期。</li>
<li>当每个函数都添加好生命周期标注后，编译器，就可以从函数调用的上下文中分析出，在传参时，引用的生命周期，是否和函数签名中要求的生命周期匹配。</li>
<li>如果不匹配，就违背了“引用的生命周期不能超出值的生命周期”，编译器就会报错。</li>
</ol>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三融会贯通从创建到消亡"><a class="header" href="#三融会贯通从创建到消亡">三、融会贯通，从创建到消亡</a></h1>
<!--ts-->
<ul>
<li><a href="1_5_go_through.html#%E4%B8%89%E8%9E%8D%E4%BC%9A%E8%B4%AF%E9%80%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1">三、融会贯通，从创建到消亡</a>
<ul>
<li><a href="1_5_go_through.html#%E5%88%9B%E5%BB%BA">创建</a>
<ul>
<li><a href="1_5_go_through.html#%E5%A0%86%E5%86%85%E5%AD%98%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%8F%91%E5%B1%95%E5%8F%B2">堆内存生命周期管理发展史</a></li>
<li><a href="1_5_go_through.html#structenumvecstring%E5%88%9B%E5%BB%BA%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">struct/enum/vec/String创建时的内存布局</a>
<ul>
<li><a href="1_5_go_through.html#struct">struct</a></li>
<li><a href="1_5_go_through.html#enum">enum</a></li>
<li><a href="1_5_go_through.html#vec%E5%92%8Cstring">vec和String</a></li>
<li><a href="1_5_go_through.html#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">引用类型的内存布局</a></li>
</ul>
</li>
<li><a href="1_5_go_through.html#%E6%9B%B4%E5%A4%9A%E5%8F%AF%E8%A7%81cheatsrs">更多可见cheats.rs</a></li>
</ul>
</li>
<li><a href="1_5_go_through.html#%E4%BD%BF%E7%94%A8">使用</a>
<ul>
<li><a href="1_5_go_through.html#copy%E5%92%8Cmove">copy和move</a></li>
</ul>
</li>
<li><a href="1_5_go_through.html#%E9%94%80%E6%AF%81">销毁</a>
<ul>
<li><a href="1_5_go_through.html#drop%E9%87%8A%E6%94%BE%E5%A0%86%E5%86%85%E5%AD%98">drop释放堆内存</a></li>
<li><a href="1_5_go_through.html#raii%E9%87%8A%E6%94%BE%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90">RAII释放其他资源</a></li>
<li><a href="1_5_go_through.html#rust%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%9F%A5%E8%B0%83%E7%94%A8drop">Rust在编译时、运行时检查调用drop</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:16 UTC 2022 -->
<!--te-->
<h2 id="创建"><a class="header" href="#创建">创建</a></h2>
<h3 id="堆内存生命周期管理发展史"><a class="header" href="#堆内存生命周期管理发展史">堆内存生命周期管理发展史</a></h3>
<details id="admonition-堆内存生命周期管理发展史" class="admonition info">
<summary class="admonition-title">
<p>堆内存生命周期管理发展史</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-堆内存生命周期管理发展史"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.jpg" alt="堆内存生命周期管理发展史" /></p>
</div>
</details>
<details id="admonition-堆内存管理需求动态大小-or-生命周期" class="admonition info">
<summary class="admonition-title">
<p>堆内存管理需求：动态大小 or 生命周期</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-堆内存管理需求动态大小-or-生命周期"></a></p>
</summary>
<div>
<p>Rust 的创造者们，重新审视了堆内存的生命周期，发现:</p>
<ul>
<li>大部分堆内存的需求在于动态大小</li>
<li>小部分需求是更长的生命周期。</li>
</ul>
<blockquote>
<p>所以它默认将堆内存的生命周期和使用它的栈内存的生命周期绑在一起，并留了个小口子 leaked 机制，让堆内存在需要的时候，可以有超出帧存活期的生命周期。</p>
</blockquote>
<hr />
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4639705.jpg" alt="Rust与其他编程语言堆内存管理对比" /></p>
</div>
</details>
<h3 id="structenumvecstring创建时的内存布局"><a class="header" href="#structenumvecstring创建时的内存布局">struct/enum/vec/String创建时的内存布局</a></h3>
<h4 id="struct"><a class="header" href="#struct">struct</a></h4>
<details id="admonition-内存布局优化示意图" class="admonition info">
<summary class="admonition-title">
<p>内存布局优化示意图</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-内存布局优化示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4639867.jpg" alt="内存布局优化示意图" /></p>
</div>
</details>
<details id="admonition-c语言手动优化内存布局" class="admonition info">
<summary class="admonition-title">
<p>c语言手动优化内存布局</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-c语言手动优化内存布局"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4639905.jpg" alt="c语言手动优化内存布局" /></p>
</div>
</details>
<details id="admonition-c语言手动优化内存布局与rust自动优化内存布局对比" class="admonition info">
<summary class="admonition-title">
<p>c语言手动优化内存布局与rust自动优化内存布局对比</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-c语言手动优化内存布局与rust自动优化内存布局对比"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4639936.jpg" alt="c语言手动优化内存布局与rust自动优化内存布局对比" /></p>
</div>
</details>
<details id="admonition-代码对比rust和clang的内存布局优化" class="admonition info">
<summary class="admonition-title">
<p>代码对比rust和clang的内存布局优化</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-代码对比rust和clang的内存布局优化"></a></p>
</summary>
<div>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct S1 {
    u_int8_t a;
    u_int16_t b;
    u_int8_t c;
};

struct S2 {
    u_int8_t a;
    u_int8_t c;
    u_int16_t b;
};

void main() {
    printf(&quot;size of S1: %d, S2: %d&quot;, sizeof(struct S1), sizeof(struct S2));
}
</code></pre>
<hr />
<pre><pre class="playground"><code class="language-rust  editable">use std::mem::{align_of, size_of};

#[allow(dead_code)]
struct S1 {
    a: u8,
    b: u16,
    c: u8,
}

#[allow(dead_code)]
struct S2 {
    a: u8,
    c: u8,
    b: u16,
}

fn main() {
    println!(&quot;sizeof S1: {}, S2: {}&quot;, size_of::&lt;S1&gt;(), size_of::&lt;S2&gt;());
    println!(&quot;alignof S1: {}, S2: {}&quot;, align_of::&lt;S1&gt;(), align_of::&lt;S2&gt;());
}
</code></pre></pre>
</div>
</details>
<h4 id="enum"><a class="header" href="#enum">enum</a></h4>
<details id="admonition-enumoptionresult内存布局对比" class="admonition info">
<summary class="admonition-title">
<p>enum/Option<T>/Result&lt;T,E&gt;内存布局对比</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-enumoptionresult内存布局对比"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4640218.jpg" alt="enum/Option&lt;T&gt;/Result&lt;T,E&gt;内存布局对比" /></p>
</div>
</details>
<details id="admonition-rust-编译器会对-enum-做一些额外的优化让某些常用结构的内存布局更紧凑" class="admonition info">
<summary class="admonition-title">
<p>Rust 编译器会对 enum 做一些额外的优化，让某些常用结构的内存布局更紧凑。</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-rust-编译器会对-enum-做一些额外的优化让某些常用结构的内存布局更紧凑"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::collections::HashMap;
use std::mem::size_of;

#[allow(dead_code)]
enum E {
    A(f64),
    B(HashMap&lt;String, String&gt;),
    C(Result&lt;Vec&lt;u8&gt;, String&gt;),
}

macro_rules! show_size {
    (header) =&gt; {
        println!(
            &quot;{:&lt;24} {:&gt;4}    {}    {}&quot;,
            &quot;Type&quot;, &quot;T&quot;, &quot;Option&lt;T&gt;&quot;, &quot;Result&lt;T, io::Error&gt;&quot;
        );
        println!(&quot;{}&quot;, &quot;-&quot;.repeat(64));
    };
    ($t:ty) =&gt; {
        println!(
            &quot;{:&lt;24} {:4} {:8} {:12}&quot;,
            stringify!($t),
            size_of::&lt;$t&gt;(),
            size_of::&lt;Option&lt;$t&gt;&gt;(),
            size_of::&lt;Result&lt;$t, std::io::Error&gt;&gt;(),
        )
    };
}

fn main() {
    show_size!(header);
    show_size!(u8);
    show_size!(f64);
    show_size!(&amp;u8);
    show_size!(Box&lt;u8&gt;);
    show_size!(&amp;[u8]);

    show_size!(String);
    show_size!(Vec&lt;u8&gt;);
    show_size!(HashMap&lt;String, String&gt;);
    show_size!(E);
}
</code></pre></pre>
<hr />
<blockquote>
<p>你会发现，Option 配合带有引用类型的数据结构，比如 &amp;u8、Box、Vec、HashMap ，没有额外占用空间，这就很有意思了</p>
</blockquote>
<pre><code class="language-shell">
Type                        T    Option&lt;T&gt;    Result&lt;T, io::Error&gt;
----------------------------------------------------------------
u8                          1        2           24
f64                         8       16           24
&amp;u8                         8        8           24
Box&lt;u8&gt;                     8        8           24
&amp;[u8]                      16       16           24
String                     24       24           32
Vec&lt;u8&gt;                    24       24           32
HashMap&lt;String, String&gt;    48       48           56
E                          56       56           64
</code></pre>
<hr />
<p>Rust 是这么处理的:</p>
<ol>
<li>我们知道，引用类型的第一个域是个指针，而指针是不可能等于 0 的，</li>
<li>但是我们可以复用这个指针：当其为 0 时，表示 None，否则是 Some，减少了内存占用，这是个非常巧妙的优化</li>
</ol>
</div>
</details>
<h4 id="vec和string"><a class="header" href="#vec和string">vec<T>和String</a></h4>
<details id="admonition-string其实就是vec" class="admonition info">
<summary class="admonition-title">
<p>String其实就是Vec<u8></p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-string其实就是vec"></a></p>
</summary>
<div>
<p>String 和 Vec 占用相同的大小，都是 24 个字节。其实，如果你打开 String 结构的<a href="https://doc.rust-lang.org/src/alloc/string.rs.html#279-281">源码</a>，可以看到，它内部就是一个 Vec</p>
</div>
</details>
<details id="admonition-vec-结构是-3-个-word-的胖指针" class="admonition info">
<summary class="admonition-title">
<p>Vec 结构是 3 个 word 的胖指针</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-vec-结构是-3-个-word-的胖指针"></a></p>
</summary>
<div>
<h2 id=""><a class="header" href="#"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4640654.jpg" alt="vec就是一个胖指针" /></a></h2>
<p>包含：</p>
<ol>
<li>一个指向堆内存的指针 pointer</li>
<li>分配的堆内存的容量 capacity</li>
<li>以及数据在堆内存的长度 length</li>
</ol>
</div>
</details>
<h4 id="引用类型的内存布局"><a class="header" href="#引用类型的内存布局">引用类型的内存布局</a></h4>
<details id="admonition-引用类型的内存布局" class="admonition info">
<summary class="admonition-title">
<p>引用类型的内存布局</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-引用类型的内存布局"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.png" alt="引用类型的内存布局" /></p>
</div>
</details>
<h3 id="更多可见cheatsrs"><a class="header" href="#更多可见cheatsrs">更多可见cheats.rs</a></h3>
<ul>
<li><a href="https://cheats.rs/#data-layout">Rust Language Cheat Sheet</a></li>
</ul>
<h2 id="使用-1"><a class="header" href="#使用-1">使用</a></h2>
<h3 id="copy和move"><a class="header" href="#copy和move">copy和move</a></h3>
<details id="admonition-copy和move的内部实现都只是浅层按位做内存复制" class="admonition info">
<summary class="admonition-title">
<p>copy和move的内部实现都只是浅层按位做内存复制</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-copy和move的内部实现都只是浅层按位做内存复制"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4640936.jpg" alt="copy和move的内部实现都只是浅层按位做内存复制" /></p>
</div>
</details>
<h2 id="销毁"><a class="header" href="#销毁">销毁</a></h2>
<h3 id="drop释放堆内存"><a class="header" href="#drop释放堆内存">drop释放堆内存</a></h3>
<details id="admonition-当一个值被释放其实就是调用它的drop方法" class="admonition info">
<summary class="admonition-title">
<p>当一个值被释放，其实就是调用它的drop方法</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-当一个值被释放其实就是调用它的drop方法"></a></p>
</summary>
<div>
<h2 id="-1"><a class="header" href="#-1"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4641072.jpg" alt="当一个值被释放，其实就是调用它的drop方法" /></a></h2>
<ol>
<li>变量 greeting 是一个字符串，在退出作用域时，其 drop() 函数被自动调用</li>
<li>释放堆上包含 “hello world” 的内存</li>
<li>然后再释放栈上的内存</li>
</ol>
</div>
</details>
<details id="admonition-复杂结构递归调用drop" class="admonition info">
<summary class="admonition-title">
<p>复杂结构递归调用drop</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-复杂结构递归调用drop"></a></p>
</summary>
<div>
<h2 id="-2"><a class="header" href="#-2"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4641173.jpg" alt="复杂结构递归调用drop" /></a></h2>
<blockquote>
<p>如果要释放的值是一个复杂的数据结构，比如一个结构体，那么:</p>
</blockquote>
<ol>
<li>这个结构体在调用 drop() 时，会依次调用每一个域的 drop() 函数</li>
<li>如果域又是一个复杂的结构或者集合类型，就会递归下去</li>
<li>直到每一个域都释放干净。</li>
</ol>
<hr />
<ul>
<li>student 变量是一个结构体，有 name、age、scores。</li>
<li>其中 name 是 String，scores 是 HashMap，它们本身需要额外 drop()。</li>
<li>又因为 HashMap 的 key 是 String，所以还需要进一步调用这些 key 的 drop()。</li>
</ul>
<blockquote>
<p>整个释放顺序从内到外是：先释放 HashMap 下的 key，然后释放 HashMap 堆上的表结构，最后释放栈上的内存</p>
</blockquote>
</div>
</details>
<h3 id="raii释放其他资源"><a class="header" href="#raii释放其他资源">RAII释放其他资源</a></h3>
<details id="admonition-rust基于raii释放文件资源" class="admonition info">
<summary class="admonition-title">
<p>Rust基于RAII释放文件资源</p>
<p><a class="admonition-anchor-link" href="1_5_go_through.html#admonition-rust基于raii释放文件资源"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::fs::File;
use std::io::prelude::*;
fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut file = File::create(&quot;foo.txt&quot;)?;
    file.write_all(b&quot;Hello, world!&quot;)?;
    Ok(())
}
</code></pre></pre>
</div>
</details>
<h3 id="rust在编译时运行时检查调用drop"><a class="header" href="#rust在编译时运行时检查调用drop">Rust在编译时、运行时检查调用drop</a></h3>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4641604.jpg" alt="Rust在编译时、运行时检查调用drop" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ii-类型系统"><a class="header" href="#ii-类型系统">II. 类型系统</a></h1>
<!--ts-->
<ul>
<li><a href="2_type_system.html#ii-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">II. 类型系统</a></li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:18 UTC 2022 -->
<!--te-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型系统"><a class="header" href="#类型系统">类型系统</a></h1>
<!--ts-->
<ul>
<li><a href="2_1_type_details.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">类型系统</a>
<ul>
<li><a href="2_1_type_details.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB%E5%9B%BE">类型系统分类图</a>
<ul>
<li><a href="2_1_type_details.html#%E4%B8%89%E4%B8%AA%E6%A0%87%E5%87%86">三个标准</a></li>
<li><a href="2_1_type_details.html#rust%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9">Rust类型系统特点</a></li>
</ul>
</li>
<li><a href="2_1_type_details.html#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">类型分类</a>
<ul>
<li><a href="2_1_type_details.html#%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B">原生类型</a></li>
<li><a href="2_1_type_details.html#%E7%BB%84%E5%90%88%E7%B1%BB%E5%9E%8B">组合类型</a></li>
<li><a href="2_1_type_details.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E5%90%88%E7%B1%BB%E5%9E%8B">自定义组合类型</a></li>
</ul>
</li>
<li><a href="2_1_type_details.html#%E5%B0%8F%E4%BE%8B%E5%AD%90">小例子</a>
<ul>
<li><a href="2_1_type_details.html#%E5%B8%B8%E9%87%8F">常量</a></li>
</ul>
</li>
<li><a href="2_1_type_details.html#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">类型推导</a></li>
<li><a href="2_1_type_details.html#turbofish">Turbofish</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:17 UTC 2022 -->
<!--te-->
<h2 id="类型系统分类图"><a class="header" href="#类型系统分类图">类型系统分类图</a></h2>
<div id="admonition-类型系统分类图" class="admonition info">
<div class="admonition-title">
<p>类型系统分类图</p>
<p><a class="admonition-anchor-link" href="2_1_type_details.html#admonition-类型系统分类图"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F.jpg" alt="类型系统分类图" /></p>
</div>
</div>
<h3 id="三个标准"><a class="header" href="#三个标准">三个标准</a></h3>
<ol>
<li>隐式转换</li>
<li>检查时机</li>
<li>多态支持</li>
</ol>
<h3 id="rust类型系统特点"><a class="header" href="#rust类型系统特点">Rust类型系统特点</a></h3>
<div id="admonition-rust的类型系统有什么特点" class="admonition info">
<div class="admonition-title">
<p>Rust的类型系统有什么特点？</p>
<p><a class="admonition-anchor-link" href="2_1_type_details.html#admonition-rust的类型系统有什么特点"></a></p>
</div>
<div>
<h2 id="-3"><a class="header" href="#-3"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F-4257735.jpg" alt="Rust的类型系统有什么特点？" /></a></h2>
<p>强类型 + 静态类型 + 显式类型</p>
</div>
</div>
<h2 id="类型分类"><a class="header" href="#类型分类">类型分类</a></h2>
<h3 id="原生类型"><a class="header" href="#原生类型">原生类型</a></h3>
<details id="admonition-rust原声类型" class="admonition info">
<summary class="admonition-title">
<p>Rust原声类型</p>
<p><a class="admonition-anchor-link" href="2_1_type_details.html#admonition-rust原声类型"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F-4257523.jpg" alt="Rust原生类型" /></p>
</div>
</details>
<h3 id="组合类型"><a class="header" href="#组合类型">组合类型</a></h3>
<details id="admonition-rust组合类型" class="admonition info">
<summary class="admonition-title">
<p>Rust组合类型</p>
<p><a class="admonition-anchor-link" href="2_1_type_details.html#admonition-rust组合类型"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F-4257587.jpg" alt="Rust组合类型" /></p>
</div>
</details>
<h3 id="自定义组合类型"><a class="header" href="#自定义组合类型">自定义组合类型</a></h3>
<h2 id="小例子"><a class="header" href="#小例子">小例子</a></h2>
<h3 id="常量"><a class="header" href="#常量">常量</a></h3>
<details id="admonition-常量定义使用" class="admonition info">
<summary class="admonition-title">
<p>常量定义使用</p>
<p><a class="admonition-anchor-link" href="2_1_type_details.html#admonition-常量定义使用"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">const PI: f64 = std::f64::consts::PI;
static E: f32 = std::f32::consts::E;

fn main() {
    const V: u32 = 10;
    static V1: &amp;str = &quot;hello&quot;;
    println!(&quot;PI: {}, E: {}, V {}, V1: {}&quot;, PI, E, V, V1);
}
</code></pre></pre>
</div>
</details>
<h2 id="类型推导"><a class="header" href="#类型推导">类型推导</a></h2>
<details id="admonition-rust编译器可以从上下文自动推导类型" class="admonition info">
<summary class="admonition-title">
<p>Rust编译器可以从上下文自动推导类型</p>
<p><a class="admonition-anchor-link" href="2_1_type_details.html#admonition-rust编译器可以从上下文自动推导类型"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::collections::BTreeMap;

fn main() {
    let mut map = BTreeMap::new();
    // 没有这一行就缺少自动推导信息
    // map.insert(&quot;hello&quot;, &quot;world&quot;);
    println!(&quot;map: {:?}&quot;, map);
}
</code></pre></pre>
<hr />
<p>把第 5 行这个作用域内的 insert 语句注释去掉，Rust 编译器就会报错：“cannot infer type for type parameter K”。</p>
</div>
</details>
<details id="admonition-rust编译器不能获取足够上下文信息时就需要明确类型" class="admonition info">
<summary class="admonition-title">
<p>Rust编译器不能获取足够上下文信息时，就需要明确类型</p>
<p><a class="admonition-anchor-link" href="2_1_type_details.html#admonition-rust编译器不能获取足够上下文信息时就需要明确类型"></a></p>
</summary>
<div>
<ol>
<li>无法自动推导collect返回什么类型</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let even_numbers = numbers
        .into_iter()
        .filter(|n| n % 2 == 0)
        .collect();

    println!(&quot;{:?}&quot;, even_numbers);
}
</code></pre></pre>
<hr />
<ol start="2">
<li>给even_numbers添加类型声明即可</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let even_numbers: Vec&lt;_&gt; = numbers
        .into_iter()
        .filter(|n| n % 2 == 0)
        .collect();

    println!(&quot;{:?}&quot;, even_numbers);
}
</code></pre></pre>
<blockquote>
<p>这里编译器只是无法推断出集合类型，但集合类型内部元素的类型，还是可以根据上下文得出，所以我们可以简写成 Vec&lt;_&gt;</p>
</blockquote>
<ol start="3">
<li>也可以让 collect 返回一个明确的类型</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let even_numbers = numbers
        .into_iter()
        .filter(|n| n % 2 == 0)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;{:?}&quot;, even_numbers);
}
</code></pre></pre>
<hr />
<blockquote>
<p>这里在泛型函数后使用 :: 来强制使用类型 T，这种写法被称为 turbofish</p>
</blockquote>
</div>
</details>
<h2 id="turbofish"><a class="header" href="#turbofish">Turbofish</a></h2>
<details id="admonition-一个对-ip-地址和端口转换的例子" class="admonition info">
<summary class="admonition-title">
<p>一个对 IP 地址和端口转换的例子</p>
<p><a class="admonition-anchor-link" href="2_1_type_details.html#admonition-一个对-ip-地址和端口转换的例子"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::net::SocketAddr;

fn main() {
    let addr = &quot;127.0.0.1:8080&quot;.parse::&lt;SocketAddr&gt;().unwrap();
    println!(&quot;addr: {:?}, port: {:?}&quot;, addr.ip(), addr.port());
}
</code></pre></pre>
</div>
</details>
<details id="admonition-如果类型在上下文无法被推导出来又没有-turbofish-的写法我们就不得不先给一个局部变量赋值时声明类型然后再返回这样代码就变得冗余" class="admonition info">
<summary class="admonition-title">
<p>如果类型在上下文无法被推导出来，又没有 turbofish 的写法，我们就不得不先给一个局部变量赋值时声明类型，然后再返回，这样代码就变得冗余</p>
<p><a class="admonition-anchor-link" href="2_1_type_details.html#admonition-如果类型在上下文无法被推导出来又没有-turbofish-的写法我们就不得不先给一个局部变量赋值时声明类型然后再返回这样代码就变得冗余"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match data {
    Some(s) =&gt; v.parse::&lt;User&gt;()?,
    _ =&gt; return Err(...),
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<!--ts-->
<ul>
<li><a href="2_2_generic.html#%E6%B3%9B%E5%9E%8B">泛型</a>
<ul>
<li><a href="2_2_generic.html#%E6%B3%9B%E5%9E%8B%E5%B0%B1%E5%83%8F%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">泛型就像定义函数</a></li>
<li><a href="2_2_generic.html#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a></li>
<li><a href="2_2_generic.html#%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">泛型数据结构</a>
<ul>
<li><a href="2_2_generic.html#%E9%80%90%E6%AD%A5%E7%BA%A6%E6%9D%9F%E6%8A%8A%E5%86%B3%E7%AD%96%E4%BA%A4%E7%BB%99%E4%BD%BF%E7%94%A8%E8%80%85">逐步约束：把决策交给使用者</a></li>
</ul>
</li>
<li><a href="2_2_generic.html#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0">泛型参数</a>
<ul>
<li><a href="2_2_generic.html#%E5%8F%82%E6%95%B0%E5%A4%9A%E6%80%81">参数多态</a></li>
<li><a href="2_2_generic.html#%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">三种使用场景</a>
<ul>
<li><a href="2_2_generic.html#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A">延迟绑定</a></li>
<li><a href="2_2_generic.html#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A-1">延迟绑定</a></li>
<li><a href="2_2_generic.html#%E5%A4%9A%E4%B8%AA%E5%AE%9E%E7%8E%B0">多个实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="2_2_generic.html#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0">泛型函数</a>
<ul>
<li><a href="2_2_generic.html#%E5%8D%95%E6%80%81%E5%8C%96">单态化</a>
<ul>
<li><a href="2_2_generic.html#%E4%BC%98%E5%8A%A3">优劣</a></li>
</ul>
</li>
<li><a href="2_2_generic.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E6%90%BA%E5%B8%A6%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0">返回值携带泛型参数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:17 UTC 2022 -->
<!--te-->
<h2 id="泛型就像定义函数"><a class="header" href="#泛型就像定义函数">泛型就像定义函数</a></h2>
<ol>
<li>函数，是把重复代码中的参数抽取出来，使其更加通用，调用函数的时候，根据参数的不同，我们得到不同的结果；</li>
<li>而泛型，是把重复数据结构中的参数抽取出来，在使用泛型类型时，根据不同的参数，我们会得到不同的具体类型。</li>
</ol>
<details id="admonition-泛型结构vec例子" class="admonition info">
<summary class="admonition-title">
<p>泛型结构Vec<T>例子</p>
<p><a class="admonition-anchor-link" href="2_2_generic.html#admonition-泛型结构vec例子"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct Vec&lt;T, A: Allocator = Global&gt; {
    buf: RawVec&lt;T, A&gt;,
    len: usize,
}

pub struct RawVec&lt;T, A: Allocator = Global&gt; {
    ptr: Unique&lt;T&gt;,
    cap: usize,
    alloc: A,
}
</code></pre></pre>
<hr />
<p>Vec有两个参数:</p>
<ol>
<li>一个是 T，是列表里的每个数据的类型</li>
<li>另一个是 A，它有进一步的限制 A: Allocator </li>
</ol>
<blockquote>
<p>也就是说 A 需要满足 Allocator trait。
A 这个参数有默认值 Global，它是 Rust 默认的全局分配器</p>
</blockquote>
<ol start="3">
<li>这也是为什么 Vec 虽然有两个参数，使用时都只需要用 T。</li>
</ol>
</div>
</details>
<details id="admonition-枚举类型cow例子" class="admonition info">
<summary class="admonition-title">
<p>枚举类型Cow<T>例子</p>
<p><a class="admonition-anchor-link" href="2_2_generic.html#admonition-枚举类型cow例子"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub enum Cow&lt;'a, B: ?Sized + 'a&gt; where B: ToOwned,
{
    // 借用的数据
    Borrowed(&amp;'a B),
    // 拥有的数据
    Owned(&lt;B as ToOwned&gt;::Owned),
}
</code></pre></pre>
<p>这里对 B 的三个约束分别是：</p>
<ol>
<li>生命周期 ’a</li>
<li>长度可变 ?Sized</li>
<li>符合 ToOwned trait</li>
</ol>
</div>
</details>
<details id="admonition-cow" class="admonition info">
<summary class="admonition-title">
<p>Cow</p>
<p><a class="admonition-anchor-link" href="2_2_generic.html#admonition-cow"></a></p>
</summary>
<div>
<p>Cow（Clone-on-Write）是 Rust 中一个很有意思且很重要的数据结构。它就像 Option 一样，在返回数据的时候，提供了一种可能：要么返回一个借用的数据（只读），要么返回一个拥有所有权的数据（可写）。</p>
</div>
</details>
<details id="admonition-sized代表可变大小" class="admonition info">
<summary class="admonition-title">
<p>?Sized代表可变大小</p>
<p><a class="admonition-anchor-link" href="2_2_generic.html#admonition-sized代表可变大小"></a></p>
</summary>
<div>
<p>?Sized 是一种特殊的约束写法，? 代表可以放松问号之后的约束。由于 Rust 默认的泛型参数都需要是 Sized，也就是固定大小的类型，所以这里 ?Sized 代表用可变大小的类型。</p>
</div>
</details>
<details id="admonition-toowned" class="admonition info">
<summary class="admonition-title">
<p>ToOwned</p>
<p><a class="admonition-anchor-link" href="2_2_generic.html#admonition-toowned"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html">ToOwned</a> 是一个 trait，它可以把借用的数据克隆出一个拥有所有权的数据。</p>
</div>
</details>
<details id="admonition-owned" class="admonition info">
<summary class="admonition-title">
<p><B as ToOwned>::Owned</p>
<p><a class="admonition-anchor-link" href="2_2_generic.html#admonition-owned"></a></p>
</summary>
<div>
<h2 id="它对-b-做了一个强制类型转换转成-toowned-trait然后访问-toowned-trait-内部的-owned-类型"><a class="header" href="#它对-b-做了一个强制类型转换转成-toowned-trait然后访问-toowned-trait-内部的-owned-类型">它对 B 做了一个强制类型转换，转成 ToOwned trait，然后访问 ToOwned trait 内部的 Owned 类型</a></h2>
<p>因为在 Rust 里，子类型可以强制转换成父类型，B 可以用 ToOwned 约束，所以它是 ToOwned trait 的子类型，因而 B 可以安全地强制转换成 ToOwned。这里 B as ToOwned 是成立的。</p>
</div>
</details>
<h2 id="实现方式"><a class="header" href="#实现方式">实现方式</a></h2>
<details id="admonition-不同语言实现泛型的方式" class="admonition info">
<summary class="admonition-title">
<p>不同语言实现泛型的方式</p>
<p><a class="admonition-anchor-link" href="2_2_generic.html#admonition-不同语言实现泛型的方式"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F.png" alt="不同语言实现泛型的方式" /></p>
</div>
</details>
<h2 id="泛型数据结构"><a class="header" href="#泛型数据结构">泛型数据结构</a></h2>
<h3 id="逐步约束把决策交给使用者"><a class="header" href="#逐步约束把决策交给使用者">逐步约束：把决策交给使用者</a></h3>
<details id="admonition-在不同的实现下逐步添加约束" class="admonition info">
<summary class="admonition-title">
<p>在不同的实现下逐步添加约束</p>
<p><a class="admonition-anchor-link" href="2_2_generic.html#admonition-在不同的实现下逐步添加约束"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::fs::File;
use std::io::{BufReader, Read, Result};

struct MyReader&lt;R&gt; {
    reader: R,
    buf: String,
}

impl&lt;R&gt; MyReader&lt;R&gt; {
    pub fn new(reader: R) -&gt; Self {
        Self {
            reader,
            buf: String::with_capacity(1024),
        }
    }
}

impl&lt;R&gt; MyReader&lt;R&gt;
where
    R: Read,
{
    pub fn process(&amp;mut self) -&gt; Result&lt;usize&gt; {
        self.reader.read_to_string(&amp;mut self.buf)
    }
}

fn main() {
    let f = File::open(&quot;/etc/hosts&quot;).unwrap();
    let mut reader = MyReader::new(BufReader::new(f));

    let size = reader.process().unwrap();
    println!(&quot;total size read: {}&quot;, size);
}
</code></pre></pre>
</div>
</details>
<h2 id="泛型参数"><a class="header" href="#泛型参数">泛型参数</a></h2>
<h3 id="参数多态"><a class="header" href="#参数多态">参数多态</a></h3>
<h3 id="三种使用场景"><a class="header" href="#三种使用场景">三种使用场景</a></h3>
<h4 id="延迟绑定"><a class="header" href="#延迟绑定">延迟绑定</a></h4>
<h4 id="延迟绑定-1"><a class="header" href="#延迟绑定-1">延迟绑定</a></h4>
<h4 id="多个实现"><a class="header" href="#多个实现">多个实现</a></h4>
<h2 id="泛型函数"><a class="header" href="#泛型函数">泛型函数</a></h2>
<h3 id="单态化"><a class="header" href="#单态化">单态化</a></h3>
<details id="admonition-编译时展开泛型参数单态化" class="admonition info">
<summary class="admonition-title">
<p>编译时展开泛型参数单态化</p>
<p><a class="admonition-anchor-link" href="2_2_generic.html#admonition-编译时展开泛型参数单态化"></a></p>
</summary>
<div>
<blockquote>
<p>对于泛型函数，Rust 会进行单态化（Monomorphization）处理，也就是在编译时，把所有用到的泛型函数的泛型参数展开，生成若干个函数。
所以，下方的 id() 编译后会得到 一个处理后的多个版本</p>
</blockquote>
<hr />
<pre><pre class="playground"><code class="language-rust  editable">fn id&lt;T&gt;(x: T) -&gt; T {
    x
}

fn main() {
    let int = id(42);
    let string = id(&quot;Tyr&quot;);
    println!(&quot;{}, {}&quot;, int, string);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-单态化的优劣" class="admonition info">
<summary class="admonition-title">
<p>单态化的优劣</p>
<p><a class="admonition-anchor-link" href="2_2_generic.html#admonition-单态化的优劣"></a></p>
</summary>
<div>
<ol>
<li>单态化的好处是:</li>
</ol>
<ul>
<li>泛型函数的调用是静态分派（static dispatch） 在编译时就一一对应</li>
<li>既保有多态的灵活性，又没有任何效率的损失，和普通函数调用一样高效。</li>
</ul>
<ol start="2">
<li>坏处：编译慢、文件大、丢失泛型信息。这反过来又是动态分派的好处</li>
</ol>
<ul>
<li>但是对比刚才编译会展开的代码也能很清楚看出来，单态化有很明显的坏处</li>
<li>就是编译速度很慢，一个泛型函数，编译器需要找到所有用到的不同类型，一个个编译</li>
<li>所以 Rust 编译代码的速度总被人吐槽，这和单态化脱不开干系（另一个重要因素是宏）。</li>
<li>同时，这样编出来的二进制会比较大，因为泛型函数的二进制代码实际存在 N 份。</li>
<li>还有一个可能你不怎么注意的问题：因为单态化，代码以二进制分发会损失泛型的信息。</li>
<li>如果我写了一个库，提供了如上的 id() 函数，使用这个库的开发者如果拿到的是二进制</li>
<li>那么这个二进制中必须带有原始的泛型函数，才能正确调用。但单态化之后，原本的泛型信息就被丢弃了。</li>
</ul>
</div>
</details>
<h4 id="优劣"><a class="header" href="#优劣">优劣</a></h4>
<h3 id="返回值携带泛型参数"><a class="header" href="#返回值携带泛型参数">返回值携带泛型参数</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait"><a class="header" href="#trait">Trait</a></h1>
<!--ts-->
<ul>
<li><a href="2_3_trait.html#trait">Trait</a>
<ul>
<li><a href="2_3_trait.html#%E5%9F%BA%E6%9C%AC%E7%BB%83%E4%B9%A0">基本练习</a>
<ul>
<li><a href="2_3_trait.html#self%E5%92%8Cself">Self和self</a></li>
<li><a href="2_3_trait.html#%E9%80%92%E8%BF%9B%E7%BB%83%E4%B9%A0trait%E4%BD%BF%E7%94%A8">递进练习trait使用</a>
<ul>
<li><a href="2_3_trait.html#%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89trait">基础定义trait</a></li>
<li><a href="2_3_trait.html#%E6%B7%BB%E5%8A%A0%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F">添加泛型参数作为泛型约束</a></li>
<li><a href="2_3_trait.html#%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E6%B7%BB%E5%8A%A0resultt-e">使用关联类型+添加Result&lt;T, E&gt;</a></li>
</ul>
</li>
<li><a href="2_3_trait.html#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F-%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E7%9A%84trait">泛型约束: 支持泛型的trait</a>
<ul>
<li><a href="2_3_trait.html#%E6%80%9D%E8%80%83%E9%A2%98">思考题</a></li>
<li><a href="2_3_trait.html#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
</ul>
</li>
<li><a href="2_3_trait.html#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">关联类型</a></li>
<li><a href="2_3_trait.html#%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B">支持泛型</a></li>
<li><a href="2_3_trait.html#%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF">支持继承</a></li>
<li><a href="2_3_trait.html#%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1-or-%E7%89%B9%E8%AE%BE%E5%A4%9A%E6%80%81">接口抽象 or 特设多态</a></li>
</ul>
</li>
<li><a href="2_3_trait.html#trait-object">Trait Object</a>
<ul>
<li><a href="2_3_trait.html#%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%A4%9A%E6%80%81-%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE">子类型多态: 动态分派</a></li>
<li><a href="2_3_trait.html#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86ptrvtable">实现机理：ptr+vtable</a></li>
<li><a href="2_3_trait.html#%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8">对象安全</a></li>
<li><a href="2_3_trait.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a>
<ul>
<li><a href="2_3_trait.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8">在函数中使用</a></li>
<li><a href="2_3_trait.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%AD%E4%BD%BF%E7%94%A8">在函数返回值中使用</a>
<ul>
<li><a href="2_3_trait.html#%E5%9C%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E4%BD%BF%E7%94%A8">在数据结构中使用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="2_3_trait.html#%E5%AD%A4%E5%84%BF%E8%A7%84%E5%88%99">孤儿规则</a></li>
<li><a href="2_3_trait.html#%E5%B8%B8%E7%94%A8trait">常用trait</a>
<ul>
<li><a href="2_3_trait.html#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3">内存相关</a>
<ul>
<li><a href="2_3_trait.html#copy">Copy</a></li>
<li><a href="2_3_trait.html#drop">Drop</a></li>
</ul>
</li>
<li><a href="2_3_trait.html#%E6%A0%87%E7%AD%BEtrait">标签trait</a>
<ul>
<li><a href="2_3_trait.html#sized">Sized</a></li>
<li><a href="2_3_trait.html#sendsync">Send/Sync</a></li>
</ul>
</li>
<li><a href="2_3_trait.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a>
<ul>
<li><a href="2_3_trait.html#frominto-%E5%80%BC%E5%88%B0%E5%80%BC">From/Into: 值到值</a></li>
<li><a href="2_3_trait.html#tryfromtryinto-%E5%80%BC%E5%88%B0%E5%80%BC%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF">TryFrom/TryInto: 值到值，可能出现错误</a></li>
<li><a href="2_3_trait.html#asrefasmut-%E5%BC%95%E7%94%A8%E5%88%B0%E5%BC%95%E7%94%A8">AsRef/AsMut: 引用到引用</a></li>
</ul>
</li>
<li><a href="2_3_trait.html#%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9B%B8%E5%85%B3-derefderefmut">操作符相关: Deref/DerefMut</a></li>
<li><a href="2_3_trait.html#%E5%85%B6%E4%BB%96debugdisplaydefault">其他：Debug/Display/Default</a></li>
</ul>
</li>
<li><a href="2_3_trait.html#%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84">设计架构</a>
<ul>
<li><a href="2_3_trait.html#%E9%A1%BA%E6%89%8B%E8%87%AA%E7%84%B6">顺手自然</a></li>
<li><a href="2_3_trait.html#%E6%A1%A5%E6%8E%A5">桥接</a></li>
<li><a href="2_3_trait.html#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC">控制反转</a></li>
<li><a href="2_3_trait.html#solid%E5%8E%9F%E5%88%99">SOLID原则</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:18 UTC 2022 -->
<!--te-->
<div id="admonition-trait概览图" class="admonition info">
<div class="admonition-title">
<p>trait概览图</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-trait概览图"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/13%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F.jpg" alt="trait概览图" /></p>
</div>
</div>
<h2 id="基本练习"><a class="header" href="#基本练习">基本练习</a></h2>
<h3 id="self和self"><a class="header" href="#self和self">Self和self</a></h3>
<details id="admonition-self和self区别使用-self其实就是静态方法" class="admonition info">
<summary class="admonition-title">
<p>Self和self区别使用, Self其实就是静态方法</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-self和self区别使用-self其实就是静态方法"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::fmt;
use std::io::Write;

struct BufBuilder {
    buf: Vec&lt;u8&gt;,
}

impl BufBuilder {
    pub fn new() -&gt; Self {
        Self {
            buf: Vec::with_capacity(1024),
        }
    }
}

impl fmt::Debug for BufBuilder {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, String::from_utf8_lossy(self.buf.as_ref()))
    }
}

impl Write for BufBuilder {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; std::io::Result&lt;usize&gt; {
        self.buf.extend_from_slice(buf);
        Ok(buf.len())
    }

    fn flush(&amp;mut self) -&gt; std::io::Result&lt;()&gt; {
        Ok(())
    }
}

fn main() {
    let mut buf = BufBuilder::new();
    buf.write_all(b&quot;Hello world!&quot;).unwrap();
    println!(&quot;{:?}&quot;, buf);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-self-self-实例来自于类型" class="admonition info">
<summary class="admonition-title">
<p>self: Self, 实例来自于类型</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-self-self-实例来自于类型"></a></p>
</summary>
<div>
<ol>
<li>Self 代表当前的类型，比如 File 类型实现了 Write，那么实现过程中使用到的 Self 就指代 File。</li>
<li>self 在用作方法的第一个参数时，实际上是 self: Self 的简写，所以 &amp;self 是 self: &amp;Self, 而 &amp;mut self 是 self: &amp;mut Self。</li>
</ol>
</div>
</details>
<h3 id="递进练习trait使用"><a class="header" href="#递进练习trait使用">递进练习trait使用</a></h3>
<h4 id="基础定义trait"><a class="header" href="#基础定义trait">基础定义trait</a></h4>
<details id="admonition-定义parse-trait并实现使用" class="admonition info">
<summary class="admonition-title">
<p>定义Parse trait并实现使用</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-定义parse-trait并实现使用"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use regex::Regex;
pub trait Parse {
    fn parse(s: &amp;str) -&gt; Self;
}

impl Parse for u8 {
    fn parse(s: &amp;str) -&gt; Self {
        let re: Regex = Regex::new(r&quot;^[0-9]+&quot;).unwrap();
        if let Some(captures) = re.captures(s) {
            captures
                .get(0)
                .map_or(0, |s| s.as_str().parse().unwrap_or(0))
        } else {
            0
        }
    }
}

#[test]
fn parse_should_work() {
    assert_eq!(u8::parse(&quot;123abcd&quot;), 123);
    assert_eq!(u8::parse(&quot;1234abcd&quot;), 0);
    assert_eq!(u8::parse(&quot;abcd&quot;), 0);
}

fn main() {
    println!(&quot;result: {}&quot;, u8::parse(&quot;255 hello world&quot;));
}
</code></pre></pre>
</div>
</details>
<h4 id="添加泛型参数作为泛型约束"><a class="header" href="#添加泛型参数作为泛型约束">添加泛型参数作为泛型约束</a></h4>
<details id="admonition-impl-parse-for-t" class="admonition info">
<summary class="admonition-title">
<p>impl<T> Parse for T</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-impl-parse-for-t"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::str::FromStr;

use regex::Regex;
pub trait Parse {
    fn parse(s: &amp;str) -&gt; Self;
}

impl&lt;T&gt; Parse for T
where
    T: FromStr + Default,
{
    fn parse(s: &amp;str) -&gt; Self {
        let re: Regex = Regex::new(r&quot;^[0-9]+(\.[0-9]+)?&quot;).unwrap();
        let d = || Default::default();
        if let Some(captures) = re.captures(s) {
            captures
                .get(0)
                .map_or(d(), |s| s.as_str().parse().unwrap_or_else(|_| d()))
        } else {
            d()
        }
    }
}

#[test]
fn parse_should_work() {
    assert_eq!(u32::parse(&quot;123abcd&quot;), 123);
    assert_eq!(u32::parse(&quot;123.45abcd&quot;), 0);
    assert_eq!(f64::parse(&quot;123.45abcd&quot;).to_string(), &quot;123.45&quot;);
    assert_eq!(f64::parse(&quot;abcd&quot;).to_string(), &quot;0&quot;);
}

fn main() {
    println!(&quot;result: {}&quot;, u8::parse(&quot;255 hello world&quot;));
}
</code></pre></pre>
</div>
</details>
<h4 id="使用关联类型添加resultt-e"><a class="header" href="#使用关联类型添加resultt-e">使用关联类型+添加Result&lt;T, E&gt;</a></h4>
<details id="admonition-关联类型自定义error" class="admonition info">
<summary class="admonition-title">
<p>关联类型自定义Error</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-关联类型自定义error"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::str::FromStr;

use regex::Regex;
pub trait Parse {
    type Error;
    fn parse(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt;
    where
        Self: Sized;
}

impl&lt;T&gt; Parse for T
where
    T: FromStr + Default,
{
    // 定义关联类型 Error 为 String
    type Error = String;
    fn parse(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {
        let re: Regex = Regex::new(r&quot;^[0-9]+(\.[0-9]+)?&quot;).unwrap();
        if let Some(captures) = re.captures(s) {
            // 当出错时我们返回 Err(String)
            captures
                .get(0)
                .map_or(Err(&quot;failed to capture&quot;.to_string()), |s| {
                    s.as_str()
                        .parse()
                        .map_err(|_err| &quot;failed to parse captured string&quot;.to_string())
                })
        } else {
            Err(&quot;failed to parse string&quot;.to_string())
        }
    }
}

#[test]
fn parse_should_work() {
    assert_eq!(u32::parse(&quot;123abcd&quot;), Ok(123));
    assert_eq!(
        u32::parse(&quot;123.45abcd&quot;),
        Err(&quot;failed to parse captured string&quot;.into())
    );
    assert_eq!(f64::parse(&quot;123.45abcd&quot;), Ok(123.45));
    assert!(f64::parse(&quot;abcd&quot;).is_err());
}

fn main() {
    println!(&quot;result: {:?}&quot;, u8::parse(&quot;255 hello world&quot;));
}
</code></pre></pre>
</div>
</details>
<h3 id="泛型约束-支持泛型的trait"><a class="header" href="#泛型约束-支持泛型的trait">泛型约束: 支持泛型的trait</a></h3>
<h4 id="思考题"><a class="header" href="#思考题">思考题</a></h4>
<details id="admonition-泛型参数impl报错" class="admonition info">
<summary class="admonition-title">
<p>泛型参数impl报错</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-泛型参数impl报错"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::io::{BufWriter, Write};
use std::net::TcpStream;

#[derive(Debug)]
struct MyWriter&lt;W&gt; {
    writer: W,
}

impl&lt;W: Write&gt; MyWriter&lt;W&gt; {
    pub fn new(addr: &amp;str) -&gt; Self {
        let stream = TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap();
        Self {
            writer: BufWriter::new(stream),
        }
    }

    pub fn write(&amp;mut self, buf: &amp;str) -&gt; std::io::Result&lt;()&gt; {
        self.writer.write_all(buf.as_bytes())
    }
}

fn main() {
    let writer = MyWriter::new(&quot;127.0.0.1:8080&quot;);
    writer.write(&quot;hello world!&quot;);
}
</code></pre></pre>
</div>
</details>
<div id="admonition-分析编译报错原因" class="admonition tip">
<div class="admonition-title">
<p>分析编译报错原因</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-分析编译报错原因"></a></p>
</div>
<div>
<p>主要原因是，实现 new 方法时，对泛型的约束要求要满足 W: Write，而 new 的声明返回值是 Self，也就是说 self.wirter 必须是 W: Write 类型(泛型)，但实际返回值是一个确定的类型 BufWriter<TcpStream>，这不满足要求。</p>
</div>
</div>
<h4 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h4>
<div id="admonition-解决方案梳理" class="admonition info">
<div class="admonition-title">
<p>解决方案梳理</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-解决方案梳理"></a></p>
</div>
<div>
<ol>
<li>修改 new 方法的返回值</li>
<li>对确定的类型 MyWriter&lt;BufWriter<TcpStream>&gt;实现 new 方法</li>
<li>修改 new 方法的实现，使用依赖注入</li>
</ol>
</div>
</div>
<details id="admonition-1-修改new方法返回值" class="admonition info">
<summary class="admonition-title">
<ol>
<li>修改new方法返回值</li>
</ol>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-1-修改new方法返回值"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::io::{BufWriter, Write};
use std::net::TcpStream;

#[derive(Debug)]
struct MyWriter&lt;W&gt; {
    writer: W,
}

impl&lt;W: Write&gt; MyWriter&lt;W&gt; {
    pub fn new(writer: W) -&gt; Self {
        Self { writer }
    }

    pub fn write(&amp;mut self, buf: &amp;str) -&gt; std::io::Result&lt;()&gt; {
        self.writer.write_all(buf.as_bytes())
    }
}

fn main() {
    let stream = TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap();

    let mut writer = MyWriter::new(BufWriter::new(stream));
    writer.write(&quot;hello world!&quot;).unwrap();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-2-针对实现new方法" class="admonition info">
<summary class="admonition-title">
<ol start="2">
<li>针对实现new方法</li>
</ol>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-2-针对实现new方法"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl MyWriter&lt;BufWriter&lt;TcpStream&gt;&gt; {
    pub fn new(addr: &amp;str) -&gt; Self {
        let stream = TcpStream::connect(addr).unwrap();
        Self {
            writer: BufWriter::new(stream),
        }
    }
}

fn main() {
    let mut writer = MyWriter::new(&quot;127.0.0.1:8080&quot;);
    writer.write(&quot;hello world!&quot;);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-3-使用依赖注入修改new方法实现" class="admonition info">
<summary class="admonition-title">
<ol start="3">
<li>使用依赖注入修改new方法实现</li>
</ol>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-3-使用依赖注入修改new方法实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;W: Write&gt; MyWriter&lt;W&gt; {
    pub fn new(writer: W) -&gt; Self {
        Self {
            writer,
        }
    }
}

fn main() {
    let stream = TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap();
    let mut writer = MyWriter::new(BufWriter::new(stream));
    writer.write(&quot;hello world!&quot;);
}
</code></pre></pre>
</div>
</details>
<h3 id="关联类型"><a class="header" href="#关联类型">关联类型</a></h3>
<h3 id="支持泛型"><a class="header" href="#支持泛型">支持泛型</a></h3>
<details id="admonition-版本一支持数字相加" class="admonition info">
<summary class="admonition-title">
<p>版本一：支持数字相加</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-版本一支持数字相加"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::ops::Add;

#[derive(Debug)]
struct Complex {
    real: f64,
    imagine: f64,
}

impl Complex {
    pub fn new(real: f64, imagine: f64) -&gt; Self {
        Self { real, imagine }
    }
}

// 对 Complex 类型的实现
impl Add for Complex {
    type Output = Self;

    // 注意 add 第一个参数是 self，会移动所有权
    fn add(self, rhs: Self) -&gt; Self::Output {
        let real = self.real + rhs.real;
        let imagine = self.imagine + rhs.imagine;
        Self::new(real, imagine)
    }
}


fn main() {
    let c1 = Complex::new(1.0, 1f64);
    let c2 = Complex::new(2 as f64, 3.0);
    println!(&quot;{:?}&quot;, c1 + c2);
    // c1, c2 已经被移动，所以下面这句无法编译
    // println!(&quot;{:?}&quot;, c1 + c2);
}
</code></pre></pre>
</div>
</details>
<h3 id="支持继承"><a class="header" href="#支持继承">支持继承</a></h3>
<details id="admonition-trait-ba" class="admonition info">
<summary class="admonition-title">
<p>trait B:A</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-trait-ba"></a></p>
</summary>
<div>
<p>在 Rust 中，一个 trait 可以“继承”另一个 trait 的关联类型和关联函数。比如 trait B: A ，是说任何类型 T，如果实现了 trait B，它也必须实现 trait A，换句话说，trait B 在定义时可以使用 trait A 中的关联类型和方法。</p>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T: ?Sized&gt; StreamExt for T where T: Stream {}
</code></pre></pre>
<hr />
<p>如果你实现了 Stream trait，就可以直接使用 StreamExt 里的方法了</p>
</div>
</details>
<h3 id="接口抽象-or-特设多态"><a class="header" href="#接口抽象-or-特设多态">接口抽象 or 特设多态</a></h3>
<details id="admonition-对不同类型统一实现-trait将各种接口定义场景考虑进去" class="admonition info">
<summary class="admonition-title">
<p>对不同类型统一实现: trait将各种接口定义场景考虑进去</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-对不同类型统一实现-trait将各种接口定义场景考虑进去"></a></p>
</summary>
<div>
<p>trait 作为对不同数据结构中相同行为的一种抽象。</p>
<ol>
<li>除了基本 trait 之外，当行为和具体的数据关联时，比如字符串解析时定义的 Parse trait，我们引入了带有关联类型的 trait，把和行为有关的数据类型的定义，进一步延迟到 trait 实现的时候。</li>
<li>对于同一个类型的同一个 trait 行为，可以有不同的实现，比如我们之前大量使用的 From，此时可以用泛型 trait。可以说 Rust 的 trait 就像一把瑞士军刀，把需要定义接口的各种场景都考虑进去了。</li>
</ol>
</div>
</details>
<details id="admonition-对不同类型的不同实现-特设多态" class="admonition info">
<summary class="admonition-title">
<p>对不同类型的不同实现: 特设多态</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-对不同类型的不同实现-特设多态"></a></p>
</summary>
<div>
<p>特设多态是同一种行为的不同实现。所以其实，通过定义 trait 以及为不同的类型实现这个 trait，我们就已经实现了特设多态。</p>
<ol>
<li>Add trait 就是一个典型的特设多态，同样是加法操作，根据操作数据的不同进行不同的处理。</li>
<li>Service trait 是一个不那么明显的特设多态，同样是 Web 请求，对于不同的 URL，我们使用不同的代码去处理。</li>
</ol>
</div>
</details>
<h2 id="trait-object"><a class="header" href="#trait-object">Trait Object</a></h2>
<h3 id="子类型多态-动态分派"><a class="header" href="#子类型多态-动态分派">子类型多态: 动态分派</a></h3>
<details id="admonition-在运行期决定" class="admonition info">
<summary class="admonition-title">
<p>在运行期决定</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-在运行期决定"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">pub trait Formatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool;
}

struct MarkdownFormatter;
impl Formatter for MarkdownFormatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool {
        input.push_str(&quot;\nformatted with Markdown formatter&quot;);
        true
    }
}

struct RustFormatter;
impl Formatter for RustFormatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool {
        input.push_str(&quot;\nformatted with Rust formatter&quot;);
        true
    }
}

struct HtmlFormatter;
impl Formatter for HtmlFormatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool {
        input.push_str(&quot;\nformatted with HTML formatter&quot;);
        true
    }
}

pub fn format(input: &amp;mut String, formatters: Vec&lt;&amp;dyn Formatter&gt;) {
    for formatter in formatters {
        formatter.format(input);
    }
}

fn main() {
    let mut text = &quot;Hello world!&quot;.to_string();
    let html: &amp;dyn Formatter = &amp;HtmlFormatter;
    let rust: &amp;dyn Formatter = &amp;RustFormatter;
    let formatters = vec![html, rust];
    format(&amp;mut text, formatters);

    println!(&quot;text: {}&quot;, text);
}
</code></pre></pre>
<hr />
<p>要有一种手段，告诉编译器，此处需要并且仅需要任何实现了 Formatter 接口的数据类型。在 Rust 里，这种类型叫 Trait Object，表现为 &amp;dyn Trait 或者 Box。</p>
<ol>
<li>这里结构体只是声明了一下，并不关注其包含什么字段</li>
</ol>
</div>
</details>
<h3 id="实现机理ptrvtable"><a class="header" href="#实现机理ptrvtable">实现机理：ptr+vtable</a></h3>
<details id="admonition-trait-object的底层逻辑就是胖指针" class="admonition info">
<summary class="admonition-title">
<p>Trait Object的底层逻辑就是胖指针</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-trait-object的底层逻辑就是胖指针"></a></p>
</summary>
<div>
<h2 id="-4"><a class="header" href="#-4"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/13%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F-4258625.jpg" alt="13｜类型系统：如何使用trait来定义接口？" /></a></h2>
<p>HtmlFormatter 的引用赋值给 Formatter 后，会生成一个 Trait Object，在上图中可以看到，Trait Object 的底层逻辑就是胖指针。</p>
<blockquote>
<p>其中，一个指针指向数据本身，另一个则指向虚函数表（vtable）。</p>
</blockquote>
</div>
</details>
<details id="admonition-vtable是一张静态表" class="admonition info">
<summary class="admonition-title">
<p>vtable是一张静态表</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-vtable是一张静态表"></a></p>
</summary>
<div>
<h2 id="-5"><a class="header" href="#-5"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/13%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F-4258661.jpg" alt="13｜类型系统：如何使用trait来定义接口？" /></a></h2>
<ol>
<li>vtable 是一张静态的表，Rust 在编译时会为使用了 trait object 的类型的 trait 实现生成一张表，放在可执行文件中（一般在 TEXT 或 RODATA 段）</li>
</ol>
<blockquote>
<p>在这张表里，包含具体类型的一些信息，如 size、aligment 以及一系列函数指针
这个接口支持的所有的方法，比如 format() ；具体类型的 drop trait，当 Trait object 被释放，它用来释放其使用的所有资源。这样，当在运行时执行 formatter.format() 时，formatter 就可以从 vtable 里找到对应的函数指针，执行具体的操作。</p>
</blockquote>
</div>
</details>
<details id="admonition-vtable会为每个类型的每个trait实现一张表" class="admonition info">
<summary class="admonition-title">
<p>vtable会为每个类型的每个trait实现一张表</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-vtable会为每个类型的每个trait实现一张表"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::fmt::{Debug, Display};
use std::mem::transmute;

fn main() {
    let s = String::from(&quot;hello world!&quot;);
    let s1 = String::from(&quot;goodbye world!&quot;);
    // Display / Debug trait object for s
    let w1: &amp;dyn Display = &amp;s;
    let w2: &amp;dyn Debug = &amp;s;

    // Display / Debug trait object for s1
    let w3: &amp;dyn Display = &amp;s1;
    let w4: &amp;dyn Debug = &amp;s1;

    // 强行把 triat object 转换成两个地址 (usize, usize)
    // 这是不安全的，所以是 unsafe
    let (addr1, vtable1): (usize, usize) = unsafe { transmute(w1) };
    let (addr2, vtable2): (usize, usize) = unsafe { transmute(w2) };
    let (addr3, vtable3): (usize, usize) = unsafe { transmute(w3) };
    let (addr4, vtable4): (usize, usize) = unsafe { transmute(w4) };

    // s 和 s1 在栈上的地址，以及 main 在 TEXT 段的地址
    println!(
        &quot;s: {:p}, s1: {:p}, main(): {:p}&quot;,
        &amp;s, &amp;s1, main as *const ()
    );
    // trait object(s / Display) 的 ptr 地址和 vtable 地址
    println!(&quot;addr1: 0x{:x}, vtable1: 0x{:x}&quot;, addr1, vtable1);
    // trait object(s / Debug) 的 ptr 地址和 vtable 地址
    println!(&quot;addr2: 0x{:x}, vtable2: 0x{:x}&quot;, addr2, vtable2);

    // trait object(s1 / Display) 的 ptr 地址和 vtable 地址
    println!(&quot;addr3: 0x{:x}, vtable3: 0x{:x}&quot;, addr3, vtable3);

    // trait object(s1 / Display) 的 ptr 地址和 vtable 地址
    println!(&quot;addr4: 0x{:x}, vtable4: 0x{:x}&quot;, addr4, vtable4);

    // 指向同一个数据的 trait object 其 ptr 地址相同
    assert_eq!(addr1, addr2);
    assert_eq!(addr3, addr4);

    // 指向同一种类型的同一个 trait 的 vtable 地址相同
    // 这里都是 String + Display
    assert_eq!(vtable1, vtable3);
    // 这里都是 String + Debug
    assert_eq!(vtable2, vtable4);
}
</code></pre></pre>
</div>
</details>
<h3 id="对象安全"><a class="header" href="#对象安全">对象安全</a></h3>
<details id="admonition-那什么样的-trait-不是对象安全的呢" class="admonition info">
<summary class="admonition-title">
<p>那什么样的 trait 不是对象安全的呢？</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-那什么样的-trait-不是对象安全的呢"></a></p>
</summary>
<div>
<ol>
<li>如果 trait 所有的方法，返回值是 Self 或者携带泛型参数，那么这个 trait 就不能产生 trait object。</li>
<li>不允许返回 Self，是因为 trait object 在产生时，原来的类型会被抹去，所以 Self 究竟是谁不知道。</li>
<li>比如 Clone trait 只有一个方法 clone()，返回 Self，所以它就不能产生 trait object。</li>
<li>不允许携带泛型参数，是因为 Rust 里带泛型的类型在编译时会做单态化，而 trait object 是运行时的产物，两者不能兼容。</li>
<li>比如 Fromtrait，因为整个 trait 带了泛型，每个方法也自然包含泛型，就不能产生 trait object。如果一个 trait 只有部分方法返回 Self 或者使用了泛型参数，那么这部分方法在 trait object 中不能调用。</li>
</ol>
</div>
</details>
<h3 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h3>
<h4 id="在函数中使用"><a class="header" href="#在函数中使用">在函数中使用</a></h4>
<h4 id="在函数返回值中使用"><a class="header" href="#在函数返回值中使用">在函数返回值中使用</a></h4>
<h5 id="在数据结构中使用"><a class="header" href="#在数据结构中使用">在数据结构中使用</a></h5>
<h2 id="孤儿规则"><a class="header" href="#孤儿规则">孤儿规则</a></h2>
<details id="admonition-定义或实现至少有一个" class="admonition info">
<summary class="admonition-title">
<p>定义或实现，至少有一个</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-定义或实现至少有一个"></a></p>
</summary>
<div>
<p>trait 和实现 trait 的数据类型，至少有一个是在当前 crate 中定义的，也就是说，你不能为第三方的类型实现第三方的 trait，当你尝试这么做时，Rust 编译器会报错。</p>
</div>
</details>
<h2 id="常用trait"><a class="header" href="#常用trait">常用trait</a></h2>
<div id="admonition-常用trait分类整理" class="admonition info">
<div class="admonition-title">
<p>常用trait分类整理</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-常用trait分类整理"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/14%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84trait%EF%BC%9F.jpg" alt="14｜类型系统：有哪些必须掌握的trait？" /></p>
</div>
</div>
<h3 id="内存相关"><a class="header" href="#内存相关">内存相关</a></h3>
<details id="admonition-clone使用示例" class="admonition info">
<summary class="admonition-title">
<p>Clone使用示例</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-clone使用示例"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Clone {
  fn clone(&amp;self) -&gt; Self;

  fn clone_from(&amp;mut self, source: &amp;Self) {
    *self = source.clone()
  }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-clone与clone_from" class="admonition info">
<summary class="admonition-title">
<p>clone()与clone_from()</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-clone与clone_from"></a></p>
</summary>
<div>
<p>Clone trait 有两个方法， clone() 和 clone_from() ，后者有缺省实现，所以平时我们只需要实现 clone() 方法即可。你也许会疑惑，这个 clone_from() 有什么作用呢？因为看起来 a.clone_from(&amp;b) ，和 a = b.clone() 是等价的。其实不是，如果 a 已经存在，在 clone 过程中会分配内存，那么用 a.clone_from(&amp;b) 可以避免内存分配，提高效率。b.clone() 是等价的。其实不是，如果 a 已经存在，在 clone 过程中会分配内存，那么用 a.clone_from(&amp;b) 可以避免内存分配，提高效率。</p>
</div>
</details>
<details id="admonition-clone-trait-可以通过派生宏直接实现这样能简化不少代码" class="admonition info">
<summary class="admonition-title">
<p>Clone trait 可以通过派生宏直接实现，这样能简化不少代码</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-clone-trait-可以通过派生宏直接实现这样能简化不少代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[derive(Clone, Debug)]
struct Developer {
  name: String,
  age: u8,
  lang: Language
}

#[allow(dead_code)]
#[derive(Clone, Debug)]
enum Language {
  Rust,
  TypeScript,
  Elixir,
  Haskell
}

fn main() {
    let dev = Developer {
        name: &quot;Tyr&quot;.to_string(),
        age: 18,
        lang: Language::Rust
    };
    let dev1 = dev.clone();
    println!(&quot;dev: {:?}, addr of dev name: {:p}&quot;, dev, dev.name.as_str());
    println!(&quot;dev1: {:?}, addr of dev1 name: {:p}&quot;, dev1, dev1.name.as_str())
}
</code></pre></pre>
<hr />
<p>如果没有为 Language 实现 Clone 的话，Developer 的派生宏 Clone 将会编译出错。运行这段代码可以看到，对于 name，也就是 String 类型的 Clone，其堆上的内存也被 Clone 了一份，所以 Clone 是深度拷贝，栈内存和堆内存一起拷贝。</p>
</div>
</details>
<details id="admonition-clone-方法的接口是-self" class="admonition info">
<summary class="admonition-title">
<p>clone 方法的接口是 &amp;self</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-clone-方法的接口是-self"></a></p>
</summary>
<div>
<p>值得注意的是，clone 方法的接口是 &amp;self，这在绝大多数场合下都是适用的，我们在 clone 一个数据时只需要有已有数据的只读引用。但对 Rc 这样在 clone() 时维护引用计数的数据结构，clone() 过程中会改变自己，所以要用 Cell 这样提供内部可变性的结构来进行改变，如果你也有类似的需求，可以参考</p>
</div>
</details>
<h4 id="copy"><a class="header" href="#copy">Copy</a></h4>
<details id="admonition-不可变引用实现了-copy而可变引用-mut-t-没有实现-copy" class="admonition info">
<summary class="admonition-title">
<p>不可变引用实现了 Copy，而可变引用 &amp;mut T 没有实现 Copy</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-不可变引用实现了-copy而可变引用-mut-t-没有实现-copy"></a></p>
</summary>
<div>
<p>不可变引用实现了 Copy，而可变引用 &amp;mut T 没有实现 Copy。为什么是这样？因为如果可变引用实现了 Copy trait，那么生成一个可变引用然后把它赋值给另一个变量时，就会违背所有权规则：
同一个作用域下只能有一个可变引用。可见，Rust 标准库在哪些结构可以 Copy、哪些不可以 Copy 上，有着仔细的考量。</p>
</div>
</details>
<h4 id="drop"><a class="header" href="#drop">Drop</a></h4>
<details id="admonition-有两种情况你可能需要手工实现-drop" class="admonition info">
<summary class="admonition-title">
<p>有两种情况你可能需要手工实现 Drop</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-有两种情况你可能需要手工实现-drop"></a></p>
</summary>
<div>
<p>大部分场景无需为数据结构提供 Drop trait，系统默认会依次对数据结构的每个域做 drop。但有两种情况你可能需要手工实现 Drop。</p>
<ol>
<li>第一种是希望在数据结束生命周期的时候做一些事情，比如记日志。</li>
<li>第二种是需要对资源回收的场景。编译器并不知道你额外使用了哪些资源，也就无法帮助你 drop 它们。比如说锁资源的释放，</li>
<li>在 MutexGuard 中实现了 Drop 来释放锁资源：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    #[inline]
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.poison.done(&amp;self.poison);
            self.lock.inner.raw_unlock();
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-copy与drop互斥" class="admonition info">
<summary class="admonition-title">
<p>Copy与Drop互斥</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-copy与drop互斥"></a></p>
</summary>
<div>
<p>需要注意的是，Copy trait 和 Drop trait 是互斥的，两者不能共存，当你尝试为同一种数据类型实现 Copy 时，也实现 Drop，编译器就会报错。</p>
<blockquote>
<p>这其实很好理解：</p>
</blockquote>
<ul>
<li>Copy 是按位做浅拷贝，那么它会默认拷贝的数据没有需要释放的资源；</li>
<li>而 Drop 恰恰是为了释放额外的资源而生的。</li>
</ul>
<hr />
<p>辅助理解，在代码中，强行用 Box::into_raw 获得堆内存的指针，放入 RawBuffer 结构中，这样就接管了这块堆内存的释放。
虽然 RawBuffer 可以实现 Copy trait，但这样一来就无法实现 Drop trait。
如果程序非要这么写，会导致内存泄漏，因为该释放的堆内存没有释放。</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::{fmt, slice};

// 注意这里，我们实现了 Copy，这是因为 *mut u8/usize 都支持 Copy
#[derive(Clone, Copy)]
struct RawBuffer {
    // 裸指针用 *const / *mut 来表述，这和引用的 &amp; 不同
    ptr: *mut u8,
    len: usize,
}

impl From&lt;Vec&lt;u8&gt;&gt; for RawBuffer {
    fn from(vec: Vec&lt;u8&gt;) -&gt; Self {
        let slice = vec.into_boxed_slice();
        Self {
            len: slice.len(),
            // into_raw 之后，Box 就不管这块内存的释放了，RawBuffer 需要处理释放
            ptr: Box::into_raw(slice) as *mut u8,
        }
    }
}

// 如果 RawBuffer 实现了 Drop trait，就可以在所有者退出时释放堆内存
// 然后，Drop trait 会跟 Copy trait 冲突，要么不实现 Copy，要么不实现 Drop
// 如果不实现 Drop，那么就会导致内存泄漏，但它不会对正确性有任何破坏
// 比如不会出现 use after free 这样的问题。
// 你可以试着把下面注释去掉，看看会出什么问题
// impl Drop for RawBuffer {
//     #[inline]
//     fn drop(&amp;mut self) {
//         let data = unsafe { Box::from_raw(slice::from_raw_parts_mut(self.ptr, self.len)) };
//         drop(data)
//     }
// }

impl fmt::Debug for RawBuffer {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        let data = self.as_ref();
        write!(f, &quot;{:p}: {:?}&quot;, self.ptr, data)
    }
}

impl AsRef&lt;[u8]&gt; for RawBuffer {
    fn as_ref(&amp;self) -&gt; &amp;[u8] {
        unsafe { slice::from_raw_parts(self.ptr, self.len) }
    }
}

fn main() {
    let data = vec![1, 2, 3, 4];

    let buf: RawBuffer = data.into();

    // 因为 buf 允许 Copy，所以这里 Copy 了一份
    use_buffer(buf);

    // buf 还能用
    println!(&quot;buf: {:?}&quot;, buf);
}

fn use_buffer(buf: RawBuffer) {
    println!(&quot;buf to die: {:?}&quot;, buf);

    // 这里不用特意 drop，写出来只是为了说明 Copy 出来的 buf 被 Drop 了
    drop(buf)
}
</code></pre></pre>
<hr />
<p>但是这个操作不会破坏 Rust 的正确性保证：即便你 Copy 了 N 份 RawBuffer，由于无法实现 Drop trait，RawBuffer 指向的那同一块堆内存不会释放，所以不会出现 use after free 的内存安全问题</p>
</div>
</details>
<details id="admonition-对于代码安全来说内存泄漏危害大还是-use-after-free-危害大呢" class="admonition info">
<summary class="admonition-title">
<p>对于代码安全来说，内存泄漏危害大？还是 use after free 危害大呢？</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-对于代码安全来说内存泄漏危害大还是-use-after-free-危害大呢"></a></p>
</summary>
<div>
<p>对于代码安全来说，内存泄漏危害大？还是 use after free 危害大呢？</p>
<blockquote>
<p>肯定是后者。</p>
</blockquote>
<ul>
<li>Rust 的底线是内存安全，所以两害相权取其轻。</li>
<li>实际上，任何编程语言都无法保证不发生人为的内存泄漏</li>
<li>比如程序在运行时，开发者疏忽了，对哈希表只添加不删除，就会造成内存泄漏。</li>
<li>但 Rust 会保证即使开发者疏忽了，也不会出现内存安全问题。</li>
</ul>
</div>
</details>
<h3 id="标签trait"><a class="header" href="#标签trait">标签trait</a></h3>
<h4 id="sized"><a class="header" href="#sized">Sized</a></h4>
<details id="admonition-size-data-和处理-data-的函数-process_data" class="admonition info">
<summary class="admonition-title">
<p>Size: Data 和处理 Data 的函数 process_data</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-size-data-和处理-data-的函数-process_data"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
struct Data&lt;T&gt; {
    inner: T,
}

fn process_data&lt;T&gt;(data: Data&lt;T&gt;) {
    todo!();
}
</code></pre></pre>
<p>等价于：</p>
<pre><pre class="playground"><code class="language-rust  editable">
struct Data&lt;T: Sized&gt; {
    inner: T,
}

fn process_data&lt;T: Sized&gt;(data: Data&lt;T&gt;) {
    todo!();
}
</code></pre></pre>
<hr />
<p>大部分时候，我们都希望能自动添加这样的约束，因为这样定义出的泛型结构，在编译期，大小是固定的，可以作为参数传递给函数。如果没有这个约束，T 是大小不固定的类型， process_data 函数会无法编译。</p>
</div>
</details>
<details id="admonition-sized-在少数情况下需要-t-是可变类型的" class="admonition info">
<summary class="admonition-title">
<p>?Sized: 在少数情况下，需要 T 是可变类型的</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-sized-在少数情况下需要-t-是可变类型的"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub enum Cow&lt;'a, B: ?Sized + 'a&gt; where B: ToOwned,
{
    // 借用的数据
    Borrowed(&amp;'a B),
    // 拥有的数据
    Owned(&lt;B as ToOwned&gt;::Owned),
}
</code></pre></pre>
<hr />
<p>这样 B 就可以是 [T] 或者 str 类型，大小都是不固定的。要注意 Borrowed(&amp;’a B) 大小是固定的，因为它内部是对 B 的一个引用，而引用的大小是固定的</p>
</div>
</details>
<h4 id="sendsync"><a class="header" href="#sendsync">Send/Sync</a></h4>
<details id="admonition-这两个-trait-都是-unsafe-auto-trait" class="admonition info">
<summary class="admonition-title">
<p>这两个 trait 都是 unsafe auto trait</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-这两个-trait-都是-unsafe-auto-trait"></a></p>
</summary>
<div>
<p>这两个 trait 都是 unsafe auto trait:</p>
<ul>
<li>auto 意味着编译器会在合适的场合，自动为数据结构添加它们的实现</li>
<li>而 unsafe 代表实现的这个 trait 可能会违背 Rust 的内存安全准则</li>
<li>如果开发者手工实现这两个 trait ，要自己为它们的安全性负责。</li>
</ul>
</div>
</details>
<details id="admonition-sendsync-是-rust-并发安全的基础" class="admonition info">
<summary class="admonition-title">
<p>Send/Sync 是 Rust 并发安全的基础</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-sendsync-是-rust-并发安全的基础"></a></p>
</summary>
<div>
<p>Send/Sync 是 Rust 并发安全的基础：</p>
<ul>
<li>如果一个类型 T 实现了 Send trait，意味着 T 可以安全地从一个线程移动到另一个线程，也就是说所有权可以在线程间移动。</li>
<li>如果一个类型 T 实现了 Sync trait，则意味着 &amp;T 可以安全地在多个线程中共享。一个类型 T 满足 Sync trait，当且仅当 &amp;T 满足 Send trait。</li>
</ul>
</div>
</details>
<details id="admonition-sendsync-在线程安全中的作用" class="admonition info">
<summary class="admonition-title">
<p>Send/Sync 在线程安全中的作用</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-sendsync-在线程安全中的作用"></a></p>
</summary>
<div>
<p>对于 Send/Sync 在线程安全中的作用，可以这么看:</p>
<ol>
<li>如果一个类型 T: Send，那么 T 在某个线程中的独占访问是线程安全的；</li>
<li>如果一个类型 T: Sync，那么 T 在线程间的只读共享是安全的。</li>
</ol>
</div>
</details>
<details id="admonition-绝大多数自定义的数据结构都是满足-send--sync-的标准库中不支持-send--sync-的数据结构主要有" class="admonition info">
<summary class="admonition-title">
<p>绝大多数自定义的数据结构都是满足 Send / Sync 的。标准库中，不支持 Send / Sync 的数据结构主要有</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-绝大多数自定义的数据结构都是满足-send--sync-的标准库中不支持-send--sync-的数据结构主要有"></a></p>
</summary>
<div>
<ol>
<li>裸指针 *const T / *mut T。
它们是不安全的，所以既不是 Send 也不是 Sync。</li>
<li>UnsafeCell 不支持 Sync。
也就是说，任何使用了 Cell 或者 RefCell 的数据结构不支持 Sync。</li>
<li>引用计数 Rc 不支持 Send 也不支持 Sync。所以 Rc 无法跨线程。</li>
</ol>
</div>
</details>
<details id="admonition-尝试跨线程使用-rc--refcell会发生什么" class="admonition info">
<summary class="admonition-title">
<p>尝试跨线程使用 Rc / RefCell，会发生什么</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-尝试跨线程使用-rc--refcell会发生什么"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::{
    cell::RefCell,
    rc::Rc,
    sync::{Arc, Mutex},
    thread,
};

// Rc 既不是 Send，也不是 Sync
#[allow(dead_code, unused_variables)]
fn rc_is_not_send_and_sync() {
    let a = Rc::new(1);
    let b = a.clone();
    let c = a.clone();

    println!(&quot;{:?} {:?} {:?}&quot;, a, b, c);

    // 无法编译通过
    // thread::spawn(move || {
    //     println!(&quot;c= {:?}&quot;, c);
    // });
}

#[allow(dead_code)]
fn refcell_is_send() {
    let a = RefCell::new(1);
    thread::spawn(move || {
        println!(&quot;a= {:?}&quot;, a);
    });
}

// RefCell 现在有多个 Arc 持有它，虽然 Arc 是 Send/Sync，但 RefCell 不是 Sync
#[allow(dead_code, unused_variables)]
fn refcell_is_not_sync() {
    let a = Arc::new(RefCell::new(1));
    let b = a.clone();
    let c = a.clone();

    println!(&quot;{:?} {:?} {:?}&quot;, a, b, c);

    // 无法编译通过
    // thread::spawn(move || {
    //     println!(&quot;c= {:?}&quot;, c);
    // });
}

// Arc&lt;Mutext&lt;T&gt;&gt; 可以多线程共享且修改数据
#[allow(dead_code)]
fn arc_mutext_is_send_sync() {
    let a = Arc::new(Mutex::new(1));
    let b = a.clone();
    let c = a.clone();
    let handle = thread::spawn(move || {
        let mut g = c.lock().unwrap();
        *g += 1;
    });

    {
        let mut g = b.lock().unwrap();
        *g += 1;
    }

    handle.join().unwrap();
    println!(&quot;a= {:?}&quot;, a);
}

// 无法编译通过
// fn mutex_guard_is_not_send() {
//     let mutex = Mutex::new(1);
//     let guard = mutex.lock().unwrap();
//     thread::spawn(|| {
//         println!(&quot;data= {:?}&quot;, guard);
//     });

//     thread::spawn(move || {
//         println!(&quot;data= {:?}&quot;, guard);
//     });
// }

fn main() {}
</code></pre></pre>
</div>
</details>
<details id="admonition-用到的stdthreadspawn" class="admonition info">
<summary class="admonition-title">
<p>用到的std::thread::spawn</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-用到的stdthreadspawn"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; 
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static,
</code></pre></pre>
<hr />
<p>它的参数是一个闭包，这个闭包需要 Send + ’static：</p>
<ol>
<li>’static 意思是闭包捕获的自由变量必须是一个拥有所有权的类型，或者是一个拥有静态生命周期的引用；</li>
<li>Send 意思是，这些被捕获自由变量的所有权可以从一个线程移动到另一个线程。</li>
</ol>
<blockquote>
<p>从这个接口上，可以得出结论：如果在线程间传递 Rc，是无法编译通过的</p>
</blockquote>
</div>
</details>
<details id="admonition-rc不支持send和sync" class="admonition info">
<summary class="admonition-title">
<p>Rc不支持Send和Sync</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-rc不支持send和sync"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
// Rc 既不是 Send，也不是 Sync
fn rc_is_not_send_and_sync() {
    let a = Rc::new(1);
    let b = a.clone();
    let c = a.clone();
    thread::spawn(move || {
        println!(&quot;c= {:?}&quot;, c);
    });
}
</code></pre></pre>
<hr />
<h2 id="-6"><a class="header" href="#-6"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/14%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84trait%EF%BC%9F-4694742.jpg" alt="Rc不支持Send/Sync" /></a></h2>
<p><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-Send">Rc 的实现不支持 Send 和 Sync</a></p>
</div>
</details>
<details id="admonition-refcell-可以在线程间转移所有权么" class="admonition info">
<summary class="admonition-title">
<p>RefCell 可以在线程间转移所有权么？</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-refcell-可以在线程间转移所有权么"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn refcell_is_send() {
    let a = RefCell::new(1);
    thread::spawn(move || {
        println!(&quot;a= {:?}&quot;, a);
    });
}
</code></pre></pre>
<hr />
<blockquote>
<p><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#impl-Send">RefCell 实现了 Send，但没有实现 Sync</a></p>
</blockquote>
</div>
</details>
<details id="admonition-arc支持sendsync" class="admonition info">
<summary class="admonition-title">
<p>Arc支持Send/Sync</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-arc支持sendsync"></a></p>
</summary>
<div>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-Send">Arc支持Send/Sync</a></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
// RefCell 现在有多个 Arc 持有它，虽然 Arc 是 Send/Sync，但 RefCell 不是 Sync
fn refcell_is_not_sync() {
    let a = Arc::new(RefCell::new(1));
    let b = a.clone();
    let c = a.clone();
    thread::spawn(move || {
        println!(&quot;c= {:?}&quot;, c);
    });
}

</code></pre></pre>
<hr />
<p>因为 Arc 内部的数据是共享的，需要支持 Sync 的数据结构，但是 RefCell 不是 Sync，编译失败。</p>
</div>
</details>
<details id="admonition-在多线程情况下我们只能使用支持-sendsync-的-arc-和-mutex-一起构造一个可以在多线程间共享且可以修改的类型" class="admonition info">
<summary class="admonition-title">
<p>在多线程情况下，我们只能使用支持 Send/Sync 的 Arc ，和 Mutex 一起，构造一个可以在多线程间共享且可以修改的类型</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-在多线程情况下我们只能使用支持-sendsync-的-arc-和-mutex-一起构造一个可以在多线程间共享且可以修改的类型"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::{
    sync::{Arc, Mutex},
    thread,
};

// Arc&lt;Mutex&lt;T&gt;&gt; 可以多线程共享且修改数据
fn arc_mutext_is_send_sync() {
    let a = Arc::new(Mutex::new(1));
    let b = a.clone();
    let c = a.clone();
    let handle = thread::spawn(move || {
        let mut g = c.lock().unwrap();
        *g += 1;
    });

    {
        let mut g = b.lock().unwrap();
        *g += 1;
    }

    handle.join().unwrap();
    println!(&quot;a= {:?}&quot;, a);
}

fn main() {
    arc_mutext_is_send_sync();
}
</code></pre></pre>
<hr />
<p>最后一个标记 trait Unpin，是用于自引用类型的，属于Future trait。</p>
</div>
</details>
<h3 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h3>
<details id="admonition-对比两种转化方式" class="admonition info">
<summary class="admonition-title">
<p>对比两种转化方式</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-对比两种转化方式"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
// 第一种方法，为每一种转换提供一个方法
// 把字符串 s 转换成 Path
let v = s.to_path();
// 把字符串 s 转换成 u64
let v = s.to_u64();

// 第二种方法，为 s 和要转换的类型之间实现一个 Into&lt;T&gt; trait
// v 的类型根据上下文得出
let v = s.into();
// 或者也可以显式地标注 v 的类型
let v: u64 = s.into();
</code></pre></pre>
<hr />
<p>显然，第二种方法要更好，因为它符合软件开发的开闭原则（Open-Close Principle），</p>
<blockquote>
<p>“软件中的对象（类、模块、函数等等）对扩展是开放的，但是对修改是封闭的”。</p>
</blockquote>
<ol>
<li>在第一种方式下，未来每次要添加对新类型的转换，都要重新修改类型 T 的实现</li>
<li>而第二种方式，我们只需要添加一个对于数据转换 trait 的新实现即可。</li>
</ol>
</div>
</details>
<details id="admonition-rust-提供了两套不同的-trait" class="admonition info">
<summary class="admonition-title">
<p>Rust 提供了两套不同的 trait</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-rust-提供了两套不同的-trait"></a></p>
</summary>
<div>
<ol>
<li>值类型到值类型的转换：From / Into / TryFrom / TryInto</li>
<li>引用类型到引用类型的转换：AsRef / AsMut</li>
</ol>
</div>
</details>
<h4 id="frominto-值到值"><a class="header" href="#frominto-值到值">From/Into: 值到值</a></h4>
<details id="admonition-这两种方式是等价的怎么选呢" class="admonition info">
<summary class="admonition-title">
<p>这两种方式是等价的，怎么选呢？</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-这两种方式是等价的怎么选呢"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">let s = String::from(&quot;Hello world!&quot;);
let s: String = &quot;Hello world!&quot;.into();
</code></pre></pre>
<hr />
<p>这两种方式是等价的，怎么选呢？</p>
<ol>
<li>From 可以根据上下文做类型推导，使用场景更多；</li>
<li>而且因为实现了 From 会自动实现 Into，反之不会。</li>
<li>所以需要的时候，不要去实现 Into，只要实现 From 就好了。</li>
</ol>
</div>
</details>
<details id="admonition-from-和-into-还是自反的" class="admonition info">
<summary class="admonition-title">
<p>From 和 Into 还是自反的</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-from-和-into-还是自反的"></a></p>
</summary>
<div>
<p>把类型 T 的值转换成类型 T，会直接返回。这是因为标准库有如下的实现：</p>
<pre><pre class="playground"><code class="language-rust  editable">
// From（以及 Into）是自反的
impl&lt;T&gt; From&lt;T&gt; for T {
    fn from(t: T) -&gt; T {
        t
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-有了-from-和-into很多函数的接口就可以变得灵活" class="admonition info">
<summary class="admonition-title">
<p>有了 From 和 Into，很多函数的接口就可以变得灵活</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-有了-from-和-into很多函数的接口就可以变得灵活"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

fn print(v: impl Into&lt;IpAddr&gt;) {
    println!(&quot;{:?}&quot;, v.into());
}

fn main() {
    let v4: Ipv4Addr = &quot;2.2.2.2&quot;.parse().unwrap();
    let v6: Ipv6Addr = &quot;::1&quot;.parse().unwrap();
    
    // IPAddr 实现了 From&lt;[u8; 4]，转换 IPv4 地址
    print([1, 1, 1, 1]);
    // IPAddr 实现了 From&lt;[u16; 8]，转换 IPv6 地址
    print([0xfe80, 0, 0, 0, 0xaede, 0x48ff, 0xfe00, 0x1122]);
    // IPAddr 实现了 From&lt;Ipv4Addr&gt;
    print(v4);
    // IPAddr 实现了 From&lt;Ipv6Addr&gt;
    print(v6);
}
</code></pre></pre>
<hr />
<p>函数如果接受一个 IpAddr 为参数，我们可以使用 Into 让更多的类型可以被这个函数使用
所以，合理地使用 From / Into，可以让代码变得简洁，符合 Rust 可读性强的风格，更符合开闭原则。</p>
</div>
</details>
<h4 id="tryfromtryinto-值到值可能出现错误"><a class="header" href="#tryfromtryinto-值到值可能出现错误">TryFrom/TryInto: 值到值，可能出现错误</a></h4>
<p>注意，如果你的数据类型在转换过程中有可能出现错误，可以使用 TryFrom 和 TryInto，它们的用法和 From / Into 一样，只是 trait 内多了一个关联类型 Error，且返回的结果是 Result。</p>
<h4 id="asrefasmut-引用到引用"><a class="header" href="#asrefasmut-引用到引用">AsRef/AsMut: 引用到引用</a></h4>
<details id="admonition-asrefasmut定义" class="admonition info">
<summary class="admonition-title">
<p>AsRef/AsMut定义</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-asrefasmut定义"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait AsRef&lt;T&gt; where T: ?Sized {
    fn as_ref(&amp;self) -&gt; &amp;T;
}

pub trait AsMut&lt;T&gt; where T: ?Sized {
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}
</code></pre></pre>
<hr />
<p>在 trait 的定义上，都允许 T 使用大小可变的类型，如 str、[u8] 等。
AsMut 除了使用可变引用生成可变引用外，其它都和 AsRef 一样，所以我们重点看 AsRef</p>
</div>
</details>
<details id="admonition-体验一下-asref-的使用和实现" class="admonition info">
<summary class="admonition-title">
<p>体验一下 AsRef 的使用和实现</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-体验一下-asref-的使用和实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[allow(dead_code)]
enum Language {
    Rust,
    TypeScript,
    Elixir,
    Haskell,
}

impl AsRef&lt;str&gt; for Language {
    fn as_ref(&amp;self) -&gt; &amp;str {
        match self {
            Language::Rust =&gt; &quot;Rust&quot;,
            Language::TypeScript =&gt; &quot;TypeScript&quot;,
            Language::Elixir =&gt; &quot;Elixir&quot;,
            Language::Haskell =&gt; &quot;Haskell&quot;,
        }
    }
}

fn print_ref(v: impl AsRef&lt;str&gt;) {
    println!(&quot;{}&quot;, v.as_ref());
}

fn main() {
    let lang = Language::Rust;
    // &amp;str 实现了 AsRef&lt;str&gt;
    print_ref(&quot;Hello world!&quot;);
    // String 实现了 AsRef&lt;str&gt;
    print_ref(&quot;Hello world!&quot;.to_string());
    // 我们自己定义的 enum 也实现了 AsRef&lt;str&gt;
    print_ref(lang);
}
</code></pre></pre>
<hr />
</div>
</details>
<details id="admonition-vas_refclone" class="admonition info">
<summary class="admonition-title">
<p>v.as_ref().clone()</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-vas_refclone"></a></p>
</summary>
<div>
<p>额外说明一下的是:
如果代码出现 v.as_ref().clone() 这样的语句，也就是说你要对 v 进行引用转换，然后又得到了拥有所有权的值，那么应该实现 From，然后做 v.into()。</p>
</div>
</details>
<h3 id="操作符相关-derefderefmut"><a class="header" href="#操作符相关-derefderefmut">操作符相关: Deref/DerefMut</a></h3>
<details id="admonition-derefderefmut定义及说明" class="admonition info">
<summary class="admonition-title">
<p>Deref/DerefMut定义及说明</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-derefderefmut定义及说明"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Deref {
    // 解引用出来的结果类型
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

pub trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
</code></pre></pre>
<hr />
<p>可以看到，DerefMut “继承”了 Deref，只是它额外提供了一个 deref_mut 方法，用来获取可变的解引用。所以这里重点学习 Deref。</p>
</div>
</details>
<details id="admonition-对于普通的引用解引用很直观" class="admonition info">
<summary class="admonition-title">
<p>对于普通的引用，解引用很直观</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-对于普通的引用解引用很直观"></a></p>
</summary>
<div>
<blockquote>
<p>对于普通的引用，解引用很直观，因为它只有一个指向值的地址，从这个地址可以获取到所需要的值</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
let mut x = 42;
let y = &amp;mut x;
// 解引用，内部调用 DerefMut（其实现就是 *self）
*y += 1;
</code></pre></pre>
</div>
</details>
<details id="admonition-智能指针来说拿什么域来解引用就不那么直观-看看rc如何实现deref" class="admonition info">
<summary class="admonition-title">
<p>智能指针来说，拿什么域来解引用就不那么直观, 看看Rc如何实现Deref</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-智能指针来说拿什么域来解引用就不那么直观-看看rc如何实现deref"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;T: ?Sized&gt; Deref for Rc&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.inner().value
    }
}
</code></pre></pre>
<hr />
<h2 id="可以看到它最终指向了堆上的-rcbox-内部的-value-的地址然后如果对其解引用的话得到了-value-对应的值以下图为例最终打印出-v--1"><a class="header" href="#可以看到它最终指向了堆上的-rcbox-内部的-value-的地址然后如果对其解引用的话得到了-value-对应的值以下图为例最终打印出-v--1">可以看到，它最终指向了堆上的 RcBox 内部的 value 的地址，然后如果对其解引用的话，得到了 value 对应的值。以下图为例，最终打印出 v = 1。</a></h2>
<p>从图中还可以看到，Deref 和 DerefMut 是自动调用的，*b 会被展开为 *(b.deref())。</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/14%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84trait%EF%BC%9F-4696029.jpg" alt="RcBox解引用" /></p>
</div>
</details>
<details id="admonition-在-rust-里绝大多数智能指针都实现了-deref我们也可以为自己的数据结构实现-deref" class="admonition info">
<summary class="admonition-title">
<p>在 Rust 里，绝大多数智能指针都实现了 Deref，我们也可以为自己的数据结构实现 Deref</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-在-rust-里绝大多数智能指针都实现了-deref我们也可以为自己的数据结构实现-deref"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::ops::{Deref, DerefMut};

#[derive(Debug)]
struct Buffer&lt;T&gt;(Vec&lt;T&gt;);

impl&lt;T&gt; Buffer&lt;T&gt; {
    pub fn new(v: impl Into&lt;Vec&lt;T&gt;&gt;) -&gt; Self {
        Self(v.into())
    }
}

impl&lt;T&gt; Deref for Buffer&lt;T&gt; {
    type Target = [T];

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl&lt;T&gt; DerefMut for Buffer&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.0
    }
}

fn main() {
    let mut buf = Buffer::new([1, 3, 2, 4]);
    // 因为实现了 Deref 和 DerefMut，这里 buf 可以直接访问 Vec&lt;T&gt; 的方法
    // 下面这句相当于：(&amp;mut buf).deref_mut().sort()，也就是 (&amp;mut buf.0).sort()
    buf.sort();
    println!(&quot;buf: {:?}&quot;, buf);
}
</code></pre></pre>
<hr />
<p>但是在这个例子里，数据结构 Buffer 包裹住了 Vec，但这样一来，原本 Vec 实现了的很多方法，现在使用起来就很不方便，需要用 buf.0 来访问。怎么办？
可以实现 Deref 和 DerefMut，这样在解引用的时候，直接访问到 buf.0，省去了代码的啰嗦和数据结构内部字段的隐藏。</p>
</div>
</details>
<details id="admonition-编译器默认强制做解引用" class="admonition info">
<summary class="admonition-title">
<p>编译器默认强制做解引用</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-编译器默认强制做解引用"></a></p>
</summary>
<div>
<p>在上面代码里，还有一个值得注意的地方：
写 buf.sort() 的时候，并没有做解引用的操作，为什么会相当于访问了 buf.0.sort() 呢？这是因为 sort() 方法第一个参数是 &amp;mut self，此时 Rust 编译器会强制做 Deref/DerefMut 的解引用，所以这相当于 (*(&amp;mut buf)).sort()。</p>
</div>
</details>
<h3 id="其他debugdisplaydefault"><a class="header" href="#其他debugdisplaydefault">其他：Debug/Display/Default</a></h3>
<details id="admonition-debugdisplaydefalut定义" class="admonition info">
<summary class="admonition-title">
<p>Debug/Display/Defalut定义</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-debugdisplaydefalut定义"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
</code></pre></pre>
<hr />
<p>可以看到，Debug 和 Display 两个 trait 的签名一样，都接受一个 &amp;self 和一个 &amp;mut Formatter。那为什么要有两个一样的 trait 呢？</p>
<h2 id="这是因为-debug-是为开发者调试打印数据结构所设计的而-display-是给用户显示数据结构所设计的这也是为什么-debug-trait-的实现可以通过派生宏直接生成而-display-必须手工实现在使用的时候debug-用--来打印display-用--打印"><a class="header" href="#这是因为-debug-是为开发者调试打印数据结构所设计的而-display-是给用户显示数据结构所设计的这也是为什么-debug-trait-的实现可以通过派生宏直接生成而-display-必须手工实现在使用的时候debug-用--来打印display-用--打印">这是因为 Debug 是为开发者调试打印数据结构所设计的，而 Display 是给用户显示数据结构所设计的。这也是为什么 Debug trait 的实现可以通过派生宏直接生成，而 Display 必须手工实现。在使用的时候，Debug 用 {:?} 来打印，Display 用 {} 打印。</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Default {
    fn default() -&gt; Self;
}
---
Default trait 用于为类型提供缺省值。它也可以通过 derive 宏 #[derive(Default)] 来生成实现，前提是类型中的每个字段都实现了 Default trait。在初始化一个数据结构时，我们可以部分初始化，然后剩余的部分使用 Default::default()。
</code></pre></pre>
</div>
</details>
<details id="admonition-debugdisplaydefault统一使用例子" class="admonition info">
<summary class="admonition-title">
<p>Debug/Display/Default统一使用例子</p>
<p><a class="admonition-anchor-link" href="2_3_trait.html#admonition-debugdisplaydefault统一使用例子"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::fmt;
// struct 可以 derive Default，但我们需要所有字段都实现了 Default
#[derive(Clone, Debug, Default)]
struct Developer {
    name: String,
    age: u8,
    lang: Language,
}

// enum 不能 derive Default
#[allow(dead_code)]
#[derive(Clone, Debug)]
enum Language {
    Rust,
    TypeScript,
    Elixir,
    Haskell,
}

// 手工实现 Default
impl Default for Language {
    fn default() -&gt; Self {
        Language::Rust
    }
}

impl Developer {
    pub fn new(name: &amp;str) -&gt; Self {
        // 用 ..Default::default() 为剩余字段使用缺省值
        Self {
            name: name.to_owned(),
            ..Default::default()
        }
    }
}

impl fmt::Display for Developer {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            &quot;{}({} years old): {:?} developer&quot;,
            self.name, self.age, self.lang
        )
    }
}

fn main() {
    // 使用 T::default()
    let dev1 = Developer::default();
    // 使用 Default::default()，但此时类型无法通过上下文推断，需要提供类型
    let dev2: Developer = Default::default();
    // 使用 T::new
    let dev3 = Developer::new(&quot;Tyr&quot;);
    println!(&quot;dev1: {}\\ndev2: {}\\ndev3: {:?}&quot;, dev1, dev2, dev3);
}
</code></pre></pre>
</div>
</details>
<h2 id="设计架构"><a class="header" href="#设计架构">设计架构</a></h2>
<h3 id="顺手自然"><a class="header" href="#顺手自然">顺手自然</a></h3>
<h3 id="桥接"><a class="header" href="#桥接">桥接</a></h3>
<h3 id="控制反转"><a class="header" href="#控制反转">控制反转</a></h3>
<h3 id="solid原则"><a class="header" href="#solid原则">SOLID原则</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iii-数据结构"><a class="header" href="#iii-数据结构">III. 数据结构</a></h1>
<!--ts-->
<ul>
<li><a href="3_data_structure.html#iii-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">III. 数据结构</a>
<ul>
<li><a href="3_data_structure.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BF%AB%E9%80%9F%E4%B8%80%E8%A7%88">数据结构快速一览</a></li>
<li><a href="3_data_structure.html#%E5%88%86%E7%B1%BB%E5%9B%BE">分类图</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:21 UTC 2022 -->
<!--te-->
<h2 id="数据结构快速一览"><a class="header" href="#数据结构快速一览">数据结构快速一览</a></h2>
<div id="admonition-数据结构快速一览" class="admonition tip">
<div class="admonition-title">
<p>数据结构快速一览</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-数据结构快速一览"></a></p>
</div>
<div>
<blockquote>
<p>用40分钟的时间，总结了Rust的主要数据结构的内 存布局。它能厘清“数据是如何在堆和栈上存储“的思路，在这里也推荐给你。
<a href="https://www.youtube.com/watch?v=rDoqT-a6UFg">Visualizing memory layout of Rust’s data types - YouTube</a></p>
</blockquote>
</div>
</div>
<h2 id="分类图"><a class="header" href="#分类图">分类图</a></h2>
<blockquote>
<p>数据结构可以看作对于类型系统的进一步整理，结构化。这其实是进一步抽象，从类型中提取出日常常用的工具并分类。</p>
</blockquote>
<div id="admonition-从系统容器原生三个纬度分类" class="admonition info">
<div class="admonition-title">
<p>从系统/容器/原生三个纬度分类</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-从系统容器原生三个纬度分类"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F.jpg" alt="" /></p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一智能指针"><a class="header" href="#一智能指针">一、智能指针</a></h1>
<!--ts-->
<ul>
<li><a href="3_1_smart_pointer.html#%E4%B8%80%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">一、智能指针</a>
<ul>
<li><a href="3_1_smart_pointer.html#%E6%8C%87%E9%92%88%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8">指针还是引用</a></li>
<li><a href="3_1_smart_pointer.html#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8D%E4%BB%85%E6%98%AF%E6%8C%87%E9%92%88">智能指针不仅是指针</a></li>
<li><a href="3_1_smart_pointer.html#box-%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98">Box: 在堆上分配内存</a>
<ul>
<li><a href="3_1_smart_pointer.html#%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8">实现内存分配器</a></li>
<li><a href="3_1_smart_pointer.html#%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E9%87%8A%E6%94%BE">内存如何释放</a></li>
</ul>
</li>
<li><a href="3_1_smart_pointer.html#cowa-b-%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D">Cow&lt;’a, B&gt;： 写时拷贝</a>
<ul>
<li><a href="3_1_smart_pointer.html#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="3_1_smart_pointer.html#%E4%B8%A4%E4%B8%AAtraittoownedborrowed">两个trait：ToOwned、Borrowed</a></li>
<li><a href="3_1_smart_pointer.html#toowned">ToOwned</a></li>
<li><a href="3_1_smart_pointer.html#%E5%8C%B9%E9%85%8D%E5%88%86%E5%8F%91">匹配分发</a></li>
<li><a href="3_1_smart_pointer.html#cow%E5%9C%A8%E9%9C%80%E8%A6%81%E6%97%B6%E6%89%8D%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%8B%B7%E8%B4%9D">Cow在需要时才进行内存分配拷贝</a></li>
</ul>
</li>
<li><a href="3_1_smart_pointer.html#mutexguard-%E6%95%B0%E6%8D%AE%E5%8A%A0%E9%94%81">MutexGuard： 数据加锁</a>
<ul>
<li><a href="3_1_smart_pointer.html#mutexguard%E4%B8%8Estringboxcowa-b%E7%9A%84%E5%AF%B9%E6%AF%94">MutexGuard与String、Box、Cow&lt;’a, B&gt;的对比</a></li>
<li><a href="3_1_smart_pointer.html#%E4%BD%BF%E7%94%A8mutexlock%E8%8E%B7%E5%8F%96">使用Mutex::lock获取</a></li>
<li><a href="3_1_smart_pointer.html#%E5%AE%9A%E4%B9%89%E4%B8%8Ederefdrop-trait%E5%AE%9E%E7%8E%B0">定义与Deref、Drop trait实现</a></li>
<li><a href="3_1_smart_pointer.html#%E4%BD%BF%E7%94%A8mutex_mutexguard%E7%9A%84%E4%BE%8B%E5%AD%90">使用Mutex_MutexGuard的例子</a></li>
</ul>
</li>
<li><a href="3_1_smart_pointer.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">自定义智能指针</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:19 UTC 2022 -->
<!--te-->
<h2 id="指针还是引用"><a class="header" href="#指针还是引用">指针还是引用</a></h2>
<details id="admonition-引用是特殊的指针" class="admonition info">
<summary class="admonition-title">
<p>引用是特殊的指针</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-引用是特殊的指针"></a></p>
</summary>
<div>
<ol>
<li>指针是一个持有内存地址的值，可以通过解引用来访问它指向的内存地址，理论上可以解引用到任意数据类型；</li>
<li>引用是一个特殊 的指针，它的解引用访问是受限的，只能解引用到它引用数据的类型，不能用作它用。</li>
</ol>
</div>
</details>
<h2 id="智能指针不仅是指针"><a class="header" href="#智能指针不仅是指针">智能指针不仅是指针</a></h2>
<details id="admonition-智能指针指针额外处理能力" class="admonition info">
<summary class="admonition-title">
<p>智能指针=指针+额外处理能力</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-智能指针指针额外处理能力"></a></p>
</summary>
<div>
<ol>
<li>在指针和引用的基础上，Rust 偷师 C++，提供了智能指针。</li>
<li>智能指针是一个表现行为很 像指针的数据结构，但除了指向数据的指针外，它还有元数据以提供额外的处理能力。</li>
</ol>
</div>
</details>
<details id="admonition-智能指针胖指针所有权" class="admonition info">
<summary class="admonition-title">
<p>智能指针=胖指针+所有权</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-智能指针胖指针所有权"></a></p>
</summary>
<div>
<ol>
<li>智能指针一定是一个胖指针，但胖指针不一定是一个 智能指针。</li>
<li>比如 &amp;str 就只是一个胖指针，它有指向堆内存字符串的指针，同时还有关于字 符串长度的元数据。</li>
</ol>
<h2 id="-7"><a class="header" href="#-7"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/15%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F.jpg" alt="" /></a></h2>
<ol>
<li>String 除了多一个 capacity 字段，似乎也没有什么特殊。</li>
<li>但 String 对 堆上的值有所有权，而 &amp;str 是没有所有权的</li>
<li>这是 Rust 中智能指针和普通胖指针的区 别。</li>
</ol>
</div>
</details>
<details id="admonition-智能指针和结构体有什么区别" class="admonition info">
<summary class="admonition-title">
<p>智能指针和结构体有什么区别</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-智能指针和结构体有什么区别"></a></p>
</summary>
<div>
<ol>
<li>String用结构体定义，其实就是Vec<u8></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>和普通的结构体不同的是，<a href="https://doc.rust-lang.org/src/alloc/string.rs.html#2301-2316">String 实现了 Deref 和 DerefMut</a>，这使得它在解引用的时
候，会得到 &amp;str</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl ops::Deref for String {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;str {
        unsafe { str::from_utf8_unchecked(&amp;self.vec) }
    }
}

impl ops::DerefMut for String {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut str {
        unsafe { str::from_utf8_unchecked_mut(&amp;mut *self.vec) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>另外，由于在堆上分配了数据，String 还需要为其分配的资源做相应的回收。而 String 内部使用了
Vec，所以它可以<a href="https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#2710-2720">依赖 Vec 的能力来释放堆内存</a></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>unsafe impl&lt;#[may_dangle] T, A: Allocator&gt; Drop for Vec&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // use drop for [T]
            // use a raw slice to refer to the elements of the vector as weakest necessary type;
            // could avoid questions of validity in certain cases
            ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))
        }
        // RawVec handles deallocation
    }
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-在-rust-中凡是需要做资源回收的数据结构且实现了-derefderefmutdrop都是智能指针" class="admonition info">
<summary class="admonition-title">
<p>在 Rust 中，凡是需要做资源回收的数据结构，且实现了 Deref/DerefMut/Drop，都是智能指针。</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-在-rust-中凡是需要做资源回收的数据结构且实现了-derefderefmutdrop都是智能指针"></a></p>
</summary>
<div>
<p>按照这个定义，除了 String，还有很多智能指针，比如：</p>
<ol>
<li>
<p>用于在堆上 分配内存的 Box<T> 和 Vec<T></p>
</li>
<li>
<p>用于引用计数的 Rc<T> 和 Arc<T> </p>
</li>
<li>
<p>很多其他数据结 构，如 PathBuf、Cow&lt;’a, B&gt;、MutexGuard<T>、RwLockReadGuard<T> 和 RwLockWriteGuard 等也是智能指针。</p>
</li>
</ol>
</div>
</details>
<h2 id="box-在堆上分配内存"><a class="header" href="#box-在堆上分配内存">Box<T>: 在堆上分配内存</a></h2>
<details id="admonition-从cc得到box灵感" class="admonition info">
<summary class="admonition-title">
<p>从c/c++得到Box<T>灵感</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-从cc得到box灵感"></a></p>
</summary>
<div>
<p>我们先看 Box<T>，它是 Rust 中最基本的在堆上分配内存的方式，绝大多数其它包含堆内 存分配的数据类型，内部都是通过 Box<T> 完成的，比如 Vec<T>。</p>
<p>为什么有 Box<T> 的设计，我们得先回忆一下在 C 语言中，堆内存是怎么分配的。</p>
<ol>
<li>
<p>C 需要使用 malloc/calloc/realloc/free 来处理内存的分配，很多时候，被分配出来的内存 在函数调用中来来回回使用，导致谁应该负责释放这件事情很难确定，给开发者造成了极 大的心智负担。</p>
</li>
<li>
<p>C++ 在此基础上改进了一下，提供了一个智能指针  unique_ptr，可以在指针退出作用 域的时候释放堆内存，这样保证了堆内存的单一所有权。这个 unique_ptr 就是 Rust 的 Box<T> 的前身。</p>
</li>
</ol>
<hr />
<p><a href="https://doc.rust-lang.org/src/core/ptr/unique.rs.html#36-44">Box<T> 的定义</a>里，内部就是一个 Unique<T> 用于致敬 C++，Unique<T> 是
一个私有的数据结构，我们不能直接使用，它包裹了一个 *const T 指针，并唯一拥有这个 指针。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Unique&lt;T: ?Sized&gt; {
    pointer: *const T,
    // NOTE: this marker has no consequences for variance, but is necessary
    // for dropck to understand that we logically own a `T`.
    //
    // For details, see:
    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data
    _marker: PhantomData&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-堆上分配内存的-box-其实有一个缺省的泛型参数-a" class="admonition info">
<summary class="admonition-title">
<p>堆上分配内存的 Box<T> 其实有一个缺省的泛型参数 A</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-堆上分配内存的-box-其实有一个缺省的泛型参数-a"></a></p>
</summary>
<div>
<p>设计内存分配器的目的除了保证正确性之外，就是为了有效地利用剩余内存，并控制内存 在分配和释放过程中产生的碎片的数量。
在多核环境下，它还要能够高效地处理并发请 求。（如果你对通用内存分配器感兴趣，可以看参考资料） 堆上分配内存的 Box<T></p>
<p>其实有一个缺省的泛型参数 A，就需要满足 <a href="https://doc.rust-lang.org/std/alloc/trait.Allocator.html">Allocator trait</a>， 并且默认是 Global：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub struct Box&lt;T: ?Sized, A: Allocator = Global&gt;(Unique&lt;T&gt;, A);
<span class="boring">}
</span></code></pre></pre>
<hr />
<p>Allocator trait 提供很多方法：</p>
<ol>
<li>
<p>allocate 是主要方法，用于分配内存，对应 C 的 malloc/calloc；</p>
</li>
<li>
<p>deallocate，用于释放内存，对应 C 的 free；</p>
</li>
<li>
<p>还有 grow / shrink，用来扩大或缩小堆上已分配的内存，对应 C 的 realloc。</p>
</li>
</ol>
</div>
</details>
<details id="admonition-替换默认的内存分配器" class="admonition info">
<summary class="admonition-title">
<p>替换默认的内存分配器</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-替换默认的内存分配器"></a></p>
</summary>
<div>
<p>如果你想替换默认的内存分配器，可以使用 #[global_allocator] 标记宏，定义你自己的全局分配器。下面的代码展示了如何在 Rust
下使用<a href="https://crates.io/crates/jemallocator">jemalloc</a>:</p>
<pre><pre class="playground"><code class="language-rust">
use jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

fn main() {}
</code></pre></pre>
</div>
</details>
<h3 id="实现内存分配器"><a class="header" href="#实现内存分配器">实现内存分配器</a></h3>
<details id="admonition-内存分配器" class="admonition info">
<summary class="admonition-title">
<p>内存分配器</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-内存分配器"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::alloc::{GlobalAlloc, Layout, System};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        let data = System.alloc(layout);
        eprintln!(&quot;ALLOC: {:p}, size {}&quot;, data, layout.size());
        data
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        eprintln!(&quot;FREE: {:p}, size {}&quot;, ptr, layout.size());
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;

#[allow(dead_code)]
struct Matrix {
    // 使用不规则的数字如 505 可以让 dbg! 的打印很容易分辨出来
    data: [u8; 505],
}

impl Default for Matrix {
    fn default() -&gt; Self {
        Self { data: [0; 505] }
    }
}

fn main() {
    // 在这句执行之前已经有一些内存分配和释放
    let data = Box::new(Matrix::default());
    println!(
        &quot;!!! allocated memory: {:p}, len: {}&quot;,
        &amp;*data,
        std::mem::size_of::&lt;Matrix&gt;()
    );

    // data 在这里 drop，可以在打印中看到 FREE
    // 之后还有很多其它内存被释放
}
</code></pre></pre>
<hr />
<ol>
<li>这里 MyAllocator 就用 System allocator，然后加 eprintln!()，和我 们常用的 println!() 不同的是，eprintln!() 将数据打印到 stderr</li>
<li>注意这里不能使用 println!() 。因为 stdout 会打印到一个由 Mutex 互斥锁保护的共享全 局 buffer 中，这个过程中会涉及内存的分配，分配的内存又会触发 println!()，最终造成 程序崩溃。而
eprintln! 直接打印到 stderr，不会 buffer。</li>
<li>在使用 Box 分配堆内存的时候要注意，Box::new() 是一个函数，所以传入它的数据会出现 在栈上，再移动到堆上。所以，如果我们的 Matrix 结构不是 505 个字节，是一个非常大 的结构，就有可能出问题。</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">// #![feature(dropck_eyepatch)]

// struct MyBox&lt;T&gt;(Box&lt;T&gt;);

// unsafe impl&lt;#[may_dangle] T&gt; Drop for MyBox&lt;T&gt; {
//     fn drop(&amp;mut self) {
//         todo!();
//     }
// }

fn main() {
    // 在堆上分配 16M 内存，但它会现在栈上出现，再移动到堆上
    let boxed = Box::new([0u8; 1 &lt;&lt; 24]);
    println!(&quot;len: {}&quot;, boxed.len());
}
</code></pre></pre>
<ul>
<li><code>cargo run --bin box</code>或者在 playground 里运行，直接栈溢出 stack overflow</li>
<li>本地使用 “cargo run –bin box —release” 编译成 release 代码运行，会正常执行！</li>
</ul>
<blockquote>
<p>这是因为 “cargo run” 或者在 playground 下运行，默认是 debug build，它不会做任 何 inline 的优化，而 Box::new() 的实现就一行代码，并注明了要 inline，在 release 模式
下，这个函数调用会被优化掉, 本质是编译器自动调用下列方式:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(not(no_global_oom_handling))]
#[inline(always)]
#[doc(alias = &quot;alloc&quot;)]
#[doc(alias = &quot;malloc&quot;)]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub fn new(x: T) -&gt; Self {
    box x
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这里的关键字 box是 Rust 内部的关键字，用户代码无法调用，它只出现在 Rust 代码中，用于分配堆内存，box 关键字在编译时，会使用内存分配器 分配内存。</p>
</blockquote>
</div>
</details>
<h3 id="内存如何释放"><a class="header" href="#内存如何释放">内存如何释放</a></h3>
<details id="admonition-box默认实现的drop-trait" class="admonition info">
<summary class="admonition-title">
<p>Box<T>默认实现的Drop trait</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-box默认实现的drop-trait"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
unsafe impl&lt;#[may_dangle] T: ?Sized, A: Allocator&gt; Drop for Box&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        // FIXME: Do nothing, drop is currently performed by compiler.
    }
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-先稳定接口再迭代稳定实现" class="admonition info">
<summary class="admonition-title">
<p>先稳定接口，再迭代稳定实现</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-先稳定接口再迭代稳定实现"></a></p>
</summary>
<div>
<p>目前 drop trait 什么都没有做，编译器会自动插入 deallocate 的代码。这是 Rust 语 言的一种策略：在具体实现还没有稳定下来之前，我先把接口稳定，实现随着之后的迭代 慢慢稳定。</p>
</div>
</details>
<h2 id="cowa-b-写时拷贝"><a class="header" href="#cowa-b-写时拷贝">Cow&lt;’a, B&gt;： 写时拷贝</a></h2>
<div id="admonition-写时复制copy-on-write有异曲同工之妙" class="admonition info">
<div class="admonition-title">
<p>写时复制（Copy-on-write）有异曲同工之妙</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-写时复制copy-on-write有异曲同工之妙"></a></p>
</div>
<div>
<p>Cow 是 Rust 下用于提供写时克隆（Clone-on-Write）的一个智能指针，它跟虚拟内存管 理的写时复制（Copy-on-write）有异曲同工之妙：</p>
<blockquote>
<p>包裹一个只读借用，但如果调用者需 要所有权或者需要修改内容，那么它会 clone 借用的数据</p>
</blockquote>
</div>
</div>
<h3 id="定义"><a class="header" href="#定义">定义</a></h3>
<div id="admonition-cow定义" class="admonition info">
<div class="admonition-title">
<p>Cow定义</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-cow定义"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub enum Cow&lt;'a, B&gt; where B: 'a + ToOwned + ?Sized {
    Borrowed(&amp;'a B),
    Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>它是一个 enum，可以包含一个对类型 B 的只读引用，或者包含对类型 B 的拥有所有权的 数据。</p>
</blockquote>
</div>
</div>
<h3 id="两个traittoownedborrowed"><a class="header" href="#两个traittoownedborrowed">两个trait：ToOwned、Borrowed</a></h3>
<div id="admonition-cow定义用到两个traittoowned和borrowed" class="admonition info">
<div class="admonition-title">
<p>Cow定义用到两个trait：ToOwned和Borrowed</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-cow定义用到两个traittoowned和borrowed"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait ToOwned {
    type Owned: Borrow&lt;Self&gt;;
    #[must_use = &quot;cloning is often expensive and is not expected to have side effects&quot;]
    fn to_owned(&amp;self) -&gt; Self::Owned;

    fn clone_into(&amp;self, target: &amp;mut Self::Owned) { ... }
}

pub trait Borrow&lt;Borrowed&gt; where Borrowed: ?Sized {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>它是一个 enum，可以包含一个对类型 B 的只读引用，或者包含对类型 B 的拥有所有权的 数据。</p>
</blockquote>
</div>
</div>
<h3 id="toowned"><a class="header" href="#toowned">ToOwned</a></h3>
<div id="admonition-type-owned-borrow" class="admonition info">
<div class="admonition-title">
<p>type Owned: Borrow<Self></p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-type-owned-borrow"></a></p>
</div>
<div>
<ol>
<li>首先，type Owned: Borrow<Self> 是一个带有关联类型的 trait. 这里 Owned 是关联类型，需要使用者定义.</li>
<li>这里 Owned 不能是任意类型，它必须满足 Borrow<T> trait</li>
<li><a href="https://doc.rust-lang.org/src/alloc/str.rs.html#215-227">参考str对ToOwned trait的实现</a>：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl ToOwned for str {
    type Owned = String;
    #[inline]
    fn to_owned(&amp;self) -&gt; String {
        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }
    }

    fn clone_into(&amp;self, target: &amp;mut String) {
        let mut b = mem::take(target).into_bytes();
        self.as_bytes().clone_into(&amp;mut b);
        *target = unsafe { String::from_utf8_unchecked(b) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol start="4">
<li>可以看到关联类型 Owned 被定义为 String，而根据要求，String 必须定义 Borrow，那这里 Borrow 里的泛型变量 T 是谁呢？</li>
<li>ToOwned 要求是 Borrow，而此刻实现 ToOwned 的主体是 str，所以 Borrow 是 Borrow，也就是说 String 要实现 Borrow</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl Borrow&lt;str&gt; for String {
    #[inline]
    fn borrow(&amp;self) -&gt; &amp;str {
        &amp;self[..]
    }
}
<span class="boring">}
</span></code></pre></pre>
</div>
</div>
<div id="admonition-cow-和-toowned--borrow-之间的关系示意图" class="admonition info">
<div class="admonition-title">
<p>Cow 和 ToOwned / Borrow<T> 之间的关系示意图</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-cow-和-toowned--borrow-之间的关系示意图"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/15%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F-4781304.jpg" alt="type Owned: Borrow&lt;Self&gt; " /></p>
</div>
</div>
<h3 id="匹配分发"><a class="header" href="#匹配分发">匹配分发</a></h3>
<div id="admonition-为何-borrow-要定义成一个泛型-trait-呢" class="admonition info">
<div class="admonition-title">
<p>为何 Borrow 要定义成一个泛型 trait 呢？</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-为何-borrow-要定义成一个泛型-trait-呢"></a></p>
</div>
<div>
<ol>
<li>例子1：String不同借用方式</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use std::borrow::Borrow;

fn main() {
    let s = &quot;hello world!&quot;.to_owned();

    // 这里必须声明类型，因为 String 有多个 Borrow&lt;T&gt; 实现
    // 借用为 &amp;String
    let r1: &amp;String = s.borrow();
    // 借用为 &amp;str
    let r2: &amp;str = s.borrow();

    println!(&quot;r1: {:p}, r2: {:p}&quot;, r1, r2);
}
</code></pre></pre>
<blockquote>
<p>String 可以被借用为 &amp;String，也可以被借用为 &amp;str</p>
</blockquote>
<hr />
<ol start="2">
<li>例子2：Cow不同解引用方式</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;B: ?Sized + ToOwned&gt; Deref for Cow&lt;'_, B&gt; {
    type Target = B;

    fn deref(&amp;self) -&gt; &amp;B {
        match *self {
            Borrowed(borrowed) =&gt; borrowed,
            Owned(ref owned) =&gt; owned.borrow(),
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<hr />
<p>实现的原理很简单，根据 self 是 Borrowed 还是 Owned，我们分别取其内容，生成引 用：</p>
<ol>
<li>
<p>对于 Borrowed，直接就是引用；</p>
</li>
<li>
<p>对于 Owned，调用其 borrow() 方法，获得引用。</p>
</li>
</ol>
</div>
</div>
<div id="admonition-匹配分发使用match匹配实现静态动态分发之外的第三种分发" class="admonition info">
<div class="admonition-title">
<p>匹配分发：使用match匹配实现静态、动态分发之外的第三种分发</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-匹配分发使用match匹配实现静态动态分发之外的第三种分发"></a></p>
</div>
<div>
<p>虽然 Cow 是一个 enum，但是通过 Deref 的实现，我们可以获得统一的 体验.
比如 Cow<str>，使用的感觉和 &amp;str / String 是基本一致的。
注意，这种根据 enum 的不同状态来进行统一分发的方法是第三种分发手段，另外还可以使用泛型参数 做静态分发和使用 trait object 做动态分发</p>
</div>
</div>
<h3 id="cow在需要时才进行内存分配拷贝"><a class="header" href="#cow在需要时才进行内存分配拷贝">Cow在需要时才进行内存分配拷贝</a></h3>
<div id="admonition-写时拷贝" class="admonition info">
<div class="admonition-title">
<p>写时拷贝</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-写时拷贝"></a></p>
</div>
<div>
<p>那么 Cow 有什么用呢？</p>
<ol>
<li>显然，它可以在需要的时候才进行内存的分配和拷贝，在很多应用 场合，它可以大大提升系统的效率。</li>
<li>如果 Cow&lt;’a, B&gt; 中的 Owned 数据类型是一个需要 在堆上分配内存的类型，如 String、Vec<T> 等，还能减少堆内存分配的次数。 </li>
<li>相对于栈内存的分配释放来说，堆内存的分配和释放效率要低很多，其内部还 涉及系统调用和锁，减少不必要的堆内存分配是提升系统效率的关键手段。</li>
<li>而 Rust 的 Cow&lt;’a, B&gt;，在帮助你达成这个效果的同时，使用体验还非常简单舒服。</li>
</ol>
</div>
</div>
<details id="admonition-举例使用cow进行url解析" class="admonition info">
<summary class="admonition-title">
<p>举例使用Cow进行URL解析</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-举例使用cow进行url解析"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::borrow::Cow;

use url::Url;
fn main() {
    let url = Url::parse(&quot;https://tyr.com/rust?page=1024&amp;sort=desc&amp;extra=hello%20world&quot;).unwrap();
    let mut pairs = url.query_pairs();

    assert_eq!(pairs.count(), 3);

    let (mut k, v) = pairs.next().unwrap();
    // 因为 k, v 都是 Cow&lt;str&gt; 他们用起来感觉和 &amp;str 或者 String 一样
    // 此刻，他们都是 Borrowed
    println!(&quot;key: {}, v: {}&quot;, k, v);
    // 当修改发生时，k 变成 Owned
    k.to_mut().push_str(&quot;_lala&quot;);

    print_pairs((k, v));

    print_pairs(pairs.next().unwrap());
    print_pairs(pairs.next().unwrap());
}

fn print_pairs(pair: (Cow&lt;str&gt;, Cow&lt;str&gt;)) {
    println!(&quot;key: {}, value: {}&quot;, show_cow(pair.0), show_cow(pair.1));
}

fn show_cow(cow: Cow&lt;str&gt;) -&gt; String {
    match cow {
        Cow::Borrowed(v) =&gt; format!(&quot;Borrowed {}&quot;, v),
        Cow::Owned(v) =&gt; format!(&quot;Owned {}&quot;, v),
    }
}
</code></pre></pre>
<hr />
<blockquote>
<p>在解析 URL 的时候，我们经常需要将 querystring 中的参数，提取成 KV pair 来进一步使 用。
绝大多数语言中，提取出来的 KV 都是新的字符串，在每秒钟处理几十 k 甚至上百 k 请求的系统中，你可以想象这会带来多少次堆内存的分配。 
但在 Rust 中，我们可以用 Cow 类型轻松高效处理它，在读取 URL 的过程中：</p>
</blockquote>
<ol>
<li>每解析出一个 key 或者 value，我们可以用一个 &amp;str 指向 URL 中相应的位置，然后用 Cow 封装它 </li>
<li>而当解析出来的内容不能直接使用，需要 decode 时，比如 “hello%20world”，我们 可以生成一个解析后的 String，同样用 Cow 封装它。</li>
</ol>
</div>
</details>
<details id="admonition-举例serde使用cow进行序列化反序列化" class="admonition info">
<summary class="admonition-title">
<p>举例serde使用Cow进行序列化/反序列化</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-举例serde使用cow进行序列化反序列化"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use serde::Deserialize;
use std::borrow::Cow;

#[allow(dead_code)]
#[derive(Debug, Deserialize)]
struct User&lt;'input&gt; {
    #[serde(borrow)]
    name: Cow&lt;'input, str&gt;,
    age: u8,
}

fn main() {
    let input = r#&quot;{ &quot;name&quot;: &quot;Tyr&quot;, &quot;age&quot;: 18 }&quot;#;
    let user: User = serde_json::from_str(input).unwrap();

    match user.name {
        Cow::Borrowed(x) =&gt; println!(&quot;borrowed {}&quot;, x),
        Cow::Owned(x) =&gt; println!(&quot;owned {}&quot;, x),
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="mutexguard-数据加锁"><a class="header" href="#mutexguard-数据加锁">MutexGuard<T>： 数据加锁</a></h2>
<h3 id="mutexguard与stringboxcowa-b的对比"><a class="header" href="#mutexguard与stringboxcowa-b的对比">MutexGuard与String、Box<T>、Cow&lt;’a, B&gt;的对比</a></h3>
<details id="admonition-derefdrop" class="admonition info">
<summary class="admonition-title">
<p>Deref+Drop</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-derefdrop"></a></p>
</summary>
<div>
<p>String、Box<T>、Cow&lt;’a, B&gt; 等智能指针，都是通过 Deref 来提 供良好的用户体验， 
MutexGuard<T> 是另外一类很有意思的智能指针：</p>
<ol>
<li>它不但通过 Deref 提供良好的用户体验</li>
<li>还通过 Drop trait 来确保，使用到的内存以外的资源在退出 时进行释放。</li>
</ol>
</div>
</details>
<h3 id="使用mutexlock获取"><a class="header" href="#使用mutexlock获取">使用Mutex::lock获取</a></h3>
<details id="admonition-mutexguard这个结构是在调用-mutexlock-时生成的" class="admonition info">
<summary class="admonition-title">
<p>MutexGuard这个结构是在调用 Mutex::lock 时生成的</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-mutexguard这个结构是在调用-mutexlock-时生成的"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
    unsafe {
        self.inner.raw_lock();
        MutexGuard::new(self)
    }
}
</code></pre></pre>
<hr />
<p><a href="https://doc.rust-lang.org/src/std/sync/mutex.rs.html#279-284">rust文档</a></p>
<ol>
<li>首先，它会取得锁资源，如果拿不到，会在这里等待；</li>
<li>如果拿到了，会把 Mutex 结构的引 用传递给 MutexGuard。</li>
</ol>
</div>
</details>
<h3 id="定义与derefdrop-trait实现"><a class="header" href="#定义与derefdrop-trait实现">定义与Deref、Drop trait实现</a></h3>
<details id="admonition-mutexguard-的定义以及它的-deref-和-drop-的实现" class="admonition info">
<summary class="admonition-title">
<p>MutexGuard 的定义以及它的 Deref 和 Drop 的实现</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-mutexguard-的定义以及它的-deref-和-drop-的实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
// 这里用 must_use，当你得到了却不使用 MutexGuard 时会报警
#[must_use = &quot;if unused the Mutex will immediately unlock&quot;]
pub struct MutexGuard&lt;'a, T: ?Sized + 'a&gt; {
    lock: &amp;'a Mutex&lt;T&gt;,
    poison: poison::Guard,
}

impl&lt;T: ?Sized&gt; Deref for MutexGuard&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        unsafe { &amp;*self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; DerefMut for MutexGuard&lt;'_, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        unsafe { &amp;mut *self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    #[inline]
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.poison.done(&amp;self.poison);
            self.lock.inner.raw_unlock();
        }
    }
}
</code></pre></pre>
<hr />
<p>从代码中可以看到:</p>
<ol>
<li>当 MutexGuard 结束时，Mutex 会做 unlock</li>
<li>这样用户在使用 Mutex 时，可以不必关心何时释放这个互斥锁。</li>
<li>因为无论你在调用栈上怎样传递 MutexGuard ，哪怕在错误处理流程上提前退出，Rust 有所有权机制，可以确保只要 MutexGuard 离开作用域，锁就会被释放</li>
</ol>
</div>
</details>
<h3 id="使用mutex_mutexguard的例子"><a class="header" href="#使用mutex_mutexguard的例子">使用Mutex_MutexGuard的例子</a></h3>
<details id="admonition-mutex--mutexguard-example" class="admonition info">
<summary class="admonition-title">
<p>Mutex &amp; MutexGuard example</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-mutex--mutexguard-example"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use lazy_static::lazy_static;
use std::borrow::Cow;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

// lazy_static 宏可以生成复杂的 static 对象
lazy_static! {
    // 一般情况下 Mutex 和 Arc 一起在多线程环境下提供对共享内存的使用
    // 如果你把 Mutex 声明成 static，其生命周期是静态的，不需要 Arc
    static ref METRICS: Mutex&lt;HashMap&lt;Cow&lt;'static, str&gt;, usize&gt;&gt; =
        Mutex::new(HashMap::new());
}

fn main() {
    // 用 Arc 来提供并发环境下的共享所有权（使用引用计数）
    let metrics: Arc&lt;Mutex&lt;HashMap&lt;Cow&lt;'static, str&gt;, usize&gt;&gt;&gt; =
        Arc::new(Mutex::new(HashMap::new()));
    for _ in 0..32 {
        let m = metrics.clone();
        thread::spawn(move || {
            let mut g = m.lock().unwrap();
            // 此时只有拿到 MutexGuard 的线程可以访问 HashMap
            let data = &amp;mut *g;
            // Cow 实现了很多数据结构的 From trait，所以我们可以用 &quot;hello&quot;.into() 生成 Cow
            let entry = data.entry(&quot;hello&quot;.into()).or_insert(0);
            *entry += 1;
            // MutexGuard 被 Drop，锁被释放
        });
    }

    thread::sleep(Duration::from_millis(100));

    println!(&quot;metrics: {:?}&quot;, metrics.lock().unwrap());
}
</code></pre></pre>
<hr />
<blockquote>
<p>在解析 URL 的时候，我们经常需要将 querystring 中的参数，提取成 KV pair 来进一步使 用。
绝大多数语言中，提取出来的 KV 都是新的字符串，在每秒钟处理几十 k 甚至上百 k 请求的系统中，你可以想象这会带来多少次堆内存的分配。 
但在 Rust 中，我们可以用 Cow 类型轻松高效处理它，在读取 URL 的过程中：</p>
</blockquote>
<ol>
<li>每解析出一个 key 或者 value，我们可以用一个 &amp;str 指向 URL 中相应的位置，然后用 Cow 封装它 </li>
<li>而当解析出来的内容不能直接使用，需要 decode 时，比如 “hello%20world”，我们 可以生成一个解析后的 String，同样用 Cow 封装它。</li>
</ol>
</div>
</details>
<details id="admonition-你可以把-mutexguard-的引用传给另一个线程使用但你无法把-mutexguard-整个移动到另一个线程" class="admonition info">
<summary class="admonition-title">
<p>你可以把 MutexGuard 的引用传给另一个线程使用，但你无法把 MutexGuard 整个移动到另一个线程</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-你可以把-mutexguard-的引用传给另一个线程使用但你无法把-mutexguard-整个移动到另一个线程"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::sync::Mutex;

fn main() {
    //
    let m = Mutex::new(Mutex::new(1));
    let g = m.lock().unwrap();
    {
        rayon::join(
            || {
                let mut g1 = g.lock().unwrap();
                *g1 += 1;
                println!(&quot;Thread 1: {:?}&quot;, *g1);
            },
            || {
                let mut g1 = g.lock().unwrap();
                *g1 += 1;
                println!(&quot;Thread 1: {:?}&quot;, *g1);
            },
        );
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-mutexguard-的智能指针有很多用途" class="admonition info">
<summary class="admonition-title">
<p>MutexGuard 的智能指针有很多用途</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-mutexguard-的智能指针有很多用途"></a></p>
</summary>
<div>
<ul>
<li>r2d2类似实现一个数据库连接池：<a href="https://github.com/sfackler/r2d2/blob/master/src/lib.rs#L611-L638">源码</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;M&gt; Drop for PooledConnection&lt;M&gt;
where
    M: ManageConnection,
{
    fn drop(&amp;mut self) {
        self.pool.put_back(self.checkout, self.conn.take().unwrap());
    }
}

impl&lt;M&gt; Deref for PooledConnection&lt;M&gt;
where
    M: ManageConnection,
{
    type Target = M::Connection;

    fn deref(&amp;self) -&gt; &amp;M::Connection {
        &amp;self.conn.as_ref().unwrap().conn
    }
}

impl&lt;M&gt; DerefMut for PooledConnection&lt;M&gt;
where
    M: ManageConnection,
{
    fn deref_mut(&amp;mut self) -&gt; &amp;mut M::Connection {
        &amp;mut self.conn.as_mut().unwrap().conn
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>类似 MutexGuard 的智能指针有很多用途。比如要创建一个连接池，你可以在 Drop trait 中，回收 checkout 出来的连接，将其再放回连接池。</li>
</ul>
</div>
</details>
<h2 id="自定义智能指针"><a class="header" href="#自定义智能指针">自定义智能指针</a></h2>
<details id="admonition-mystring结构示意图" class="admonition info">
<summary class="admonition-title">
<p>MyString结构示意图</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-mystring结构示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/15%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F-4783668.jpg" alt="MyString" /></p>
</div>
</details>
<details id="admonition-mystring实现代码" class="admonition info">
<summary class="admonition-title">
<p>MyString实现代码</p>
<p><a class="admonition-anchor-link" href="3_1_smart_pointer.html#admonition-mystring实现代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::{fmt, ops::Deref, str};

const MINI_STRING_MAX_LEN: usize = 30;

// MyString 里，String 有 3 个 word，供 24 字节，所以它以 8 字节对齐
// 所以 enum 的 tag + padding 最少 8 字节，整个结构占 32 字节。
// MiniString 可以最多有 30 字节（再加上 1 字节长度和 1字节 tag），就是 32 字节.
struct MiniString {
    len: u8,
    data: [u8; MINI_STRING_MAX_LEN],
}

impl MiniString {
    // 这里 new 接口不暴露出去，保证传入的 v 的字节长度小于等于 30
    fn new(v: impl AsRef&lt;str&gt;) -&gt; Self {
        let bytes = v.as_ref().as_bytes();
        // 我们在拷贝内容时一定要要使用字符串的字节长度
        let len = bytes.len();
        let mut data = [0u8; MINI_STRING_MAX_LEN];
        data[..len].copy_from_slice(bytes);
        Self {
            len: len as u8,
            data,
        }
    }
}

impl Deref for MiniString {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        // 由于生成 MiniString 的接口是隐藏的，它只能来自字符串，所以下面这行是安全的
        str::from_utf8(&amp;self.data[..self.len as usize]).unwrap()
        // 也可以直接用 unsafe 版本
        // unsafe { str::from_utf8_unchecked(&amp;self.data[..self.len as usize]) }
    }
}

impl fmt::Debug for MiniString {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        // 这里由于实现了 Deref trait，可以直接得到一个 &amp;str 输出
        write!(f, &quot;{}&quot;, self.deref())
    }
}

#[derive(Debug)]
enum MyString {
    Inline(MiniString),
    Standard(String),
}

// 实现 Deref 接口对两种不同的场景统一得到 &amp;str
impl Deref for MyString {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        match *self {
            MyString::Inline(ref v) =&gt; v.deref(),
            MyString::Standard(ref v) =&gt; v.deref(),
        }
    }
}

// impl From&lt;&amp;str&gt; for MyString {
//     fn from(s: &amp;str) -&gt; Self {
//         match s.len() &gt; MINI_STRING_MAX_LEN {
//             true =&gt; Self::Standard(s.to_owned()),
//             _ =&gt; Self::Inline(MiniString::new(s)),
//         }
//     }
// }

// impl From&lt;String&gt; for MyString {
//     fn from(s: String) -&gt; Self {
//         match s.len() &gt; MINI_STRING_MAX_LEN {
//             true =&gt; Self::Standard(s),
//             _ =&gt; Self::Inline(MiniString::new(s)),
//         }
//     }
// }

impl&lt;T&gt; From&lt;T&gt; for MyString
where
    T: AsRef&lt;str&gt;,
{
    fn from(s: T) -&gt; Self {
        match s.as_ref().len() &gt; MINI_STRING_MAX_LEN {
            true =&gt; Self::Standard(s.as_ref().to_owned()),
            _ =&gt; Self::Inline(MiniString::new(s)),
        }
    }
}

impl fmt::Display for MyString {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.deref())
    }
}

impl MyString {
    pub fn push_str(&amp;mut self, s: &amp;str) {
        match *self {
            MyString::Inline(ref mut v) =&gt; {
                let len = v.len as usize;
                let len1 = s.len();
                if len + len1 &gt; MINI_STRING_MAX_LEN {
                    let mut owned = v.deref().to_string();
                    owned.push_str(s);
                    *self = MyString::Standard(owned);
                } else {
                    let total = len + len1;
                    v.data[len..len + len1].copy_from_slice(s.as_bytes());
                    v.len = total as u8;
                }
            }
            MyString::Standard(ref mut v) =&gt; v.push_str(s),
        }
    }
}

fn main() {
    let len1 = std::mem::size_of::&lt;MyString&gt;();
    let len2 = std::mem::size_of::&lt;MiniString&gt;();
    println!(&quot;Len: MyString {}, MiniString {}&quot;, len1, len2);

    let s1: MyString = &quot;hello world&quot;.into();
    let s2: MyString = &quot;这是一个超过了三十个字节的很长很长的字符串&quot;.into();

    // debug 输出
    println!(&quot;s1: {:?}, s2: {:?}&quot;, s1, s2);
    // display 输出
    println!(
        &quot;s1: {}({} bytes, {} chars), s2: {}({} bytes, {} chars)&quot;,
        s1,
        s1.len(),
        s1.chars().count(),
        s2,
        s2.len(),
        s2.chars().count()
    );

    // MyString 可以使用一切 &amp;str 接口，感谢 Rust 的自动 Deref
    assert!(s1.ends_with(&quot;world&quot;));
    assert!(s2.starts_with('这'));

    let s = String::from(&quot;这是一个超过了三十个字节的很长很长的字符串&quot;);
    println!(&quot;s: {:p}&quot;, &amp;*s);
    // From&lt;T: AsRef&lt;str&gt;&gt; 的实现会导致额外的复制
    let s3: MyString = s.into();
    println!(&quot;s3: {:p}&quot;, &amp;*s3);

    let mut s4: MyString = &quot;Hello Tyr! &quot;.into();
    println!(&quot;s4: {:?}&quot;, s4);
    s4.push_str(&quot;这是一个超过了三十个字节的很长很长的字符串&quot;);
    println!(&quot;s4: {:?}&quot;, s4);
}
</code></pre></pre>
<hr />
<p>为了让 MyString 表现行为和 &amp;str 一致:</p>
<ol>
<li>我们可以通过实现 Deref trait 让 MyString 可以被解引用成 &amp;str。</li>
<li>除此之外，还可以实现 Debug/Display 和 From<T> trait，让 MyString 使用起来更方便。</li>
<li>这个简单实现的 MyString，不管它内部的数据是纯栈上的 MiniString 版本，还是包含堆 上内存的 String 版本，使用的体验和 &amp;str 都一致，仅仅牺牲了一点点效率和内存，就可
以让小容量的字符串，可以高效地存储在栈上并且自如地使用。</li>
<li><a href="https://github.com/bodil/smartstring">smartstring</a> 的第三方库实现类似功能，还做了优化。</li>
</ol>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二集合容器"><a class="header" href="#二集合容器">二、集合容器</a></h1>
<!--ts-->
<ul>
<li><a href="3_2_containers.html#%E4%BA%8C%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8">二、集合容器</a>
<ul>
<li><a href="3_2_containers.html#%E5%AF%B9%E5%AE%B9%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%B9%89">对容器进行定义</a></li>
<li><a href="3_2_containers.html#%E5%AF%B9%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%B9%89">对集合容器进行定义</a></li>
<li><a href="3_2_containers.html#%E5%88%87%E7%89%87">切片</a>
<ul>
<li><a href="3_2_containers.html#array-vs-vector">array vs vector</a></li>
<li>[Vec 和 &amp;[T]](#vec-和-t)</li>
<li><a href="3_2_containers.html#%E8%A7%A3%E5%BC%95%E7%94%A8">解引用</a></li>
<li><a href="3_2_containers.html#%E5%88%87%E7%89%87%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator">切片和迭代器 Iterator</a></li>
<li><a href="3_2_containers.html#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%88%87%E7%89%87str">特殊的切片：&amp;str</a></li>
<li>[Box&lt;[T]&gt;](#boxt)</li>
<li><a href="3_2_containers.html#%E5%B8%B8%E7%94%A8%E5%88%87%E7%89%87%E5%AF%B9%E6%AF%94%E5%9B%BE">常用切片对比图</a></li>
</ul>
</li>
<li><a href="3_2_containers.html#%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>
<ul>
<li><a href="3_2_containers.html#%E5%93%88%E5%B8%8C%E8%A1%A8%E8%BF%98%E6%98%AF%E5%88%97%E8%A1%A8">哈希表还是列表</a></li>
<li><a href="3_2_containers.html#rust-%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8">Rust 的哈希表</a></li>
</ul>
</li>
<li><a href="3_2_containers.html#-1"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/17%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F-4882967.jpg"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/17%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F-4882967.jpg" alt="17｜数据结构：软件系统核心部件哈希表，内存如何布局？" style="max-width: 100%;"></a>
</a>
<ul>
<li><a href="3_2_containers.html#hashmap-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">HashMap 的数据结构</a></li>
<li><a href="3_2_containers.html#hashmap-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">HashMap 的基本使用方法</a></li>
<li><a href="3_2_containers.html#hashmap-%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">HashMap 的内存布局</a></li>
<li><a href="3_2_containers.html#ctrl-%E8%A1%A8">ctrl 表</a></li>
<li><a href="3_2_containers.html#%E5%93%88%E5%B8%8C%E8%A1%A8%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E4%B8%8E%E5%A2%9E%E9%95%BF">哈希表重新分配与增长</a></li>
<li><a href="3_2_containers.html#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%80%BC">删除一个值</a></li>
<li><a href="3_2_containers.html#%E8%AE%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%81%9A-hash-key">让自定义的数据结构做 Hash key</a></li>
<li><a href="3_2_containers.html#hashset--btreemap--btreeset">HashSet / BTreeMap / BTreeSet</a></li>
<li><a href="3_2_containers.html#%E4%B8%BA%E4%BB%80%E4%B9%88-rust-%E7%9A%84-hashmap-%E8%A6%81%E7%BC%BA%E7%9C%81%E9%87%87%E7%94%A8%E5%8A%A0%E5%AF%86%E5%AE%89%E5%85%A8%E7%9A%84%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95">为什么 Rust 的 HashMap 要缺省采用加密安全的哈希算法？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:20 UTC 2022 -->
<!--te-->
<h2 id="对容器进行定义"><a class="header" href="#对容器进行定义">对容器进行定义</a></h2>
<details id="admonition-容器数据结构如何理解" class="admonition tip">
<summary class="admonition-title">
<p>容器数据结构如何理解</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-容器数据结构如何理解"></a></p>
</summary>
<div>
<p>提到容器，很可能你首先会想到的就是数组、列表这些可以遍历的容器，但其实只要把某 种特定的数据封装在某个数据结构中，这个数据结构就是一个容器。比如 Option<T>，它 是一个包裹了 T 存在或不存在的容器，而 Cow 是一个封装了内部数据 B 或被借用或拥有 所有权的容器。</p>
</div>
</details>
<h2 id="对集合容器进行定义"><a class="header" href="#对集合容器进行定义">对集合容器进行定义</a></h2>
<details id="admonition-把拥有相同类型对数据放在一起统一处理" class="admonition tip">
<summary class="admonition-title">
<p>把拥有相同类型对数据放在一起，统一处理</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-把拥有相同类型对数据放在一起统一处理"></a></p>
</summary>
<div>
<p>集合容器，顾名思义，就是把一系列拥有相同类型的数据放在一起，统一处理，比如：</p>
<ol>
<li>
<p>我们熟悉的字符串 String、数组 [T; n]、列表 Vec<T> 和哈希表 HashMap&lt;K, V&gt; 等；</p>
</li>
<li>
<p>虽然到处在使用，但还并不熟悉的切片 slice；</p>
</li>
<li>
<p>在其他语言中使用过，但在 Rust 中还没有用过的循环缓冲区 VecDeque<T>、双向列 表 LinkedList<T> 等。</p>
</li>
</ol>
<blockquote>
<p>这些集合容器有很多共性，比如可以被遍历、可以进行 map-reduce 操作、可以从一种类 型转换成另一种类型等等。</p>
</blockquote>
</div>
</details>
<h2 id="切片"><a class="header" href="#切片">切片</a></h2>
<details id="admonition-切片到底是什么" class="admonition tip">
<summary class="admonition-title">
<p>切片到底是什么</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-切片到底是什么"></a></p>
</summary>
<div>
<p>在 Rust 里，切片是描述一组属于同一类型、长度不确定的、在内存中连续存放的数据结 构，用 [T] 来表述。因为长度不确定，所以切片是个 DST（Dynamically Sized Type）。</p>
<p>切片一般只出现在数据结构的定义中，不能直接访问，在使用中主要用以下形式：</p>
<ul>
<li>
<p>&amp;[T]：表示一个只读的切片引用。</p>
</li>
<li>
<p>&amp;mut [T]：表示一个可写的切片引用。</p>
</li>
<li>
<p>Box&lt;[T]&gt;：一个在堆上分配的切片。</p>
</li>
</ul>
</div>
</details>
<details id="admonition-切片与数据的关系" class="admonition tip">
<summary class="admonition-title">
<p>切片与数据的关系</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-切片与数据的关系"></a></p>
</summary>
<div>
<h2 id="怎么理解切片呢我打个比方切片之于具体的数据结构就像数据库中的视图之于表-你可以把它看成一种工具让我们可以统一访问行为相同结构类似但有些许差异的类-型"><a class="header" href="#怎么理解切片呢我打个比方切片之于具体的数据结构就像数据库中的视图之于表-你可以把它看成一种工具让我们可以统一访问行为相同结构类似但有些许差异的类-型">怎么理解切片呢？我打个比方，切片之于具体的数据结构，就像数据库中的视图之于表。 你可以把它看成一种工具，让我们可以统一访问行为相同、结构类似但有些许差异的类 型。</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let arr = [1, 2, 3, 4, 5];
    let vec = vec![1, 2, 3, 4, 5];
    let s1 = &amp;arr[1..3];
    let s2 = &amp;vec[1..3];
    println!(&quot;s1: {:?}, s2: {:?}&quot;, s1, s2);

    // &amp;[T] 和 &amp;[T] 是否相等取决于长度和内容是否相等
    assert_eq!(s1, s2);
    // &amp;[T] 可以和 Vec&lt;T&gt;/[T;n] 比较，也会看长度和内容
    assert_eq!(&amp;arr[..], vec);
    assert_eq!(&amp;vec[..], arr);
}
</code></pre></pre>
<ol>
<li>对于 array 和 vector，虽然是不同的数据结构，一个放在栈上，一个放在堆上，但它们的 切片是类似的；</li>
<li>而且对于相同内容数据的相同切片，比如 &amp;arr[1…3] 和 &amp;vec[1…3]，这 两者是等价的。</li>
<li>除此之外，切片和对应的数据结构也可以直接比较，这是因为它们之间实 现了 PartialEq trait
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4785008.jpg" alt="切片与具体数据的关系" /></li>
</ol>
</div>
</details>
<h3 id="array-vs-vector"><a class="header" href="#array-vs-vector">array vs vector</a></h3>
<details id="admonition-array和vector的区别与联系" class="admonition info">
<summary class="admonition-title">
<p>array和vector的区别与联系</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-array和vector的区别与联系"></a></p>
</summary>
<div>
<p>对于 array 和 vector，虽然是不同的数据结构：</p>
<ul>
<li>一个放在栈上</li>
<li>一个放在堆上</li>
</ul>
<blockquote>
<p>但它们的切片是类似的, 而且对于相同内容数据的相同切片</p>
</blockquote>
<ul>
<li>比如 &amp;arr[1…3] 和 &amp;vec[1…3]，这两者是等价的。</li>
<li>除此之外，切片和对应的数据结构也可以直接比较，这是因为它们之间实现了 PartialEq trait（源码参考资料）。</li>
</ul>
<blockquote>
<p>下图比较清晰地呈现了切片和数据之间的关系：
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4866674.jpg" alt="切片和数据之间的关系" /></p>
</blockquote>
</div>
</details>
<h3 id="vec-和-t"><a class="header" href="#vec-和-t">Vec<T> 和 &amp;[T]</a></h3>
<details id="admonition-t与vect关系" class="admonition tip">
<summary class="admonition-title">
<p>&amp;[T]与&amp;Vec[T]关系</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-t与vect关系"></a></p>
</summary>
<div>
<p>![&amp;[T]和&amp;Vec[T]](https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4785147.jpg)</p>
</div>
</details>
<h3 id="解引用"><a class="header" href="#解引用">解引用</a></h3>
<details id="admonition-支持切片的具体数据类型可以根据需要解引用转换成切片类型" class="admonition info">
<summary class="admonition-title">
<p>支持切片的具体数据类型可以根据需要解引用转换成切片类型</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-支持切片的具体数据类型可以根据需要解引用转换成切片类型"></a></p>
</summary>
<div>
<p>在使用的时候，支持切片的具体数据类型，你可以根据需要，解引用转换成切片类型。</p>
<ul>
<li>比如 Vec<T> 和 [T; n] 会转化成为 &amp;[T]，这是因为 Vec<T> 实现了 Deref trait，而 array 内建了到 &amp;[T] 的解引用。</li>
<li>我们可以写一段代码验证这一行为（代码）：</li>
</ul>
<hr />
<pre><pre class="playground"><code class="language-rust  editable">
use std::fmt;
fn main() {
    let v = vec![1, 2, 3, 4];

    // Vec 实现了 Deref，&amp;Vec&lt;T&gt; 会被自动解引用为 &amp;[T]，符合接口定义
    print_slice(&amp;v);
    // 直接是 &amp;[T]，符合接口定义
    print_slice(&amp;v[..]);

    // &amp;Vec&lt;T&gt; 支持 AsRef&lt;[T]&gt;
    print_slice1(&amp;v);
    // &amp;[T] 支持 AsRef&lt;[T]&gt;
    print_slice1(&amp;v[..]);
    // Vec&lt;T&gt; 也支持 AsRef&lt;[T]&gt;
    print_slice1(v);

    let arr = [1, 2, 3, 4];
    // 数组虽没有实现 Deref，但它的解引用就是 &amp;[T]
    print_slice(&amp;arr);
    print_slice(&amp;arr[..]);
    print_slice1(&amp;arr);
    print_slice1(&amp;arr[..]);
    print_slice1(arr);
}

// 注意下面的泛型函数的使用
fn print_slice&lt;T: fmt::Debug&gt;(s: &amp;[T]) {
    println!(&quot;{:?}&quot;, s);
}

fn print_slice1&lt;T, U&gt;(s: T)
where
    T: AsRef&lt;[U]&gt;,
    U: fmt::Debug,
{
    println!(&quot;{:?}&quot;, s.as_ref());
}
</code></pre></pre>
<hr />
<blockquote>
<p>这也就意味着，通过解引用，这几个和切片有关的数据结构都会获得切片的所有能力，包括：binary_search、chunks、concat、contains、start_with、end_with、group_by、iter、join、sort、split、swap 等一系列丰富的功能，</p>
</blockquote>
</div>
</details>
<h3 id="切片和迭代器-iterator"><a class="header" href="#切片和迭代器-iterator">切片和迭代器 Iterator</a></h3>
<details id="admonition-迭代器可以说是切片的孪生兄弟" class="admonition info">
<summary class="admonition-title">
<p>迭代器可以说是切片的孪生兄弟</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-迭代器可以说是切片的孪生兄弟"></a></p>
</summary>
<div>
<p>迭代器可以说是切片的孪生兄弟。切片是集合数据的视图，而迭代器定义了对集合数据的各种各样的访问操作。</p>
<p>Iterator trait 有大量的方法，但绝大多数情况下，只需要定义它的关联类型 Item 和 next() 方法。</p>
<ul>
<li>Item 定义了每次我们从迭代器中取出的数据类型；</li>
<li>next() 是从迭代器里取下一个值的方法。当一个迭代器的 next() 方法返回 None 时，表明迭代器中没有数据了。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[must_use = &quot;iterators are lazy and do nothing unless consumed&quot;]
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    // 大量缺省的方法，包括 size_hint, count, chain, zip, map, 
    // filter, for_each, skip, take_while, flat_map, flatten
    // collect, partition 等
    ... 
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-对-vec-使用-iter-方法并进行各种-map--filter--take-操作" class="admonition info">
<summary class="admonition-title">
<p>对 Vec<T> 使用 iter() 方法，并进行各种 map / filter / take 操作</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-对-vec-使用-iter-方法并进行各种-map--filter--take-操作"></a></p>
</summary>
<div>
<p>一个例子：对 Vec<T> 使用 iter() 方法，并进行各种 map / filter / take 操作。在函数式编程语言中，这样的写法很常见，代码的可读性很强。Rust 也支持这种写法（代码）：</p>
<pre><pre class="playground"><code class="language-rust">
fn main() {
    // 这里 Vec&lt;T&gt; 在调用 iter() 时被解引用成 &amp;[T]，所以可以访问 iter()
    let result = vec![1, 2, 3, 4]
        .iter()
        .map(|v| v * v)
        .filter(|v| *v &lt; 16)
        .take(1)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;{:?}&quot;, result);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-rust的迭代器是个懒接口这是如何实现的" class="admonition info">
<summary class="admonition-title">
<p>Rust的迭代器是个懒接口，这是如何实现的？</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-rust的迭代器是个懒接口这是如何实现的"></a></p>
</summary>
<div>
<p>需要注意的是 Rust 下的迭代器是个懒接口（lazy interface），也就是说这段代码直到运行到 collect 时才真正开始执行，之前的部分不过是在不断地生成新的结构，来累积处理逻辑而已。你可能好奇，这是怎么做到的呢？</p>
<p>原来，Iterator 大部分方法都返回一个实现了 Iterator 的数据结构，所以可以这样一路链式下去，在 Rust 标准库中，这些数据结构被称为 <a href="https://doc.rust-lang.org/src/core/iter/adapters/mod.rs.html">Iterator Adapter</a>。比如上面的 map 方法，它返回 Map 结构，而 Map 结构实现了 <a href="https://doc.rust-lang.org/src/core/iter/adapters/map.rs.html#93-133">Iterator（源码）</a>。
整个过程是这样的（链接均为源码资料）：</p>
<ol>
<li>在 collect() 执行的时候，它<a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1744-1749">实际试图使用 FromIterator 从迭代器中构建一个集合类型</a>，这会不断调用 next() 获取下一个数据；</li>
<li>此时的 Iterator 是 Take，Take 调自己的 next()，也就是它会<a href="https://doc.rust-lang.org/src/core/iter/adapters/take.rs.html#34-41">调用 Filter 的 next()</a>；</li>
<li>Filter 的 next() 实际上<a href="https://time.geekbang.org/column/article/422975">调用自己内部的 iter 的 find()</a>，此时内部的 iter 是 Map，find() 会使用 <a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2312-2325">try_fold()</a>，它会<a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2382-2406">继续调用 next()</a>，也就是 Map 的 next()；</li>
<li>Map 的 next() 会<a href="https://time.geekbang.org/column/article/422975">调用其内部的 iter 取 next() 然后执行 map 函数</a>。而此时内部的 iter 来自 Vec<i32>。</li>
</ol>
<p>所以，只有在 collect() 时，才触发代码一层层调用下去，并且调用会根据需要随时结束。这段代码中我们使用了 take(1)，整个调用链循环一次，就能满足 take(1) 以及所有中间过程的要求，所以它只会循环一次。</p>
</div>
</details>
<details id="admonition-rust的函数式编程写法性能如何" class="admonition info">
<summary class="admonition-title">
<p>Rust的函数式编程写法性能如何？</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-rust的函数式编程写法性能如何"></a></p>
</summary>
<div>
<p>你可能会有疑惑：这种函数式编程的写法，代码是漂亮了，然而这么多无谓的函数调用，性能肯定很差吧？毕竟，函数式编程语言的一大恶名就是性能差。</p>
<p>这个你完全不用担心， Rust 大量使用了 inline 等优化技巧，这样非常清晰友好的表达方式，性能和 C 语言的 for 循环差别不大。</p>
</div>
</details>
<details id="admonition-rust的iterator除了标准库还有itertools提供更多功能" class="admonition info">
<summary class="admonition-title">
<p>Rust的iterator除了标准库，还有itertools提供更多功能</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-rust的iterator除了标准库还有itertools提供更多功能"></a></p>
</summary>
<div>
<p>如果标准库中的功能还不能满足你的需求，你可以看看 itertools，它是和 Python 下 itertools 同名且功能类似的工具，提供了大量额外的 adapter。可以看一个简单的例子（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use itertools::Itertools;

fn main() {
    let err_str = &quot;bad happened&quot;;
    let input = vec![Ok(21), Err(err_str), Ok(7)];
    let it = input
        .into_iter()
        .filter_map_ok(|i| if i &gt; 10 { Some(i * 2) } else { None });
    // 结果应该是：vec![Ok(42), Err(err_str)]
    println!(&quot;{:?}&quot;, it.collect::&lt;Vec&lt;_&gt;&gt;());
}
</code></pre></pre>
<p>在实际开发中，我们可能从一组 Future 中汇聚出一组结果，里面有成功执行的结果，也有失败的错误信息。如果想对成功的结果进一步做 filter/map，那么标准库就无法帮忙了，就需要用 itertools 里的 filter_map_ok()。</p>
</div>
</details>
<h3 id="特殊的切片str"><a class="header" href="#特殊的切片str">特殊的切片：&amp;str</a></h3>
<details id="admonition-stringstring和str的区别与联系" class="admonition info">
<summary class="admonition-title">
<p>String、&amp;String和&amp;str的区别与联系</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-stringstring和str的区别与联系"></a></p>
</summary>
<div>
<p>我们来看一种特殊的切片：&amp;str。之前讲过，String 是一个特殊的 Vec<u8>，所以在 String 上做切片，也是一个特殊的结构 &amp;str。</p>
<p>对于 String、&amp;String、&amp;str，很多人也经常分不清它们的区别，我们在之前的一篇加餐中简单聊了这个问题，在上一讲智能指针中，也对比过 String 和 &amp;str。对于 &amp;String 和 &amp;str，如果你理解了上文中 &amp;Vec<T> 和 &amp;[T] 的区别，那么它们也是一样的：
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867212.jpg" alt="&amp;String和&amp;str" /></p>
</div>
</details>
<details id="admonition-string在解引用时会转换成str" class="admonition info">
<summary class="admonition-title">
<p>String在解引用时会转换成&amp;str</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-string在解引用时会转换成str"></a></p>
</summary>
<div>
<p>String 在解引用时，会转换成 &amp;str。可以用下面的代码验证（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::fmt;
fn main() {
    let s = String::from(&quot;hello&quot;);
    // &amp;String 会被解引用成 &amp;str
    print_slice(&amp;s);
    // &amp;s[..] 和 s.as_str() 一样，都会得到 &amp;str
    print_slice(&amp;s[..]);

    // String 支持 AsRef&lt;str&gt;
    print_slice1(&amp;s);
    print_slice1(&amp;s[..]);
    print_slice1(s.clone());

    // String 也实现了 AsRef&lt;[u8]&gt;，所以下面的代码成立
    // 打印出来是 [104, 101, 108, 108, 111]
    print_slice2(&amp;s);
    print_slice2(&amp;s[..]);
    print_slice2(s);
}

fn print_slice(s: &amp;str) {
    println!(&quot;{:?}&quot;, s);
}

fn print_slice1&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
    println!(&quot;{:?}&quot;, s.as_ref());
}

fn print_slice2&lt;T, U&gt;(s: T)
where
    T: AsRef&lt;[U]&gt;,
    U: fmt::Debug,
{
    println!(&quot;{:?}&quot;, s.as_ref());
}
</code></pre></pre>
</div>
</details>
<details id="admonition-字符的列表和字符串有什么关系和区别" class="admonition info">
<summary class="admonition-title">
<p>字符的列表和字符串有什么关系和区别</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-字符的列表和字符串有什么关系和区别"></a></p>
</summary>
<div>
<p>那么字符的列表和字符串有什么关系和区别？我们直接写一段代码来看看：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::iter::FromIterator;

fn main() {
    let arr = ['h', 'e', 'l', 'l', 'o'];
    let vec = vec!['h', 'e', 'l', 'l', 'o'];
    let s = String::from(&quot;hello&quot;);
    let s1 = &amp;arr[1..3];
    let s2 = &amp;vec[1..3];
    // &amp;str 本身就是一个特殊的 slice
    let s3 = &amp;s[1..3];
    println!(&quot;s1: {:?}, s2: {:?}, s3: {:?}&quot;, s1, s2, s3);

    // &amp;[char] 和 &amp;[char] 是否相等取决于长度和内容是否相等
    assert_eq!(s1, s2);
    // &amp;[char] 和 &amp;str 不能直接对比，我们把 s3 变成 Vec&lt;char&gt;
    assert_eq!(s2, s3.chars().collect::&lt;Vec&lt;_&gt;&gt;());
    // &amp;[char] 可以通过迭代器转换成 String，String 和 &amp;str 可以直接对比
    assert_eq!(String::from_iter(s2), s3);
}
</code></pre></pre>
<hr />
<blockquote>
<p>可以看到，字符列表可以通过迭代器转换成 String，String 也可以通过 chars() 函数转换成字符列表，如果不转换，二者不能比较。</p>
</blockquote>
<hr />
<p>下图把数组、列表、字符串以及它们的切片放在一起比较，可以更好地理解它们的区别：
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867332.jpg" alt="数组、列表、字符串和各自的切片" /></p>
</div>
</details>
<h3 id="boxt"><a class="header" href="#boxt">Box&lt;[T]&gt;</a></h3>
<details id="admonition-box和vect对比" class="admonition info">
<summary class="admonition-title">
<p>Box&lt;[T]&gt;和Vec<T>&amp;[T]对比</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-box和vect对比"></a></p>
</summary>
<div>
<p>切片主要有三种使用方式：</p>
<ul>
<li>切片的只读引用 &amp;[T]</li>
<li>切片的可变引用 &amp;mut [T]: 和&amp;[T]类似</li>
<li>Box&lt;[T]&gt;</li>
</ul>
<p>现在我们来看看 Box&lt;[T]&gt;。</p>
<p>Box&lt;[T]&gt; 是一个比较有意思的存在，它和 Vec<T> 有一点点差别：</p>
<ul>
<li>Vec<T> 有额外的 capacity，可以增长；</li>
<li>而 Box&lt;[T]&gt; 一旦生成就固定下来，没有 capacity，也无法增长。</li>
</ul>
<p>Box&lt;[T]&gt; 和切片的引用 &amp;[T] 也很类似：</p>
<ol>
<li>它们都是在栈上有一个包含长度的胖指针，指向存储数据的内存位置。</li>
<li>区别是：Box&lt;[T]&gt; 只会指向堆，&amp;[T] 指向的位置可以是栈也可以是堆；</li>
<li>此外，Box&lt;[T]&gt; 对数据具有所有权，而 &amp;[T] 只是一个借用。</li>
</ol>
<hr />
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867436.jpg" alt="" /></p>
</div>
</details>
<details id="admonition-那么如何产生-box-呢" class="admonition info">
<summary class="admonition-title">
<p>那么如何产生 Box&lt;[T]&gt; 呢？</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-那么如何产生-box-呢"></a></p>
</summary>
<div>
<p>那么如何产生 Box&lt;[T]&gt; 呢？
目前可用的接口就只有一个：从已有的 Vec<T> 中转换。我们看代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::ops::Deref;

fn main() {
    let mut v1 = vec![1, 2, 3, 4];
    v1.push(5);
    println!(&quot;cap should be 8: {}&quot;, v1.capacity());

    // 从 Vec&lt;T&gt; 转换成 Box&lt;[T]&gt;，此时会丢弃多余的 capacity
    let b1 = v1.into_boxed_slice();
    let mut b2 = b1.clone();

    let v2 = b1.into_vec();
    println!(&quot;cap should be exactly 5: {}&quot;, v2.capacity());

    assert!(b2.deref() == v2);

    // Box&lt;[T]&gt; 可以更改其内部数据，但无法 push
    b2[0] = 2;
    // b2.push(6);
    println!(&quot;b2: {:?}&quot;, b2);

    // 注意 Box&lt;[T]&gt; 和 Box&lt;[T; n]&gt; 并不相同
    let b3 = Box::new([2, 2, 3, 4, 5]);
    println!(&quot;b3: {:?}&quot;, b3);

    // b2 和 b3 相等，但 b3.deref() 和 v2 无法比较
    assert!(b2 == b3);
    // assert!(b3.deref() == v2);
}
</code></pre></pre>
<hr />
<p>运行代码可以看到:</p>
<ol>
<li>Vec<T> 可以通过 into_boxed_slice() 转换成 Box&lt;[T]&gt;</li>
<li>Box&lt;[T]&gt; 也可以通过 into_vec() 转换回 Vec<T>。</li>
</ol>
<p>这两个转换都是很轻量的转换，只是变换一下结构，不涉及数据的拷贝。</p>
<p>区别是:</p>
<ol>
<li>当 Vec<T> 转换成 Box&lt;[T]&gt; 时，没有使用到的容量就会被丢弃，所以整体占用的内存可能会降低。</li>
<li>而且 Box&lt;[T]&gt; 有一个很好的特性是，不像 Box&lt;[T;n]&gt; 那样在编译时就要确定大小，它可以在运行期生成，以后大小不会再改变。</li>
</ol>
<p>所以，当我们需要在堆上创建固定大小的集合数据，且不希望自动增长，那么，可以先创建 Vec<T>，再转换成 Box&lt;[T]&gt;。</p>
<blockquote>
<p>tokio 在提供 broadcast channel 时，就使用了 Box&lt;[T]&gt; 这个特性，你感兴趣的话，可以自己看看<a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/sync/broadcast.rs#L447">源码</a>。</p>
</blockquote>
</div>
</details>
<h3 id="常用切片对比图"><a class="header" href="#常用切片对比图">常用切片对比图</a></h3>
<div id="admonition-strtnvectmutt的区别与联系图" class="admonition info">
<div class="admonition-title">
<p>&amp;str、[T;n]、Vec<T>、&amp;[T]、&amp;mut[T]的区别与联系图 </p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-strtnvectmutt的区别与联系图"></a></p>
</div>
<div>
<p>下图描述了切片和数组 [T;n]、列表 Vec<T>、切片引用 &amp;[T] /&amp;mut [T]，以及在堆上分配的切片 Box&lt;[T]&gt; 之间的关系。</p>
<blockquote>
<p>建议花些时间理解这张图，也可以用相同的方式去总结学到的其他有关联的数据结构。</p>
</blockquote>
<hr />
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867546.jpg" alt="" /></p>
</div>
</div>
<h2 id="哈希表"><a class="header" href="#哈希表">哈希表</a></h2>
<h3 id="哈希表还是列表"><a class="header" href="#哈希表还是列表">哈希表还是列表</a></h3>
<details id="admonition-哈希表和列表的选择" class="admonition info">
<summary class="admonition-title">
<p>哈希表和列表的选择</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-哈希表和列表的选择"></a></p>
</summary>
<div>
<h2 id="我们知道哈希表和列表类似都用于处理需要随机访问的数据结构如果数据结构的输入和输出能一一对应那么可以使用列表如果无法一一对应那么就需要使用哈希表"><a class="header" href="#我们知道哈希表和列表类似都用于处理需要随机访问的数据结构如果数据结构的输入和输出能一一对应那么可以使用列表如果无法一一对应那么就需要使用哈希表">我们知道，哈希表和列表类似，都用于处理需要随机访问的数据结构。如果数据结构的输入和输出能一一对应，那么可以使用列表，如果无法一一对应，那么就需要使用哈希表。</a></h2>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/17%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F-4882989.jpg" alt="17｜数据结构：软件系统核心部件哈希表，内存如何布局？" /></p>
</div>
</details>
<h3 id="rust-的哈希表"><a class="header" href="#rust-的哈希表">Rust 的哈希表</a></h3>
<details id="admonition-哈希表的核心特点与解决" class="admonition info">
<summary class="admonition-title">
<p>哈希表的核心特点与解决</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-哈希表的核心特点与解决"></a></p>
</summary>
<div>
<p>哈希表最核心的特点就是：巨量的可能输入和有限的哈希表容量。这就会引发哈希冲突，也就是两个或者多个输入的哈希被映射到了同一个位置，所以我们要能够处理哈希冲突。</p>
<p>要解决冲突，首先可以通过更好的、分布更均匀的哈希函数，以及使用更大的哈希表来缓解冲突，但无法完全解决，所以我们还需要使用冲突解决机制。</p>
</div>
</details>
<p>如何解决冲突？</p>
<p>理论上，主要的冲突解决机制有链地址法（chaining）和开放寻址法（open addressing）。</p>
<ul>
<li>链地址法，我们比较熟悉，就是把落在同一个哈希上的数据用单链表或者双链表连接起来。这样在查找的时候，先找到对应的哈希桶（hash bucket），然后再在冲突链上挨个比较，直到找到匹配的项。</li>
</ul>
<blockquote>
<p>冲突链处理哈希冲突非常直观，很容易理解和撰写代码，但缺点是哈希表和冲突链使用了不同的内存，对缓存不友好。</p>
</blockquote>
<hr />
<h2 id="-8"><a class="header" href="#-8"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/17%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F-4882976.jpg" alt="17｜数据结构：软件系统核心部件哈希表，内存如何布局？" /></a></h2>
<ul>
<li>
<p>开放寻址法把整个哈希表看做一个大数组，不引入额外的内存，当冲突产生时，按照一定的规则把数据插入到其它空闲的位置。比如线性探寻（linear probing）在出现哈希冲突时，不断往后探寻，直到找到空闲的位置插入。</p>
</li>
<li>
<p>而二次探查，理论上是在冲突发生时，不断探寻哈希位置加减 n 的二次方，找到空闲的位置插入，我们看图，更容易理解：</p>
</li>
</ul>
<hr />
<h2 id="-9"><a class="header" href="#-9"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/17%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F-4882967.jpg" alt="17｜数据结构：软件系统核心部件哈希表，内存如何布局？" /></a></h2>
<blockquote>
<p>图中示意是理论上的处理方法，实际为了性能会有很多不同的处理。</p>
</blockquote>
<h3 id="hashmap-的数据结构"><a class="header" href="#hashmap-的数据结构">HashMap 的数据结构</a></h3>
<details id="admonition-深入rust哈希表的数据结构hashmap-hashbrown-rawtable" class="admonition info">
<summary class="admonition-title">
<p>深入Rust哈希表的数据结构：HashMap-&gt;hashbrown-&gt;RawTable</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-深入rust哈希表的数据结构hashmap-hashbrown-rawtable"></a></p>
</summary>
<div>
<p>我们来看看 Rust 哈希表的数据结构是什么样子的，打开标准库的 <a href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#206-208">源代码</a>：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use hashbrown::hash_map as base;

#[derive(Clone)]
pub struct RandomState {
    k0: u64,
    k1: u64,
}

pub struct HashMap&lt;K, V, S = RandomState&gt; {
    base: base::HashMap&lt;K, V, S&gt;,
}
</code></pre></pre>
<hr />
<p>可以看到，HashMap 有三个泛型参数:</p>
<ol>
<li>K 和 V 代表 key / value 的类型</li>
<li>S 是哈希算法的状态，它默认是 RandomState，占两个 u64。</li>
</ol>
<blockquote>
<p>RandomState 使用 SipHash 作为缺省的哈希算法，它是一个加密安全的哈希函数（cryptographically secure hashing）。</p>
</blockquote>
<p>从定义中还能看到，Rust 的 HashMap 复用了 hashbrown 的 HashMap: 
hashbrown 是 Rust 下对 <a href="https://abseil.io/blog/20180927-swisstables">Google Swiss Table</a> 的一个改进版实现，我们<a href="https://docs.rs/hashbrown/0.11.2/src/hashbrown/map.rs.html#192-195">打开 hashbrown 的代码</a>，看它的结构：</p>
<pre><pre class="playground"><code class="language-rust  editable">pub struct HashMap&lt;K, V, S = DefaultHashBuilder, A: Allocator + Clone = Global&gt; {
    pub(crate) hash_builder: S,
    pub(crate) table: RawTable&lt;(K, V), A&gt;,
}
</code></pre></pre>
<hr />
<p>可以看到，HashMap 里有两个域:</p>
<ol>
<li>一个是 hash_builder，类型是刚才我们提到的标准库使用的 RandomState</li>
<li>还有一个是具体的 RawTable：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct RawTable&lt;T, A: Allocator + Clone = Global&gt; {
    table: RawTableInner&lt;A&gt;,
    // Tell dropck that we own instances of T.
    marker: PhantomData&lt;T&gt;,
}

struct RawTableInner&lt;A&gt; {
    // Mask to get an index from a hash value. The value is one less than the
    // number of buckets in the table.
    bucket_mask: usize,

    // [Padding], T1, T2, ..., Tlast, C1, C2, ...
    //                                ^ points here
    ctrl: NonNull&lt;u8&gt;,

    // Number of elements that can be inserted before we need to grow the table
    growth_left: usize,

    // Number of elements in the table, only really used by len()
    items: usize,

    alloc: A,
}
</code></pre></pre>
<p>RawTable 中，实际上有意义的数据结构是 RawTableInner:</p>
<blockquote>
<p>前四个字段很重要：</p>
</blockquote>
<ol>
<li>usize 的 bucket_mask，是哈希表中哈希桶的数量减一；</li>
<li>名字叫 ctrl 的指针，它指向哈希表堆内存末端的 ctrl 区；</li>
<li>usize 的字段 growth_left，指哈希表在下次自动增长前还能存储多少数据；</li>
<li>Usize 的 items，表明哈希表现在有多少数据。</li>
</ol>
<blockquote>
<p>这里最后的 alloc 字段，和 RawTable 的 marker 一样，只是一个用来占位的类型，它用来分配在堆上的内存。</p>
</blockquote>
</div>
</details>
<h3 id="hashmap-的基本使用方法"><a class="header" href="#hashmap-的基本使用方法">HashMap 的基本使用方法</a></h3>
<details id="admonition-hashmap基本使用方法" class="admonition info">
<summary class="admonition-title">
<p>HashMap基本使用方法</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-hashmap基本使用方法"></a></p>
</summary>
<div>
<p>数据结构搞清楚，我们再看具体使用方法。Rust 哈希表的使用很简单，它提供了一系列很方便的方法，使用起来和其它语言非常类似，你只要看看文档，就很容易理解。</p>
<blockquote>
<p>我们来写段代码，尝试一下（代码）：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    explain(&quot;empty&quot;, &amp;map);

    map.insert('a', 1);
    explain(&quot;added 1&quot;, &amp;map);

    map.insert('b', 2);
    map.insert('c', 3);
    explain(&quot;added 3&quot;, &amp;map);

    map.insert('d', 4);
    explain(&quot;added 4&quot;, &amp;map);

    // get 时需要使用引用，并且也返回引用
    assert_eq!(map.get(&amp;'a'), Some(&amp;1));
    assert_eq!(map.get_key_value(&amp;'b'), Some((&amp;'b', &amp;2)));

    map.remove(&amp;'a');
    // 删除后就找不到了
    assert_eq!(map.contains_key(&amp;'a'), false);
    assert_eq!(map.get(&amp;'a'), None);
    explain(&quot;removed&quot;, &amp;map);
    // shrink 后哈希表变小
    map.shrink_to_fit();
    explain(&quot;shrinked&quot;, &amp;map);
}

fn explain&lt;K, V&gt;(name: &amp;str, map: &amp;HashMap&lt;K, V&gt;) {
    println!(&quot;{}: len: {}, cap: {}&quot;, name, map.len(), map.capacity());
}
</code></pre></pre>
<hr />
<ol>
<li>可以看到，当 HashMap::new() 时，它并没有分配空间，容量为零</li>
<li>随着哈希表不断插入数据，它会以 2 的幂减一的方式增长，最小是 3。</li>
<li>当删除表中的数据时，原有的表大小不变，只有显式地调用 shrink_to_fit，才会让哈希表变小。</li>
</ol>
</div>
</details>
<h3 id="hashmap-的内存布局"><a class="header" href="#hashmap-的内存布局">HashMap 的内存布局</a></h3>
<details id="admonition-ctrl表的变化借助stdmemtransmute查看内存布局" class="admonition info">
<summary class="admonition-title">
<p>ctrl表的变化：借助std::mem::transmute查看内存布局</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-ctrl表的变化借助stdmemtransmute查看内存布局"></a></p>
</summary>
<div>
<p>通过 HashMap 的公开接口无法看到 HashMap 在内存中是如何布局，还是需要借助 std::mem::transmute 方法，来把数据结构打出来。</p>
<blockquote>
<p>我们把刚才的代码改一改（代码）：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
use std::collections::HashMap;

fn main() {
    let map = HashMap::new();
    let mut map = explain(&quot;empty&quot;, map);

    map.insert('a', 1);
    let mut map = explain(&quot;added 1&quot;, map);
    map.insert('b', 2);
    map.insert('c', 3);

    let mut map = explain(&quot;added 3&quot;, map);

    map.insert('d', 4);

    let mut map = explain(&quot;added 4&quot;, map);

    map.remove(&amp;'a');

    explain(&quot;final&quot;, map);
}

// HashMap 结构有两个 u64 的 RandomState，然后是四个 usize，
// 分别是 bucket_mask, ctrl, growth_left 和 items
// 我们 transmute 打印之后，再 transmute 回去
fn explain&lt;K, V&gt;(name: &amp;str, map: HashMap&lt;K, V&gt;) -&gt; HashMap&lt;K, V&gt; {
    let arr: [usize; 6] = unsafe { std::mem::transmute(map) };
    println!(
        &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
        name, arr[2], arr[3], arr[4], arr[5]
    );
    unsafe { std::mem::transmute(arr) }
}
</code></pre></pre>
<hr />
<p>运行之后，可以看到：</p>
<pre><code class="language-shell">empty: bucket_mask 0x0, ctrl 0x1056df820, growth_left: 0, items: 0

added 1: bucket_mask 0x3, ctrl 0x7fa0d1405e30, growth_left: 2, items: 1

added 3: bucket_mask 0x3, ctrl 0x7fa0d1405e30, growth_left: 0, items: 3

added 4: bucket_mask 0x7, ctrl 0x7fa0d1405e90, growth_left: 3, items: 4

final: bucket_mask 0x7, ctrl 0x7fa0d1405e90, growth_left: 4, items: 3
</code></pre>
<blockquote>
<p>发现在运行的过程中，ctrl 对应的堆地址发生了改变。</p>
</blockquote>
<ul>
<li>在我的 OS X 下，一开始哈希表为空，ctrl 地址看上去是一个 TEXT/RODATA 段的地址，应该是指向了一个默认的空表地址；</li>
<li>插入第一个数据后，哈希表分配了 4 个 bucket，ctrl 地址发生改变；</li>
<li>在插入三个数据后，growth_left 为零</li>
<li>再插入时，哈希表重新分配，ctrl 地址继续改变。</li>
</ul>
<blockquote>
<p>在探索 HashMap 数据结构时，说过 ctrl 是一个指向哈希表堆地址末端 ctrl 区的地址，所以我们可以通过这个地址，计算出哈希表堆地址的起始地址。</p>
</blockquote>
<p>因为哈希表有 8 个 bucket（0x7 + 1），每个 bucket 大小是 key（char） + value（i32） 的大小，也就是 8 个字节，所以一共是 64 个字节。
对于这个例子，通过 ctrl 地址减去 64，就可以得到哈希表的堆内存起始地址。然后，我们可以用 rust-gdb / rust-lldb 来打印这个内存。</p>
<blockquote>
<p>可以用 Linux 下的 rust-gdb 设置断点，依次查看哈希表有一个、三个、四个值，以及删除一个值的状态：</p>
</blockquote>
<pre><code class="language-shell">
❯ rust-gdb ~/.target/debug/hashmap2
GNU gdb (Ubuntu 9.2-0ubuntu2) 9.2
...
(gdb) b hashmap2.rs:32
Breakpoint 1 at 0xa43e: file src/hashmap2.rs, line 32.
(gdb) r
Starting program: /home/tchen/.target/debug/hashmap2
...
# 最初的状态，哈希表为空
empty: bucket_mask 0x0, ctrl 0x555555597be0, growth_left: 0, items: 0

Breakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32
32      unsafe { std::mem::transmute(arr) }
(gdb) c
Continuing.
# 插入了一个元素后，bucket 有 4 个（0x3+1），堆地址起始位置 0x5555555a7af0 - 4*8(0x20)
added 1: bucket_mask 0x3, ctrl 0x5555555a7af0, growth_left: 2, items: 1

Breakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32
32      unsafe { std::mem::transmute(arr) }
(gdb) x /12x 0x5555555a7ad0
0x5555555a7ad0:  0x00000061  0x00000001  0x00000000  0x00000000
0x5555555a7ae0:  0x00000000  0x00000000  0x00000000  0x00000000
0x5555555a7af0:  0x0affffff  0xffffffff  0xffffffff  0xffffffff
(gdb) c
Continuing.
# 插入了三个元素后，哈希表没有剩余空间，堆地址起始位置不变 0x5555555a7af0 - 4*8(0x20)
added 3: bucket_mask 0x3, ctrl 0x5555555a7af0, growth_left: 0, items: 3

Breakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32
32      unsafe { std::mem::transmute(arr) }
(gdb) x /12x 0x5555555a7ad0
0x5555555a7ad0:  0x00000061  0x00000001  0x00000062  0x00000002
0x5555555a7ae0:  0x00000000  0x00000000  0x00000063  0x00000003
0x5555555a7af0:  0x0a72ff02  0xffffffff  0xffffffff  0xffffffff
(gdb) c
Continuing.
# 插入第四个元素后，哈希表扩容，堆地址起始位置变为 0x5555555a7b50 - 8*8(0x40)
added 4: bucket_mask 0x7, ctrl 0x5555555a7b50, growth_left: 3, items: 4

Breakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32
32      unsafe { std::mem::transmute(arr) }
(gdb) x /20x 0x5555555a7b10
0x5555555a7b10:  0x00000061  0x00000001  0x00000000  0x00000000
0x5555555a7b20:  0x00000064  0x00000004  0x00000063  0x00000003
0x5555555a7b30:  0x00000000  0x00000000  0x00000062  0x00000002
0x5555555a7b40:  0x00000000  0x00000000  0x00000000  0x00000000
0x5555555a7b50:  0xff72ffff  0x0aff6502  0xffffffff  0xffffffff
(gdb) c
Continuing.
# 删除 a 后，剩余 4 个位置。注意 ctrl bit 的变化，以及 0x61 0x1 并没有被清除
final: bucket_mask 0x7, ctrl 0x5555555a7b50, growth_left: 4, items: 3

Breakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32
32      unsafe { std::mem::transmute(arr) }
(gdb) x /20x 0x5555555a7b10
0x5555555a7b10:  0x00000061  0x00000001  0x00000000  0x00000000
0x5555555a7b20:  0x00000064  0x00000004  0x00000063  0x00000003
0x5555555a7b30:  0x00000000  0x00000000  0x00000062  0x00000002
0x5555555a7b40:  0x00000000  0x00000000  0x00000000  0x00000000
0x5555555a7b50:  0xff72ffff  0xffff6502  0xffffffff  0xffffffff
</code></pre>
<hr />
<p>这段输出蕴藏了很多信息，结合示意图来仔细梳理。</p>
<ol>
<li>首先，插入第一个元素 ‘a’: 1 后，哈希表的内存布局如下：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/17%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F-4882958.jpg" alt="17｜数据结构：软件系统核心部件哈希表，内存如何布局？" /></p>
<ul>
<li>key ‘a’ 的 hash 和 bucket_mask 0x3 运算后得到第 0 个位置插入。</li>
<li>同时，这个 hash 的头 7 位取出来，在 ctrl 表中对应的位置，也就是第 0 个字节，把这个值写入。</li>
</ul>
<p>要理解这个步骤，关键就是要搞清楚这个 ctrl 表是什么。</p>
</div>
</details>
<h3 id="ctrl-表"><a class="header" href="#ctrl-表">ctrl 表</a></h3>
<details id="admonition-ctrl-表的主要目的与设计" class="admonition info">
<summary class="admonition-title">
<p>ctrl 表的主要目的与设计</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-ctrl-表的主要目的与设计"></a></p>
</summary>
<div>
<p>ctrl 表的主要目的是快速查找。它的设计非常优雅，值得我们学习。</p>
<p>一张 ctrl 表里:</p>
<ul>
<li>有若干个 128bit 或者说 16 个字节的分组（group）</li>
<li>group 里的每个字节叫 ctrl byte，对应一个 bucket，那么一个 group 对应 16 个 bucket。</li>
<li>如果一个 bucket 对应的 ctrl byte 首位不为 1，就表示这个 ctrl byte 被使用；</li>
<li>如果所有位都是 1，或者说这个字节是 0xff，那么它是空闲的。</li>
</ul>
<blockquote>
<p>一组 control byte 的整个 128 bit 的数据，可以通过一条指令被加载进来，然后和某个值进行 mask，找到它所在的位置。这就是HashMap的 SIMD 查表。</p>
</blockquote>
<blockquote>
<p>我们知道，现代 CPU 都支持单指令多数据集的操作，而 Rust 充分利用了 CPU 这种能力，一条指令可以让多个相关的数据载入到缓存中处理，大大加快查表的速度。所以，Rust 的哈希表查询的效率非常高。</p>
</blockquote>
<p>具体怎么操作，我们来看 HashMap 是如何通过 ctrl 表来进行数据查询的。</p>
<blockquote>
<p>假设这张表里已经添加了一些数据，我们现在要查找 key 为 ‘c’ 的数据：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/17%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F-4882948.jpg" alt="17｜数据结构：软件系统核心部件哈希表，内存如何布局？" /></p>
<ol>
<li>把 h 跟 bucket_mask 做与，得到一个值，图中是 139；</li>
<li>拿着这个 139，找到对应的 ctrl group 的起始位置，因为 ctrl group 以 16 为一组，所以这里找到 128；</li>
<li>用 SIMD 指令加载从 128 对应地址开始的 16 个字节；</li>
<li>对 hash 取头 7 个 bit，然后和刚刚取出的 16 个字节一起做与，找到对应的匹配，如果找到了，它（们）很大概率是要找的值；</li>
<li>如果不是，那么以二次探查（以 16 的倍数不断累积）的方式往后查找，直到找到为止。</li>
</ol>
<blockquote>
<p>所以，当 HashMap 插入和删除数据，以及因此导致重新分配的时候，主要工作就是在维护这张 ctrl 表和数据的对应。</p>
</blockquote>
<blockquote>
<p>因为 ctrl 表是所有操作最先触及的内存，所以，在 HashMap 的结构中，堆内存的指针直接指向 ctrl 表，而不是指向堆内存的起始位置，这样可以减少一次内存的访问。</p>
</blockquote>
</div>
</details>
<h3 id="哈希表重新分配与增长"><a class="header" href="#哈希表重新分配与增长">哈希表重新分配与增长</a></h3>
<details id="admonition-插入三个元素后没有剩余空间的哈希表在加入-d-4-时hash-map是如何增长的" class="admonition info">
<summary class="admonition-title">
<p>插入三个元素后没有剩余空间的哈希表，在加入 ‘d’: 4 时，hash map是如何增长的</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-插入三个元素后没有剩余空间的哈希表在加入-d-4-时hash-map是如何增长的"></a></p>
</summary>
<div>
<p>在插入第一条数据后，哈希表只有 4 个 bucket，所以只有头 4 个字节的 ctrl 表有用。随着哈希表的增长，bucket 不够，就会导致重新分配。由于 bucket_mask 永远比 bucket 数量少 1，所以插入三个元素后就会重新分配。</p>
<p>根据 rust-gdb 中得到的信息，我们看插入三个元素后没有剩余空间的哈希表，在加入 ‘d’: 4 时，是如何增长的: </p>
<ol>
<li>首先，哈希表会按幂扩容，从 4 个 bucket 扩展到 8 个 bucket。</li>
</ol>
<p>这会导致分配新的堆内存，然后原来的 ctrl table 和对应的 kv 数据会被移动到新的内存中。</p>
<ul>
<li>这个例子里因为 char 和 i32 实现了 Copy trait，所以是拷贝；</li>
<li>如果 key 的类型是 String，那么只有 String 的 24 个字节 (ptr|cap|len) 的结构被移动，String 的实际内存不需要变动。</li>
<li>在移动的过程中，会涉及哈希的重分配。</li>
<li>从下图可以看到，‘a’ / ‘c’ 的相对位置和它们的 ctrl byte 没有变化，但重新做 hash 后，‘b’ 的 ctrl byte 和位置都发生了变化：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/17%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F-4882903-4882936.jpg" alt="" /></p>
</div>
</details>
<h3 id="删除一个值"><a class="header" href="#删除一个值">删除一个值</a></h3>
<details id="admonition-哈希表删除时内存如何释放" class="admonition info">
<summary class="admonition-title">
<p>哈希表删除时内存如何释放？</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-哈希表删除时内存如何释放"></a></p>
</summary>
<div>
<p>明白了哈希表是如何增长的，我们再来看删除的时候会发生什么。</p>
<p>当要在哈希表中删除一个值时，整个过程和查找类似:</p>
<ol>
<li>先要找到要被删除的 key 所在的位置。</li>
<li>在找到具体位置后，并不需要实际清除内存，只需要将它的 ctrl byte 设回 0xff（或者标记成删除状态）。这样，这个 bucket 就可以被再次使用了</li>
</ol>
<blockquote>
<p>这里有一个问题，当 key/value 有额外的内存时，比如 String，它的内存不会立即回收，只有在下一次对应的 bucket 被使用时，让 HashMap 不再拥有这个 String 的所有权之后，这个 String 的内存才被回收。我们看下面的示意图：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/17%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F-4882903.jpg" alt="17｜数据结构：软件系统核心部件哈希表，内存如何布局？" /></p>
<p>一般来说，这并不会带来什么问题，顶多是内存占用率稍高一些。但某些极端情况下，比如在哈希表中添加大量内容，又删除大量内容后运行，这时你可以通过 shrink_to_fit / shrink_to 释放掉不需要的内存。</p>
</div>
</details>
<h3 id="让自定义的数据结构做-hash-key"><a class="header" href="#让自定义的数据结构做-hash-key">让自定义的数据结构做 Hash key</a></h3>
<details id="admonition-自定义数据结构需要实现hashpartialeqeq这三个trait" class="admonition info">
<summary class="admonition-title">
<p>自定义数据结构需要实现Hash、PartialEq、Eq这三个trait</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-自定义数据结构需要实现hashpartialeqeq这三个trait"></a></p>
</summary>
<div>
<p>有时候，我们需要让自定义的数据结构成为 HashMap 的 key。此时，要使用到三个 trait：<a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a>、<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a>、<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a>，不过这三个 trait 都可以通过派生宏自动生成。其中：</p>
<ol>
<li>实现了 Hash ，可以让数据结构计算哈希；</li>
<li>实现了 PartialEq/Eq，可以让数据结构进行相等和不相等的比较。</li>
<li>Eq 实现了比较的自反性（a == a）、对称性（a == b 则 b == a）以及传递性（a == b，b == c，则 a == c）</li>
<li>PartialEq 没有实现自反性。</li>
</ol>
<p>我们可以写个例子，看看自定义数据结构如何支持 HashMap：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::{
    collections::{hash_map::DefaultHasher, HashMap},
    hash::{Hash, Hasher},
};

// 如果要支持 Hash，可以用 #[derive(Hash)]，前提是每个字段都实现了 Hash
// 如果要能作为 HashMap 的 key，还需要 PartialEq 和 Eq
#[derive(Debug, Hash, PartialEq, Eq)]
struct Student&lt;'a&gt; {
    name: &amp;'a str,
    age: u8,
}

impl&lt;'a&gt; Student&lt;'a&gt; {
    pub fn new(name: &amp;'a str, age: u8) -&gt; Self {
        Self { name, age }
    }
}
fn main() {
    let mut hasher = DefaultHasher::new();
    let student = Student::new(&quot;Tyr&quot;, 18);
    // 实现了 Hash 的数据结构可以直接调用 hash 方法
    student.hash(&amp;mut hasher);
    let mut map = HashMap::new();
    // 实现了 Hash / PartialEq / Eq 的数据结构可以作为 HashMap 的 key
    map.insert(student, vec![&quot;Math&quot;, &quot;Writing&quot;]);
    println!(&quot;hash: 0x{:x}, map: {:?}&quot;, hasher.finish(), map);
}
</code></pre></pre>
</div>
</details>
<h3 id="hashset--btreemap--btreeset"><a class="header" href="#hashset--btreemap--btreeset">HashSet / BTreeMap / BTreeSet</a></h3>
<details id="admonition-hashset只用于确认存在存放无序集合" class="admonition info">
<summary class="admonition-title">
<p>HashSet只用于确认存在，存放无序集合</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-hashset只用于确认存在存放无序集合"></a></p>
</summary>
<div>
<p>有时我们只需要简单确认元素是否在集合中，如果用 HashMap 就有些浪费空间了。这时可以用 HashSet，它就是简化的 HashMap，可以用来存放无序的集合，定义直接是 HashMap&lt;K, ()&gt;：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use hashbrown::hash_set as base;

pub struct HashSet&lt;T, S = RandomState&gt; {
    base: base::HashSet&lt;T, S&gt;,
}

pub struct HashSet&lt;T, S = DefaultHashBuilder, A: Allocator + Clone = Global&gt; {
    pub(crate) map: HashMap&lt;T, (), S, A&gt;,
}
</code></pre></pre>
<blockquote>
<p>使用 HashSet 查看一个元素是否属于集合的效率非常高。</p>
</blockquote>
</div>
</details>
<details id="admonition-btreemap和btreeset都是用于查找存放有序集合" class="admonition info">
<summary class="admonition-title">
<p>BTreeMap和BTreeSet都是用于查找，存放有序集合</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-btreemap和btreeset都是用于查找存放有序集合"></a></p>
</summary>
<div>
<p>BTreeMap 是内部使用 <a href="https://en.wikipedia.org/wiki/B-tree">B-tree</a> 来组织哈希表的数据结构。另外 BTreeSet 和 HashSet 类似，是 BTreeMap 的简化版，可以用来存放有序集合。
我们这里重点看下 BTreeMap，它的数据结构如下：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct BTreeMap&lt;K, V&gt; {
    root: Option&lt;Root&lt;K, V&gt;&gt;,
    length: usize,
}

pub type Root&lt;K, V&gt; = NodeRef&lt;marker::Owned, K, V, marker::LeafOrInternal&gt;;

pub struct NodeRef&lt;BorrowType, K, V, Type&gt; {
    height: usize,
    node: NonNull&lt;LeafNode&lt;K, V&gt;&gt;,
    _marker: PhantomData&lt;(BorrowType, Type)&gt;,
}

struct LeafNode&lt;K, V&gt; {
    parent: Option&lt;NonNull&lt;InternalNode&lt;K, V&gt;&gt;&gt;,
    parent_idx: MaybeUninit&lt;u16&gt;,
    len: u16,
    keys: [MaybeUninit&lt;K&gt;; CAPACITY],
    vals: [MaybeUninit&lt;V&gt;; CAPACITY],
}

struct InternalNode&lt;K, V&gt; {
    data: LeafNode&lt;K, V&gt;,
    edges: [MaybeUninit&lt;BoxedNode&lt;K, V&gt;&gt;; 2 * B],
}
</code></pre></pre>
<blockquote>
<p>和 HashMap 不同的是，BTreeMap 是有序的。我们看个例子（代码）:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
use std::collections::BTreeMap;

fn main() {
    let map = BTreeMap::new();
    let mut map = explain(&quot;empty&quot;, map);

    for i in 0..16usize {
        map.insert(format!(&quot;Tyr {}&quot;, i), i);
    }

    let mut map = explain(&quot;added&quot;, map);

    map.remove(&quot;Tyr 1&quot;);

    let map = explain(&quot;remove 1&quot;, map);

    for item in map.iter() {
        println!(&quot;{:?}&quot;, item);
    }
}

// BTreeMap 结构有 height，node 和 length
// 我们 transmute 打印之后，再 transmute 回去
fn explain&lt;K, V&gt;(name: &amp;str, map: BTreeMap&lt;K, V&gt;) -&gt; BTreeMap&lt;K, V&gt; {
    let arr: [usize; 3] = unsafe { std::mem::transmute(map) };
    println!(
        &quot;{}: height: {}, root node: 0x{:x}, len: 0x{:x}&quot;,
        name, arr[0], arr[1], arr[2]
    );
    unsafe { std::mem::transmute(arr) }
}
</code></pre></pre>
<blockquote>
<p>可以看到，在遍历时，BTreeMap 会按照 key 的顺序把值打印出来。如果你想让自定义的数据结构可以作为 BTreeMap 的 key，那么需要实现 PartialOrd 和 Ord，这两者的关系和 PartialEq / Eq 类似，PartialOrd 也没有实现自反性。同样的，PartialOrd 和 Ord 也可以通过派生宏来实现。</p>
</blockquote>
</div>
</details>
<h3 id="为什么-rust-的-hashmap-要缺省采用加密安全的哈希算法"><a class="header" href="#为什么-rust-的-hashmap-要缺省采用加密安全的哈希算法">为什么 Rust 的 HashMap 要缺省采用加密安全的哈希算法？</a></h3>
<details id="admonition-为什么-rust-的-hashmap-要缺省采用加密安全的哈希算法" class="admonition info">
<summary class="admonition-title">
<p>为什么 Rust 的 HashMap 要缺省采用加密安全的哈希算法？</p>
<p><a class="admonition-anchor-link" href="3_2_containers.html#admonition-为什么-rust-的-hashmap-要缺省采用加密安全的哈希算法"></a></p>
</summary>
<div>
<p>我们知道哈希表在软件系统中的重要地位，但哈希表在最坏情况下，如果绝大多数 key 的 hash 都碰撞在一起，性能会到 O(n)，这会极大拖累系统的效率。</p>
<p>比如 1M 大小的 session 表，正常情况下查表速度是 O(1)，但极端情况下，需要比较 1M 个数据后才能找到，这样的系统就容易被 DoS 攻击。所以如果不是加密安全的哈希函数，只要黑客知道哈希算法，就可以构造出大量的 key 产生足够多的哈希碰撞，造成目标系统 DoS。</p>
<p>SipHash 就是为了回应 DoS 攻击而创建的哈希算法，虽然和 sha2 这样的加密哈希不同（不要将 SipHash 用于加密！），但它可以提供类似等级的安全性。把 SipHash 作为 HashMap 的缺省的哈希算法，Rust 可以避免开发者在不知情的情况下被 DoS，就像曾经在 Web 世界发生的那样。
当然，这一切的代价是性能损耗，虽然 SipHash 非常快，但它比 hashbrown 缺省使用的 Ahash 慢了不少。如果你确定使用的 HashMap 不需要 DoS 防护（比如一个完全内部使用的 HashMap），那么可以用 Ahash 来替换。你只需要使用 Ahash 提供的 RandomState 即可：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use ahash::{AHasher, RandomState};
use std::collections::HashMap;
let mut map: HashMap&lt;char, i32, RandomState&gt; = HashMap::default();
map.insert('a', 1);
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三错误处理"><a class="header" href="#三错误处理">三、错误处理</a></h1>
<!--ts-->
<ul>
<li><a href="3_3_error_handling.html#%E4%B8%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">三、错误处理</a>
<ul>
<li><a href="3_3_error_handling.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%8C%85%E5%90%AB%E8%BF%99%E4%B9%88%E5%87%A0%E9%83%A8%E5%88%86">错误处理包含这么几部分</a></li>
<li><a href="3_3_error_handling.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%BB%E6%B5%81%E6%96%B9%E6%B3%95">错误处理的主流方法</a></li>
<li><a href="3_3_error_handling.html#rust-%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">Rust 的错误处理</a>
<ul>
<li><a href="3_3_error_handling.html#rust-%E5%81%B7%E5%B8%88-haskell%E6%9E%84%E5%BB%BA%E4%BA%86%E5%AF%B9%E6%A0%87-maybe-%E7%9A%84-option-%E7%B1%BB%E5%9E%8B%E5%92%8C-%E5%AF%B9%E6%A0%87-either-%E7%9A%84-result-%E7%B1%BB%E5%9E%8B">Rust 偷师 Haskell，构建了对标 Maybe 的 Option 类型和 对标 Either 的 Result 类型。</a></li>
<li><a href="3_3_error_handling.html#-%E6%93%8D%E4%BD%9C%E7%AC%A6">? 操作符</a></li>
<li><a href="3_3_error_handling.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">函数式错误处理</a></li>
<li><a href="3_3_error_handling.html#panic-%E5%92%8C-catch_unwind">panic! 和 catch_unwind</a></li>
<li><a href="3_3_error_handling.html#error-trait-%E5%92%8C%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2">Error trait 和错误类型的转换</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:20 UTC 2022 -->
<!--te-->
<h2 id="错误处理包含这么几部分"><a class="header" href="#错误处理包含这么几部分">错误处理包含这么几部分</a></h2>
<details id="admonition-错误处理包含这么几部分" class="admonition info">
<summary class="admonition-title">
<p>错误处理包含这么几部分</p>
<p><a class="admonition-anchor-link" href="3_3_error_handling.html#admonition-错误处理包含这么几部分"></a></p>
</summary>
<div>
<p>在一门编程语言中，控制流程是语言的核心流程，而错误处理又是控制流程的重要组成部分。</p>
<p>语言优秀的错误处理能力，会大大减少错误处理对整体流程的破坏，让我们写代码更行云流水，读起来心智负担也更小。</p>
<p>对我们开发者来说，错误处理包含这么几部分：</p>
<ol>
<li>错误捕获后，可以立刻处理</li>
<li>也可以延迟到不得不处理的地方再处理，这就涉及到错误的传播（propagate）。</li>
<li>最后，根据不同的错误类型，给用户返回合适的、帮助他们理解问题所在的错误消息。</li>
</ol>
<hr />
<h2 id="-10"><a class="header" href="#-10"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/18%EF%BD%9C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Rust%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%EF%BC%9F-4895295.jpg" alt="18｜错误处理：为什么Rust的错误处理与众不同？" /></a></h2>
<blockquote>
<p>作为一门极其注重用户体验的编程语言，Rust 从其它优秀的语言中，尤其是 Haskell ，吸收了错误处理的精髓，并以自己独到的方式展现出来。</p>
</blockquote>
</div>
</details>
<h2 id="错误处理的主流方法"><a class="header" href="#错误处理的主流方法">错误处理的主流方法</a></h2>
<details id="admonition-错误处理的三种主流方法以及其他语言是如何应用这些方法的" class="admonition info">
<summary class="admonition-title">
<p>错误处理的三种主流方法以及其他语言是如何应用这些方法的。</p>
<p><a class="admonition-anchor-link" href="3_3_error_handling.html#admonition-错误处理的三种主流方法以及其他语言是如何应用这些方法的"></a></p>
</summary>
<div>
<ol>
<li>使用返回值（错误码）</li>
</ol>
<p>使用返回值来表征错误，是最古老也是最实用的一种方式，它的使用范围很广，从函数返回值，到操作系统的系统调用的错误码 errno、进程退出的错误码 retval，甚至 HTTP API 的状态码，都能看到这种方法的身影。</p>
<blockquote>
<p>举个例子，在 C 语言中，如果 fopen(filename) 无法打开文件，会返回 NULL，调用者通过判断返回值是否为 NULL，来进行相应的错误处理。</p>
</blockquote>
<blockquote>
<p>我们再看个例子：</p>
</blockquote>
<pre><code class="language-c">
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
</code></pre>
<p>单看这个接口，我们很难直观了解，当读文件出错时，错误是如何返回的。从文档中，我们得知，如果返回的 size_t 和传入的 size_t 不一致，那么要么发生了错误，要么是读到文件尾（EOF），调用者要进一步通过 ferror 才能得到更详细的错误。</p>
<p>像 C 这样，通过返回值携带错误信息，有很多局限。返回值有它原本的语义，强行把错误类型嵌入到返回值原本的语义中，需要全面且实时更新的文档，来确保开发者能正确区别对待，正常返回和错误返回。</p>
<p>所以 Golang 对其做了扩展，在函数返回的时候，可以专门携带一个错误对象。比如上文的 fread，在 Golang 下可以这么定义：</p>
<pre><code class="language-go">
func Fread(file *File, b []byte) (n int, err error)
</code></pre>
<p>Golang 这样，区分开错误返回和正常返回，相对 C 来说进了一大步。</p>
<blockquote>
<p>但是使用返回值的方式，始终有个致命的问题：在调用者调用时，错误就必须得到处理或者显式的传播。</p>
</blockquote>
<p>如果函数 A 调用了函数 B，在 A 返回错误的时候，就要把 B 的错误转换成 A 的错误，显示出来。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/18%EF%BD%9C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Rust%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%EF%BC%9F-4895283.jpg" alt="18｜错误处理：为什么Rust的错误处理与众不同？" /></p>
<p>这样写出来的代码会非常冗长，对我们开发者的用户体验不太好。如果不处理，又会丢掉这个错误信息，造成隐患。</p>
<p>另外，大部分生产环境下的错误是嵌套的。一个 SQL 执行过程中抛出的错误，可能是服务器出错，而更深层次的错误可能是，连接数据库服务器的 TLS session 状态异常。</p>
<p>其实知道服务器出错之外，我们更需要清楚服务器出错的内在原因。</p>
<ul>
<li>因为服务器出错这个表层错误会提供给最终用户，而出错的深层原因要提供给我们自己，服务的维护者。</li>
<li>但是这样的嵌套错误在 C / Golang 都是很难完美表述的。</li>
</ul>
<hr />
<ol start="2">
<li>使用异常</li>
</ol>
<p>因为返回值不利于错误的传播，有诸多限制，Java 等很多语言使用异常来处理错误。</p>
<p>你可以把异常看成一种关注点分离（Separation of Concerns）：</p>
<ol>
<li>错误的产生和错误的处理完全被分隔开</li>
<li>调用者不必关心错误，而被调者也不强求调用者关心错误。</li>
</ol>
<ul>
<li>程序中任何可能出错的地方，都可以抛出异常；</li>
<li>而异常可以通过栈回溯（stack unwind）被一层层自动传递，直到遇到捕获异常的地方，</li>
<li>如果回溯到 main 函数还无人捕获，程序就会崩溃。如下图所示：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/18%EF%BD%9C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Rust%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%EF%BC%9F-4895270.jpg" alt="18｜错误处理：为什么Rust的错误处理与众不同？" /></p>
<p>使用异常来返回错误可以极大地简化错误处理的流程，它解决了返回值的传播问题。</p>
<p>然而，上图中异常返回的过程看上去很直观，就像数据库中的事务（transaction）在出错时会被整体撤销（rollback）一样。</p>
<blockquote>
<p>但实际上，这个过程远比你想象的复杂，而且需要额外操心<a href="https://www.lighterra.com/papers/exceptionsharmful/">异常安全（exception safety）</a>。
我们看下面用来切换背景图片的（伪）代码：</p>
</blockquote>
<pre><code class="language-c++">
void transition(...) {
  lock(&amp;mutex);
  delete background;
  ++changed;
  background = new Background(...);
  unlock(&amp;mutex);
}
</code></pre>
<p>试想, 如果在创建新的背景时失败，抛出异常，会跳过后续的处理流程，一路栈回溯到 try catch 的代码，那么，这里锁住的 mutex 无法得到释放，而已有的背景被清空，新的背景没有创建，程序进入到一个奇怪的状态。</p>
<p>确实在大多数情况下，用异常更容易写代码，但当异常安全无法保证时，程序的正确性会受到很大的挑战。因此，你在使用异常处理时，需要特别注意异常安全，尤其是在并发环境下。</p>
<p>异常处理另外一个比较严重的问题是：开发者会滥用异常。只要有错误，不论是否严重、是否可恢复，都一股脑抛个异常。到了需要的地方，捕获一下了之。殊不知，异常处理的开销要比处理返回值大得多，滥用会有很多额外的开销。</p>
</div>
</details>
<ol start="3">
<li>使用类型系统</li>
</ol>
<p>第三种错误处理的方法就是使用类型系统。其实，在使用返回值处理错误的时候，我们已经看到了类型系统的雏形。</p>
<p>错误信息既然可以通过已有的类型携带，或者通过多返回值的方式提供，那么通过类型来表征错误，使用一个内部包含正常返回类型和错误返回类型的复合类型，通过类型系统来强制错误的处理和传递，是不是可以达到更好的效果呢？</p>
<p>的确如此。这种方式被大量使用在有强大类型系统支持的函数式编程语言中，如 Haskell/Scala/Swift。其中最典型的包含了错误类型的复合类型是 Haskell 的 Maybe 和 Either 类型。</p>
<ul>
<li>
<p>Maybe 类型允许数据包含一个值（Just）或者没有值（Nothing），这对简单的不需要类型的错误很有用。还是以打开文件为例，如果我们只关心成功打开文件的句柄，那么 Maybe 就足够了。</p>
</li>
<li>
<p>当我们需要更为复杂的错误处理时，我们可以使用 Either 类型。它允许数据是 Left a 或者 Right b 。其中，a 是运行出错的数据类型，b 可以是成功的数据类型。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/18%EF%BD%9C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Rust%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%EF%BC%9F-4895260.jpg" alt="18｜错误处理：为什么Rust的错误处理与众不同？" /></p>
<blockquote>
<p>我们可以看到，这种方法依旧是通过返回值返回错误，但是错误被包裹在一个完整的、必须处理的类型中，比 Golang 的方法更安全。</p>
</blockquote>
<p>我们前面提到，使用返回值返回错误的一大缺点是，错误需要被调用者立即处理或者显式传递。但是使用 Maybe / Either 这样的类型来处理错误的好处是，我们可以用函数式编程的方法简化错误的处理，比如 map、fold
等函数，让代码相对不那么冗余。</p>
<p>需要注意的是，很多不可恢复的错误，如“磁盘写满，无法写入”的错误，使用异常处理可以避免一层层传递错误，让代码简洁高效，所以大多数使用类型系统来处理错误的语言，会同时使用异常处理作为补充。</p>
<h2 id="rust-的错误处理"><a class="header" href="#rust-的错误处理">Rust 的错误处理</a></h2>
<p>由于诞生的年代比较晚，Rust 有机会从已有的语言中学习到各种错误处理的优劣。对于 Rust 来说，目前的几种方式相比而言，最佳的方法是，使用类型系统来构建主要的错误处理流程。</p>
<h3 id="rust-偷师-haskell构建了对标-maybe-的-option-类型和-对标-either-的-result-类型"><a class="header" href="#rust-偷师-haskell构建了对标-maybe-的-option-类型和-对标-either-的-result-类型">Rust 偷师 Haskell，构建了对标 Maybe 的 Option 类型和 对标 Either 的 Result 类型。</a></h3>
<details id="admonition-rust-偷师-haskell构建了对标-maybe-的-option-类型和-对标-either-的-result-类型" class="admonition info">
<summary class="admonition-title">
<p>Rust 偷师 Haskell，构建了对标 Maybe 的 Option 类型和 对标 Either 的 Result 类型</p>
<p><a class="admonition-anchor-link" href="3_3_error_handling.html#admonition-rust-偷师-haskell构建了对标-maybe-的-option-类型和-对标-either-的-result-类型"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/18%EF%BD%9C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Rust%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%EF%BC%9F-4895260.jpg" alt="18｜错误处理：为什么Rust的错误处理与众不同？" /></p>
<ul>
<li>Option 是一个 enum，其定义如下：</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">
pub enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre></pre>
<blockquote>
<p>它可以承载有值 / 无值这种最简单的错误类型。</p>
</blockquote>
<ul>
<li>Result 是一个更加复杂的 enum，其定义如下：</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">
#[must_use = &quot;this `Result` may be an `Err` variant, which should be handled&quot;]
pub enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre></pre>
<blockquote>
<p>当函数出错时，可以返回 Err(E)，否则 Ok(T)。</p>
</blockquote>
<p>我们看到，Result 类型声明时还有个 must_use 的标注，编译器会对有 must_use 标注的所有类型做特殊处理：如果该类型对应的值没有被显式使用，则会告警。这样，保证错误被妥善处理。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/e2100e3f17a9587c4d4bf50523c10653.png" alt="img" /></p>
<p>这里，如果我们调用 read_file 函数时，直接丢弃返回值，由于 #[must_use] 的标注，Rust 编译器报警，要求我们使用其返回值。</p>
</div>
</details>
<h3 id="-操作符"><a class="header" href="#-操作符">? 操作符</a></h3>
<details id="admonition--操作符的由来" class="admonition info">
<summary class="admonition-title">
<p>? 操作符的由来</p>
<p><a class="admonition-anchor-link" href="3_3_error_handling.html#admonition--操作符的由来"></a></p>
</summary>
<div>
<p>这虽然可以极大避免遗忘错误的显示处理，但如果我们并不关心错误，只需要传递错误，还是会写出像 C 或者 Golang 一样比较冗余的代码。怎么办？</p>
<p>好在 Rust 除了有强大的类型系统外，还具备元编程的能力。早期 Rust 提供了 try! 宏来简化错误的显式处理，后来为了进一步提升用户体验，try! 被进化成 ? 操作符。</p>
<p>所以在 Rust 代码中，如果你只想传播错误，不想就地处理，可以用 ? 操作符，比如（代码）:</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::fs::File;
use std::io::Read;

fn read_file(name: &amp;str) -&gt; Result&lt;String, std::io::Error&gt; {
  let mut f = File::open(name)?;
  let mut contents = String::new();
  f.read_to_string(&amp;mut contents)?;
  Ok(contents)
}
</code></pre></pre>
<blockquote>
<p>通过 ? 操作符，Rust 让错误传播的代价和异常处理不相上下，同时又避免了异常处理的诸多问题。</p>
</blockquote>
<hr />
<p>? 操作符内部被展开成类似这样的代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">
match result {
  Ok(v) =&gt; v,
  Err(e) =&gt; return Err(e.into())
}
</code></pre></pre>
<blockquote>
<p>所以，我们可以方便地写出类似这样的代码，简洁易懂，可读性很强：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
fut
  .await?
  .process()?
  .next()
  .await?;
</code></pre></pre>
<p>整个代码的执行流程如下：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/18%EF%BD%9C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Rust%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%EF%BC%9F-4895239.jpg" alt="18｜错误处理：为什么Rust的错误处理与众不同？" /></p>
<p>虽然 ? 操作符使用起来非常方便，但你要注意在不同的错误类型之间是无法直接使用的，需要实现 From trait 在二者之间建立起转换的桥梁，这会带来额外的麻烦。</p>
</div>
</details>
<h3 id="函数式错误处理"><a class="header" href="#函数式错误处理">函数式错误处理</a></h3>
<details id="admonition-map--map_err--and_then-使用函数式错误处理" class="admonition info">
<summary class="admonition-title">
<p>map / map_err / and_then: 使用函数式错误处理</p>
<p><a class="admonition-anchor-link" href="3_3_error_handling.html#admonition-map--map_err--and_then-使用函数式错误处理"></a></p>
</summary>
<div>
<p>Rust 还为 Option 和 Result 提供了大量的辅助函数，如 map / map_err / and_then，你可以很方便地处理数据结构中部分情况。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/18%EF%BD%9C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Rust%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%EF%BC%9F.jpg" alt="18｜错误处理：为什么Rust的错误处理与众不同？" /></p>
<p>通过这些函数，你可以很方便地对错误处理引入 <a href="https://www.slideshare.net/ScottWlaschin/railway-oriented-programming">Railroad oriented programming 范式</a>。比如用户注册的流程，你需要校验用户输入，对数据进行处理，转换，然后存入数据库中。你可以这么撰写这个流程：</p>
<pre><pre class="playground"><code class="language-rust  editable">
Ok(data)
  .and_then(validate)
  .and_then(process)
  .map(transform)
  .and_then(store)
  .map_error(...)
</code></pre></pre>
<blockquote>
<p>执行流程如下图所示：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/image-20221004225336162.png" alt="image-20221004225336162" /></p>
<p>此外，Option 和 Result 的互相转换也很方换，这也得益于 Rust 构建的强大的函数式编程的能力。</p>
</div>
</details>
<p>我们可以看到，无论是通过 ? 操作符，还是函数式编程进行错误处理，Rust 都力求让错误处理灵活高效，让开发者使用起来简单直观。</p>
<h3 id="panic-和-catch_unwind"><a class="header" href="#panic-和-catch_unwind">panic! 和 catch_unwind</a></h3>
<details id="admonition-rust-也提供了特殊的异常处理能力-panic和catch_unwind" class="admonition info">
<summary class="admonition-title">
<p>Rust 也提供了特殊的异常处理能力: panic!和catch_unwind</p>
<p><a class="admonition-anchor-link" href="3_3_error_handling.html#admonition-rust-也提供了特殊的异常处理能力-panic和catch_unwind"></a></p>
</summary>
<div>
<p>使用 Option 和 Result 是 Rust 中处理错误的首选，绝大多数时候我们也应该使用，但 Rust 也提供了特殊的异常处理能力。</p>
<p>在 Rust 看来，一旦你需要抛出异常，那抛出的一定是严重的错误。所以，Rust 跟 Golang 一样，使用了诸如 panic! 这样的字眼警示开发者：想清楚了再使用我。在使用 Option 和 Result 类型时，开发者也可以对其 unwarp() 或者 expect()，强制把 Option<T> 和 Result&lt;T, E&gt; 转换成 T，如果无法完成这种转换，也会 panic! 出来。</p>
<p>一般而言，panic! 是不可恢复或者不想恢复的错误，我们希望在此刻，程序终止运行并得到崩溃信息。比如下面的代码，它解析<a href="https://noiseprotocol.org/noise.html#protocol-names-and-modifiers"> noise protocol</a>的协议变量：</p>
<pre><pre class="playground"><code class="language-rust  editable">
let params: NoiseParams = &quot;Noise_XX_25519_AESGCM_SHA256&quot;.parse().unwrap();
</code></pre></pre>
<h2 id="如果开发者不小心把协议变量写错了最佳的方式是立刻-panic-出来让错误立刻暴露以便解决这个问题"><a class="header" href="#如果开发者不小心把协议变量写错了最佳的方式是立刻-panic-出来让错误立刻暴露以便解决这个问题">如果开发者不小心把协议变量写错了，最佳的方式是立刻 panic! 出来，让错误立刻暴露，以便解决这个问题。</a></h2>
<p>有些场景下，我们也希望能够像异常处理那样能够栈回溯，把环境恢复到捕获异常的上下文。Rust 标准库下提供了 catch_unwind() ，把调用栈回溯到 catch_unwind 这一刻，作用和其它语言的 try {…} catch {…} 一样。见如下代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        println!(&quot;hello!&quot;);
    });
    assert!(result.is_ok());
    let result = panic::catch_unwind(|| {
        panic!(&quot;oh no!&quot;);
    });
    assert!(result.is_err());
    println!(&quot;panic captured: {:#?}&quot;, result);
}
</code></pre></pre>
<p>当然，和异常处理一样，并不意味着你可以滥用这一特性，我想，这也是 Rust 把抛出异常称作 panic! ，而捕获异常称作 catch_unwind 的原因，让初学者望而生畏，不敢轻易使用。这也是一个不错的用户体验。</p>
<p>catch_unwind 在某些场景下非常有用:</p>
<ol>
<li>比如你在使用 Rust 为 erlang VM 撰写 NIF，你不希望 Rust 代码中的任何 panic! 导致 erlang VM 崩溃。因为崩溃是一个非常不好的体验，它违背了 erlang 的设计原则：process 可以 let it crash，但错误代码不该导致 VM 崩溃。</li>
<li>此刻，你就可以把 Rust 代码整个封装在 catch_unwind() 函数所需要传入的闭包中。这样，一旦任何代码中，包括第三方 crates 的代码，含有能够导致 panic! 的代码，都会被捕获，并被转换为一个 Result。</li>
</ol>
</div>
</details>
<h3 id="error-trait-和错误类型的转换"><a class="header" href="#error-trait-和错误类型的转换">Error trait 和错误类型的转换</a></h3>
<details id="admonition-使用error-trait自定义错误类型" class="admonition info">
<summary class="admonition-title">
<p>使用Error trait自定义错误类型</p>
<p><a class="admonition-anchor-link" href="3_3_error_handling.html#admonition-使用error-trait自定义错误类型"></a></p>
</summary>
<div>
<p>上文中，我们讲到 Result&lt;T, E&gt; 里 E 是一个代表错误的数据类型。为了规范这个代表错误的数据类型的行为，Rust 定义了 Error trait：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; { ... }
    fn backtrace(&amp;self) -&gt; Option&lt;&amp;Backtrace&gt; { ... }
    fn description(&amp;self) -&gt; &amp;str { ... }
    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; { ... }
}
</code></pre></pre>
<p>我们可以定义我们自己的数据类型，然后为其实现 Error trait。</p>
</div>
</details>
<details id="admonition-使用thiserror和anyhow简化步骤" class="admonition info">
<summary class="admonition-title">
<p>使用thiserror和anyhow简化步骤</p>
<p><a class="admonition-anchor-link" href="3_3_error_handling.html#admonition-使用thiserror和anyhow简化步骤"></a></p>
</summary>
<div>
<p>不过，这样的工作已经有人替我们简化了：我们可以使用 thiserror和 anyhow来简化这个步骤。</p>
<ul>
<li>thiserror 提供了一个派生宏（derive macro）来简化错误类型的定义，比如：</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">
use thiserror::Error;
#[derive(Error, Debug)]
#[non_exhaustive]
pub enum DataStoreError {
    #[error(&quot;data store disconnected&quot;)]
    Disconnect(#[from] io::Error),
    #[error(&quot;the data for key `{0}` is not available&quot;)]
    Redaction(String),
    #[error(&quot;invalid header (expected {expected:?}, found {found:?})&quot;)]
    InvalidHeader {
        expected: String,
        found: String,
    },
    #[error(&quot;unknown data store error&quot;)]
    Unknown,
}
</code></pre></pre>
<p>如果你在撰写一个 Rust 库，那么 thiserror 可以很好地协助你对这个库里所有可能发生的错误进行建模。</p>
<ul>
<li>anyhow 实现了 anyhow::Error 和任意符合 Error trait 的错误类型之间的转换，让你可以使用 ? 操作符，不必再手工转换错误类型。</li>
</ul>
<blockquote>
<p>anyhow 还可以让你很容易地抛出一些临时的错误，而不必费力定义错误类型，当然，我们不提倡滥用这个能力。</p>
</blockquote>
<p>作为一名严肃的开发者，我非常建议你在开发前，先用类似 thiserror 的库定义好你项目中主要的错误类型，并随着项目的深入，不断增加新的错误类型，让系统中所有的潜在错误都无所遁形。</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="四闭包结构"><a class="header" href="#四闭包结构">四、闭包结构</a></h1>
<!--ts-->
<ul>
<li><a href="3_4_closure.html#%E5%9B%9B%E9%97%AD%E5%8C%85%E7%BB%93%E6%9E%84">四、闭包结构</a>
<ul>
<li><a href="3_4_closure.html#%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89">闭包的定义</a></li>
<li><a href="3_4_closure.html#%E9%97%AD%E5%8C%85%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E4%BB%80%E4%B9%88">闭包本质上是什么？</a></li>
<li><a href="3_4_closure.html#%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E9%97%AD%E5%8C%85%E8%AE%BE%E8%AE%A1">不同语言的闭包设计</a></li>
<li><a href="3_4_closure.html#rust-%E7%9A%84%E9%97%AD%E5%8C%85%E7%B1%BB%E5%9E%8B">Rust 的闭包类型</a>
<ul>
<li><a href="3_4_closure.html#fnonce">FnOnce</a></li>
<li><a href="3_4_closure.html#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-fnonce-%E7%9A%84-args-%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E5%91%A2">怎么理解 FnOnce 的 Args 泛型参数呢？</a></li>
<li><a href="3_4_closure.html#fnmut">FnMut</a></li>
<li><a href="3_4_closure.html#fn">Fn</a></li>
<li><a href="3_4_closure.html#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E4%B8%89%E7%A7%8D%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">总结一下三种闭包使用的情况以及它们之间的关系</a></li>
</ul>
</li>
<li><a href="3_4_closure.html#%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">闭包的使用场景</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:21 UTC 2022 -->
<!--te-->
<h2 id="闭包的定义"><a class="header" href="#闭包的定义">闭包的定义</a></h2>
<details id="admonition-闭包的基本概念" class="admonition info">
<summary class="admonition-title">
<p>闭包的基本概念</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-闭包的基本概念"></a></p>
</summary>
<div>
<p>闭包的基本概念：</p>
<ul>
<li>闭包是将函数，或者说代码和其环境一起存储的一种数据结构。</li>
<li>闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分</li>
<li>闭包会根据内部的使用情况，捕获环境中的自由变量。</li>
</ul>
</div>
</details>
<details id="admonition-rust中闭包捕获自由变量的两个方法" class="admonition info">
<summary class="admonition-title">
<p>Rust中闭包捕获自由变量的两个方法</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-rust中闭包捕获自由变量的两个方法"></a></p>
</summary>
<div>
<blockquote>
<p>在 Rust 里，闭包可以用 |args| {code} 来表述，图中闭包 c 捕获了上下文中的 a 和 b，并通过引用来使用这两个自由变量：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/19%EF%BD%9C%E9%97%AD%E5%8C%85%EF%BC%9AFnOnce%E3%80%81FnMut%E5%92%8CFn%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E7%B1%BB%E5%9E%8B%EF%BC%9F-4897625.jpg" alt="19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？" /></p>
<blockquote>
<p>除了用引用来捕获自由变量之外，还有另外一个方法使用 move 关键字 move |args| {code} 。</p>
</blockquote>
</div>
</details>
<details id="admonition-threadspawn的参数是一个闭包使用move关键字" class="admonition info">
<summary class="admonition-title">
<p>thread::spawn的参数是一个闭包，使用move关键字</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-threadspawn的参数是一个闭包使用move关键字"></a></p>
</summary>
<div>
<p>比如创建新线程的 thread::spawn，它的参数就是一个闭包：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; 
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static,
</code></pre></pre>
<blockquote>
<p>仔细看这个接口：</p>
</blockquote>
<ol>
<li>F: FnOnce() → T，表明 F 是一个接受 0 个参数、返回 T 的闭包。FnOnce 我们稍后再说。</li>
<li>F: Send + ’static，说明闭包 F 这个数据结构，需要静态生命周期或者拥有所有权，并且它还能被发送给另一个线程。a</li>
<li>T: Send + ’static，说明闭包 F 返回的数据结构 T，需要静态生命周期或者拥有所有权，并且它还能被发送给另一个线程。</li>
</ol>
<blockquote>
<p>1 和 3 都很好理解，2 就有些费解了。一个闭包，它不就是一段代码 + 被捕获的变量么？需要静态生命周期或者拥有所有权是什么意思？</p>
</blockquote>
<p>拆开看:</p>
<ul>
<li>代码自然是静态生命周期</li>
<li>那么是不是意味着被捕获的变量，需要静态生命周期或者拥有所有权？</li>
</ul>
<blockquote>
<p>的确如此。在使用 thread::spawn 时，我们需要使用 move 关键字，把变量的所有权从当前作用域移动到闭包的作用域，让 thread::spawn 可以正常编译通过：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
use std::thread;

fn main() {
    let s = String::from(&quot;hello world&quot;);

    let handle = thread::spawn(move || {
        println!(&quot;moved: {:?}&quot;, s);
    });

    handle.join().unwrap();
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>但你有没有好奇过，加 move 和不加 move，这两种闭包有什么本质上的不同？闭包究竟是一种什么样的数据类型，让编译器可以判断它是否满足 Send + ’static 呢？我们从闭包的本质下手来尝试回答这两个问题。</p>
</blockquote>
<h2 id="闭包本质上是什么"><a class="header" href="#闭包本质上是什么">闭包本质上是什么？</a></h2>
<details id="admonition-闭包的本质是匿名结构体move会转移自由变量的所有权" class="admonition info">
<summary class="admonition-title">
<p>闭包的本质是匿名结构体，move会转移自由变量的所有权</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-闭包的本质是匿名结构体move会转移自由变量的所有权"></a></p>
</summary>
<div>
<p>在官方的 Rust reference 中，有这样的定义：</p>
<blockquote>
<p>A closure expression produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables.</p>
</blockquote>
<hr />
<p>闭包是一种匿名类型，一旦声明，就会产生一个新的类型，但这个类型无法被其它地方使用。这个类型就像一个结构体，会包含所有捕获的变量。</p>
<p>所以闭包类似一个特殊的结构体？</p>
<p>为了搞明白这一点，我们得写段代码探索一下，建议你跟着敲一遍认真思考（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::{collections::HashMap, mem::size_of_val};
fn main() {
    // 长度为 0
    let c1 = || println!(&quot;hello world!&quot;);
    // 和参数无关，长度也为 0
    let c2 = |i: i32| println!(&quot;hello: {}&quot;, i);
    let name = String::from(&quot;tyr&quot;);
    let name1 = name.clone();
    let mut table = HashMap::new();
    table.insert(&quot;hello&quot;, &quot;world&quot;);
    // 如果捕获一个引用，长度为 8
    let c3 = || println!(&quot;hello: {}&quot;, name);
    // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
    let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
    let name2 = name.clone();
    // 和局部变量无关，捕获了一个 String name2，closure 长度 24
    let c5 = move || {
        let x = 1;
        let name3 = String::from(&quot;lindsey&quot;);
        println!(&quot;hello: {}, {:?}, {:?}&quot;, x, name2, name3);
    };

    println!(
        &quot;c1: {}, c2: {}, c3: {}, c4: {}, c5: {}, main: {}&quot;,
        size_of_val(&amp;c1),
        size_of_val(&amp;c2),
        size_of_val(&amp;c3),
        size_of_val(&amp;c4),
        size_of_val(&amp;c5),
        size_of_val(&amp;main),
    )
}
</code></pre></pre>
<blockquote>
<p>分别生成了 5 个闭包：</p>
</blockquote>
<ol>
<li>c1 没有参数，也没捕获任何变量，从代码输出可以看到，c1 长度为 0；</li>
<li>c2 有一个 i32 作为参数，没有捕获任何变量，长度也为 0，可以看出参数跟闭包的大小无关；</li>
<li>c3 捕获了一个对变量 name 的引用，这个引用是 &amp;String，长度为 8。而 c3 的长度也是 8；</li>
<li>c4 捕获了变量 name1 和 table，由于用了 move，它们的所有权移动到了 c4 中。c4 长度是 72，恰好等于 String 的 24 字节，加上 HashMap 的 48 字节。</li>
<li>c5 捕获了 name2，name2 的所有权移动到了 c5，虽然 c5 有局部变量，但它的大小和局部变量也无关，c5 的大小等于 String 的 24 字节。</li>
</ol>
<blockquote>
<p>可以看到，不带 move 时，闭包捕获的是对应自由变量的引用；带 move 时，对应自由变量的所有权会被移动到闭包结构中。</p>
</blockquote>
</div>
</details>
<p>继续分析这段代码的运行结果。</p>
<details id="admonition-闭包大小只跟捕获的变量有关" class="admonition info">
<summary class="admonition-title">
<p>闭包大小只跟捕获的变量有关</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-闭包大小只跟捕获的变量有关"></a></p>
</summary>
<div>
<p>还知道了，闭包的大小跟参数、局部变量都无关，只跟捕获的变量有关:</p>
<blockquote>
<p>因为它们是在调用的时刻才在栈上产生的内存分配，说到底和闭包类型本身是无关的，所以闭包的大小跟它们自然无关。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
use std::{collections::HashMap, mem::size_of_val};
fn main() {
    // 长度为 0
    let c1 = || println!(&quot;hello world!&quot;);
    // 和参数无关，长度也为 0
    let c2 = |i: i32| println!(&quot;hello: {}&quot;, i);
    let name = String::from(&quot;tyr&quot;);
    let name1 = name.clone();
    let mut table = HashMap::new();
    table.insert(&quot;hello&quot;, &quot;world&quot;);
    // 如果捕获一个引用，长度为 8
    let c3 = || println!(&quot;hello: {}&quot;, name);
    // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
    let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
    let name2 = name.clone();
    // 和局部变量无关，捕获了一个 String name2，closure 长度 24
    let c5 = move || {
        let x = 1;
        let name3 = String::from(&quot;lindsey&quot;);
        println!(&quot;hello: {}, {:?}, {:?}&quot;, x, name2, name3);
    };

    println!(
        &quot;c1: {}, c2: {}, c3: {}, c4: {}, c5: {}, main: {}&quot;,
        size_of_val(&amp;c1),
        size_of_val(&amp;c2),
        size_of_val(&amp;c3),
        size_of_val(&amp;c4),
        size_of_val(&amp;c5),
        size_of_val(&amp;main),
    )
}
</code></pre></pre>
</div>
</details>
<details id="admonition-闭包的内存布局与结构体有什么区别" class="admonition info">
<summary class="admonition-title">
<p>闭包的内存布局与结构体有什么区别？</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-闭包的内存布局与结构体有什么区别"></a></p>
</summary>
<div>
<p>那一个闭包类型在内存中究竟是如何排布的，和结构体有什么区别？</p>
<blockquote>
<p>我们要再次结合 rust-gdb 探索，看看上面的代码在运行结束前，几个长度不为 0 闭包内存里都放了什么：</p>
</blockquote>
<h2 id="-11"><a class="header" href="#-11"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/19%EF%BD%9C%E9%97%AD%E5%8C%85%EF%BC%9AFnOnce%E3%80%81FnMut%E5%92%8CFn%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E7%B1%BB%E5%9E%8B%EF%BC%9F-4897598.png" alt="19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？" /></a></h2>
<p>可以看到:</p>
<ol>
<li>c3 的确是一个引用，把它指向的内存地址的 24 个字节打出来，是 (ptr | cap | len) 的标准结构。如果打印 ptr 对应的堆内存的 3 个字节，是 ‘t’ ‘y’ ‘r’。</li>
<li>而 c4 捕获的 name 和 table，内存结构和下面的结构体一模一样：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
struct Closure4 {
    name: String,  // (ptr|cap|len)=24字节
    table: HashMap&lt;&amp;str, &amp;str&gt; // (RandomState(16)|mask|ctrl|left|len)=48字节
}
</code></pre></pre>
<p>不过，对于 closure 类型来说，编译器知道像函数一样调用闭包 c4() 是合法的，并且知道执行 c4() 时，代码应该跳转到什么地址来执行。在执行过程中，如果遇到 name、table，可以从自己的数据结构中获取。</p>
<p>那么多想一步，闭包捕获变量的顺序，和其内存结构的顺序是一致的么？</p>
<p>的确如此，如果我们调整闭包里使用 name1 和 table 的顺序：</p>
<pre><pre class="playground"><code class="language-rust  editable">
let c4 = move || println!(&quot;hello: {:?}, {}&quot;, table, name1);
</code></pre></pre>
<p>其数据的位置是相反的，类似于：</p>
<pre><pre class="playground"><code class="language-rust  editable">
struct Closure4 {
    table: HashMap&lt;&amp;str, &amp;str&gt; // (RandomState(16)|mask|ctrl|left|len)=48字节
    name: String,  // (ptr|cap|len)=24字节
}
</code></pre></pre>
<p>从 gdb 中也可以看到同样的结果：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/19%EF%BD%9C%E9%97%AD%E5%8C%85%EF%BC%9AFnOnce%E3%80%81FnMut%E5%92%8CFn%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E7%B1%BB%E5%9E%8B%EF%BC%9F.png" alt="19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？" /></p>
<blockquote>
<p>不过这只是逻辑上的位置，Rust 编译器会重排内存，让数据能够以最小的代价对齐，所以有些情况下，内存中数据的顺序可能和 struct 定义不一致。</p>
</blockquote>
<p>所以回到刚才闭包和结构体的比较。</p>
<p>在 Rust 里，闭包产生的匿名数据类型，格式和 struct 是一样的。看图中 gdb 的输出，闭包是存储在栈上，并且除了捕获的数据外，闭包本身不包含任何额外函数指针指向闭包的代码。如果你理解了 c3 / c4 这两个闭包，c5 是如何构造的就很好理解了。</p>
<p>现在，你是不是可以回答为什么 thread::spawn 对传入的闭包约束是 Send + ’static 了？究竟什么样的闭包满足它呢？</p>
<blockquote>
<p>很明显，使用了 move 且 move 到闭包内的数据结构满足 Send，因为此时，闭包的数据结构拥有所有数据的所有权，它的生命周期是 ’static。</p>
</blockquote>
</div>
</details>
<p>看完 Rust 闭包的内存结构，你是不是想说“就这”，没啥独特之处吧？但是对比其他语言，结合接下来我的解释，你再仔细想想就会有一种“这怎么可能”的惊讶。</p>
<h2 id="不同语言的闭包设计"><a class="header" href="#不同语言的闭包设计">不同语言的闭包设计</a></h2>
<details id="admonition-其他语言闭包设计有什么问题为何rust可以保证闭包的性能与函数差不多" class="admonition info">
<summary class="admonition-title">
<p>其他语言闭包设计有什么问题？为何Rust可以保证闭包的性能与函数差不多</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-其他语言闭包设计有什么问题为何rust可以保证闭包的性能与函数差不多"></a></p>
</summary>
<div>
<p>闭包最大的问题是变量的多重引用导致生命周期不明确，所以你先想，其它支持闭包的语言（lambda 也是闭包），它们的闭包会放在哪里？</p>
<p>栈上么？是，又好像不是。</p>
<p>因为闭包这玩意，从当前上下文中捕获了些变量，变得有点不伦不类，不像函数那样清楚，尤其是这些被捕获的变量，它们的归属和生命周期处理起来很麻烦。所以，大部分编程语言的闭包很多时候无法放在栈上，需要额外的堆分配。<a href="https://github.com/golang/go/issues/43210">你可以看这个 Golang 的例子</a>。</p>
<p>不光 Golang，Java / Swift / Python / JavaScript 等语言都是如此，这也是为什么大多数编程语言闭包的性能要远低于函数调用。</p>
<p>因为使用闭包就意味着：</p>
<ol>
<li>额外的堆内存分配</li>
<li>潜在的动态分派（很多语言会把闭包处理成函数指针）</li>
<li>额外的内存回收。</li>
</ol>
<p>在性能上，唯有 C++ 的 lambda 和 Rust 闭包类似，不过 C++ 的闭包还有一些场景会触发堆内存分配。</p>
<p>Rust / Swift / Kotlin iterator 函数式编程的性能测试：</p>
<ol>
<li>Kotlin 运行超时</li>
<li>Swift 很慢</li>
<li>Rust 的性能却和使用命令式编程的 C 几乎一样，除了编译器优化的效果，也因为 Rust 闭包的性能和函数差不多。</li>
</ol>
<blockquote>
<p>为什么 Rust 可以做到这样呢？</p>
</blockquote>
<p>这又跟 Rust 从根本上使用所有权和借用，解决了内存归属问题有关。</p>
<p>在其他语言中，闭包变量因为多重引用导致生命周期不明确，但 Rust 从一开始就消灭了这个问题：</p>
<ul>
<li>
<p>如果不使用 move 转移所有权，闭包会引用上下文中的变量，这个引用受借用规则的约束，所以只要编译通过，那么闭包对变量的引用就不会超过变量的生命周期，没有内存安全问题。</p>
</li>
<li>
<p>如果使用 move 转移所有权，上下文中的变量在转移后就无法访问，闭包完全接管这些变量，它们的生命周期和闭包一致，所以也不会有内存安全问题。</p>
</li>
<li>
<p>而 Rust 为每个闭包生成一个新的类型，又使得调用闭包时可以直接和代码对应，省去了使用函数指针再转一道手的额外消耗。</p>
</li>
</ul>
<blockquote>
<p>所以还是那句话，当回归到最初的本原，你解决的不是单个问题，而是由此引发的所有问题。我们不必为堆内存管理设计 GC、不必为其它资源的回收提供 defer 关键字、不必为并发安全进行诸多限制、也不必为闭包挖空心思搞优化。</p>
</blockquote>
</div>
</details>
<h2 id="rust-的闭包类型"><a class="header" href="#rust-的闭包类型">Rust 的闭包类型</a></h2>
<p>现在我们搞明白了闭包究竟是个什么东西，在内存中怎么表示，接下来我们看看 FnOnce / FnMut / Fn 这三种闭包类型有什么区别。</p>
<p>在声明闭包的时候，我们并不需要指定闭包要满足的约束，但是当闭包作为函数的参数或者数据结构的一个域时，我们需要告诉调用者，对闭包的约束。</p>
<p>还以 thread::spawn 为例，它要求传入的闭包满足 FnOnce trait。</p>
<h3 id="fnonce"><a class="header" href="#fnonce">FnOnce</a></h3>
<details id="admonition-fnonce定义-例子解析" class="admonition info">
<summary class="admonition-title">
<p>FnOnce定义-&gt;例子解析</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-fnonce定义-例子解析"></a></p>
</summary>
<div>
<p>先来看 FnOnce。它的<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">定义</a>如下：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait FnOnce&lt;Args&gt; {
    type Output;
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
</code></pre></pre>
<ol>
<li>FnOnce 有一个关联类型 Output，显然，它是闭包返回值的类型；</li>
<li>还有一个方法 call_once，要注意的是 call_once 第一个参数是 self，它会转移 self 的所有权到 call_once 函数中。</li>
</ol>
<blockquote>
<p>这也是为什么 FnOnce 被称作 Once ：它只能被调用一次。再次调用，编译器就会报变量已经被 move 这样的常见所有权错误了。</p>
</blockquote>
<p>至于 FnOnce 的参数，是一个叫 Args 的泛型参数，它并没有任何约束。</p>
<p>看一个隐式的 FnOnce 的例子：</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let name = String::from(&quot;Tyr&quot;);
    // 这个闭包啥也不干，只是把捕获的参数返回去
    let c = move |greeting: String| (greeting, name);

    let result = c(&quot;hello&quot;.to_string());

    println!(&quot;result: {:?}&quot;, result);

    // 无法再次调用
    let result = c(&quot;hi&quot;.to_string());
}
</code></pre></pre>
<ol>
<li>这个闭包 c，啥也没做，只是把捕获的参数返回。</li>
<li>就像一个结构体里，某个字段被转移走之后，就不能再访问一样，闭包内部的数据一旦被转移，这个闭包就不完整了，也就无法再次使用，所以它是一个 FnOnce 的闭包。</li>
</ol>
<p>如果一个闭包并不转移自己的内部数据，那么它就不是 FnOnce，然而，一旦它被当做 FnOnce 调用，自己会被转移到 call_once 函数的作用域中，之后就无法再次调用了，我们看个例子（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let name = String::from(&quot;Tyr&quot;);

    // 这个闭包会 clone 内部的数据返回，所以它不是 FnOnce
    let c = move |greeting: String| (greeting, name.clone());

    // 所以 c1 可以被调用多次

    println!(&quot;c1 call once: {:?}&quot;, c(&quot;qiao&quot;.into()));
    println!(&quot;c1 call twice: {:?}&quot;, c(&quot;bonjour&quot;.into()));

    // 然而一旦它被当成 FnOnce 被调用，就无法被再次调用
    println!(&quot;result: {:?}&quot;, call_once(&quot;hi&quot;.into(), c));

    // 无法再次调用
    // let result = c(&quot;hi&quot;.to_string());

    // Fn 也可以被当成 FnOnce 调用，只要接口一致就可以
    println!(&quot;result: {:?}&quot;, call_once(&quot;hola&quot;.into(), not_closure));
}

fn call_once(arg: String, c: impl FnOnce(String) -&gt; (String, String)) -&gt; (String, String) {
    c(arg)
}

fn not_closure(arg: String) -&gt; (String, String) {
    (arg, &quot;Rosie&quot;.into())
}
</code></pre></pre>
</div>
</details>
<h3 id="怎么理解-fnonce-的-args-泛型参数呢"><a class="header" href="#怎么理解-fnonce-的-args-泛型参数呢">怎么理解 FnOnce 的 Args 泛型参数呢？</a></h3>
<details id="admonition-怎么理解-fnonce-的-args-泛型参数呢" class="admonition info">
<summary class="admonition-title">
<p>怎么理解 FnOnce 的 Args 泛型参数呢？</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-怎么理解-fnonce-的-args-泛型参数呢"></a></p>
</summary>
<div>
<p>Args 又是怎么和 FnOnce 的约束，比如 FnOnce(String) 这样的参数匹配呢？感兴趣的同学可以看下面的例子，它（不完全）模拟了 FnOnce 中闭包的使用（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
struct ClosureOnce&lt;Captured, Args, Output&gt; {
    // 捕获的数据
    captured: Captured,
    // closure 的执行代码
    func: fn(Args, Captured) -&gt; Output,
}

impl&lt;Captured, Args, Output&gt; ClosureOnce&lt;Captured, Args, Output&gt; {
    // 模拟 FnOnce 的 call_once，直接消耗 self
    fn call_once(self, greeting: Args) -&gt; Output {
        (self.func)(greeting, self.captured)
    }
}

// 类似 greeting 闭包的函数体
fn greeting_code1(args: (String,), captured: (String,)) -&gt; (String, String) {
    (args.0, captured.0)
}

fn greeting_code2(args: (String, String), captured: (String, u8)) -&gt; (String, String, String, u8) {
    (args.0, args.1, captured.0, captured.1)
}

fn main() {
    let name = &quot;Tyr&quot;.into();
    // 模拟变量捕捉
    let c = ClosureOnce {
        captured: (name,),
        func: greeting_code1,
    };

    // 模拟闭包调用，这里和 FnOnce 不完全一样，传入的是一个 tuple 来匹配 Args 参数
    println!(&quot;{:?}&quot;, c.call_once((&quot;hola&quot;.into(),)));
    // 调用一次后无法继续调用
    // println!(&quot;{:?}&quot;, clo.call_once(&quot;hola&quot;.into()));

    // 更复杂一些的复杂的闭包
    let c1 = ClosureOnce {
        captured: (&quot;Tyr&quot;.into(), 18),
        func: greeting_code2,
    };

    println!(&quot;{:?}&quot;, c1.call_once((&quot;hola&quot;.into(), &quot;hallo&quot;.into())));
}
</code></pre></pre>
</div>
</details>
<h3 id="fnmut"><a class="header" href="#fnmut">FnMut</a></h3>
<details id="admonition-fnmut的定义与例子" class="admonition info">
<summary class="admonition-title">
<p>FnMut的定义与例子</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-fnmut的定义与例子"></a></p>
</summary>
<div>
<p>理解了 FnOnce，我们再来看 FnMut，<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">它的定义如下</a>：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(
        &amp;mut self, 
        args: Args
    ) -&gt; Self::Output;
}
</code></pre></pre>
<ol>
<li>首先，FnMut “继承”了 FnOnce，或者说 FnOnce 是 FnMut 的 super trait。</li>
<li>所以 FnMut 也拥有 Output 这个关联类型和 call_once 这个方法。</li>
<li>此外，它还有一个 call_mut() 方法。</li>
<li>注意 call_mut() 传入 &amp;mut self，它不移动 self，所以 FnMut 可以被多次调用。</li>
</ol>
<blockquote>
<p>因为 FnOnce 是 FnMut 的 super trait，所以，一个 FnMut 闭包，可以被传给一个需要 FnOnce 的上下文，此时调用闭包相当于调用了 call_once()。</p>
</blockquote>
<p>如果你理解了前面讲的闭包的内存组织结构，那么 FnMut 就不难理解，就像结构体如果想改变数据需要用 let mut 声明一样，如果你想改变闭包捕获的数据结构，那么就需要 FnMut。</p>
<p>我们看个例子（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">

fn main() {
    let mut name = String::from(&quot;hello&quot;);
    let mut name1 = String::from(&quot;hola&quot;);

    // 捕获 &amp;mut name
    let mut c = || {
        name.push_str(&quot; Tyr&quot;);
        println!(&quot;c: {}&quot;, name);
    };

    // 捕获 mut name1，注意 name1 需要声明成 mut
    let mut c1 = move || {
        name1.push_str(&quot;!&quot;);
        println!(&quot;c1: {}&quot;, name1);
    };

    c();
    c1();

    call_mut(&amp;mut c);
    call_mut(&amp;mut c1);

    call_once(c);
    call_once(c1);
}

// 在作为参数时，FnMut 也要显式地使用 mut，或者 &amp;mut
fn call_mut(c: &amp;mut impl FnMut()) {
    c();
}

// 想想看，为啥 call_once 不需要 mut？
fn call_once(c: impl FnOnce()) {
    c();
}

</code></pre></pre>
<ol>
<li>在声明的闭包 c 和 c1 里，我们修改了捕获的 name 和 name1。</li>
<li>不同的是 name 使用了引用，而 name1 移动了所有权，这两种情况和其它代码一样，也需要遵循所有权和借用有关的规则。</li>
<li>所以，如果在闭包 c 里借用了 name，你就不能把 name 移动给另一个闭包 c1。</li>
</ol>
<blockquote>
<p>这里也展示了，c 和 c1 这两个符合 FnMut 的闭包，能作为 FnOnce 来调用。我们在代码中也确认了，FnMut 可以被多次调用，这是因为 call_mut() 使用的是 &amp;mut self，不移动所有权。</p>
</blockquote>
</div>
</details>
<h3 id="fn"><a class="header" href="#fn">Fn</a></h3>
<details id="admonition-fn的定义与例子" class="admonition info">
<summary class="admonition-title">
<p>Fn的定义与例子</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-fn的定义与例子"></a></p>
</summary>
<div>
<p>最后我们来看看 Fn trait。<a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">它的定义如下</a>：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}
</code></pre></pre>
<ol>
<li>可以看到，它“继承”了 FnMut，或者说 FnMut 是 Fn 的 super trait。</li>
<li>这也就意味着任何需要 FnOnce 或者 FnMut 的场合，都可以传入满足 Fn 的闭包。</li>
</ol>
<p>我们继续看例子（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let v = vec![0u8; 1024];
    let v1 = vec![0u8; 1023];

    // Fn，不移动所有权
    let mut c = |x: u64| v.len() as u64 * x;
    // Fn，移动所有权
    let mut c1 = move |x: u64| v1.len() as u64 * x;

    println!(&quot;direct call: {}&quot;, c(2));
    println!(&quot;direct call: {}&quot;, c1(2));

    println!(&quot;call: {}&quot;, call(3, &amp;c));
    println!(&quot;call: {}&quot;, call(3, &amp;c1));

    println!(&quot;call_mut: {}&quot;, call_mut(4, &amp;mut c));
    println!(&quot;call_mut: {}&quot;, call_mut(4, &amp;mut c1));

    println!(&quot;call_once: {}&quot;, call_once(5, c));
    println!(&quot;call_once: {}&quot;, call_once(5, c1));
}

fn call(arg: u64, c: &amp;impl Fn(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}

fn call_mut(arg: u64, c: &amp;mut impl FnMut(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}

fn call_once(arg: u64, c: impl FnOnce(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}
</code></pre></pre>
</div>
</details>
<h3 id="总结一下三种闭包使用的情况以及它们之间的关系"><a class="header" href="#总结一下三种闭包使用的情况以及它们之间的关系">总结一下三种闭包使用的情况以及它们之间的关系</a></h3>
<details id="admonition-总结一下三种闭包使用的情况以及它们之间的关系" class="admonition info">
<summary class="admonition-title">
<p>总结一下三种闭包使用的情况以及它们之间的关系</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-总结一下三种闭包使用的情况以及它们之间的关系"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/19%EF%BD%9C%E9%97%AD%E5%8C%85%EF%BC%9AFnOnce%E3%80%81FnMut%E5%92%8CFn%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E7%B1%BB%E5%9E%8B%EF%BC%9F.jpg" alt="19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？" /></p>
</div>
</details>
<h2 id="闭包的使用场景"><a class="header" href="#闭包的使用场景">闭包的使用场景</a></h2>
<details id="admonition-在函数的参数和返回值中使用闭包" class="admonition info">
<summary class="admonition-title">
<p>在函数的参数和返回值中使用闭包</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-在函数的参数和返回值中使用闭包"></a></p>
</summary>
<div>
<p>thread::spawn 自不必说，我们熟悉的 Iterator trait 里面大部分函数都接受一个闭包，<a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#682-685">比如 map</a>：</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
where
    Self: Sized,
    F: FnMut(Self::Item) -&gt; B,
{
    Map::new(self, f)
}
</code></pre></pre>
<ol>
<li>可以看到，Iterator 的 map() 方法接受一个 FnMut</li>
<li>它的参数是 Self::Item</li>
<li>返回值是没有约束的泛型参数 B。</li>
<li>Self::Item 是 Iterator::next() 方法吐出来的数据，被 map 之后，可以得到另一个结果。</li>
</ol>
<p>所以在函数的参数中使用闭包，是闭包一种非常典型的用法。另外闭包也可以作为函数的返回值，举个简单的例子（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::ops::Mul;

fn main() {
    let c1 = curry(5);
    println!(&quot;5 multiply 2 is: {}&quot;, c1(2));

    let adder2 = curry(3.14);
    println!(&quot;pi multiply 4^2 is: {}&quot;, adder2(4. * 4.));
}

fn curry&lt;T&gt;(x: T) -&gt; impl Fn(T) -&gt; T
where
    T: Mul&lt;Output = T&gt; + Copy,
{
    move |y| x * y
}
</code></pre></pre>
</div>
</details>
<details id="admonition-为闭包实现某个-trait使其也能表现出其他行为而不仅仅是作为函数被调用" class="admonition info">
<summary class="admonition-title">
<p>为闭包实现某个 trait，使其也能表现出其他行为，而不仅仅是作为函数被调用。</p>
<p><a class="admonition-anchor-link" href="3_4_closure.html#admonition-为闭包实现某个-trait使其也能表现出其他行为而不仅仅是作为函数被调用"></a></p>
</summary>
<div>
<p>最后，闭包还有一种并不少见，但可能不太容易理解的用法：</p>
<p>为它实现某个 trait，使其也能表现出其他行为，而不仅仅是作为函数被调用。</p>
<p>比如说有些接口既可以传入一个结构体，又可以传入一个函数或者闭包。</p>
<blockquote>
<p>我们看一个 <a href="https://github.com/hyperium/tonic">tonic（Rust 下的 gRPC 库）</a>的<a href="https://docs.rs/tonic/0.5.2/src/tonic/service/interceptor.rs.html#41-53">例子</a></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Interceptor {
    /// Intercept a request before it is sent, optionally cancelling it.
    fn call(&amp;mut self, request: crate::Request&lt;()&gt;) -&gt; Result&lt;crate::Request&lt;()&gt;, Status&gt;;
}

impl&lt;F&gt; Interceptor for F
where
    F: FnMut(crate::Request&lt;()&gt;) -&gt; Result&lt;crate::Request&lt;()&gt;, Status&gt;,
{
    fn call(&amp;mut self, request: crate::Request&lt;()&gt;) -&gt; Result&lt;crate::Request&lt;()&gt;, Status&gt; {
        self(request)
    }
}
</code></pre></pre>
<p>在这个例子里，Interceptor 有一个 call 方法，它可以让 gRPC Request 被发送出去之前被修改，一般是添加各种头，比如 Authorization 头。</p>
<p>我们可以创建一个结构体，为它实现 Interceptor，不过大部分时候 Interceptor 可以直接通过一个闭包函数完成。为了让传入的闭包也能通过 Interceptor::call() 来统一调用，可以为符合某个接口的闭包实现 Interceptor trait。掌握了这种用法，我们就可以通过某些 trait 把特定的结构体和闭包统一起来调用，是不是很神奇。</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><style>.extended-markdown-table {
    display: grid;
}

.extended-markdown-table > div {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 3px 20px;
    border-bottom: 1px solid var(--table-border-color);
    border-right: 1px solid var(--table-border-color);
}

.extended-markdown-table > div.extended-markdown-left-border {
    border-left: 1px solid var(--table-border-color);
}

.extended-markdown-table > div.extended-markdown-header {
    text-align: center;
    background: var(--table-header-bg);
    border-bottom: 1px solid var(--table-header-bg);
    border-right: 1px solid var(--table-header-bg);
    font-weight: bold;
}

.extended-markdown-table > div.extended-markdown-header.extended-markdown-left-border {
    border-left: 1px solid var(--table-header-bg);
}
</style>
<h1 id="iv-宏编程"><a class="header" href="#iv-宏编程">IV 宏编程</a></h1>
<!--ts-->
<ul>
<li><a href="4_macros.html#iv-%E5%AE%8F%E7%BC%96%E7%A8%8B">IV 宏编程</a>
<ul>
<li><a href="4_macros.html#%E8%B5%84%E6%96%99">资料</a></li>
<li><a href="4_macros.html#%E5%AE%8F%E7%9A%84%E5%88%86%E7%B1%BB">宏的分类</a>
<ul>
<li><a href="4_macros.html#%E4%BD%BF%E7%94%A8%E6%B3%B3%E9%81%93%E5%9B%BE">使用泳道图</a></li>
<li><a href="4_macros.html#%E8%A1%A8%E6%A0%BC">表格</a></li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%9A%84%E7%BC%BA%E9%99%B7%E8%80%8C%E5%90%8E%E6%9C%89%E4%BA%86%E8%BF%87%E7%A8%8B%E5%AE%8F">声明宏的缺陷，而后有了过程宏</a></li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8Fdeclarative-macros-macro_rulesbang">声明宏(declarative macros): macro_rules!(bang)</a></li>
<li><a href="4_macros.html#%E8%BF%87%E7%A8%8B%E5%AE%8F%E6%B7%B1%E5%BA%A6%E5%AE%9A%E5%88%B6%E4%B8%8E%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81">过程宏：深度定制与生成代码</a>
<ul>
<li><a href="4_macros.html#%E5%87%BD%E6%95%B0%E5%AE%8F">函数宏</a></li>
<li><a href="4_macros.html#%E5%B1%9E%E6%80%A7%E5%AE%8F">属性宏</a></li>
<li><a href="4_macros.html#%E6%B4%BE%E7%94%9F%E5%AE%8F">派生宏</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F">声明宏</a>
<ul>
<li><a href="4_macros.html#rust%E5%B8%B8%E7%94%A8%E5%A3%B0%E6%98%8E%E5%AE%8F">Rust常用声明宏</a>
<ul>
<li><a href="4_macros.html#println">println!</a></li>
<li><a href="4_macros.html#writeln">writeln!</a></li>
<li><a href="4_macros.html#eprintln">eprintln!</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E7%A4%BA%E4%BE%8B">示例</a>
<ul>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%A4%BA%E6%84%8F%E5%9B%BE">声明宏示意图</a></li>
<li><a href="4_macros.html#macro_rules%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8">macro_rules!定义与使用</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%94%A8%E5%88%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B">声明宏用到的参数类型</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E8%BF%87%E7%A8%8B%E5%AE%8F%E6%89%8B%E5%B7%A5%E5%AE%9A%E4%B9%89%E5%9B%BE">过程宏手工定义图</a>
<ul>
<li><a href="4_macros.html#cargotoml%E6%B7%BB%E5%8A%A0proc-macro%E5%A3%B0%E6%98%8E">Cargo.toml添加proc-macro声明</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E5%AE%8F">过程函数宏</a></li>
<li><a href="4_macros.html#%E8%BF%87%E7%A8%8B%E6%B4%BE%E7%94%9F%E5%AE%8F">过程派生宏:</a>
<ul>
<li><a href="4_macros.html#%E5%B8%B8%E7%94%A8%E6%B4%BE%E7%94%9F%E5%AE%8F">常用派生宏</a>
<ul>
<li>[#[derive(Debug)]](#derivedebug)</li>
</ul>
</li>
<li><a href="4_macros.html#%E5%8E%9F%E5%A7%8B%E5%AE%9E%E7%8E%B0builder%E6%A8%A1%E5%BC%8F">原始实现builder模式</a></li>
<li><a href="4_macros.html#%E6%B4%BE%E7%94%9F%E5%AE%8F%E6%80%9D%E8%B7%AF">派生宏思路</a></li>
<li><a href="4_macros.html#%E4%BD%BF%E7%94%A8synquote%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E6%A8%A1%E7%89%88">使用syn/quote可以不用自己定义模版</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E8%BF%87%E7%A8%8B%E5%B1%9E%E6%80%A7%E5%AE%8F-proc_macro_derivemacro_name-attributesattr_name">过程属性宏: proc_macro_derive(macro_name, attributes(attr_name))</a>
<ul>
<li><a href="4_macros.html#%E4%BD%BF%E7%94%A8synquote%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AE%8F">使用syn/quote定义属性宏</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:22 UTC 2022 -->
<!--te-->
<h2 id="资料"><a class="header" href="#资料">资料</a></h2>
<ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html">宏 - Rust 程序设计语言 简体中文版</a></li>
<li><a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/reference/macros-by-example.html">Macros By Example - The Rust Reference</a></li>
</ul>
<h2 id="宏的分类"><a class="header" href="#宏的分类">宏的分类</a></h2>
<h3 id="使用泳道图"><a class="header" href="#使用泳道图">使用泳道图</a></h3>
<details id="admonition-宏编程使用对比泳道图" class="admonition info">
<summary class="admonition-title">
<p>宏编程使用对比泳道图</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-宏编程使用对比泳道图"></a></p>
</summary>
<div>
<figure><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="2887px" preserveAspectRatio="none" style="width:943px;height:2887px;background:#FFFFFF;" version="1.1" viewBox="0 0 943 2887" width="943px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="42.5938" id="_title" style="stroke:none;stroke-width:1.0;" width="192" x="374" y="15"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="98" x="421" y="32.9951">两类四种宏对比</text><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="182" x="379" y="49.292">（具体内容看详细版泳道图）</text><rect fill="none" height="20.9531" style="stroke:none;stroke-width:1.0;" width="910" x="15" y="66.3389"/><ellipse cx="128.5" cy="320.167" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="131" x="63" y="350.167"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="107" x="77" y="371.3057">基于TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="73" y="385.2744">定义过程函数宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="88.5" y="418.1045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="98.5" y="439.2432">打开过程宏</text><ellipse cx="128.5" cy="699.9482" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="215" x="21" y="729.9482"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="191" x="35" y="751.0869">手工抽取TokenStream定义派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="86.5" y="783.917"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="100.5" y="805.0557">打开过程宏</text><ellipse cx="128.5" cy="1461.167" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="193" x="32" y="1491.167"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="169" x="46" y="1512.3057">syn/quote抽取TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="42" y="1526.2744">为DeriveInput定义派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="86.5" y="1559.1045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="100.5" y="1580.2432">打开过程宏</text><ellipse cx="128.5" cy="2126.5107" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="193" x="32" y="2156.5107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="169" x="46" y="2177.6494">syn/quote抽取TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="42" y="2191.6182">为DeriveInput定义属性宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="86.5" y="2224.4482"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="100.5" y="2245.5869">打开过程宏</text><line style="stroke:#000000;stroke-width:1.5;" x1="15" x2="15" y1="66.3389" y2="2875.667"/><rect fill="#FAEBD7" height="2809.3281" style="stroke:#FAEBD7;stroke-width:1.0;" width="318" x="240" y="66.3389"/><rect fill="#F1F1F1" height="85.875" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="307" x="246" y="837.8857"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="287" x="256" y="859.0244">使用anyhow与askama抽取TokenStream中的信息</text><line style="stroke:#181818;stroke-width:1.0;" x1="246" x2="553" y1="866.8545" y2="866.8545"/><line style="stroke:#181818;stroke-width:1.0;" x1="246" x2="553" y1="868.8545" y2="868.8545"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="182" x="256" y="882.9932">1. 分别定义BuilderContext和Fd</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="228" x="256" y="896.9619">2. BuilderContext处理jinja模版数据结构</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="105" x="256" y="910.9307">3. Fd描述每个field</text><rect fill="#AAAAAA" height="75.875" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="145" x="327" y="943.7607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="125" x="337" y="964.8994">templates/builder.j2</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="4" x="337" y="978.8682"> </text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="116" x="337" y="992.8369">编写与tokenstream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="93" x="337" y="1006.8057">对应的jinja2模版</text><rect fill="#F1F1F1" height="169.6875" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="227" x="286" y="1039.6357"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="296" y="1060.7744">实现对应抽取方法</text><line style="stroke:#181818;stroke-width:1.0;" x1="286" x2="513" y1="1068.6045" y2="1068.6045"/><line style="stroke:#181818;stroke-width:1.0;" x1="286" x2="513" y1="1070.6045" y2="1070.6045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="194" x="296" y="1084.7432">1. Fd实现new方法处理TokenTree</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="191" x="296" y="1098.7119">2. BuilderContext实现下列方法：</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="37" x="296" y="1112.6807">- new:</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="175" x="328" y="1126.6494">从 TokenStream 中提取信息，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="119" x="328" y="1140.6182">构建 BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="54" x="296" y="1154.5869">- render:</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="165" x="328" y="1168.5557">把jinja2模版渲染成字符串代码</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="142" x="328" y="1182.5244">&gt; render里面用到split和</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="127" x="344" y="1196.4932">get_struct_fields方法</text><rect fill="#F1F1F1" height="57.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="273" x="263" y="1613.0732"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="253" x="273" y="1634.2119">使用syn与quote抽取 TokenStream中的信息</text><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="1642.042" y2="1642.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="1644.042" y2="1644.042"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="182" x="273" y="1658.1807">1. 同样定义BuilderContext和Fd</text><rect fill="#F1F1F1" height="183.6563" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="219" x="290" y="1691.0107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108" x="300" y="1712.1494">不需要自己手动定义</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132" x="300" y="1726.1182">抽取模版，直接实现方法</text><line style="stroke:#181818;stroke-width:1.0;" x1="290" x2="509" y1="1733.9482" y2="1733.9482"/><line style="stroke:#181818;stroke-width:1.0;" x1="290" x2="509" y1="1735.9482" y2="1735.9482"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="191" x="300" y="1750.0869">1. 比起手动方式，BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="162" x="316" y="1764.0557">和Fd还需要实现From Trait。</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="187" x="300" y="1778.0244">2. 接着Fd就不需要再处理，主要在</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="91" x="316" y="1791.9932">BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="179" x="300" y="1805.9619">3. BuilderContext实现下列方法</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="124" x="316" y="1819.9307">- render: 用到quote!</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="183" x="316" y="1833.8994">- gen_optionized_fields(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="135" x="316" y="1847.8682">- gen_methods(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="128" x="316" y="1861.8369">- gen_assigns(&amp;self)</text><rect fill="#F1F1F1" height="71.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="273" x="263" y="2278.417"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="253" x="273" y="2299.5557">使用syn与quote抽取 TokenStream中的信息</text><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="2307.3857" y2="2307.3857"/><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="2309.3857" y2="2309.3857"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="199" x="273" y="2323.5244">1. 定义Opts、Fd、BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="240" x="273" y="2337.4932">2. 比起派生宏，多了Opts用于捕获Fd的属性</text><rect fill="#F1F1F1" height="155.7188" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="250" x="274.5" y="2370.3232"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="284.5" y="2391.4619">不需要自己手动定</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132" x="284.5" y="2405.4307">抽取模版，直接实现方法</text><line style="stroke:#181818;stroke-width:1.0;" x1="274.5" x2="524.5" y1="2413.2607" y2="2413.2607"/><line style="stroke:#181818;stroke-width:1.0;" x1="274.5" x2="524.5" y1="2415.2607" y2="2415.2607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="230" x="284.5" y="2429.3994">1. 和派生宏一样，给Fd、BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="150" x="300.5" y="2443.3682">和Fd还需要实现From Trait</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="215" x="284.5" y="2457.3369">2. BuilderContext同样实现下列方法：</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="124" x="300.5" y="2471.3057">- render: 用到quote!</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="183" x="300.5" y="2485.2744">- gen_optionized_fields(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="135" x="300.5" y="2499.2432">- gen_methods(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="128" x="300.5" y="2513.2119">- gen_assigns(&amp;self)</text><line style="stroke:#000000;stroke-width:1.5;" x1="240" x2="240" y1="66.3389" y2="2875.667"/><ellipse cx="652" cy="102.292" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="612" y="132.292"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="622" y="153.4307">定义声明宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="612" y="472.0732"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="622" y="493.2119">定义过程宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="600" y="1229.3232"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="610" y="1250.4619">定义过程派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="600" y="1894.667"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="610" y="1915.8057">定义过程派生宏</text><rect fill="#F1F1F1" height="151.75" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="176" x="564" y="2546.042"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="574" y="2567.1807">定义过程派生宏</text><line style="stroke:#181818;stroke-width:1.0;" x1="564" x2="740" y1="2575.0107" y2="2575.0107"/><line style="stroke:#181818;stroke-width:1.0;" x1="564" x2="740" y1="2577.0107" y2="2577.0107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="574" y="2591.1494">和派生宏不同的是</text><line style="stroke:#181818;stroke-width:1.0;" x1="564" x2="740" y1="2598.9795" y2="2598.9795"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72" x="574" y="2615.1182">这里多了一个</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="155" x="574" y="2629.0869">attributes(builder) 属性，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="574" y="2643.0557">这是告诉编译器，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108" x="574" y="2657.0244">请允许代码中出现的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="12" x="574" y="2670.9932">1.</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="87" x="590" y="2670.9932">[builder(...)]，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="156" x="574" y="2684.9619">它是我这个宏认识并要处理的</text><line style="stroke:#000000;stroke-width:1.5;" x1="558" x2="558" y1="66.3389" y2="2875.667"/><rect fill="#F1F1F1" height="71.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="127" x="771" y="186.2607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="781" y="207.3994">使用声明宏</text><line style="stroke:#181818;stroke-width:1.0;" x1="771" x2="898" y1="215.2295" y2="215.2295"/><line style="stroke:#181818;stroke-width:1.0;" x1="771" x2="898" y1="217.2295" y2="217.2295"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="107" x="781" y="231.3682">没有TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="48" x="781" y="245.3369">难以调试</text><ellipse cx="834.5" cy="289.167" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="289.167" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="794.5" y="526.042"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="804.5" y="547.1807">使用过程宏</text><rect fill="#F1F1F1" height="57.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="163" x="753" y="580.0107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="763" y="601.1494">Terminal</text><line style="stroke:#181818;stroke-width:1.0;" x1="753" x2="916" y1="608.9795" y2="608.9795"/><line style="stroke:#181818;stroke-width:1.0;" x1="753" x2="916" y1="610.9795" y2="610.9795"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="763" y="625.1182">查看打印的TokenStream</text><ellipse cx="834.5" cy="668.9482" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="668.9482" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="782.5" y="1283.292"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="792.5" y="1304.4307">使用派生宏抽取</text><rect fill="#F1F1F1" height="61.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="103" x="783" y="1337.2607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="793" y="1358.3994">Terminal</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="793" y="1372.3682">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="83" x="793" y="1386.3369">TokenStream</text><ellipse cx="834.5" cy="1430.167" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="1430.167" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="782.5" y="1948.6357"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="792.5" y="1969.7744">使用派生宏抽取</text><rect fill="#F1F1F1" height="61.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="91" x="789" y="2002.6045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="799" y="2023.7432">Terminal</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="799" y="2037.7119">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="71" x="799" y="2051.6807">DeriveInput</text><ellipse cx="834.5" cy="2095.5107" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="2095.5107" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="782.5" y="2717.792"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="792.5" y="2738.9307">使用派生宏抽取</text><rect fill="#F1F1F1" height="61.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="91" x="789" y="2771.7607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="799" y="2792.8994">Terminal</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="799" y="2806.8682">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="71" x="799" y="2820.8369">DeriveInput</text><ellipse cx="834.5" cy="2864.667" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="2864.667" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><line style="stroke:#000000;stroke-width:1.5;" x1="745" x2="745" y1="66.3389" y2="2875.667"/><line style="stroke:#000000;stroke-width:1.5;" x1="923" x2="923" y1="66.3389" y2="2875.667"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="330.167" y2="350.167"/><polygon fill="#181818" points="124.5,340.167,128.5,350.167,132.5,340.167,128.5,344.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="398.1045" y2="418.1045"/><polygon fill="#181818" points="124.5,408.1045,128.5,418.1045,132.5,408.1045,128.5,412.1045" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="709.9482" y2="729.9482"/><polygon fill="#181818" points="124.5,719.9482,128.5,729.9482,132.5,719.9482,128.5,723.9482" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="763.917" y2="783.917"/><polygon fill="#181818" points="124.5,773.917,128.5,783.917,132.5,773.917,128.5,777.917" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="1471.167" y2="1491.167"/><polygon fill="#181818" points="124.5,1481.167,128.5,1491.167,132.5,1481.167,128.5,1485.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="1539.1045" y2="1559.1045"/><polygon fill="#181818" points="124.5,1549.1045,128.5,1559.1045,132.5,1549.1045,128.5,1553.1045" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="2136.5107" y2="2156.5107"/><polygon fill="#181818" points="124.5,2146.5107,128.5,2156.5107,132.5,2146.5107,128.5,2150.5107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="2204.4482" y2="2224.4482"/><polygon fill="#181818" points="124.5,2214.4482,128.5,2224.4482,132.5,2214.4482,128.5,2218.4482" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="923.7607" y2="943.7607"/><polygon fill="#181818" points="395.5,933.7607,399.5,943.7607,403.5,933.7607,399.5,937.7607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1019.6357" y2="1039.6357"/><polygon fill="#181818" points="395.5,1029.6357,399.5,1039.6357,403.5,1029.6357,399.5,1033.6357" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1671.0107" y2="1691.0107"/><polygon fill="#181818" points="395.5,1681.0107,399.5,1691.0107,403.5,1681.0107,399.5,1685.0107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="2350.3232" y2="2370.3232"/><polygon fill="#181818" points="395.5,2360.3232,399.5,2370.3232,403.5,2360.3232,399.5,2364.3232" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="112.292" y2="132.292"/><polygon fill="#181818" points="648,122.292,652,132.292,656,122.292,652,126.292" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="258.167" y2="278.167"/><polygon fill="#181818" points="830.5,268.167,834.5,278.167,838.5,268.167,834.5,272.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="560.0107" y2="580.0107"/><polygon fill="#181818" points="830.5,570.0107,834.5,580.0107,838.5,570.0107,834.5,574.0107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="637.9482" y2="657.9482"/><polygon fill="#181818" points="830.5,647.9482,834.5,657.9482,838.5,647.9482,834.5,651.9482" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1317.2607" y2="1337.2607"/><polygon fill="#181818" points="830.5,1327.2607,834.5,1337.2607,838.5,1327.2607,834.5,1331.2607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1399.167" y2="1419.167"/><polygon fill="#181818" points="830.5,1409.167,834.5,1419.167,838.5,1409.167,834.5,1413.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1982.6045" y2="2002.6045"/><polygon fill="#181818" points="830.5,1992.6045,834.5,2002.6045,838.5,1992.6045,834.5,1996.6045" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2064.5107" y2="2084.5107"/><polygon fill="#181818" points="830.5,2074.5107,834.5,2084.5107,838.5,2074.5107,834.5,2078.5107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2751.7607" y2="2771.7607"/><polygon fill="#181818" points="830.5,2761.7607,834.5,2771.7607,838.5,2761.7607,834.5,2765.7607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2833.667" y2="2853.667"/><polygon fill="#181818" points="830.5,2843.667,834.5,2853.667,838.5,2843.667,834.5,2847.667" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="166.2607" y2="171.2607"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="171.2607" y2="171.2607"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="171.2607" y2="186.2607"/><polygon fill="#181818" points="830.5,176.2607,834.5,186.2607,838.5,176.2607,834.5,180.2607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="452.0732" y2="457.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="652" y1="457.0732" y2="457.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="457.0732" y2="472.0732"/><polygon fill="#181818" points="648,462.0732,652,472.0732,656,462.0732,652,466.0732" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="506.042" y2="511.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="511.042" y2="511.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="511.042" y2="526.042"/><polygon fill="#181818" points="830.5,516.042,834.5,526.042,838.5,516.042,834.5,520.042" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="817.8857" y2="822.8857"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="399.5" y1="822.8857" y2="822.8857"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="822.8857" y2="837.8857"/><polygon fill="#181818" points="395.5,827.8857,399.5,837.8857,403.5,827.8857,399.5,831.8857" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1209.3232" y2="1214.3232"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="652" y1="1214.3232" y2="1214.3232"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1214.3232" y2="1229.3232"/><polygon fill="#181818" points="648,1219.3232,652,1229.3232,656,1219.3232,652,1223.3232" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1263.292" y2="1268.292"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="1268.292" y2="1268.292"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1268.292" y2="1283.292"/><polygon fill="#181818" points="830.5,1273.292,834.5,1283.292,838.5,1273.292,834.5,1277.292" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="1593.0732" y2="1598.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="399.5" y1="1598.0732" y2="1598.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1598.0732" y2="1613.0732"/><polygon fill="#181818" points="395.5,1603.0732,399.5,1613.0732,403.5,1603.0732,399.5,1607.0732" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1874.667" y2="1879.667"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="652" y1="1879.667" y2="1879.667"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1879.667" y2="1894.667"/><polygon fill="#181818" points="648,1884.667,652,1894.667,656,1884.667,652,1888.667" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1928.6357" y2="1933.6357"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="1933.6357" y2="1933.6357"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1933.6357" y2="1948.6357"/><polygon fill="#181818" points="830.5,1938.6357,834.5,1948.6357,838.5,1938.6357,834.5,1942.6357" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="2258.417" y2="2263.417"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="399.5" y1="2263.417" y2="2263.417"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="2263.417" y2="2278.417"/><polygon fill="#181818" points="395.5,2268.417,399.5,2278.417,403.5,2268.417,399.5,2272.417" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="2526.042" y2="2531.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="652" y1="2531.042" y2="2531.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="2531.042" y2="2546.042"/><polygon fill="#181818" points="648,2536.042,652,2546.042,656,2536.042,652,2540.042" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="2697.792" y2="2702.792"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="2702.792" y2="2702.792"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2702.792" y2="2717.792"/><polygon fill="#181818" points="830.5,2707.792,834.5,2717.792,838.5,2707.792,834.5,2711.792" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="99" x="81" y="83.0469">Cargo.toml</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="281" x="261.5" y="83.0469">src/&lt;对应抽取字段与方法定义&gt;.rs</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="74" x="617.5" y="83.0469">src/lib.rs</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="162" x="756" y="83.0469">examples/调用代码</text></g></svg></figure>
</div>
</details>
<h3 id="表格"><a class="header" href="#表格">表格</a></h3>
<div class="extended-markdown-table"><div class="extended-markdown-header extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 1; grid-row-end: 2">Macros</div><div class="extended-markdown-header" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2">Define</div><div class="extended-markdown-header" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2">Usage</div><div class="extended-markdown-header" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 1; grid-row-end: 2">note</div><div class="extended-markdown-header" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 1; grid-row-end: 2">Example</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 2; grid-row-end: 3">Declarative Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 2; grid-row-end: 3">#[macro_export]/macro_rules! macro_name{}</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 2; grid-row-end: 3">macro_name!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 2; grid-row-end: 3"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 2; grid-row-end: 3">println!</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 3; grid-row-end: 4">Function Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 3; grid-row-end: 4">#[proc_macros]/pub fn macro_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 3; grid-row-end: 4">macro_name!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 3; grid-row-end: 4">advanced declarative macro</div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 3; grid-row-end: 4"></div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 4; grid-row-end: 5">Derive Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 4; grid-row-end: 5">#[proc_macros_derive(DeriveMacroName)]/pub  fn other_fn_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 4; grid-row-end: 5">DeriveMacroName!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 4; grid-row-end: 5"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 4; grid-row-end: 5">#[derive(Debug)]</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 5; grid-row-end: 6">Attritubte Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 5; grid-row-end: 6">#[proc_macros_derive(AttributeMacroName, attributes(attr_name))]/pub  fn other_fn_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 5; grid-row-end: 6">Only Diff with DeriveMacro when define struct</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 5; grid-row-end: 6"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 5; grid-row-end: 6"></div></div>
<h3 id="声明宏的缺陷而后有了过程宏"><a class="header" href="#声明宏的缺陷而后有了过程宏">声明宏的缺陷，而后有了过程宏</a></h3>
<ul>
<li><a href="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/#limitationsofdeclarativemacros">Macros in Rust: A tutorial with examples - LogRocket Blog</a></li>
</ul>
<details id="admonition-为什么过程宏和声明宏那么像" class="admonition tip">
<summary class="admonition-title">
<p>为什么过程宏和声明宏那么像</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-为什么过程宏和声明宏那么像"></a></p>
</summary>
<div>
<blockquote>
<p>过程宏的缺陷</p>
</blockquote>
<ol>
<li>缺乏对宏自动完成和扩展的支持 </li>
<li>调试声明性宏很困难 </li>
<li>修改能力有限 </li>
<li>较大的二进制文件 </li>
<li>更长的编译时间（这适用于声明性宏和过程宏）</li>
</ol>
<blockquote>
<p>过程宏是语法树级别的转换
过程宏是宏的更高级版本。过程宏允许你扩展现有的 Rust 语法。它接受任意输入并返回有效的 Rust 代码。 
过程宏是将 TokenStream 作为输入并返回另一个 Token Stream 的函数。过程宏操作输入 TokenStream 以产生输出流。</p>
</blockquote>
</div>
</details>
<h3 id="声明宏declarative-macros-macro_rulesbang"><a class="header" href="#声明宏declarative-macros-macro_rulesbang">声明宏(declarative macros): macro_rules!(bang)</a></h3>
<blockquote>
<p>对代码模版做简单替换
声明宏可以用 macro_rules! 来描述, 如果重复性的代码无法用函数来封装，那么声明宏就是一个好的选择</p>
</blockquote>
<h3 id="过程宏深度定制与生成代码"><a class="header" href="#过程宏深度定制与生成代码">过程宏：深度定制与生成代码</a></h3>
<details id="admonition-陈天b站视频另外提供详细演示" class="admonition info">
<summary class="admonition-title">
<p>陈天B站视频另外提供详细演示</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-陈天b站视频另外提供详细演示"></a></p>
</summary>
<div>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Za411q7LQ">Rust 过程宏(1): 如何硬生生解析和手写过程宏</a></li>
</ul>
<blockquote>
<p>主要以如何使用 function-like macro 在不依赖于 syn / quote 的情况下，把 Json Schema 在编译期转换成 Rust struct。主要目的是让大家熟悉基本的处理 TokenStream 的思路</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Fu411m7W7">Rust 过程宏(2): 使用 syn/quote 撰写过程宏</a></li>
</ul>
<blockquote>
<p>主要通过一个 derive Builder 宏，来展示使用 syn/quote 如何开发过程宏。</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV1dr4y1v74n">Rust 过程宏(3): 使用 darling 处理 attributes</a></li>
</ul>
<blockquote>
<p>做个收尾，对上一讲的 derive macro 支持 attributes。 我们可以直接解析 attributes 相关的 TokenStream，也可以使用 darling 这个很方便的库，直接把 attributes 像
Clap/Structopts 那样收集到一个数据结构中，然后再进一步处理。</p>
</blockquote>
</div>
</details>
<details id="admonition-总结" class="admonition info">
<summary class="admonition-title">
<p>总结</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-总结"></a></p>
</summary>
<div>
<p>这三讲的内容虽然简单，但足以应付大家绝大多数宏编程的需求。
其实我们现在对 syn 库的使用还只是一个皮毛，我们还没有深入
去撰写自己的数据结构去实现 Parse trait，像 DeriveInput 
那样可以直接把 TokenStream 转换成我们想要的东西。</p>
<p>大家感兴趣的话，可以自行去看 syn 库的文档。</p>
</div>
</details>
<h4 id="函数宏"><a class="header" href="#函数宏">函数宏</a></h4>
<details id="admonition-看起来像函数的宏但在编译期进行处理" class="admonition info">
<summary class="admonition-title">
<p>看起来像函数的宏，但在编译期进行处理.</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-看起来像函数的宏但在编译期进行处理"></a></p>
</summary>
<div>
<blockquote>
<p>sqlx 用函数宏来处理SQL query、tokio使用属性宏 #[tokio::main] 来引入 runtime。
它们可以帮助目标代码的实现逻辑变得更加简单， 但一般除非特别必要，否则并不推荐写。
并没有特定的使用场景</p>
</blockquote>
</div>
</details>
<h4 id="属性宏"><a class="header" href="#属性宏">属性宏</a></h4>
<p>可以在其他代码块上添加属性，为代码块提供更多功能。</p>
<h4 id="派生宏"><a class="header" href="#派生宏">派生宏</a></h4>
<p>为 derive属性添加新的功能。这是我们平时使用最多的宏，比如 #[derive(Debug)].</p>
<blockquote>
<p>如果你定义的 trait 别人实现起来有固定的模式可循，那么可以考虑为其构建派生宏</p>
</blockquote>
<h2 id="声明宏"><a class="header" href="#声明宏">声明宏</a></h2>
<h3 id="rust常用声明宏"><a class="header" href="#rust常用声明宏">Rust常用声明宏</a></h3>
<h4 id="println"><a class="header" href="#println">println!</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.println.html">println in std - Rust</a></li>
<li><a href="https://blog.csdn.net/jiangjkd/article/details/120994956">Rust声明宏println剖析_一线coder的博客-CSDN博客_rust 声明宏</a></li>
</ul>
<details id="admonition-println使用示例" class="admonition info">
<summary class="admonition-title">
<p>println!使用示例</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-println使用示例"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
#[allow_internal_unstable(print_internals, format_args_nl)]
macro_rules! println {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ({
        $crate::io::_print($crate::format_args_nl!($($arg)*));
    })
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<h4 id="writeln"><a class="header" href="#writeln">writeln!</a></h4>
<blockquote>
<p>可以将内容输入到指定文件</p>
</blockquote>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.writeln.html">writeln in std - Rust</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/148945862">rust入门笔记—翻译rust write！宏 - 知乎</a></li>
</ul>
<pre><code class="language-shell">cargo run --example raw_command &gt; examples/raw_command_output.txt
</code></pre>
<h4 id="eprintln"><a class="header" href="#eprintln">eprintln!</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.eprintln.html">eprintln in std - Rust</a></li>
</ul>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<h4 id="声明宏示意图"><a class="header" href="#声明宏示意图">声明宏示意图</a></h4>
<details id="admonition-声明宏定义使用流程图" class="admonition info">
<summary class="admonition-title">
<p>声明宏定义使用流程图</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-声明宏定义使用流程图"></a></p>
</summary>
<div>
<figure><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="633px" preserveAspectRatio="none" style="width:474px;height:633px;background:#FFFFFF;" version="1.1" viewBox="0 0 474 633" width="474px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="26.2969" id="_title" style="stroke:none;stroke-width:1.0;" width="136" x="167.5" y="15"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="126" x="172.5" y="32.9951">声明宏定义使用流程</text><ellipse cx="51" cy="57.2969" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><path d="M101,77.2969 L101,389.9531 L462,389.9531 L462,87.2969 L452,77.2969 L101,77.2969 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M452,77.2969 L452,87.2969 L462,87.2969 L452,77.2969 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="12" x="107" y="94.3638">1.</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="99" x="123" y="94.3638">[macro_export]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="149" x="107" y="109.4966">macro_rules! my_vec {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="299" x="123" y="124.6294">// 没带任何参数的 my_vec，我们创建一个空的 vec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="324" x="123" y="139.7622">// 注意，由于宏要在调用的地方展开，我们无法预测调用</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="316" x="123" y="154.895">// 者的环境是否已经 做了相关的 use，所以我们使用的</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="194" x="123" y="170.0278">// 代码最好带着完整的命名空间。</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="48" x="123" y="185.1606">() =&gt; {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="125" x="139" y="200.2935">std::vec::Vec::new()</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="12" x="123" y="215.4263">};</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="162" x="123" y="230.5591">// 处理 my_vec![1, 2, 3, 4]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="133" x="123" y="245.6919">($($el:expr),*) =&gt; ({</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="139" y="260.8247">let mut v = std::vec::Vec::new();</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="100" x="139" y="275.9575">$(v.push($el);)*</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="7" x="139" y="291.0903">v</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="17" x="123" y="306.2231">});</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="138" x="123" y="321.356">// 处理 my_vec![0; 10]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="155" x="123" y="336.4888">($el:expr; $n:expr) =&gt; {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="180" x="139" y="351.6216">std::vec::from_elem($el, $n)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="123" y="366.7544">}</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="107" y="381.8872">}</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="11" y="216.6406"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="21" y="237.7793">定义声明宏</text><path d="M101,399.9531 L101,621.8125 L318,621.8125 L318,409.9531 L308,399.9531 L101,399.9531 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M308,399.9531 L308,409.9531 L318,409.9531 L308,399.9531 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="70" x="107" y="417.02">fn main() {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="144" x="123" y="432.1528">let mut v = my_vec![];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="64" x="123" y="447.2856">v.push(1);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="159" x="123" y="462.4185">// 调用时可以使用 [], (), {}</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="177" x="123" y="477.5513">let _v = my_vec!(1, 2, 3, 4);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="177" x="123" y="492.6841">let _v = my_vec![1, 2, 3, 4];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="180" x="123" y="507.8169">let v = my_vec! {1, 2, 3, 4};</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="522.9497">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="4" x="107" y="538.0825"> </text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="553.2153">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="123" y="568.3481">//</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="146" x="123" y="583.481">let v = my_vec![1; 10];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="598.6138">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="107" y="613.7466">}</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="11" y="493.8984"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="21" y="515.0371">使用声明宏</text><line style="stroke:#181818;stroke-width:1.0;" x1="51" x2="51" y1="67.2969" y2="216.6406"/><polygon fill="#181818" points="47,206.6406,51,216.6406,55,206.6406,51,210.6406" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="51" x2="51" y1="250.6094" y2="493.8984"/><polygon fill="#181818" points="47,483.8984,51,493.8984,55,483.8984,51,487.8984" style="stroke:#181818;stroke-width:1.0;"/></g></svg></figure>
</div>
</details>
<h4 id="macro_rules定义与使用"><a class="header" href="#macro_rules定义与使用">macro_rules!定义与使用</a></h4>
<details id="admonition-macro_rules定义示例" class="admonition info">
<summary class="admonition-title">
<p>macro_rules!定义示例</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-macro_rules定义示例"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[macro_export]
macro_rules! my_vec {
    // 没带任何参数的 my_vec，我们创建一个空的 vec
    // 注意，由于宏要在调用的地方展开，我们无法预测调用
    // 者的环境是否已经 做了相关的 use，所以我们使用的
    // 代码最好带着完整的命名空间。
    () =&gt; {
        std::vec::Vec::new()
    };
    // 处理 my_vec![1, 2, 3, 4]
    ($($el:expr),*) =&gt; ({
        let mut v = std::vec::Vec::new();
        $(v.push($el);)*
        v
    });
    // 处理 my_vec![0; 10]
    ($el:expr; $n:expr) =&gt; {
        std::vec::from_elem($el, $n)
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-elexpr-" class="admonition info">
<summary class="admonition-title">
<p>$($el:expr), *)</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-elexpr-"></a></p>
</summary>
<div>
<ol>
<li>在声明宏中，条件捕获的参数使用 $ 开头的标识符来声明。</li>
<li>每个参数都需要提供类型，这里<code>expr</code>代表表达式，所以 $el:expr 是说把匹配到的表达式命名为 $el。</li>
<li>$(…),* 告诉编译器可以匹配任意多个以逗号分隔的表达式，然后捕获到的每一个表达式可以用 $el 来访问。</li>
<li>由于匹配的时候匹配到一个 $(…)* （我们可以不管分隔符），在执行的代码块中，我们也要相应地使用 $(…)* 展开。</li>
<li>所以这句 $(v.push($el);)* 相当于匹配出多少个 $el就展开多少句 push 语句。</li>
</ol>
</div>
</details>
<details id="admonition-macro_rules使用示例" class="admonition info">
<summary class="admonition-title">
<p>macro_rules!使用示例</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-macro_rules使用示例"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let mut v = my_vec![];
    v.push(1);
    // 调用时可以使用 [], (), {}
    let _v = my_vec!(1, 2, 3, 4);
    let _v = my_vec![1, 2, 3, 4];
    let v = my_vec! {1, 2, 3, 4};
    println!(&quot;{:?}&quot;, v);

    println!(&quot;{:?}&quot;, v);
    //
    let v = my_vec![1; 10];
    println!(&quot;{:?}&quot;, v);
}
</code></pre></pre>
</div>
</details>
<h3 id="声明宏用到的参数类型"><a class="header" href="#声明宏用到的参数类型">声明宏用到的参数类型</a></h3>
<details id="admonition-类型列表" class="admonition info">
<summary class="admonition-title">
<p>类型列表</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-类型列表"></a></p>
</summary>
<div>
<ol>
<li>item，比如一个函数、结构体、模块等。 </li>
<li>block，代码块。比如一系列由花括号包裹的表达式和语句。 </li>
<li>stmt，语句。比如一个赋值语句。 </li>
<li>pat，模式。 </li>
<li>expr，表达式。刚才的例子使用过了。 </li>
<li>ty，类型。比如 Vec。 </li>
<li>ident，标识符。比如一个变量名。 </li>
<li>path，路径。比如：foo、::std::mem::replace、transmute::&lt;_, int&gt;。 </li>
<li>meta，元数据。一般是在 #[…] 和 #![…] 属性内部的数据。 </li>
<li>tt，单个的 token 树。 </li>
<li>vis，可能为空的一个 Visibility 修饰符。比如 pub、pub(crate)</li>
</ol>
</div>
</details>
<h2 id="过程宏手工定义图"><a class="header" href="#过程宏手工定义图">过程宏手工定义图</a></h2>
<blockquote>
<p>过程宏要比声明宏要复杂很多，不过无论是哪一种过程宏，本质都是一样的，都涉及要把 <code>输入的 TokenStream</code> 处理成<code>输出的 TokenStream</code>。</p>
</blockquote>
<h3 id="cargotoml添加proc-macro声明"><a class="header" href="#cargotoml添加proc-macro声明">Cargo.toml添加proc-macro声明</a></h3>
<blockquote>
<p>这样，编译器才允许你使用 #[proc_macro] 相关的宏。</p>
</blockquote>
<pre><code class="language-toml  editable">[lib]
proc-macro = true
</code></pre>
<h2 id="过程函数宏"><a class="header" href="#过程函数宏">过程函数宏</a></h2>
<ul>
<li>#[proc_macro]</li>
</ul>
<blockquote>
<p>和macro_rules! 功能类似，但更为强大。</p>
</blockquote>
<details id="admonition-srclibrs定义过程函数宏示例可以看到都是处理tokenstream" class="admonition info">
<summary class="admonition-title">
<p>src/lib.rs:定义过程函数宏示例：可以看到，都是处理TokenStream</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-srclibrs定义过程函数宏示例可以看到都是处理tokenstream"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">mod builder;
mod builder_with_attr;
mod raw_builder;

use proc_macro::TokenStream;
use raw_builder::BuilderContext;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro]
pub fn query(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    &quot;fn hello() { println!(\&quot;Hello world!\&quot;); }&quot;
        .parse()
        .unwrap()
}

#[proc_macro_derive(RawBuilder)]
pub fn derive_raw_builder(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    BuilderContext::render(input).unwrap().parse().unwrap()
}

#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    println!(&quot;{:#?}&quot;, input);
    builder::BuilderContext::from(input).render().into()
}

#[proc_macro_derive(BuilderWithAttr, attributes(builder))]
pub fn derive_builder_with_attr(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    println!(&quot;{:#?}&quot;, input);
    builder_with_attr::BuilderContext::from(input)
        .render()
        .into()
}
</code></pre></pre>
</div>
</details>
<details id="admonition-tokenstream" class="admonition info">
<summary class="admonition-title">
<p>TokenStream</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-tokenstream"></a></p>
</summary>
<div>
<p>使用者可以通过 query!(…) 来调用。我们打印传入的 TokenStream，
然后把一段包含在字符串中的代码解析成 TokenStream 返回。</p>
<p>这里可以非常方便地用字符串的 parse() 方法来获得 TokenStream，
是因为 TokenStream 实现了  FromStr trait。</p>
</div>
</details>
<details id="admonition-examplesqueryrs使用过冲示例" class="admonition info">
<summary class="admonition-title">
<p>examples/query.rs使用过冲示例</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-examplesqueryrs使用过冲示例"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use macros::query;

fn main() {
    // query!(SELECT * FROM users WHERE age &gt; 10);
    query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id);
    hello()
}
</code></pre></pre>
</div>
</details>
<ol>
<li>.parse().unwrap(): 字符串自动转为TokenStream类型</li>
</ol>
<pre><code class="language-shell">cargo run --example query &gt; examples/query_output.txt
</code></pre>
<details id="admonition-运行结果示例可以看到打印出来的tokenstream" class="admonition info">
<summary class="admonition-title">
<p>运行结果示例：可以看到打印出来的TokenStream</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-运行结果示例可以看到打印出来的tokenstream"></a></p>
</summary>
<div>
<pre><code class="language-shell">TokenStream [
    Ident {
        ident: &quot;SELECT&quot;,
        span: #0 bytes(94..100),
    },
    Punct {
        ch: '*',
        spacing: Alone,
        span: #0 bytes(101..102),
    },
    Ident {
        ident: &quot;FROM&quot;,
        span: #0 bytes(103..107),
    },
    Ident {
        ident: &quot;users&quot;,
        span: #0 bytes(108..113),
    },
    Ident {
        ident: &quot;u&quot;,
        span: #0 bytes(114..115),
    },
    Ident {
        ident: &quot;JOIN&quot;,
        span: #0 bytes(116..120),
    },
    Group {
        delimiter: Parenthesis,
        stream: TokenStream [
            Ident {
                ident: &quot;SELECT&quot;,
                span: #0 bytes(122..128),
            },
            Punct {
                ch: '*',
                spacing: Alone,
                span: #0 bytes(129..130),
            },
            Ident {
                ident: &quot;from&quot;,
                span: #0 bytes(131..135),
            },
            Ident {
                ident: &quot;profiles&quot;,
                span: #0 bytes(136..144),
            },
            Ident {
                ident: &quot;p&quot;,
                span: #0 bytes(145..146),
            },
        ],
        span: #0 bytes(121..147),
    },
    Ident {
        ident: &quot;WHERE&quot;,
        span: #0 bytes(148..153),
    },
    Ident {
        ident: &quot;u&quot;,
        span: #0 bytes(154..155),
    },
    Punct {
        ch: '.',
        spacing: Alone,
        span: #0 bytes(155..156),
    },
    Ident {
        ident: &quot;id&quot;,
        span: #0 bytes(156..158),
    },
    Punct {
        ch: '=',
        spacing: Alone,
        span: #0 bytes(159..160),
    },
    Ident {
        ident: &quot;p&quot;,
        span: #0 bytes(161..162),
    },
    Punct {
        ch: '.',
        spacing: Alone,
        span: #0 bytes(162..163),
    },
    Ident {
        ident: &quot;id&quot;,
        span: #0 bytes(163..165),
    },
]
Hello world!
</code></pre>
</div>
</details>
<details id="admonition-tokenstream是一个iterator里面包含一系列的tokentree" class="admonition tip">
<summary class="admonition-title">
<p>TokenStream是一个Iterator，里面包含一系列的TokenTree</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-tokenstream是一个iterator里面包含一系列的tokentree"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TokenTree {
    // 组，如果代码中包含括号，比如{} [] &lt;&gt; () ，那么内部的内容会被分析成一个Group（组）
    Group(Group), 
    // 标识符
    Ident(Ident),
    // 标点符号 
    Punct(Punct),
    // 字面量 
    Literal(Literal), 
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-group-example" class="admonition info">
<summary class="admonition-title">
<p>Group Example</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-group-example"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust">use macros::query;

fn main() {
    // query!(SELECT * FROM users WHERE age &gt; 10);
    query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id);
    hello()
}
</code></pre></pre>
</div>
</details>
<h2 id="过程派生宏"><a class="header" href="#过程派生宏">过程派生宏:</a></h2>
<p>#[proc_macro_devive(DeriveMacroName)]</p>
<blockquote>
<p>用于结构体（struct）、枚举（enum）、联合（union）类型，可为其实现函数或特征（Trait）</p>
</blockquote>
<h3 id="常用派生宏"><a class="header" href="#常用派生宏">常用派生宏</a></h3>
<h4 id="derivedebug"><a class="header" href="#derivedebug">#[derive(Debug)]</a></h4>
<h3 id="原始实现builder模式"><a class="header" href="#原始实现builder模式">原始实现builder模式</a></h3>
<details id="admonition-想到达到链式调用的效果" class="admonition info">
<summary class="admonition-title">
<p>想到达到链式调用的效果</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-想到达到链式调用的效果"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .current_dir(&quot;..&quot;.to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
    println!(&quot;{:?}&quot;, command);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-可以这样定义" class="admonition info">
<summary class="admonition-title">
<p>可以这样定义</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-可以这样定义"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 这是command.rs的派生宏实现的代码样子
#[allow(dead_code)]
#[derive(Debug)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}

#[derive(Debug, Default)]
pub struct CommandBuilder {
    executable: Option&lt;String&gt;,
    args: Option&lt;Vec&lt;String&gt;&gt;,
    env: Option&lt;Vec&lt;String&gt;&gt;,
    current_dir: Option&lt;String&gt;,
}

impl Command {
    pub fn builder() -&gt; CommandBuilder {
        Default::default()
    }
}

impl CommandBuilder {
    pub fn executable(mut self, v: String) -&gt; Self {
        self.executable = Some(v.to_owned());
        self
    }

    pub fn args(mut self, v: Vec&lt;String&gt;) -&gt; Self {
        self.args = Some(v.to_owned());
        self
    }

    pub fn env(mut self, v: Vec&lt;String&gt;) -&gt; Self {
        self.env = Some(v.to_owned());
        self
    }

    pub fn current_dir(mut self, v: String) -&gt; Self {
        self.current_dir = Some(v.to_owned());
        self
    }

    pub fn build(mut self) -&gt; Result&lt;Command, &amp;'static str&gt; {
        Ok(Command {
            executable: self.executable.take().ok_or(&quot;executable must be set&quot;)?,
            args: self.args.take().ok_or(&quot;args must be set&quot;)?,
            env: self.env.take().ok_or(&quot;env must be set&quot;)?,
            current_dir: self.current_dir.take(),
        })
    }
</code></pre></pre>
</div>
</details>
<blockquote>
<p>但是有点繁琐，可以使用派生宏派生出这些代码</p>
</blockquote>
<h3 id="派生宏思路"><a class="header" href="#派生宏思路">派生宏思路</a></h3>
<details id="admonition-要生成的代码模版-把输入的-tokenstream-抽取出来也就是把在-struct-的定义内部每个域的名字及其类型都抽出来然后生成对应的方法代码" class="admonition info">
<summary class="admonition-title">
<p>要生成的代码模版: 把输入的 TokenStream 抽取出来，也就是把在 struct 的定义内部，每个域的名字及其类型都抽出来，然后生成对应的方法代码。</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-要生成的代码模版-把输入的-tokenstream-抽取出来也就是把在-struct-的定义内部每个域的名字及其类型都抽出来然后生成对应的方法代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl {{ name }} {
    pub fn builder() -&gt; {{ builder_name }} {
        Default::default()
    }
}

#[derive(Debug, Default)]
pub struct {{ builder_name }} {
    {% for field in fields %}
        {{ field.name }}: Option&lt;{{ field.ty }}&gt;,
    {% endfor %}
}

impl {{ builder_name }} {
    {% for field in fields %}
    pub fn {{ field.name }}(mut self, v: impl Into&lt;{{ field.ty }}&gt;) -&gt; {{ builder_name }} {
        self.{{ field.name }} = Some(v.into());
        self
    }
    {% endfor %}

    pub fn build(self) -&gt; Result&lt;{{ name }}, &amp;'static str&gt; {
        Ok({{ name }} {
            {% for field in fields %}
                {% if field.optional %}
                {{ field.name }}: self.{{ field.name }},
                {% else %}
                {{ field.name }}: self.{{ field.name }}.ok_or(&quot;Build failed: missing {{ field.name }}&quot;)?,
                {% endif %}
            {% endfor %}
        })
    }
}
</code></pre></pre>
<hr />
<ol>
<li>7-12: 这里的 fileds / builder_name 是我们要传入的参数，每个 field 还需要 name 和 ty 两个 属性，分别对应 field 的名字和类型</li>
<li>25-26: 对于原本是 Option<T> 类型的域，要避免生成 Option<Option>，我们需要把是否是 Option 单独抽取出来，如果是 Option<T>，那么 ty 就是 T。所以，field 还需要一个属 性
optional。</li>
</ol>
</div>
</details>
<details id="admonition-构建对应数据结构" class="admonition info">
<summary class="admonition-title">
<p>构建对应数据结构</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-构建对应数据结构"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 处理 jinja 模板的数据结构，在模板中我们使用了 name / builder_name / fields
#[derive(Template)]
#[template(path = &quot;builder.j2&quot;, escape = &quot;none&quot;)]
pub struct BuilderContext {
    name: String,
    builder_name: String,
    fields: Vec&lt;Fd&gt;,
}
</code></pre></pre>
</div>
</details>
<details id="admonition-srclibrs-使用派生宏从tokenstream抽取出想要的信息" class="admonition info">
<summary class="admonition-title">
<p>src/lib.rs: 使用派生宏从TokenStream抽取出想要的信息</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-srclibrs-使用派生宏从tokenstream抽取出想要的信息"></a></p>
</summary>
<div>
<blockquote>
<p>对于 derive macro，要使用 proce_macro_derive 这个宏。我们把这个 derive macro 命名为 Builder。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">#[proc_macro_derive(RawBuilder)]
pub fn derive_raw_builder(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    BuilderContext::render(input).unwrap().parse().unwrap()
}
</code></pre></pre>
</div>
</details>
<details id="admonition-examplesraw_commandrs-使用这个派生宏抽取" class="admonition info">
<summary class="admonition-title">
<p>examples/raw_command.rs: 使用这个派生宏抽取</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-examplesraw_commandrs-使用这个派生宏抽取"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use macros::RawBuilder;

#[allow(dead_code)]
#[derive(Debug, RawBuilder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}

fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .current_dir(&quot;..&quot;.to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
    println!(&quot;{:?}&quot;, command);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-运行查看获取的tokenstream" class="admonition info">
<summary class="admonition-title">
<p>运行，查看获取的TokenStream</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-运行查看获取的tokenstream"></a></p>
</summary>
<div>
<pre><code class="language-shell">cargo run --example raw_command &gt; examples/raw_command_output.txt
</code></pre>
<pre><code class="language-shell">TokenStream [
    Punct {
        ch: '#',
        spacing: Alone,
        span: #0 bytes(25..26),
    },
    Group {
        delimiter: Bracket,
        stream: TokenStream [
            Ident {
                ident: &quot;allow&quot;,
                span: #0 bytes(27..32),
            },
            Group {
                delimiter: Parenthesis,
                stream: TokenStream [
                    Ident {
                        ident: &quot;dead_code&quot;,
                        span: #0 bytes(33..42),
                    },
                ],
                span: #0 bytes(32..43),
            },
        ],
        span: #0 bytes(26..44),
    },
    Ident {
        ident: &quot;pub&quot;,
        span: #0 bytes(74..77),
    },
    Ident {
        ident: &quot;struct&quot;,
        span: #0 bytes(78..84),
    },
    Ident {
        ident: &quot;Command&quot;,
        span: #0 bytes(85..92),
    },
    Group {
        delimiter: Brace,
        stream: TokenStream [
            Ident {
                ident: &quot;executable&quot;,
                span: #0 bytes(99..109),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(109..110),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(111..117),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(117..118),
            },
            Ident {
                ident: &quot;args&quot;,
                span: #0 bytes(123..127),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(127..128),
            },
            Ident {
                ident: &quot;Vec&quot;,
                span: #0 bytes(129..132),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(132..133),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(133..139),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(139..140),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(140..141),
            },
            Ident {
                ident: &quot;env&quot;,
                span: #0 bytes(146..149),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(149..150),
            },
            Ident {
                ident: &quot;Vec&quot;,
                span: #0 bytes(151..154),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(154..155),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(155..161),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(161..162),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(162..163),
            },
            Ident {
                ident: &quot;current_dir&quot;,
                span: #0 bytes(168..179),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(179..180),
            },
            Ident {
                ident: &quot;Option&quot;,
                span: #0 bytes(181..187),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(187..188),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(188..194),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(194..195),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(195..196),
            },
        ],
        span: #0 bytes(93..198),
    },
]
Command { executable: &quot;cargo&quot;, args: [&quot;build&quot;, &quot;--release&quot;], env: [], current_dir: Some(&quot;..&quot;) }
</code></pre>
</div>
</details>
<details id="admonition-打印信息说明" class="admonition info">
<summary class="admonition-title">
<p>打印信息说明</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-打印信息说明"></a></p>
</summary>
<div>
<ol>
<li>
<p>首先有一个 Group，包含了 #[allow(dead_code)] 属性的信息。因为我们现在拿到 的 derive 下的信息，所以所有不属于 #[derive(…)] 的属性，都会被放入 TokenStream 中。</p>
</li>
<li>
<p>之后是 pub / struct / Command 三个 ident。</p>
</li>
<li>
<p>随后又是一个 Group，包含了每个 field 的信息。我们看到，field 之间用逗号这个 Punct 分隔，field 的名字和类型又是通过冒号这个 Punct 分隔。而类型，可能是一个 Ident，如 String，或者一系列 Ident / Punct，如 Vec / &lt; / String / &gt;。</p>
</li>
</ol>
</div>
</details>
<details id="admonition-srcraw_builderrs-使用anyhow与askama抽取tokenstream中的信息" class="admonition info">
<summary class="admonition-title">
<p>src/raw_builder.rs: 使用anyhow与askama抽取TokenStream中的信息</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-srcraw_builderrs-使用anyhow与askama抽取tokenstream中的信息"></a></p>
</summary>
<div>
<blockquote>
<p>我们要做的就是，把这个 TokenStream 中的 struct 名字，以及每个 field 的名字和类型拿出来。
如果类型是 Option<T>，那么把 T 拿出来，把 optional 设置为 true。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">use anyhow::Result;
use askama::Template;
use proc_macro::{Ident, TokenStream, TokenTree};
use std::collections::VecDeque;

/// 处理 jinja 模板的数据结构，在模板中我们使用了 name / builder_name / fields
#[derive(Template)]
#[template(path = &quot;builder.j2&quot;, escape = &quot;none&quot;)]
pub struct BuilderContext {
    name: String,
    builder_name: String,
    fields: Vec&lt;Fd&gt;,
}

/// 描述 struct 的每个 field
#[derive(Debug, Default)]
struct Fd {
    name: String,
    ty: String,
    optional: bool,
}
</code></pre></pre>
</div>
</details>
<details id="admonition-templatesbuilderj2-上面askama用到的jinja2模版" class="admonition info">
<summary class="admonition-title">
<p>templates/builder.j2: 上面askama用到的jinja2模版</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-templatesbuilderj2-上面askama用到的jinja2模版"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl {{ name }} {
    pub fn builder() -&gt; {{ builder_name }} {
        Default::default()
    }
}

#[derive(Debug, Default)]
pub struct {{ builder_name }} {
    {% for field in fields %}
        {{ field.name }}: Option&lt;{{ field.ty }}&gt;,
    {% endfor %}
}

impl {{ builder_name }} {
    {% for field in fields %}
    pub fn {{ field.name }}(mut self, v: impl Into&lt;{{ field.ty }}&gt;) -&gt; {{ builder_name }} {
        self.{{ field.name }} = Some(v.into());
        self
    }
    {% endfor %}

    pub fn build(self) -&gt; Result&lt;{{ name }}, &amp;'static str&gt; {
        Ok({{ name }} {
            {% for field in fields %}
                {% if field.optional %}
                {{ field.name }}: self.{{ field.name }},
                {% else %}
                {{ field.name }}: self.{{ field.name }}.ok_or(&quot;Build failed: missing {{ field.name }}&quot;)?,
                {% endif %}
            {% endfor %}
        })
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-srcraw_builderrs-实现对应抽取方法" class="admonition info">
<summary class="admonition-title">
<p>src/raw_builder.rs: 实现对应抽取方法</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-srcraw_builderrs-实现对应抽取方法"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl Fd {
    /// name 和 field 都是通过冒号 Punct 切分出来的 TokenTree 切片
    pub fn new(name: &amp;[TokenTree], ty: &amp;[TokenTree]) -&gt; Self {
        // 把类似 Ident(&quot;Option&quot;), Punct('&lt;'), Ident(&quot;String&quot;), Punct('&gt;) 的 ty
        // 收集成一个 String 列表，如 vec![&quot;Option&quot;, &quot;&lt;&quot;, &quot;String&quot;, &quot;&gt;&quot;]
        let ty = ty
            .iter()
            .map(|v| match v {
                TokenTree::Ident(n) =&gt; n.to_string(),
                TokenTree::Punct(p) =&gt; p.as_char().to_string(),
                e =&gt; panic!(&quot;Expect ident, got {:?}&quot;, e),
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();
        // 冒号前最后一个 TokenTree 是 field 的名字
        // 比如：executable: String,
        // 注意这里不应该用 name[0]，因为有可能是 pub executable: String
        // 甚至，带 attributes 的 field，
        // 比如：#[builder(hello = world)] pub executable: String
        match name.last() {
            Some(TokenTree::Ident(name)) =&gt; {
                // 如果 ty 第 0 项是 Option，那么从第二项取到倒数第一项
                // 取完后上面的例子中的 ty 会变成 [&quot;String&quot;]，optiona = true
                let (ty, optional) = if ty[0].as_str() == &quot;Option&quot; {
                    (&amp;ty[2..ty.len() - 1], true)
                } else {
                    (&amp;ty[..], false)
                };
                Self {
                    name: name.to_string(),
                    ty: ty.join(&quot;&quot;), // 把 ty join 成字符串
                    optional,
                }
            }
            e =&gt; panic!(&quot;Expect ident, got {:?}&quot;, e),
        }
    }
}

impl BuilderContext {
    /// 从 TokenStream 中提取信息，构建 BuilderContext
    fn new(input: TokenStream) -&gt; Self {
        let (name, input) = split(input);
        let fields = get_struct_fields(input);
        Self {
            builder_name: format!(&quot;{}Builder&quot;, name),
            name: name.to_string(),
            fields,
        }
    }

    /// 把模板渲染成字符串代码
    pub fn render(input: TokenStream) -&gt; Result&lt;String&gt; {
        let template = Self::new(input);
        Ok(template.render()?)
    }
}

/// 把 TokenStream 分出 struct 的名字，和包含 fields 的 TokenStream
fn split(input: TokenStream) -&gt; (Ident, TokenStream) {
    let mut input = input.into_iter().collect::&lt;VecDeque&lt;_&gt;&gt;();
    // 一直往后找，找到 struct 停下来
    while let Some(item) = input.pop_front() {
        if let TokenTree::Ident(v) = item {
            if v.to_string() == &quot;struct&quot; {
                break;
            }
        }
    }

    // struct 后面，应该是 struct name
    let ident;
    if let Some(TokenTree::Ident(v)) = input.pop_front() {
        ident = v;
    } else {
        panic!(&quot;Didn't find struct name&quot;);
    }

    // struct 后面可能还有若干 TokenTree，我们不管，一路找到第一个 Group
    let mut group = None;
    for item in input {
        if let TokenTree::Group(g) = item {
            group = Some(g);
            break;
        }
    }

    (ident, group.expect(&quot;Didn't find field group&quot;).stream())
}

/// 从包含 fields 的 TokenStream 中切出来一个个 Fd
fn get_struct_fields(input: TokenStream) -&gt; Vec&lt;Fd&gt; {
    let input = input.into_iter().collect::&lt;Vec&lt;_&gt;&gt;();
    input
        .split(|v| match v {
            // 先用 ',' 切出来一个个包含 field 所有信息的 &amp;[TokenTree]
            TokenTree::Punct(p) =&gt; p.as_char() == ',',
            _ =&gt; false,
        })
        .map(|tokens| {
            tokens
                .split(|v| match v {
                    // 再用 ':' 把 &amp;[TokenTree] 切成 [&amp;[TokenTree], &amp;[TokenTree]]
                    // 它们分别对应名字和类型
                    TokenTree::Punct(p) =&gt; p.as_char() == ':',
                    _ =&gt; false,
                })
                .collect::&lt;Vec&lt;_&gt;&gt;()
        })
        // 正常情况下，应该得到 [&amp;[TokenTree], &amp;[TokenTree]]，对于切出来长度不为 2 的统统过滤掉
        .filter(|tokens| tokens.len() == 2)
        // 使用 Fd::new 创建出每个 Fd
        .map(|tokens| Fd::new(tokens[0], tokens[1]))
        .collect()
}
</code></pre></pre>
</div>
</details>
<details id="admonition-提示类比理解" class="admonition tip">
<summary class="admonition-title">
<p>提示：类比理解</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-提示类比理解"></a></p>
</summary>
<div>
<p>可以对着打印出来的 TokenStream 和刚才的分析进行理解。
核心的就是 get_struct_fields() 方法，如果觉得难懂，
可以想想如果要把一个 a=1,b=2 的字符串切成 [[a, 1], [b, 2]] 该怎么做，就很容易理解了。</p>
</div>
</details>
<h3 id="使用synquote可以不用自己定义模版"><a class="header" href="#使用synquote可以不用自己定义模版">使用syn/quote可以不用自己定义模版</a></h3>
<blockquote>
<p>详见上方对比图</p>
</blockquote>
<h2 id="过程属性宏-proc_macro_derivemacro_name-attributesattr_name"><a class="header" href="#过程属性宏-proc_macro_derivemacro_name-attributesattr_name">过程属性宏: proc_macro_derive(macro_name, attributes(attr_name))</a></h2>
<blockquote>
<p>用于属性宏， 用在结构体、字段、函数等地方，为其指定属性等功能, 类似python的计算属性</p>
</blockquote>
<details id="admonition-定义结构体时在某个字段上方使用对应attr_name" class="admonition tip">
<summary class="admonition-title">
<p>定义结构体时在某个字段上方使用对应attr_name</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-定义结构体时在某个字段上方使用对应attr_name"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(dead_code)]
#[derive(Debug, BuilderWithAttr)]
pub struct Command {
    executable: String,
    #[builder(each = &quot;arg&quot;)]
    args: Vec&lt;String&gt;,
    #[builder(each = &quot;env&quot;, default = &quot;vec![]&quot;)]
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<h3 id="使用synquote定义属性宏"><a class="header" href="#使用synquote定义属性宏">使用syn/quote定义属性宏</a></h3>
<blockquote>
<p>详见上方对比图</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v-并发与异步"><a class="header" href="#v-并发与异步">V 并发与异步</a></h1>
<!--ts-->
<ul>
<li><a href="5_concurrency_async.html#v-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5">V 并发与异步</a>
<ul>
<li><a href="5_concurrency_async.html#%E5%8C%BA%E5%88%86%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C">区分并发与并行</a></li>
<li><a href="5_concurrency_async.html#%E5%B9%B6%E5%8F%91%E7%9A%84%E9%9A%BE%E7%82%B9%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A0%B8%E5%BF%83">并发的难点、工作模式和核心</a></li>
<li><a href="5_concurrency_async.html#%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%85%B3%E7%B3%BB">并发原语与异步的关系</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:24 UTC 2022 -->
<!--te-->
<h2 id="区分并发与并行"><a class="header" href="#区分并发与并行">区分并发与并行</a></h2>
<details id="admonition-再次区分并发与并行" class="admonition info">
<summary class="admonition-title">
<p>再次区分并发与并行</p>
<p><a class="admonition-anchor-link" href="5_concurrency_async.html#admonition-再次区分并发与并行"></a></p>
</summary>
<div>
<p>很多人分不清并发和并行的概念，Rob Pike，Golang 的创始人之一，对此有很精辟很直观的解释：</p>
<p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.</p>
<ul>
<li>并发是一种同时处理很多事情的能力</li>
<li>并行是一种同时执行很多事情的手段。</li>
</ul>
<p>我们把要做的事情放在多个线程中，或者多个异步任务中处理，这是并发的能力。在多核多 CPU 的机器上同时运行这些线程或者异步任务，是并行的手段。可以说，并发是为并行赋能。当我们具备了并发的能力，并行就是水到渠成的事情。</p>
</div>
</details>
<h2 id="并发的难点工作模式和核心"><a class="header" href="#并发的难点工作模式和核心">并发的难点、工作模式和核心</a></h2>
<details id="admonition-处理并发的难点在哪里衍生出哪些工作模式核心是什么" class="admonition info">
<summary class="admonition-title">
<p>处理并发的难点在哪里？衍生出哪些工作模式？核心是什么</p>
<p><a class="admonition-anchor-link" href="5_concurrency_async.html#admonition-处理并发的难点在哪里衍生出哪些工作模式核心是什么"></a></p>
</summary>
<div>
<p>其实有很多和并发相关的内容。比如用 std::thread 来创建线程、用 std::sync 下的并发原语（Mutex）来处理并发过程中的同步问题、用 Send/Sync trait 来保证并发的安全等等。</p>
<p>在处理并发的过程中，难点并不在于如何创建多个线程来分配工作，在于如何在这些并发的任务中进行同步。</p>
<p>我们来看并发状态下几种常见的工作模式：自由竞争模式、map/reduce 模式、DAG 模式：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/33%EF%BD%9C%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F-4950283.jpg" alt="33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？" /></p>
<hr />
<ol>
<li>在自由竞争模式下，多个并发任务会竞争同一个临界区的访问权。任务之间在何时、以何种方式去访问临界区，是不确定的，或者说是最为灵活的，只要在进入临界区时获得独占访问即可。</li>
</ol>
<ul>
<li>Atomic &amp; Mutex</li>
</ul>
<ol start="2">
<li>在自由竞争的基础上，我们可以限制并发的同步模式，典型的有 map/reduce 模式和 DAG 模式：</li>
</ol>
<ul>
<li>map/reduce 模式，把工作打散，按照相同的处理完成后，再按照一定的顺序将结果组织起来；</li>
<li>DAG 模式，把工作切成不相交的、有依赖关系的子任务，然后按依赖关系并发执行。</li>
</ul>
<blockquote>
<p>这三种基本模式组合起来，可以处理非常复杂的并发场景。所以，当我们处理复杂问题的时候，应该先厘清其脉络，用分治的思想把问题拆解成正交的子问题，然后组合合适的并发模式来处理这些子问题。</p>
</blockquote>
</div>
</details>
<h2 id="并发原语与异步的关系"><a class="header" href="#并发原语与异步的关系">并发原语与异步的关系</a></h2>
<details id="admonition-区别并发原语与future" class="admonition info">
<summary class="admonition-title">
<p>区别并发原语与Future</p>
<p><a class="admonition-anchor-link" href="5_concurrency_async.html#admonition-区别并发原语与future"></a></p>
</summary>
<div>
<ul>
<li>并发原语是并发任务之间同步的手段</li>
<li>Future 以及在更高层次上处理 Future 的 async/await，是产生和运行并发任务的手段。</li>
</ul>
<p>不过产生和运行并发任务的手段有很多，async/await 只是其中之一。</p>
<ol>
<li>在一个分布式系统中，并发任务可以运行在系统的某个节点上；</li>
<li>在某个节点上，并发任务又可以运行在多个进程中；</li>
<li>而在某个进程中，并发任务可以运行在多个线程中；</li>
<li>在某个（些）线程上，并发任务可以运行在多个 Promise / Future / Goroutine / Erlang process 这样的协程上。</li>
</ol>
<p>它们的粒度从大到小如图所示：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/38%EF%BD%9C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9AFuture%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E5%92%8Casyncawait%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F-4959318.jpg" alt="38｜异步处理：Future是什么？它和asyncawait是什么关系？" /></p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并发原语"><a class="header" href="#并发原语">并发原语</a></h1>
<!--ts-->
<ul>
<li><a href="5_1_concurrency_primitives.html#%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD">并发原语</a>
<ul>
<li><a href="5_1_concurrency_primitives.html#atomic">Atomic</a>
<ul>
<li><a href="5_1_concurrency_primitives.html#%E4%BB%8E%E9%94%81%E5%BC%80%E5%A7%8B">从锁开始</a></li>
<li><a href="5_1_concurrency_primitives.html#atomiccas">Atomic+CAS</a></li>
<li><a href="5_1_concurrency_primitives.html#ordering">ordering</a></li>
</ul>
</li>
<li><a href="5_1_concurrency_primitives.html#mutex">Mutex</a></li>
<li><a href="5_1_concurrency_primitives.html#atomic%E5%92%8Cmutex%E7%9A%84%E8%81%94%E7%B3%BB">Atomic和Mutex的联系</a></li>
<li><a href="5_1_concurrency_primitives.html#condvar">Condvar</a>
<ul>
<li><a href="5_1_concurrency_primitives.html#atomic%E5%92%8Cmutex%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3dag%E6%A8%A1%E5%BC%8F">Atomic和Mutex不能解决DAG模式</a></li>
<li><a href="5_1_concurrency_primitives.html#condvar%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8">condvar介绍与使用</a></li>
</ul>
</li>
<li><a href="5_1_concurrency_primitives.html#channel">Channel</a></li>
<li><a href="5_1_concurrency_primitives.html#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84mpsc-channel">自己实现一个基本的MPSC Channel</a>
<ul>
<li><a href="5_1_concurrency_primitives.html#%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1">测试驱动的设计</a></li>
<li><a href="5_1_concurrency_primitives.html#%E5%AE%9E%E7%8E%B0-mpsc-channel">实现 MPSC channel</a></li>
<li><a href="5_1_concurrency_primitives.html#%E5%9B%9E%E9%A1%BE%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91">回顾测试驱动开发</a></li>
</ul>
</li>
<li><a href="5_1_concurrency_primitives.html#actor">Actor</a></li>
<li><a href="5_1_concurrency_primitives.html#%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B%E5%90%84%E7%A7%8D%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">小结一下各种并发原语的使用场景</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:23 UTC 2022 -->
<!--te-->
<details id="admonition-在这些并发模式背后都有哪些并发原语可以为我们所用呢" class="admonition info">
<summary class="admonition-title">
<p>在这些并发模式背后，都有哪些并发原语可以为我们所用呢</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-在这些并发模式背后都有哪些并发原语可以为我们所用呢"></a></p>
</summary>
<div>
<p>在这些并发模式背后，都有哪些并发原语可以为我们所用呢：</p>
<ol>
<li>Atomic</li>
<li>Mutex</li>
<li>Condvar</li>
<li>Channel </li>
<li>Actor model</li>
</ol>
</div>
</details>
<h2 id="atomic"><a class="header" href="#atomic">Atomic</a></h2>
<p>Atomic 是所有并发原语的基础，它为并发任务的同步奠定了坚实的基础。</p>
<h3 id="从锁开始"><a class="header" href="#从锁开始">从锁开始</a></h3>
<details id="admonition-互斥锁会导致乱序" class="admonition info">
<summary class="admonition-title">
<p>互斥锁会导致乱序</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-互斥锁会导致乱序"></a></p>
</summary>
<div>
<p>谈到同步，相信你首先会想到锁，所以在具体介绍 atomic 之前，我们从最基本的锁该如何实现讲起。自由竞争模式下，我们需要用互斥锁来保护某个临界区，使进入临界区的任务拥有独占访问的权限。</p>
<blockquote>
<p>为了简便起见，在获取这把锁的时候，如果获取不到，就一直死循环，直到拿到锁为止（代码）：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
use std::{cell::RefCell, fmt, sync::Arc, thread};

struct Lock&lt;T&gt; {
    locked: RefCell&lt;bool&gt;,
    data: RefCell&lt;T&gt;,
}

impl&lt;T&gt; fmt::Debug for Lock&lt;T&gt;
where
    T: fmt::Debug,
{
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;Lock&lt;{:?}&gt;&quot;, self.data.borrow())
    }
}

// SAFETY: 我们确信 Lock&lt;T&gt; 很安全，可以在多个线程中共享
unsafe impl&lt;T&gt; Sync for Lock&lt;T&gt; {}

impl&lt;T&gt; Lock&lt;T&gt; {
    pub fn new(data: T) -&gt; Self {
        Self {
            data: RefCell::new(data),
            locked: RefCell::new(false),
        }
    }

    pub fn lock(&amp;self, op: impl FnOnce(&amp;mut T)) {
        // 如果没拿到锁，就一直 spin
        while *self.locked.borrow() != false {} // **1

        // 拿到，赶紧加锁
        *self.locked.borrow_mut() = true; // **2

        // 开始干活
        op(&amp;mut self.data.borrow_mut()); // **3

        // 解锁
        *self.locked.borrow_mut() = false; // **4
    }
}

fn main() {
    let data = Arc::new(Lock::new(0));

    let data1 = data.clone();
    let t1 = thread::spawn(move || {
        data1.lock(|v| *v += 10);
    });

    let data2 = data.clone();
    let t2 = thread::spawn(move || {
        data2.lock(|v| *v *= 10);
    });
    t1.join().unwrap();
    t2.join().unwrap();

    println!(&quot;data: {:?}&quot;, data);
}
</code></pre></pre>
<blockquote>
<p>这段代码模拟了 Mutex 的实现，它的核心部分是 lock() 方法。</p>
</blockquote>
<p>我们之前说过，Mutex 在调用 lock() 后，会得到一个 MutexGuard 的 RAII 结构，这里为了简便起见，要求调用者传入一个闭包，来处理加锁后的事务。在 lock() 方法里，拿不到锁的并发任务会一直 spin，拿到锁的任务可以干活，干完活后会解锁，这样之前 spin 的任务会竞争到锁，进入临界区。</p>
<blockquote>
<p>这样的实现看上去似乎问题不大，但是你细想，它有好几个问题：</p>
</blockquote>
<ol>
<li>
<p>在多核情况下，**1 和 **2 之间，有可能其它线程也碰巧 spin 结束，把 locked 修改为 true。这样，存在多个线程拿到这把锁，破坏了任何线程都有独占访问的保证。</p>
</li>
<li>
<p>即便在单核情况下，**1 和 **2 之间，也可能因为操作系统的可抢占式调度，导致问题 1 发生。</p>
</li>
<li>
<p>如今的编译器会最大程度优化生成的指令，如果操作之间没有依赖关系，可能会生成乱序的机器码，比如**3 被优化放在 **1 之前，从而破坏了这个 lock 的保证。</p>
</li>
<li>
<p>即便编译器不做乱序处理，CPU 也会最大程度做指令的乱序执行，让流水线的效率最高。同样会发生 3 的问题。</p>
</li>
</ol>
<blockquote>
<p>所以，我们实现这个锁的行为是未定义的。可能大部分时间如我们所愿，但会随机出现奇奇怪怪的行为。一旦这样的事情发生，bug 可能会以各种不同的面貌出现在系统的各个角落。而且，这样的 bug 几乎是无解的，因为它很难稳定复现，表现行为很不一致，甚至，只在某个 CPU 下出现。</p>
</blockquote>
<blockquote>
<p>这里再强调一下 unsafe 代码需要足够严谨，需要非常有经验的工程师去审查，这段代码之所以破快了并发安全性，是因为我们错误地认为：为 Lock<T> 实现 Sync，是安全的。</p>
</blockquote>
<p>为了解决上面这段代码的问题，我们必须在 CPU 层面做一些保证，让某些操作成为原子操作。</p>
</div>
</details>
<h3 id="atomiccas"><a class="header" href="#atomiccas">Atomic+CAS</a></h3>
<details id="admonition-使用atomiccas确保原子操作顺序l" class="admonition info">
<summary class="admonition-title">
<p>使用Atomic+CAS确保原子操作顺序l</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-使用atomiccas确保原子操作顺序l"></a></p>
</summary>
<div>
<p>最基础的保证是：CAS</p>
<ol>
<li>可以通过一条指令读取某个内存地址，判断其值是否等于某个前置值，如果相等，将其修改为新的值。这就是 Compare-and-swap 操作，简称CAS。它是操作系统的几乎所有并发原语的基石，使得我们能实现一个可以正常工作的锁。</li>
</ol>
<p>所以，刚才的代码，我们可以把一开始的循环改成：</p>
<pre><pre class="playground"><code class="language-rust  editable">
while self
  .locked
  .compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed)
  .is_err() {}
</code></pre></pre>
<p>这句的意思是：</p>
<ol>
<li>如果 locked 当前的值是 false，就将其改成 true。</li>
<li>这整个操作在一条指令里完成，不会被其它线程打断或者修改；</li>
<li>如果 locked 的当前值不是 false，那么就会返回错误，我们会在此不停 spin，直到前置条件得到满足。</li>
<li>这里，compare_exchange 是 Rust 提供的 CAS 操作，它会被编译成 CPU 的对应 CAS 指令。</li>
</ol>
<blockquote>
<p>当这句执行成功后，locked 必然会被改变为 true，我们成功拿到了锁，而任何其他线程都会在这句话上 spin。</p>
</blockquote>
<p>同样在释放锁的时候，相应地需要使用 atomic 的版本，而非直接赋值成 false：</p>
<pre><pre class="playground"><code class="language-rust  editable">
self.locked.store(false, Ordering::Release);
</code></pre></pre>
<p>当然，为了配合这样的改动，我们还需要把 locked 从 bool 改成 AtomicBool。</p>
<p>在 Rust 里，std::sync::atomic 有大量的 atomic 数据结构，对应各种基础结构。</p>
<p>我们看使用了 AtomicBool 的新实现（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::{
    cell::RefCell,
    fmt,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc,
    },
    thread,
};

struct Lock&lt;T&gt; {
    locked: AtomicBool,
    data: RefCell&lt;T&gt;,
}

impl&lt;T&gt; fmt::Debug for Lock&lt;T&gt;
where
    T: fmt::Debug,
{
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;Lock&lt;{:?}&gt;&quot;, self.data.borrow())
    }
}

// SAFETY: 我们确信 Lock&lt;T&gt; 很安全，可以在多个线程中共享
unsafe impl&lt;T&gt; Sync for Lock&lt;T&gt; {}

impl&lt;T&gt; Lock&lt;T&gt; {
    pub fn new(data: T) -&gt; Self {
        Self {
            data: RefCell::new(data),
            locked: AtomicBool::new(false),
        }
    }

    pub fn lock(&amp;self, op: impl FnOnce(&amp;mut T)) {
        // 如果没拿到锁，就一直 spin
        while self
            .locked
            .compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed)
            .is_err()
        {} // **1

        // 已经拿到并加锁，开始干活
        op(&amp;mut self.data.borrow_mut()); // **3

        // 解锁
        self.locked.store(false, Ordering::Release);
    }
}

fn main() {
    let data = Arc::new(Lock::new(0));

    let data1 = data.clone();
    let t1 = thread::spawn(move || {
        data1.lock(|v| *v += 10);
    });

    let data2 = data.clone();
    let t2 = thread::spawn(move || {
        data2.lock(|v| *v *= 10);
    });
    t1.join().unwrap();
    t2.join().unwrap();

    println!(&quot;data: {:?}&quot;, data);
}
</code></pre></pre>
<p>可以看到:</p>
<ol>
<li>通过使用 compare_exchange ，规避了 1 和 2 面临的问题</li>
<li>但对于和编译器 /CPU 自动优化相关的 3 和 4，我们还需要一些额外处理。</li>
</ol>
</div>
</details>
<h3 id="ordering"><a class="header" href="#ordering">ordering</a></h3>
<details id="admonition-ordering枚举体说明" class="admonition info">
<summary class="admonition-title">
<p>Ordering枚举体说明</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-ordering枚举体说明"></a></p>
</summary>
<div>
<p>这就是这个函数里额外的两个和 <a href="https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html">Ordering</a> 有关的奇怪参数。</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub enum Ordering {
    Relaxed,
    Release,
    Acquire,
    AcqRel,
    SeqCst,
}
</code></pre></pre>
<blockquote>
<p>文档里解释了几种 Ordering 的用途，稍稍扩展一下。</p>
</blockquote>
<ol>
<li>第一个 Relaxed，这是最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序执行。</li>
<li>Release，当我们写入数据（比如上面代码里的 store）的时候，如果用了 Release order，那么：</li>
</ol>
<ul>
<li>对于当前线程，任何读取或写入操作都不能被乱序排在这个 store 之后。</li>
<li>也就是说，在上面的例子里，CPU 或者编译器不能把 **3 挪到 **4 之后执行。</li>
</ul>
<ol start="3">
<li>对于其它线程，如果使用了 Acquire 来读取这个 atomic 的数据， 那么它们看到的是修改后的结果。</li>
</ol>
<ul>
<li>上面代码我们在 compare_exchange 里使用了 Acquire 来读取，所以能保证读到最新的值。</li>
<li>而 Acquire 是当我们读取数据的时候，如果用了 Acquire order，那么：</li>
<li>对于当前线程，任何读取或者写入操作都不能被乱序排在这个读取之前。在上面的例子里，CPU 或者编译器不能把 **3 挪到 **1 之前执行。</li>
<li>对于其它线程，如果使用了 Release 来修改数据，那么，修改的值对当前线程可见。</li>
</ul>
<ol start="4">
<li>第四个 AcqRel 是 Acquire 和 Release 的结合，同时拥有 Acquire 和 Release 的保证。</li>
</ol>
<ul>
<li>这个一般用在 fetch_xxx 上，比如你要对一个 atomic 自增 1，你希望这个操作之前和之后的读取或写入操作不会被乱序，并且操作的结果对其它线程可见。</li>
</ul>
<ol start="5">
<li>最后的 SeqCst 是最严格的 ordering，除了 AcqRel 的保证外，它还保证所有线程看到的所有 SeqCst 操作的顺序是一致的。</li>
</ol>
</div>
</details>
<p>因为 CAS 和 ordering 都是系统级的操作，所以这里描述的 Ordering 的用途在各种语言中都大同小异。对于 Rust 来说，它的 atomic
原语<a href="https://en.cppreference.com/w/cpp/atomic/memory_order">继承于 C++</a>。如果读 Rust 的文档你感觉云里雾里，那么 C++ 关于 ordering 的文档要清晰得多。</p>
<details id="admonition-对atomic背后的cas进行获取锁的优化" class="admonition info">
<summary class="admonition-title">
<p>对Atomic背后的CAS进行获取锁的优化</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-对atomic背后的cas进行获取锁的优化"></a></p>
</summary>
<div>
<p>其实上面获取锁的 spin 过程性能不够好，更好的方式是这样处理一下：</p>
<pre><pre class="playground"><code class="language-rust  editable">
while self
    .locked
    .compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed)
    .is_err()
{
    // 性能优化：compare_exchange 需要独占访问，当拿不到锁时，我们
    // 先不停检测 locked 的状态，直到其 unlocked 后，再尝试拿锁
    while self.locked.load(Ordering::Relaxed) == true {}
}
</code></pre></pre>
<p>注意，我们在 while loop 里，又嵌入了一个 loop。</p>
<ol>
<li>这是因为 CAS 是个代价比较高的操作，它需要获得对应内存的独占访问（exclusive access）</li>
<li>我们希望失败的时候只是简单读取 atomic 的状态，只有符合条件的时候再去做独占访问，进行 CAS。</li>
<li>所以，看上去多做了一层循环，实际代码的效率更高。</li>
</ol>
<blockquote>
<p>以下是两个线程同步的过程，一开始 t1 拿到锁、t2 spin，之后 t1 释放锁、t2 进入到临界区执行：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/33%EF%BD%9C%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F-4950274.jpg" alt="33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？" /></p>
</div>
</details>
<blockquote>
<p>讲到这里，相信你对 atomic 以及其背后的 CAS 有初步的了解了。</p>
</blockquote>
<details id="admonition-那么atomic-除了做其它并发原语还有什么作用" class="admonition info">
<summary class="admonition-title">
<p>那么，atomic 除了做其它并发原语，还有什么作用？</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-那么atomic-除了做其它并发原语还有什么作用"></a></p>
</summary>
<div>
<p>那么，atomic 除了做其它并发原语，还有什么作用？</p>
<p>我个人用的最多的是做各种 lock-free 的数据结构。比如，需要一个全局的 ID 生成器。当然可以使用 UUID 这样的模块来生成唯一的 ID，但如果我们同时需要这个 ID 是有序的，那么 AtomicUsize 就是最好的选择。</p>
<p>你可以用 fetch_add 来增加这个 ID，而 fetch_add 返回的结果就可以用于当前的 ID。这样，不需要加锁，就得到了一个可以在多线程中安全使用的 ID 生成器。</p>
<p>另外，atomic 还可以用于记录系统的各种 metrics。比如一个简单的 in-memory Metrics 模块：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::{
    collections::HashMap,
    sync::atomic::{AtomicUsize, Ordering},
};

// server statistics
pub struct Metrics(HashMap&lt;&amp;'static str, AtomicUsize&gt;);

impl Metrics {
    pub fn new(names: &amp;[&amp;'static str]) -&gt; Self {
        let mut metrics: HashMap&lt;&amp;'static str, AtomicUsize&gt; = HashMap::new();
        for name in names.iter() {
            metrics.insert(name, AtomicUsize::new(0));
        }
        Self(metrics)
    }

    pub fn inc(&amp;self, name: &amp;'static str) {
        if let Some(m) = self.0.get(name) {
            m.fetch_add(1, Ordering::Relaxed);
        }
    }

    pub fn add(&amp;self, name: &amp;'static str, val: usize) {
        if let Some(m) = self.0.get(name) {
            m.fetch_add(val, Ordering::Relaxed);
        }
    }

    pub fn dec(&amp;self, name: &amp;'static str) {
        if let Some(m) = self.0.get(name) {
            m.fetch_sub(1, Ordering::Relaxed);
        }
    }

    pub fn snapshot(&amp;self) -&gt; Vec&lt;(&amp;'static str, usize)&gt; {
        self.0
            .iter()
            .map(|(k, v)| (*k, v.load(Ordering::Relaxed)))
            .collect()
    }
}
</code></pre></pre>
<p>它允许你初始化一个全局的 metrics 表，然后在程序的任何地方，无锁地操作相应的 metrics：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use lazy_static::lazy_static;
use std::{
    collections::HashMap,
    sync::atomic::{AtomicUsize, Ordering},
};

lazy_static! {
    pub(crate) static ref METRICS: Metrics = Metrics::new(&amp;[
        &quot;topics&quot;,
        &quot;clients&quot;,
        &quot;peers&quot;,
        &quot;broadcasts&quot;,
        &quot;servers&quot;,
        &quot;states&quot;,
        &quot;subscribers&quot;
    ]);
}

// server statistics
pub struct Metrics(HashMap&lt;&amp;'static str, AtomicUsize&gt;);

impl Metrics {
    pub fn new(names: &amp;[&amp;'static str]) -&gt; Self {
        let mut metrics: HashMap&lt;&amp;'static str, AtomicUsize&gt; = HashMap::new();
        for name in names.iter() {
            metrics.insert(name, AtomicUsize::new(0));
        }
        Self(metrics)
    }

    pub fn inc(&amp;self, name: &amp;'static str) {
        if let Some(m) = self.0.get(name) {
            m.fetch_add(1, Ordering::Relaxed);
        }
    }

    pub fn add(&amp;self, name: &amp;'static str, val: usize) {
        if let Some(m) = self.0.get(name) {
            m.fetch_add(val, Ordering::Relaxed);
        }
    }

    pub fn dec(&amp;self, name: &amp;'static str) {
        if let Some(m) = self.0.get(name) {
            m.fetch_sub(1, Ordering::Relaxed);
        }
    }

    pub fn snapshot(&amp;self) -&gt; Vec&lt;(&amp;'static str, usize)&gt; {
        self.0
            .iter()
            .map(|(k, v)| (*k, v.load(Ordering::Relaxed)))
            .collect()
    }
}

fn main() {
    METRICS.inc(&quot;topics&quot;);
    METRICS.inc(&quot;subscribers&quot;);

    println!(&quot;{:?}&quot;, METRICS.snapshot());
}

</code></pre></pre>
</div>
</details>
<h2 id="mutex"><a class="header" href="#mutex">Mutex</a></h2>
<details id="admonition-atomic有什么限制mutex又如何解决" class="admonition info">
<summary class="admonition-title">
<p>Atomic有什么限制，Mutex又如何解决？</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-atomic有什么限制mutex又如何解决"></a></p>
</summary>
<div>
<p>Atomic 虽然可以处理自由竞争模式下加锁的需求，但毕竟用起来不那么方便，我们需要更高层的并发原语，来保证软件系统控制多个线程对同一个共享资源的访问，使得每个线程在访问共享资源的时候，可以独占或者说互斥访问（mutual exclusive access）。</p>
<p>我们知道:</p>
<ol>
<li>对于一个共享资源，如果所有线程只做读操作，那么无需互斥，大家随时可以访问，很多 immutable language（如 Erlang / Elixir）做了语言层面的只读保证，确保了并发环境下的无锁操作。</li>
</ol>
<ul>
<li>这牺牲了一些效率（常见的 list/hashmap 需要使用 <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structure</a>），额外做了不少内存拷贝，换来了并发控制下的简单轻灵。</li>
</ul>
<ol start="2">
<li>然而，一旦有任何一个或多个线程要修改共享资源，不但写者之间要互斥，读写之间也需要互斥。毕竟如果读写之间不互斥的话，读者轻则读到脏数据，重则会读到已经被破坏的数据，导致 crash。</li>
</ol>
<ul>
<li>比如读者读到链表里的一个节点，而写者恰巧把这个节点的内存释放掉了，如果不做互斥访问，系统一定会崩溃。</li>
</ul>
<blockquote>
<p>所以操作系统提供了用来解决这种读写互斥问题的基本工具：Mutex（RwLock 我们放下不表）。</p>
</blockquote>
<p>其实上文中，为了展示如何使用 atomic，我们制作了一个非常粗糙简单的 SpinLock，就可以看做是一个广义的 Mutex。SpinLock，顾名思义，就是线程通过 CPU 空转（spin，就像前面的 while loop）忙等（busy wait），来等待某个临界区可用的一种锁。</p>
<blockquote>
<p>然而，这种通过 SpinLock 做互斥的实现方式有使用场景的限制：如果受保护的临界区太大，那么整体的性能会急剧下降， CPU 忙等，浪费资源还不干实事，不适合作为一种通用的处理方法。</p>
</blockquote>
<p>更通用的解决方案是：</p>
<ol>
<li>当多个线程竞争同一个 Mutex 时，获得锁的线程得到临界区的访问，其它线程被挂起，放入该 Mutex 上的一个等待队列里</li>
<li>当获得锁的线程完成工作，退出临界区时，Mutex 会给等待队列发一个信号，把队列中第一个线程唤醒，于是这个线程可以进行后续的访问。整个过程如下：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/33%EF%BD%9C%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F.jpg" alt="33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？" /></p>
</div>
</details>
<h2 id="atomic和mutex的联系"><a class="header" href="#atomic和mutex的联系">Atomic和Mutex的联系</a></h2>
<details id="admonition-atomicmutexsemaphore的联系" class="admonition info">
<summary class="admonition-title">
<p>Atomic、Mutex、semaphore的联系</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-atomicmutexsemaphore的联系"></a></p>
</summary>
<div>
<p>我们前面也讲过，线程的上下文切换代价很大，所以频繁将线程挂起再唤醒，会降低整个系统的效率。所以很多 Mutex 具体的实现会将 SpinLock（确切地说是 spin wait）和线程挂起结合使用：
线程的 lock 请求如果拿不到会先尝试 spin 一会，然后再挂起添加到等待队列。</p>
<p>Rust 下的 <a href="https://github.com/Amanieu/parking_lot">parking_lot </a>就是这样实现的。</p>
<p>当然，这样实现会带来公平性的问题：</p>
<ol>
<li>如果新来的线程恰巧在 spin 过程中拿到了锁</li>
<li>而当前等待队列中还有其它线程在等待锁</li>
<li>那么等待的线程只能继续等待下去</li>
<li>这不符合 FIFO，不适合那些需要严格按先来后到排队的使用场景。</li>
<li>为此，parking_lot 提供了 fair mutex。</li>
</ol>
<p>Mutex 的实现依赖于 CPU 提供的 atomic。你可以把 Mutex 想象成一个粒度更大的 atomic，只不过这个 atomic 无法由 CPU 保证，而是通过软件算法来实现。</p>
<p>两个基本的并发原语 Atomic 和 Mutex。Atomic 是一切并发同步的基础，通过 CPU 提供特殊的 CAS 指令，操作系统和应用软件可以构建更加高层的并发原语，比如 SpinLock 和 Mutex。</p>
<p>SpinLock 和 Mutex 最大的不同是，使用 SpinLock，线程在忙等（busy wait），而使用 Mutex lock，线程在等待锁的时候会被调度出去，等锁可用时再被调度回来。</p>
<p>听上去 SpinLock 似乎效率很低，其实不是，这要具体看锁的临界区大小。如果临界区要执行的代码很少，那么和 Mutex lock 带来的上下文切换（context switch）相比，SpinLock 是值得的。在 Linux Kernel 中，很多时候我们只能使用 SpinLock。</p>
<p>至于操作系统里另一个重要的概念信号量（semaphore），你可以认为是 Mutex 更通用的表现形式。比如在新冠疫情下，图书馆要控制同时在馆内的人数，如果满了，其他人就必须排队，出来一个才能再进一个。这里，如果总人数限制为 1，就是 Mutex，如果 &gt; 1，就是 semaphore。</p>
</div>
</details>
<h2 id="condvar"><a class="header" href="#condvar">Condvar</a></h2>
<h3 id="atomic和mutex不能解决dag模式"><a class="header" href="#atomic和mutex不能解决dag模式">Atomic和Mutex不能解决DAG模式</a></h3>
<details id="admonition-atomic和mutex主要用于哪种工作模式基于什么需求提出condvar原语" class="admonition info">
<summary class="admonition-title">
<p>Atomic和Mutex主要用于哪种工作模式？基于什么需求提出Condvar原语？</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-atomic和mutex主要用于哪种工作模式基于什么需求提出condvar原语"></a></p>
</summary>
<div>
<p>对于并发状态下这三种常见的工作模式：自由竞争模式、map/reduce 模式、DAG 模式，我们的难点是如何在这些并发的任务中进行同步。atomic / Mutex 解决了自由竞争模式下并发任务的同步问题，也能够很好地解决 map/reduce 模式下的同步问题，因为此时同步只发生在 map 和 reduce 两个阶段。</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/34%EF%BD%9C%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F-4951814.jpg" alt="34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？" /></p>
<p>然而，它们没有解决一个更高层次的问题，也就是 DAG 模式：如果这种访问需要按照一定顺序进行或者前后有依赖关系，该怎么做？</p>
<p>这个问题的典型场景是生产者 - 消费者模式：生产者生产出来内容后，需要有机制通知消费者可以消费。比如 socket 上有数据了，通知处理线程来处理数据，处理完成之后，再通知 socket 收发的线程发送数据。</p>
<p>所以，操作系统还提供了 Condvar。</p>
</div>
</details>
<h3 id="condvar介绍与使用"><a class="header" href="#condvar介绍与使用">condvar介绍与使用</a></h3>
<details id="admonition-condvar介绍与使用" class="admonition info">
<summary class="admonition-title">
<p>Condvar介绍与使用</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-condvar介绍与使用"></a></p>
</summary>
<div>
<p>Condvar 有两种状态：</p>
<ol>
<li>等待（wait）：线程在队列中等待，直到满足某个条件。</li>
<li>通知（notify）：当 condvar 的条件满足时，当前线程通知其他等待的线程可以被唤醒。通知可以是单个通知，也可以是多个通知，甚至广播（通知所有人）。</li>
</ol>
<p>在实践中，Condvar 往往和 Mutex 一起使用：</p>
<ul>
<li>Mutex 用于保证条件在读写时互斥</li>
<li>Condvar 用于控制线程的等待和唤醒。</li>
</ul>
<p>我们来看一个例子：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::sync::{Arc, Condvar, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = Arc::clone(&amp;pair);

    thread::spawn(move || {
        let (lock, cvar) = &amp;*pair2;
        let mut started = lock.lock().unwrap();
        *started = true;
        eprintln!(&quot;I'm a happy worker!&quot;);
        // 通知主线程
        cvar.notify_one();
        loop {
            thread::sleep(Duration::from_secs(1));
            println!(&quot;working...&quot;);
        }
    });

    // 等待工作线程的通知
    let (lock, cvar) = &amp;*pair;
    let mut started = lock.lock().unwrap();
    while !*started {
        started = cvar.wait(started).unwrap();
    }
    eprintln!(&quot;Worker started!&quot;);
}
</code></pre></pre>
<ol>
<li>
<p>这段代码通过 condvar，我们实现了 worker 线程在执行到一定阶段后通知主线程，然后主线程再做一些事情。</p>
</li>
<li>
<p>这里，我们使用了一个 Mutex 作为互斥条件，然后在 <a href="https://doc.rust-lang.org/src/std/sync/condvar.rs.html#184-191">cvar.wait() </a>中传入这个 Mutex。这个接口需要一个 MutexGuard，以便于知道需要唤醒哪个 Mutex 下等待的线程：</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn wait&lt;'a, T&gt;(
    &amp;self,
    guard: MutexGuard&lt;'a, T&gt;
) -&gt; LockResult&lt;MutexGuard&lt;'a, T&gt;&gt;
</code></pre></pre>
</div>
</details>
<h2 id="channel"><a class="header" href="#channel">Channel</a></h2>
<details id="admonition-mutex和condvar的局限性在哪channel如何解决的" class="admonition info">
<summary class="admonition-title">
<p>Mutex和Condvar的局限性在哪？Channel如何解决的？</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-mutex和condvar的局限性在哪channel如何解决的"></a></p>
</summary>
<div>
<p>但是用 Mutex 和 Condvar 来处理复杂的 DAG 并发模式会比较吃力。所以，Rust 还提供了各种各样的 Channel 用于处理并发任务之间的通讯。</p>
<p>由于 Golang 不遗余力地推广，Channel 可能是最广为人知的并发手段。相对于 Mutex，Channel 的抽象程度最高，接口最为直观，使用起来的心理负担也没那么大。使用 Mutex 时，你需要很小心地避免死锁，控制临界区的大小，防止一切可能发生的意外。</p>
<blockquote>
<p>虽然在 Rust 里，我们可以“无畏并发”（Fearless concurrency）—— 当代码编译通过，绝大多数并发问题都可以规避，但性能上的问题、逻辑上的死锁还需要开发者照料。</p>
</blockquote>
<p>Channel 把锁封装在了队列写入和读取的小块区域内，然后把读者和写者完全分离，使得读者读取数据和写者写入数据，对开发者而言，除了潜在的上下文切换外，完全和锁无关，就像访问一个本地队列一样。所以，对于大部分并发问题，我们都可以用 Channel 或者类似的思想来处理（比如 actor model）。</p>
</div>
</details>
<details id="admonition-channel根据使用场景和读写者数量分别如何分类" class="admonition info">
<summary class="admonition-title">
<p>Channel根据使用场景和读写者数量分别如何分类？</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-channel根据使用场景和读写者数量分别如何分类"></a></p>
</summary>
<div>
<p>Channel 在具体实现的时候，根据不同的使用场景，会选择不同的工具。Rust 提供了以下四种 Channel：</p>
<ol>
<li>oneshot：这可能是最简单的 Channel，写者就只发一次数据，而读者也只读一次。</li>
</ol>
<p>这种一次性的、多个线程间的同步可以用 oneshot channel 完成。由于 oneshot 特殊的用途，实现的时候可以直接用 atomic swap 来完成。</p>
<ol start="2">
<li>rendezvous：很多时候，我们只需要通过 Channel 来控制线程间的同步，并不需要发送数据。</li>
</ol>
<p>rendezvous channel 是 channel size 为 0 的一种特殊情况。</p>
<p>这种情况下，我们用 Mutex + Condvar 实现就足够了，在具体实现中，rendezvous channel 其实也就是 Mutex + Condvar 的一个包装。</p>
<ol start="3">
<li>bounded：bounded channel 有一个队列，但队列有上限。</li>
</ol>
<p>一旦队列被写满了，写者也需要被挂起等待。当阻塞发生后，读者一旦读取数据，channel 内部就会使用 Condvar 的 notify_one 通知写者，唤醒某个写者使其能够继续写入。</p>
<p>因此，实现中，一般会用到 Mutex + Condvar + VecDeque 来实现；如果不用 Condvar，可以直接使用 thread::park + thread::notify 来完成（flume 的做法）；如果不用 VecDeque，也可以使用双向链表或者其它的 ring buffer 的实现。</p>
<ol start="4">
<li>unbounded：queue 没有上限，如果写满了，就自动扩容。
我们知道，Rust 的很多数据结构如 Vec 、VecDeque 都是自动扩容的。unbounded 和 bounded 相比，除了不阻塞写者，其它实现都很类似。</li>
</ol>
<blockquote>
<p>所有这些 channel 类型，同步和异步的实现思路大同小异，主要的区别在于挂起 / 唤醒的对象：</p>
</blockquote>
<ul>
<li>在同步的世界里，挂起 / 唤醒的对象是线程；</li>
<li>而异步的世界里，是粒度很小的 task。</li>
</ul>
<h2 id="-12"><a class="header" href="#-12"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/34%EF%BD%9C%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F-4951803.jpg" alt="34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？" /></a></h2>
<p>根据 Channel 读者和写者的数量，Channel 又可以分为：</p>
<ul>
<li>
<p>SPSC：Single-Producer Single-Consumer，单生产者，单消费者。最简单，可以不依赖于 Mutex，只用 atomics 就可以实现。</p>
</li>
<li>
<p>SPMC：Single-Producer Multi-Consumer，单生产者，多消费者。需要在消费者这侧读取时加锁。</p>
</li>
<li>
<p>MPSC：Multi-Producer Single-Consumer，多生产者，单消费者。需要在生产者这侧写入时加锁。</p>
</li>
<li>
<p>MPMC：Multi-Producer Multi-Consumer。多生产者，多消费者。需要在生产者写入或者消费者读取时加锁。</p>
</li>
</ul>
<blockquote>
<p>在众多 Channel 类型中，使用最广的是 MPSC channel，多生产者，单消费者，因为往往我们希望通过单消费者来保证，用于处理消息的数据结构有独占的写访问。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/34%EF%BD%9C%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%BB%8Eatomics%E5%88%B0Channel%EF%BC%8CRust%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%EF%BC%9F.jpg" alt="34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？" /></p>
<p>比如，<a href="https://github.com/tyrchen/xunmi/blob/master/src/indexer.rs#L50">在 xunmi 的实现中</a>: </p>
<ol>
<li>index writer 内部是一个多线程的实现</li>
<li>但在使用时，我们需要用到它的可写引用。</li>
</ol>
<p>如果要能够在各种上下文中使用 index writer，我们就不得不将其用 Arc&lt;Mutex<T>&gt; 包裹起来，但这样在索引大量数据时效率太低，所以我们可以用 MPSC channel，让各种上下文都把数据发送给单一的线程，使用 index writer 索引，这样就避免了锁：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct IndexInner {
    index: Index,
    reader: IndexReader,
    config: IndexConfig,
    updater: Sender&lt;Input&gt;,
}

pub struct IndexUpdater {
    sender: Sender&lt;Input&gt;,
    t2s: bool,
    schema: Schema,
}

impl Indexer {
    // 打开或者创建一个 index
    pub fn open_or_create(config: IndexConfig) -&gt; Result&lt;Self&gt; {
        let schema = config.schema.clone();
        let index = if let Some(dir) = &amp;config.path {
            fs::create_dir_all(dir)?;
            let dir = MmapDirectory::open(dir)?;
            Index::open_or_create(dir, schema.clone())?
        } else {
            Index::create_in_ram(schema.clone())
        };

        Self::set_tokenizer(&amp;index, &amp;config);

        let mut writer = index.writer(config.writer_memory)?;

        // 创建一个 unbounded MPSC channel
        let (s, r) = unbounded::&lt;Input&gt;();

        // 启动一个线程，从 channel 的 reader 中读取数据
        thread::spawn(move || {
            for input in r {
                // 然后用 index writer 处理这个 input
                if let Err(e) = input.process(&amp;mut writer, &amp;schema) {
                    warn!(&quot;Failed to process input. Error: {:?}&quot;, e);
                }
            }
        });

        // 把 channel 的 sender 部分存入 IndexInner 结构
        Self::new(index, config, s)
    }

    pub fn get_updater(&amp;self) -&gt; IndexUpdater {
        let t2s = TextLanguage::Chinese(true) == self.config.text_lang;
        // IndexUpdater 内部包含 channel 的 sender 部分
        // 由于是 MPSC channel，所以这里可以简单 clone 一下 sender
        // 这也意味着，我们可以创建任意多个 IndexUpdater 在不同上下文发送数据
        // 而数据最终都会通过 channel 给到上面创建的线程，由 index writer 处理
        IndexUpdater::new(self.updater.clone(), self.index.schema(), t2s)
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="自己实现一个基本的mpsc-channel"><a class="header" href="#自己实现一个基本的mpsc-channel">自己实现一个基本的MPSC Channel</a></h2>
<p>之前我们谈论了如何在搜索引擎的 Index writer 上使用 MPSC channel：</p>
<ol>
<li>要更新 index 的上下文有很多（可以是线程也可以是异步任务）</li>
<li>而 IndexWriter 只能是唯一的。</li>
<li>为了避免在访问 IndexWriter 时加锁，我们可以使用 MPSC channel</li>
<li>在多个上下文中给 channel 发消息，然后在唯一拥有 IndexWriter 的线程中读取这些消息，非常高效。</li>
</ol>
<p>好，来看看今天要实现的 MPSC channel 的基本功能。为了简便起见，我们只关心 unbounded MPSC
channel。也就是说，当队列容量不够时，会自动扩容，所以，任何时候生产者写入数据都不会被阻塞，但是当队列中没有数据时，消费者会被阻塞：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/35%EF%BD%9C%E5%AE%9E%E6%93%8D%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84MPSC%20channel%EF%BC%9F.jpg" alt="35｜实操项目：如何实现一个基本的MPSC channel？" /></p>
<h3 id="测试驱动的设计"><a class="header" href="#测试驱动的设计">测试驱动的设计</a></h3>
<p>之前我们会从需求的角度来设计接口和数据结构，今天我们就换种方式，完全站在使用者的角度，用使用实例（测试）来驱动接口和数据结构的设计。</p>
<details id="admonition-需求1-基本的-sendrecv" class="admonition info">
<summary class="admonition-title">
<p>需求1: 基本的 send/recv</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-需求1-基本的-sendrecv"></a></p>
</summary>
<div>
<p>要实现刚才说的 MPSC channel，都有什么需求呢？首先，生产者可以产生数据，消费者能够消费产生出来的数据，也就是基本的 send/recv，我们以下面这个单元测试 1 来描述这个需求：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[test]
fn channel_should_work() {
    let (mut s, mut r) = unbounded();
    s.send(&quot;hello world!&quot;.to_string()).unwrap();
    let msg = r.recv().unwrap();
    assert_eq!(msg, &quot;hello world!&quot;);
}
</code></pre></pre>
<ol>
<li>这里，通过 unbounded() 方法， 可以创建一个 sender 和一个 receiver</li>
<li>sender 有 send() 方法，可以发送数据</li>
<li>receiver 有 recv() 方法，可以接受数据。</li>
<li>整体的接口，我们设计和 std::sync::mpsc 保持一致，避免使用者使用上的心智负担。</li>
</ol>
<p>为了实现这样一个接口，需要什么样的数据结构呢？</p>
<ol>
<li>首先，生产者和消费者之间会共享一个队列，可以用 VecDeque。</li>
<li>显然，这个队列在插入和取出数据时需要互斥，所以需要用 Mutex 来保护它。</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
struct Shared&lt;T&gt; {
    queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,
}

pub struct Sender&lt;T&gt; {
    shared: Arc&lt;Shared&lt;T&gt;&gt;,
}

pub struct Receiver&lt;T&gt; {
    shared: Arc&lt;Shared&lt;T&gt;&gt;,
}
</code></pre></pre>
<p>这样的数据结构应该可以满足单元测试 1。</p>
</div>
</details>
<details id="admonition-需求2-允许多个-sender-往-channel-里发送数据" class="admonition info">
<summary class="admonition-title">
<p>需求2: 允许多个 sender 往 channel 里发送数据 </p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-需求2-允许多个-sender-往-channel-里发送数据"></a></p>
</summary>
<div>
<p>由于需要的是 MPSC，所以，我们允许多个 sender 往 channel 里发送数据，用单元测试 2 来描述这个需求：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[test]
fn multiple_senders_should_work() {
    let (mut s, mut r) = unbounded();
    let mut s1 = s.clone();
    let mut s2 = s.clone();
    let t = thread::spawn(move || {
        s.send(1).unwrap();
    });
    let t1 = thread::spawn(move || {
        s1.send(2).unwrap();
    });
    let t2 = thread::spawn(move || {
        s2.send(3).unwrap();
    });
    for handle in [t, t1, t2] {
        handle.join().unwrap();
    }

    let mut result = [r.recv().unwrap(), r.recv().unwrap(), r.recv().unwrap()];
    // 在这个测试里，数据到达的顺序是不确定的，所以我们排个序再 assert
    result.sort();

    assert_eq!(result, [1, 2, 3]);
}
</code></pre></pre>
<p>这个需求，刚才的数据结构就可以满足，只是 Sender 需要实现 Clone trait。不过我们在写这个测试的时候稍微有些别扭，因为这一行有不断重复的代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">
let mut result = [r.recv().unwrap(), r.recv().unwrap(), r.recv().unwrap()];
</code></pre></pre>
<p>注意，测试代码的 DRY 也很重要，我们之前强调过。所以，当写下这个测试的时候，也许会想，我们可否提供 Iterator 的实现？恩这个想法先暂存下来。</p>
</div>
</details>
<details id="admonition-需求3-当队列空的时候receiver-所在的线程会被阻塞" class="admonition info">
<summary class="admonition-title">
<p>需求3: 当队列空的时候，receiver 所在的线程会被阻塞</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-需求3-当队列空的时候receiver-所在的线程会被阻塞"></a></p>
</summary>
<div>
<p>接下来考虑当队列空的时候，receiver 所在的线程会被阻塞这个需求。那么，如何对这个需求进行测试呢？这并不简单，我们没有比较直观的方式来检测线程的状态。</p>
<p>不过，我们可以通过检测“线程是否退出”来间接判断线程是否被阻塞。</p>
<p>理由很简单:</p>
<ol>
<li>如果线程没有继续工作，又没有退出，那么一定被阻塞住了。</li>
<li>阻塞住之后，我们继续发送数据，消费者所在的线程会被唤醒，继续工作</li>
<li>所以最终队列长度应该为 0。我们看单元测试 3：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
#[test]
fn receiver_should_be_blocked_when_nothing_to_read() {
    let (mut s, r) = unbounded();
    let mut s1 = s.clone();
    thread::spawn(move || {
        for (idx, i) in r.into_iter().enumerate() {
            // 如果读到数据，确保它和发送的数据一致
            assert_eq!(idx, i);
        }
        // 读不到应该休眠，所以不会执行到这一句，执行到这一句说明逻辑出错
        assert!(false);
    });

    thread::spawn(move || {
        for i in 0..100usize {
            s.send(i).unwrap();
        }
    });

    // 1ms 足够让生产者发完 100 个消息，消费者消费完 100 个消息并阻塞
    thread::sleep(Duration::from_millis(1));

    // 再次发送数据，唤醒消费者
    for i in 100..200usize {
        s1.send(i).unwrap();
    }

    // 留点时间让 receiver 处理
    thread::sleep(Duration::from_millis(1));

    // 如果 receiver 被正常唤醒处理，那么队列里的数据会都被读完
    assert_eq!(s1.total_queued_items(), 0);
}
</code></pre></pre>
<p>这个测试代码中:</p>
<ol>
<li>我们假定 receiver 实现了 Iterator</li>
<li>还假定 sender 提供了一个方法 total_queued_items()。这些可以在实现的时候再处理。</li>
</ol>
<p>你可以花些时间仔细看看这段代码，想想其中的处理逻辑。虽然代码很简单，不难理解，但是把一个完整的需求转化成合适的测试代码，还是要颇费些心思的。</p>
<p>好，如果要能支持队列为空时阻塞，我们需要使用 Condvar。</p>
<p>所以 Shared<T> 需要修改一下：</p>
<pre><pre class="playground"><code class="language-rust  editable">
struct Shared&lt;T&gt; {
    queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,
    available: Condvar,
}
</code></pre></pre>
<p>这样当实现 Receiver 的 recv() 方法后，我们可以在读不到数据时阻塞线程：</p>
<pre><pre class="playground"><code class="language-rust  editable">
// 拿到锁
let mut inner = self.shared.queue.lock().unwrap();
// ... 假设读不到数据
// 使用 condvar 和 MutexGuard 阻塞当前线程
self.shared.available.wait(inner)
</code></pre></pre>
</div>
</details>
<details id="admonition-需求4-receiver没有数据可读" class="admonition info">
<summary class="admonition-title">
<p>需求4: Receiver没有数据可读</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-需求4-receiver没有数据可读"></a></p>
</summary>
<div>
<p>顺着刚才的多个 sender 想，如果现在所有 Sender 都退出作用域，Receiver 继续接收，到没有数据可读了，该怎么处理？是不是应该产生一个错误，让调用者知道，现在 channel 的另一侧已经没有生产者了，再读也读不出数据了？</p>
<p>我们来写单元测试 4：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[test]
fn last_sender_drop_should_error_when_receive() {
    let (s, mut r) = unbounded();
    let s1 = s.clone();
    let senders = [s, s1];
    let total = senders.len();

    // sender 即用即抛
    for mut sender in senders {
        thread::spawn(move || {
            sender.send(&quot;hello&quot;).unwrap();
            // sender 在此被丢弃
        })
        .join()
        .unwrap();
    }

    // 虽然没有 sender 了，接收者依然可以接受已经在队列里的数据
    for _ in 0..total {
        r.recv().unwrap();
    }

    // 然而，读取更多数据时会出错
    assert!(r.recv().is_err());
}
</code></pre></pre>
<p>这个测试依旧很简单。你可以想象一下，使用什么样的数据结构可以达到这样的目的:</p>
<ol>
<li>首先，每次 Clone 时，要增加 Sender 的计数；</li>
<li>在 Sender Drop 时，减少这个计数；</li>
<li>然后，我们为 Receiver 提供一个方法 total_senders()，来读取 Sender 的计数</li>
<li>当计数为 0，且队列中没有数据可读时，recv() 方法就报错。</li>
</ol>
<blockquote>
<p>有了这个思路，你想一想，这个计数器用什么数据结构呢？用锁保护么？</p>
</blockquote>
<p>哈，你一定想到了可以使用 atomics。对，我们可以用 AtomicUsize。所以，Shared 数据结构需要更新一下：</p>
<pre><pre class="playground"><code class="language-rust  editable">
struct Shared&lt;T&gt; {
    queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,
    available: Condvar,
    senders: AtomicUsize,
}
</code></pre></pre>
</div>
</details>
<details id="admonition-需求5-没有receiver处理数据" class="admonition info">
<summary class="admonition-title">
<p>需求5: 没有Receiver处理数据</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-需求5-没有receiver处理数据"></a></p>
</summary>
<div>
<p>既然没有 Sender 了要报错，那么如果没有 Receiver 了，Sender 发送时是不是也应该错误返回？这个需求和上面类似，就不赘述了。看构造的单元测试 5：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[test]
fn receiver_drop_should_error_when_send() {
    let (mut s1, mut s2) = {
        let (s, _) = unbounded();
        let s1 = s.clone();
        let s2 = s.clone();
        (s1, s2)
    };

    assert!(s1.send(1).is_err());
    assert!(s2.send(1).is_err());
}
</code></pre></pre>
<p>这里，我们创建一个 channel，产生两个 Sender 后便立即丢弃 Receiver。两个 Sender 在发送时都会出错。</p>
<p>同样的，Shared 数据结构要更新一下：</p>
<pre><pre class="playground"><code class="language-rust  editable">
struct Shared&lt;T&gt; {
    queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,
    available: Condvar,
    senders: AtomicUsize,
    receivers: AtomicUsize,
}
</code></pre></pre>
</div>
</details>
<h3 id="实现-mpsc-channel"><a class="header" href="#实现-mpsc-channel">实现 MPSC channel</a></h3>
<p>现在写了五个单元测试，我们已经把需求摸透了，并且有了基本的接口和数据结构的设计。接下来，我们来写实现的代码。</p>
<details id="admonition-创建一个新的项目" class="admonition info">
<summary class="admonition-title">
<p>创建一个新的项目</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-创建一个新的项目"></a></p>
</summary>
<div>
<pre><code class="language-shell">cargo new con_utils --lib
</code></pre>
<ol>
<li>在 cargo.toml 中添加 anyhow 作为依赖。</li>
<li>在 lib.rs 里，我们就写入一句：pub mod channel , 然后创建 src/channel.rs</li>
<li>把刚才设计时使用的 test case、设计的数据结构，以及 test case 里使用到的接口，用代码全部放进来：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use std::{
    collections::VecDeque,
    sync::{atomic::AtomicUsize, Arc, Condvar, Mutex},
};

/// 发送者
pub struct Sender&lt;T&gt; {
    shared: Arc&lt;Shared&lt;T&gt;&gt;,
}

/// 接收者
pub struct Receiver&lt;T&gt; {
    shared: Arc&lt;Shared&lt;T&gt;&gt;,
}

/// 发送者和接收者之间共享一个 VecDeque，用 Mutex 互斥，用 Condvar 通知
/// 同时，我们记录有多少个 senders 和 receivers

struct Shared&lt;T&gt; {
    queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,
    available: Condvar,
    senders: AtomicUsize,
    receivers: AtomicUsize,
}

impl&lt;T&gt; Sender&lt;T&gt; {
    /// 生产者写入一个数据
    pub fn send(&amp;mut self, t: T) -&gt; Result&lt;()&gt; {
        todo!()
    }

    pub fn total_receivers(&amp;self) -&gt; usize {
        todo!()
    }

    pub fn total_queued_items(&amp;self) -&gt; usize {
        todo!()
    }
}

impl&lt;T&gt; Receiver&lt;T&gt; {
    pub fn recv(&amp;mut self) -&gt; Result&lt;T&gt; {
        todo!()
    }

    pub fn total_senders(&amp;self) -&gt; usize {
        todo!()
    }
}

impl&lt;T&gt; Iterator for Receiver&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        todo!()
    }
}

/// 克隆 sender
impl&lt;T&gt; Clone for Sender&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        todo!()
    }
}

/// Drop sender
impl&lt;T&gt; Drop for Sender&lt;T&gt; {
    fn drop(&amp;mut self) {
        todo!()
    }
}

impl&lt;T&gt; Drop for Receiver&lt;T&gt; {
    fn drop(&amp;mut self) {
        todo!()
    }
}

/// 创建一个 unbounded channel
pub fn unbounded&lt;T&gt;() -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {
    todo!()
}

#[cfg(test)]
mod tests {
    use std::{thread, time::Duration};

    use super::*;
    // 此处省略所有 test case
}
</code></pre></pre>
</div>
</details>
<details id="admonition-实现单元测试相关功能" class="admonition info">
<summary class="admonition-title">
<p>实现单元测试相关功能</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-实现单元测试相关功能"></a></p>
</summary>
<div>
<p>目前这个代码虽然能够编译通过，但因为没有任何实现，所以 cargo test 全部出错。接下来，我们就来一点点实现功能。</p>
<ol>
<li>创建 unbounded channel</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn unbounded&lt;T&gt;() -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {
    let shared = Shared::default();
    let shared = Arc::new(shared);
    (
        Sender {
            shared: shared.clone(),
        },
        Receiver { shared },
    )
}

const INITIAL_SIZE: usize = 32;
impl&lt;T&gt; Default for Shared&lt;T&gt; {
    fn default() -&gt; Self {
        Self {
            queue: Mutex::new(VecDeque::with_capacity(INITIAL_SIZE)),
            available: Condvar::new(),
            senders: AtomicUsize::new(1),
            receivers: AtomicUsize::new(1),
        }
    }
}
</code></pre></pre>
<p>因为这里使用 default() 创建了 Shared<T> 结构，所以我们需要为其实现 Default。创建时，我们有 1 个生产者和 1 个消费者。</p>
<ol start="2">
<li>实现消费者</li>
</ol>
<p>对于消费者，我们主要需要实现 recv 方法。</p>
<p>在 recv 中:</p>
<ul>
<li>如果队列中有数据，那么直接返回；</li>
<li>如果没数据，且所有生产者都离开了，我们就返回错误；</li>
<li>如果没数据，但还有生产者，我们就阻塞消费者的线程：</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;T&gt; Receiver&lt;T&gt; {
    pub fn recv(&amp;mut self) -&gt; Result&lt;T&gt; {
        // 拿到队列的锁
        let mut inner = self.shared.queue.lock().unwrap();
        loop {
            match inner.pop_front() {
                // 读到数据返回，锁被释放
                Some(t) =&gt; {
                    return Ok(t);
                }
                // 读不到数据，并且生产者都退出了，释放锁并返回错误
                None if self.total_senders() == 0 =&gt; return Err(anyhow!(&quot;no sender left&quot;)),
                // 读不到数据，把锁提交给 available Condvar，它会释放锁并挂起线程，等待 notify
                None =&gt; {
                    // 当 Condvar 被唤醒后会返回 MutexGuard，我们可以 loop 回去拿数据
                    // 这是为什么 Condvar 要在 loop 里使用
                    inner = self
                        .shared
                        .available
                        .wait(inner)
                        .map_err(|_| anyhow!(&quot;lock poisoned&quot;))?;
                }
            }
        }
    }

    pub fn total_senders(&amp;self) -&gt; usize {
        self.shared.senders.load(Ordering::SeqCst)
    }
}
</code></pre></pre>
<p>注意看这里 Condvar 的使用。</p>
<ul>
<li>在 wait() 方法里，它接收一个 MutexGuard，然后释放这个 Mutex，挂起线程。</li>
<li>等得到通知后，它会再获取锁，得到一个 MutexGuard，返回。所以这里是：</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">
inner = self.shared.available.wait(inner).map_err(|_| anyhow!(&quot;lock poisoned&quot;))?;
</code></pre></pre>
<p>因为 recv() 会返回一个值，所以阻塞回来之后，我们应该循环回去拿数据。这是为什么这段逻辑要被 loop {} 包裹。我们前面在设计时考虑过：当发送者发送数据时，应该通知被阻塞的消费者。所以，在实现 Sender 的 send() 时，需要做相应的 notify 处理。</p>
<p>记得还要处理消费者的 drop：</p>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;T&gt; Drop for Receiver&lt;T&gt; {
    fn drop(&amp;mut self) {
        self.shared.receivers.fetch_sub(1, Ordering::AcqRel);
    }
}
</code></pre></pre>
<p>很简单，消费者离开时，将 receivers 减一。</p>
</div>
</details>
<details id="admonition-实现生产者功能" class="admonition info">
<summary class="admonition-title">
<p>实现生产者功能</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-实现生产者功能"></a></p>
</summary>
<div>
<p>接下来我们看生产者的功能怎么实现。</p>
<ol>
<li>首先，在没有消费者的情况下，应该报错。</li>
<li>正常应该使用 thiserror 定义自己的错误，不过这里为了简化代码，就使用 anyhow! 宏产生一个 adhoc 的错误。</li>
<li>如果消费者还在，那么我们获取 VecDeque 的锁，把数据压入：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;T&gt; Sender&lt;T&gt; {
    /// 生产者写入一个数据
    pub fn send(&amp;mut self, t: T) -&gt; Result&lt;()&gt; {
        // 如果没有消费者了，写入时出错
        if self.total_receivers() == 0 {
            return Err(anyhow!(&quot;no receiver left&quot;));
        }

        // 加锁，访问 VecDeque，压入数据，然后立刻释放锁
        let was_empty = {
            let mut inner = self.shared.queue.lock().unwrap();
            let empty = inner.is_empty();
            inner.push_back(t);
            empty
        };

        // 通知任意一个被挂起等待的消费者有数据
        if was_empty {
            self.shared.available.notify_one();
        }

        Ok(())
    }

    pub fn total_receivers(&amp;self) -&gt; usize {
        self.shared.receivers.load(Ordering::SeqCst)
    }

    pub fn total_queued_items(&amp;self) -&gt; usize {
        let queue = self.shared.queue.lock().unwrap();
        queue.len()
    }
}
</code></pre></pre>
<p>这里，获取 total_receivers 时，我们使用了 Ordering::SeqCst，保证所有线程看到同样顺序的对 receivers 的操作。这个值是最新的值。</p>
<p>在压入数据时，需要判断一下之前是队列是否为空，因为队列为空的时候，我们需要用 notify_one() 来唤醒消费者。这个非常重要，如果没处理的话，会导致消费者阻塞后无法复原接收数据。</p>
<blockquote>
<p>由于我们可以有多个生产者，所以要允许它 clone：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;T&gt; Clone for Sender&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        self.shared.senders.fetch_add(1, Ordering::AcqRel);
        Self {
            shared: Arc::clone(&amp;self.shared),
        }
    }
}
</code></pre></pre>
<p>实现 Clone trait 的方法很简单，但记得要把 shared.senders 加 1，使其保持和当前的 senders 的数量一致。</p>
<blockquote>
<p>当然，在 drop 的时候我们也要维护 shared.senders 使其减 1：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;T&gt; Drop for Sender&lt;T&gt; {
    fn drop(&amp;mut self) {
        self.shared.senders.fetch_sub(1, Ordering::AcqRel);
        
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-其他功能实现" class="admonition info">
<summary class="admonition-title">
<p>其他功能实现</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-其他功能实现"></a></p>
</summary>
<div>
<p>目前还缺乏 Receiver 的 Iterator 的实现，这个很简单，就是在 next() 里调用 recv() 方法，Rust 提供了支持在 Option / Result 之间很方便转换的函数，所以这里我们可以直接通过 ok() 来将 Result 转换成 Option：</p>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;T&gt; Iterator for Receiver&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.recv().ok()
    }
}
</code></pre></pre>
<p>好，目前所有需要实现的代码都实现完毕， cargo test 测试一下。wow！测试一次性通过！这也太顺利了吧！</p>
<p>最后来仔细审视一下代码。很快，我们发现 Sender 的 Drop 实现似乎有点问题。如果 Receiver 被阻塞，而此刻所有 Sender 都走了，那么 Receiver 就没有人唤醒，会带来资源的泄露。这是一个很边边角角的问题，所以之前的测试没有覆盖到。</p>
<p>我们来设计一个场景让这个问题暴露：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[test]
fn receiver_shall_be_notified_when_all_senders_exit() {
    let (s, mut r) = unbounded::&lt;usize&gt;();
    // 用于两个线程同步
    let (mut sender, mut receiver) = unbounded::&lt;usize&gt;();
    let t1 = thread::spawn(move || {
        // 保证 r.recv() 先于 t2 的 drop 执行
        sender.send(0).unwrap();
        assert!(r.recv().is_err());
    });

    thread::spawn(move || {
        receiver.recv().unwrap();
        drop(s);
    });

    t1.join().unwrap();
}
</code></pre></pre>
<p>在我进一步解释之前，你可以停下来想想:</p>
<ol>
<li>为什么这个测试可以保证暴露这个问题？</li>
<li>它是怎么暴露的？</li>
<li>如果想不到，再 cargo test 看看会出现什么问题。</li>
</ol>
<p>来一起分析分析，这里，我们创建了两个线程 t1 和 t2，分别让它们处理消费者和生产者。t1 读取数据，此时没有数据，所以会阻塞，而 t2 直接把生产者 drop 掉。所以，此刻如果没有人唤醒 t1，那么 t1.join() 就会一直等待，因为 t1 一直没有退出。</p>
<blockquote>
<p>所以，为了保证一定是 t1 r.recv()先执行导致阻塞、t2 再 drop(s)，我们（eat your own dog food）用另一个 channel 来控制两个线程的执行顺序。这是一种很通用的做法，你可以好好琢磨一下。</p>
</blockquote>
<p>运行 cargo test 后，测试被阻塞。这是因为，t1 没有机会得到唤醒，所以这个测试就停在那里不动了。</p>
<p>要修复这个问题，我们需要妥善处理 Sender 的 Drop：</p>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;T&gt; Drop for Sender&lt;T&gt; {
    fn drop(&amp;mut self) {
        let old = self.shared.senders.fetch_sub(1, Ordering::AcqRel);
        // sender 走光了，唤醒 receiver 读取数据（如果队列中还有的话），读不到就出错
        if old &lt;= 1 {
            // 因为我们实现的是 MPSC，receiver 只有一个，所以 notify_all 实际等价 notify_one
            self.shared.available.notify_all();
        }
    }
}
</code></pre></pre>
<p>这里，如果减一之前，旧的 senders 的数量小于等于 1，意味着现在是最后一个 Sender 要离开了，不管怎样我们都要唤醒 Receiver ，所以这里使用了 notify_all()。如果 Receiver 之前已经被阻塞，此刻就能被唤醒。修改完成，cargo test 一切正常。</p>
</div>
</details>
<details id="admonition-对锁进行性能优化" class="admonition info">
<summary class="admonition-title">
<p>对锁进行性能优化</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-对锁进行性能优化"></a></p>
</summary>
<div>
<p>从功能上来说，目前我们的 MPSC unbounded channel 没有太多的问题，可以应用在任何需要 MPSC channel 的场景。然而，每次读写都需要获取锁，虽然锁的粒度很小，但还是让整体的性能打了个折扣。有没有可能优化锁呢？</p>
<p>之前我们讲到，优化锁的手段无非是减小临界区的大小，让每次加锁的时间很短，这样冲突的几率就变小。另外，就是降低加锁的频率，对于消费者来说，如果我们能够一次性把队列中的所有数据都读完缓存起来，以后在需要的时候从缓存中读取，这样就可以大大减少消费者加锁的频次。</p>
<p>顺着这个思路，我们可以在 Receiver 的结构中放一个 cache：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct Receiver&lt;T&gt; {
    shared: Arc&lt;Shared&lt;T&gt;&gt;,
    cache: VecDeque&lt;T&gt;,
}
</code></pre></pre>
<p>如果你之前有 C 语言开发的经验，也许会想，到了这一步，何必把 queue 中的数据全部读出来，存入 Receiver 的 cache 呢？这样效率太低，如果能够直接 swap 两个结构内部的指针，这样，即便队列中有再多的数据，也是一个 O(1) 的操作。</p>
<p>Rust 有类似的 <a href="https://doc.rust-lang.org/std/mem/fn.swap.html">std::mem::swap</a> 方法。比如</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::mem;

fn main() {
    let mut x = &quot;hello world&quot;.to_string();
    let mut y = &quot;goodbye world&quot;.to_string();
    
    mem::swap(&amp;mut x, &amp;mut y);
    
    assert_eq!(&quot;goodbye world&quot;, x);
    assert_eq!(&quot;hello world&quot;, y);
}
</code></pre></pre>
<blockquote>
<p>好，了解了 swap 方法，我们看看如何修改 Receiver 的 recv() 方法来提升性能：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn recv(&amp;mut self) -&gt; Result&lt;T&gt; {
    // 无锁 fast path
    if let Some(v) = self.cache.pop_front() {
        return Ok(v);
    }

    // 拿到队列的锁
    let mut inner = self.shared.queue.lock().unwrap();
    loop {
        match inner.pop_front() {
            // 读到数据返回，锁被释放
            Some(t) =&gt; {
                // 如果当前队列中还有数据，那么就把消费者自身缓存的队列（空）和共享队列 swap 一下
                // 这样之后再读取，就可以从 self.queue 中无锁读取
                if !inner.is_empty() {
                    std::mem::swap(&amp;mut self.cache, &amp;mut inner);
                }
                return Ok(t);
            }
            // 读不到数据，并且生产者都退出了，释放锁并返回错误
            None if self.total_senders() == 0 =&gt; return Err(anyhow!(&quot;no sender left&quot;)),
            // 读不到数据，把锁提交给 available Condvar，它会释放锁并挂起线程，等待 notify
            None =&gt; {
                // 当 Condvar 被唤醒后会返回 MutexGuard，我们可以 loop 回去拿数据
                // 这是为什么 Condvar 要在 loop 里使用
                inner = self
                    .shared
                    .available
                    .wait(inner)
                    .map_err(|_| anyhow!(&quot;lock poisoned&quot;))?;
            }
        }
    }
}
</code></pre></pre>
<ol>
<li>当 cache 中有数据时，总是从 cache 中读取；</li>
<li>当 cache 中没有，我们拿到队列的锁，读取一个数据</li>
<li>然后看看队列是否还有数据，有的话，就 swap cache 和 queue，然后返回之前读取的数据。</li>
</ol>
<p>好，做完这个重构和优化，我们可以运行 cargo test，看看已有的测试是否正常。如果你遇到报错，应该是 cache 没有初始化，你可以自行解决，也可以参考：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn unbounded&lt;T&gt;() -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {
    let shared = Shared::default();
    let shared = Arc::new(shared);
    (
        Sender {
            shared: shared.clone(),
        },
        Receiver {
            shared,
            cache: VecDeque::with_capacity(INITIAL_SIZE),
        },
    )
}
</code></pre></pre>
<p>虽然现有的测试全数通过，但我们并没有为这个优化写测试，这里补个测试：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[test]
    fn channel_fast_path_should_work() {
    let (mut s, mut r) = unbounded();
    for i in 0..10usize {
        s.send(i).unwrap();
    }

    assert!(r.cache.is_empty());
    // 读取一个数据，此时应该会导致 swap，cache 中有数据
    assert_eq!(0, r.recv().unwrap());
    // 还有 9 个数据在 cache 中
    assert_eq!(r.cache.len(), 9);
    // 在 queue 里没有数据了
    assert_eq!(s.total_queued_items(), 0);

    // 从 cache 里读取剩下的数据
    for (idx, i) in r.into_iter().take(9).enumerate() {
        assert_eq!(idx + 1, i);
    }
}
</code></pre></pre>
<p>这个测试很简单，详细注释也都写上了。</p>
</div>
</details>
<details id="admonition-完整代码" class="admonition info">
<summary class="admonition-title">
<p>完整代码</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-完整代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use anyhow::{anyhow, Result};
use std::{
    collections::VecDeque,
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc, Condvar, Mutex,
    },
};

/// 发送者
pub struct Sender&lt;T&gt; {
    shared: Arc&lt;Shared&lt;T&gt;&gt;,
}

/// 接收者
pub struct Receiver&lt;T&gt; {
    shared: Arc&lt;Shared&lt;T&gt;&gt;,
    cache: VecDeque&lt;T&gt;,
}

/// 发送者和接收者之间共享一个 VecDeque，用 Mutex 互斥，用 Condvar 通知
/// 同时，我们记录有多少个 senders 和 receivers

struct Shared&lt;T&gt; {
    queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,
    available: Condvar,
    senders: AtomicUsize,
    receivers: AtomicUsize,
}

const INITIAL_SIZE: usize = 32;
impl&lt;T&gt; Default for Shared&lt;T&gt; {
    fn default() -&gt; Self {
        Self {
            queue: Mutex::new(VecDeque::with_capacity(INITIAL_SIZE)),
            available: Condvar::new(),
            senders: AtomicUsize::new(1),
            receivers: AtomicUsize::new(1),
        }
    }
}

impl&lt;T&gt; Sender&lt;T&gt; {
    /// 生产者写入一个数据
    pub fn send(&amp;mut self, t: T) -&gt; Result&lt;()&gt; {
        // 如果没有消费者了，写入时出错
        if self.total_receivers() == 0 {
            return Err(anyhow!(&quot;no receiver left&quot;));
        }

        // 加锁，访问 VecDeque，压入数据，然后立刻释放锁
        let was_empty = {
            let mut inner = self.shared.queue.lock().unwrap();
            let empty = inner.is_empty();
            inner.push_back(t);
            empty
        };

        // 通知任意一个被挂起等待的消费者有数据
        if was_empty {
            self.shared.available.notify_one();
        }

        Ok(())
    }

    pub fn total_receivers(&amp;self) -&gt; usize {
        self.shared.receivers.load(Ordering::SeqCst)
    }

    pub fn total_queued_items(&amp;self) -&gt; usize {
        let queue = self.shared.queue.lock().unwrap();
        queue.len()
    }
}

/// 克隆 sender
impl&lt;T&gt; Clone for Sender&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        self.shared.senders.fetch_add(1, Ordering::AcqRel);
        Self {
            shared: Arc::clone(&amp;self.shared),
        }
    }
}

/// Drop sender
impl&lt;T&gt; Drop for Sender&lt;T&gt; {
    fn drop(&amp;mut self) {
        let old = self.shared.senders.fetch_sub(1, Ordering::AcqRel);
        // sender 走光了，唤醒 receiver 读取数据（如果队列中还有的话），读不到就出错
        if old &lt;= 1 {
            // 因为我们实现的是 MPSC，receiver 只有一个，所以 notify_all 实际等价 notify_one
            self.shared.available.notify_all();
        }
    }
}

impl&lt;T&gt; Receiver&lt;T&gt; {
    pub fn recv(&amp;mut self) -&gt; Result&lt;T&gt; {
        // 无锁 fast path
        if let Some(v) = self.cache.pop_front() {
            return Ok(v);
        }

        // 拿到队列的锁
        let mut inner = self.shared.queue.lock().unwrap();
        loop {
            match inner.pop_front() {
                // 读到数据返回，锁被释放
                Some(t) =&gt; {
                    // 如果当前队列中还有数据，那么就把消费者自身缓存的队列（空）和共享队列 swap 一下
                    // 这样之后再读取，就可以从 self.queue 中无锁读取
                    if !inner.is_empty() {
                        std::mem::swap(&amp;mut self.cache, &amp;mut inner);
                    }
                    return Ok(t);
                }
                // 读不到数据，并且生产者都退出了，释放锁并返回错误
                None if self.total_senders() == 0 =&gt; return Err(anyhow!(&quot;no sender left&quot;)),
                // 读不到数据，把锁提交给 available Condvar，它会释放锁并挂起线程，等待 notify
                None =&gt; {
                    // 当 Condvar 被唤醒后会返回 MutexGuard，我们可以 loop 回去拿数据
                    // 这是为什么 Condvar 要在 loop 里使用
                    inner = self
                        .shared
                        .available
                        .wait(inner)
                        .map_err(|_| anyhow!(&quot;lock poisoned&quot;))?;
                }
            }
        }
    }

    pub fn total_senders(&amp;self) -&gt; usize {
        self.shared.senders.load(Ordering::SeqCst)
    }
}

impl&lt;T&gt; Iterator for Receiver&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.recv().ok()
    }
}

impl&lt;T&gt; Drop for Receiver&lt;T&gt; {
    fn drop(&amp;mut self) {
        self.shared.receivers.fetch_sub(1, Ordering::AcqRel);
        // 因为 sender 不会阻塞，所以 receiver 离开不需要唤醒 sender
    }
}

/// 创建一个 unbounded channel
pub fn unbounded&lt;T&gt;() -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {
    let shared = Shared::default();
    let shared = Arc::new(shared);
    (
        Sender {
            shared: shared.clone(),
        },
        Receiver {
            shared,
            cache: VecDeque::with_capacity(INITIAL_SIZE),
        },
    )
}

#[cfg(test)]
mod tests {
    use std::{thread, time::Duration};

    use super::*;

    #[test]
    fn channel_should_work() {
        let (mut s, mut r) = unbounded();
        s.send(&quot;hello world!&quot;.to_string()).unwrap();
        let msg = r.recv().unwrap();
        assert_eq!(msg, &quot;hello world!&quot;);
    }

    #[test]
    fn multiple_senders_should_work() {
        let (mut s, mut r) = unbounded();
        let mut s1 = s.clone();
        let mut s2 = s.clone();
        let t = thread::spawn(move || {
            s.send(1).unwrap();
        });
        let t1 = thread::spawn(move || {
            s1.send(2).unwrap();
        });
        let t2 = thread::spawn(move || {
            s2.send(3).unwrap();
        });
        for handle in [t, t1, t2] {
            handle.join().unwrap();
        }

        let mut result = [r.recv().unwrap(), r.recv().unwrap(), r.recv().unwrap()];
        // 在这个测试里，数据到达的顺序是不确定的，所以我们排个序再 assert
        result.sort_unstable();

        assert_eq!(result, [1, 2, 3]);
    }

    #[test]
    #[allow(clippy::all)]
    fn receiver_should_be_blocked_when_nothing_to_read() {
        let (mut s, r) = unbounded();
        let mut s1 = s.clone();
        thread::spawn(move || {
            for (idx, i) in r.into_iter().enumerate() {
                // 如果读到数据，确保它和发送的数据一致
                assert_eq!(idx, i);
            }
            // 读不到应该休眠，所以不会执行到这一句，执行到这一句说明逻辑出错
            assert!(false);
        });

        thread::spawn(move || {
            for i in 0..100usize {
                s.send(i).unwrap();
            }
            // 防止所有 sender 都离开
            loop {}
        });

        // 1ms 足够让生产者发完 100 个消息，消费者消费完 100 个消息并阻塞
        thread::sleep(Duration::from_millis(1));

        // 再次发送数据，唤醒消费者
        for i in 100..200usize {
            s1.send(i).unwrap();
        }

        // 留点时间让 receiver 处理
        thread::sleep(Duration::from_millis(1));

        // 如果 receiver 被正常唤醒处理，那么队列里的数据会都被读完
        assert_eq!(s1.total_queued_items(), 0);
    }

    #[test]
    fn last_sender_drop_should_error_when_receive() {
        let (s, mut r) = unbounded();
        let s1 = s.clone();
        let senders = [s, s1];
        let total = senders.len();

        // sender 即用即抛
        for mut sender in senders {
            thread::spawn(move || {
                sender.send(&quot;hello&quot;).unwrap();
                // sender 在此被丢弃
            })
            .join()
            .unwrap();
        }

        // 虽然没有 sender 了，接收者依然可以接受已经在队列里的数据
        for _ in 0..total {
            r.recv().unwrap();
        }

        // 然而，读取更多数据时会出错
        assert!(r.recv().is_err());
    }

    #[test]
    fn receiver_drop_should_error_when_send() {
        let (mut s1, mut s2) = {
            let (s, _) = unbounded();
            let s1 = s.clone();
            (s1, s)
        };

        assert!(s1.send(1).is_err());
        assert!(s2.send(1).is_err());
    }

    #[test]
    fn receiver_shall_be_notified_when_all_senders_exit() {
        let (s, mut r) = unbounded::&lt;usize&gt;();
        // 用于两个线程同步
        let (mut sender, mut receiver) = unbounded::&lt;usize&gt;();
        let t1 = thread::spawn(move || {
            // 保证 r.recv() 先于 t2 的 drop 执行
            sender.send(0).unwrap();
            assert!(r.recv().is_err());
        });

        thread::spawn(move || {
            receiver.recv().unwrap();
            drop(s);
        });

        t1.join().unwrap();
    }

    #[test]
    fn channel_fast_path_should_work() {
        let (mut s, mut r) = unbounded();
        for i in 0..10usize {
            s.send(i).unwrap();
        }

        assert!(r.cache.is_empty());
        // 读取一个数据，此时应该会导致 swap，cache 中有数据
        assert_eq!(0, r.recv().unwrap());
        // 还有 9 个数据在 cache 中
        assert_eq!(r.cache.len(), 9);
        // 在 queue 里没有数据了
        assert_eq!(s.total_queued_items(), 0);

        // 从 cache 里读取剩下的数据
        for (idx, i) in r.into_iter().take(9).enumerate() {
            assert_eq!(idx + 1, i);
        }
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="回顾测试驱动开发"><a class="header" href="#回顾测试驱动开发">回顾测试驱动开发</a></h3>
<details id="admonition-回顾测试驱动开发" class="admonition info">
<summary class="admonition-title">
<p>回顾测试驱动开发</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-回顾测试驱动开发"></a></p>
</summary>
<div>
<p>这里完全顺着需求写测试，然后在写测试的过程中进行数据结构和接口的设计。和普通的 TDD 不同的是，先一口气把主要需求涉及的行为用测试来表述，然后通过这个表述，构建合适的接口，以及能够运行这个接口的数据结构。</p>
<p>在开发产品的时候，这也是一种非常有效的手段，可以让我们通过测试完善设计，最终得到一个能够让测试编译通过的、完全没有实现代码、只有接口的版本。之后，我们再一个接口一个接口实现，全部实现完成之后，运行测试，看看是否出问题。</p>
<p>在这里你可以多多关注构建测试用例的技巧。之前的课程中，我反复强调过单元测试的重要性，也以身作则在几个重要的实操中都有详尽地测试。不过相比之前写的测试，这一讲中的测试要更难写一些，尤其是在并发场景下那些边边角角的功能测试。</p>
<p>不要小看测试代码，有时候构造测试代码比撰写功能代码还要烧脑。但是，当你有了扎实的单元测试覆盖后，再做重构，比如最后我们做和性能相关的重构，就变得轻松很多，因为只要cargo test通过，起码这个重构没有引起任何回归问题（regression bug）。</p>
<p>当然，重构没有引入回归问题，并不意味着重构完全没有问题，我们还需要考虑撰写新的测试，覆盖重构带来的改动。</p>
</div>
</details>
<h2 id="actor"><a class="header" href="#actor">Actor</a></h2>
<details id="admonition-简单介绍actor并举例" class="admonition info">
<summary class="admonition-title">
<p>简单介绍Actor，并举例</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-简单介绍actor并举例"></a></p>
</summary>
<div>
<p>最后我们简单介绍一下 <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a>，它在业界主要的使用者是 Erlang VM 以及 <a href="https://akka.io/">akka</a>。actor 是一种有栈协程:</p>
<ol>
<li>每个 actor，有自己的一个独立的、轻量级的调用栈</li>
<li>以及一个用来接受消息的消息队列（mailbox 或者 message queue）</li>
<li>外界跟 actor 打交道的唯一手段就是，给它发送消息。</li>
</ol>
<p>Rust 标准库没有 actor 的实现，但是社区里有比较成熟的 <a href="https://github.com/actix/actix">actix</a>（大名鼎鼎的 actix-web 就是基于 actix 实现的），以及 <a href="https://github.com/bastion-rs/bastion">bastion</a>。</p>
<p>下面的代码用 actix 实现了一个简单的 DummyActor，它可以接收一个 InMsg，返回一个 OutMsg：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use actix::prelude::*;
use anyhow::Result;

// actor 可以处理的消息
#[derive(Message, Debug, Clone, PartialEq)]
#[rtype(result = &quot;OutMsg&quot;)]
enum InMsg {
    Add((usize, usize)),
    Concat((String, String)),
}

#[derive(MessageResponse, Debug, Clone, PartialEq)]
enum OutMsg {
    Num(usize),
    Str(String),
}

// Actor
struct DummyActor;

impl Actor for DummyActor {
    type Context = Context&lt;Self&gt;;
}

// 实现处理 InMsg 的 Handler trait
impl Handler&lt;InMsg&gt; for DummyActor {
    type Result = OutMsg; // &lt;-  返回的消息

    fn handle(&amp;mut self, msg: InMsg, _ctx: &amp;mut Self::Context) -&gt; Self::Result {
        match msg {
            InMsg::Add((a, b)) =&gt; OutMsg::Num(a + b),
            InMsg::Concat((mut s1, s2)) =&gt; {
                s1.push_str(&amp;s2);
                OutMsg::Str(s1)
            }
        }
    }
}

#[actix::main]
async fn main() -&gt; Result&lt;()&gt; {
    let addr = DummyActor.start();
    let res = addr.send(InMsg::Add((21, 21))).await?;
    let res1 = addr
        .send(InMsg::Concat((&quot;hello, &quot;.into(), &quot;world&quot;.into())))
        .await?;

    println!(&quot;res: {:?}, res1: {:?}&quot;, res, res1);

    Ok(())
}
</code></pre></pre>
<blockquote>
<p>可以看到，对 DummyActor，我们只需要实现 Actor trait 和 Handler<InMsg> trait 。</p>
</blockquote>
</div>
</details>
<h2 id="小结一下各种并发原语的使用场景"><a class="header" href="#小结一下各种并发原语的使用场景">小结一下各种并发原语的使用场景</a></h2>
<details id="admonition-如何根据使用场景选择使用atomicmutexrwlocksemaphorecondvarchannelactor" class="admonition info">
<summary class="admonition-title">
<p>如何根据使用场景选择使用Atomic、Mutex、RwLock、Semaphore、Condvar、Channel、Actor</p>
<p><a class="admonition-anchor-link" href="5_1_concurrency_primitives.html#admonition-如何根据使用场景选择使用atomicmutexrwlocksemaphorecondvarchannelactor"></a></p>
</summary>
<div>
<blockquote>
<p>Atomic、Mutex、RwLock、Semaphore、Condvar、Channel、Actor。</p>
</blockquote>
<ol>
<li>Atomic 在处理简单的原生类型时非常有用，如果你可以通过 AtomicXXX 结构进行同步，那么它们是最好的选择。</li>
<li>当你的数据结构无法简单通过 AtomicXXX 进行同步，但你又的确需要在多个线程中共享数据，那么 Mutex / RwLock 可以是一种选择。不过，你需要考虑锁的粒度，粒度太大的 Mutex / RwLock 效率很低。</li>
<li>如果你有 N 份资源可以供多个并发任务竞争使用，那么，Semaphore 是一个很好的选择。比如你要做一个 DB 连接池。</li>
<li>当你需要在并发任务中通知、协作时，Condvar 提供了最基本的通知机制，而 Channel 把这个通知机制进一步广泛扩展开，于是你可以用 Condvar 进行点对点的同步，用 Channel 做一对多、多对一、多对多的同步。</li>
</ol>
<blockquote>
<p>所以，当我们做大部分复杂的系统设计时，Channel 往往是最有力的武器，除了可以让数据穿梭于各个线程、各个异步任务间，它的接口还可以很优雅地跟 stream 适配。</p>
</blockquote>
<p>如果说在做整个后端的系统架构时，我们着眼的是：有哪些服务、服务和服务之间如何通讯、数据如何流动、服务和服务间如何同步；
那么在做某一个服务的架构时，着眼的是有哪些功能性的线程（异步任务）、它们之间的接口是什么样子、数据如何流动、如何同步。</p>
<p>在这里，Channel 兼具接口、同步和数据流三种功能，所以我说是最有力的武器。</p>
<p>然而它不该是唯一的武器。我们面临的真实世界的并发问题是多样的，解决方案也应该是多样的，计算机科学家们在过去的几十年里不断探索，构建了一系列的并发原语，也说明了很难有一种银弹解决所有问题。</p>
<p>就连 Mutex 本身，在实现中，还会根据不同的场景做不同的妥协（比如做 faireness 的妥协），因为这个世界就是这样，鱼与熊掌不可兼得，没有完美的解决方案，只有妥协出来的解决方案。所以 Channel 不是银弹，actor model 不是银弹，lock 不是银弹。</p>
<p>一门好的编程语言，可以提供大部分场景下的最佳实践（如 Erlang/Golang），但不该营造一种气氛，只有某个最佳实践才是唯一方案。我很喜欢 Erlang 的 actor model 和 Golang 的 Channel，但很可惜，它们过分依赖特定的、唯一的并发方案，使得开发者拿着榔头，看什么都是钉子。</p>
<p>相反，Rust 提供几乎你需要的所有解决方案，并且并不鼓吹它们的优劣，完全交由你按需选择。我在用 Rust 撰写多线程应用时，Channel 仍然是第一选择，但我还是会在合适的时候使用 Mutex、RwLock、Semaphore、Condvar、Atomic 等工具，而不是试图笨拙地用 Channel 叠加 Channel 来应对所有的场景。</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future"><a class="header" href="#future">Future</a></h1>
<!--ts-->
<ul>
<li><a href="5_2_future_async_await.html#future">Future</a>
<ul>
<li><a href="5_2_future_async_await.html#actor%E6%98%AF%E6%9C%89%E6%A0%88%E5%8D%8F%E7%A8%8Bfuture%E6%98%AF%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B">actor是有栈协程，Future是无栈协程</a></li>
<li><a href="5_2_future_async_await.html#rust%E7%9A%84future">Rust的Future</a></li>
<li><a href="5_2_future_async_await.html#future%E5%92%8Casyncawait">Future和async/await</a></li>
<li><a href="5_2_future_async_await.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-future">为什么需要 Future？</a></li>
<li><a href="5_2_future_async_await.html#%E6%B7%B1%E5%85%A5%E6%80%9D%E8%B7%AF">深入思路</a></li>
<li><a href="5_2_future_async_await.html#%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3">深入了解</a></li>
<li><a href="5_2_future_async_await.html#executor">executor</a></li>
<li><a href="5_2_future_async_await.html#reactor-pattern">reactor pattern</a></li>
<li><a href="5_2_future_async_await.html#%E6%80%8E%E4%B9%88%E7%94%A8-future-%E5%81%9A%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86">怎么用 Future 做异步处理？</a></li>
<li><a href="5_2_future_async_await.html#%E4%BD%BF%E7%94%A8-future-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">使用 Future 的注意事项</a></li>
<li><a href="5_2_future_async_await.html#%E5%AF%B9%E6%AF%94%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0future">对比线程学习Future</a></li>
<li><a href="5_2_future_async_await.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84-mutex-%E4%B8%8D%E8%83%BD%E8%B7%A8%E8%B6%8A-await">为什么标准库的 Mutex 不能跨越 await？</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:23 UTC 2022 -->
<!--te-->
<h2 id="actor是有栈协程future是无栈协程"><a class="header" href="#actor是有栈协程future是无栈协程">actor是有栈协程，Future是无栈协程</a></h2>
<details id="admonition-actor是有栈协程future是无栈协程" class="admonition info">
<summary class="admonition-title">
<p>actor是有栈协程，Future是无栈协程</p>
<p><a class="admonition-anchor-link" href="5_2_future_async_await.html#admonition-actor是有栈协程future是无栈协程"></a></p>
</summary>
<div>
<p>待补充</p>
</div>
</details>
<h2 id="rust的future"><a class="header" href="#rust的future">Rust的Future</a></h2>
<details id="admonition-rust-的-future-跟-javascript-的-promisepython的future非常相似" class="admonition info">
<summary class="admonition-title">
<p>Rust 的 Future 跟 JavaScript 的 Promise、Python的Future非常相似</p>
<p><a class="admonition-anchor-link" href="5_2_future_async_await.html#admonition-rust-的-future-跟-javascript-的-promisepython的future非常相似"></a></p>
</summary>
<div>
<p>其实 Rust 的 Future 跟 JavaScript 的 Promise 非常类似。</p>
<p>如果你熟悉 JavaScript，应该熟悉 Promise 的概念，它代表了在未来的某个时刻才能得到的结果的值，Promise 一般存在三个状态；</p>
<ol>
<li>等待（pending）状态</li>
<li>Promise 已运行，但还未结束；</li>
<li>结束状态，Promise 成功解析出一个值，或者执行失败。</li>
</ol>
<p>只不过 JavaScript 的 Promise 和线程类似，一旦创建就开始执行，对 Promise await 只是为了“等待”并获取解析出来的值；而 Rust 的 Future，只有在主动 await 后才开始执行。</p>
</div>
</details>
<h2 id="future和asyncawait"><a class="header" href="#future和asyncawait">Future和async/await</a></h2>
<details id="admonition-一般而言asyncawait和future是什么关系" class="admonition info">
<summary class="admonition-title">
<p>一般而言，async/await和Future是什么关系</p>
<p><a class="admonition-anchor-link" href="5_2_future_async_await.html#admonition-一般而言asyncawait和future是什么关系"></a></p>
</summary>
<div>
<p>讲到这里估计你也看出来了，谈 Future 的时候，我们总会谈到 async/await。</p>
<p>一般而言：</p>
<ol>
<li>async 定义了一个可以并发执行的任务</li>
<li>而 await 则触发这个任务并发执行。</li>
<li>大多数语言，包括 Rust，async/await 都是一个语法糖（syntactic sugar）</li>
<li>它们使用状态机将 Promise/Future 这样的结构包装起来进行处理。</li>
</ol>
</div>
</details>
<h2 id="为什么需要-future"><a class="header" href="#为什么需要-future">为什么需要 Future？</a></h2>
<details id="admonition-为什么需要future那不用asyncawait有什么问题" class="admonition info">
<summary class="admonition-title">
<p>为什么需要Future，那不用async/await有什么问题？</p>
<p><a class="admonition-anchor-link" href="5_2_future_async_await.html#admonition-为什么需要future那不用asyncawait有什么问题"></a></p>
</summary>
<div>
<p>首先，谈一谈为什么需要 Future 这样的并发结构。</p>
<p>在 Future 出现之前，我们的 Rust 代码都是同步的。也就是说：</p>
<ol>
<li>当你执行一个函数，CPU 处理完函数中的每一个指令才会返回。</li>
<li>如果这个函数里有 IO 的操作，实际上，操作系统会把函数对应的线程挂起，放在一个等待队列中</li>
<li>直到 IO 操作完成，才恢复这个线程，并从挂起的位置继续执行下去。</li>
</ol>
<blockquote>
<p>这个模型非常简单直观，代码是一行一行执行的，开发者并不需要考虑哪些操作会阻塞，哪些不会，只关心他的业务逻辑就好。</p>
</blockquote>
<blockquote>
<p>然而，随着 CPU 技术的不断发展，新世纪应用软件的主要矛盾不再是 CPU 算力不足，而是过于充沛的 CPU 算力和提升缓慢的 IO 速度之间的矛盾。如果有大量的 IO 操作，你的程序大部分时间并没有在运算，而是在不断地等待 IO。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use serde_yaml::Value;
use std::fs;

fn main() -&gt; Result&lt;()&gt; {
    // 读取 Cargo.toml，IO 操作 1
    let content1 = fs::read_to_string(&quot;./Cargo.toml&quot;)?;
    // 读取 Cargo.lock，IO 操作 2
    let content2 = fs::read_to_string(&quot;./Cargo.lock&quot;)?;

    // 计算
    let yaml1 = toml2yaml(&amp;content1)?;
    let yaml2 = toml2yaml(&amp;content2)?;

    // 写入 /tmp/Cargo.yml，IO 操作 3
    fs::write(&quot;/tmp/Cargo.yml&quot;, &amp;yaml1)?;
    // 写入 /tmp/Cargo.lock，IO 操作 4
    fs::write(&quot;/tmp/Cargo.lock&quot;, &amp;yaml2)?;

    // 打印
    println!(&quot;{}&quot;, yaml1);
    println!(&quot;{}&quot;, yaml2);

    Ok(())
}

fn toml2yaml(content: &amp;str) -&gt; Result&lt;String&gt; {
    let value: Value = toml::from_str(&amp;content)?;
    Ok(serde_yaml::to_string(&amp;value)?)
}
</code></pre></pre>
<blockquote>
<p>这段代码读取 Cargo.toml 和 Cargo.lock 将其转换成 yaml，再分别写入到 /tmp 下。</p>
</blockquote>
<p>虽然说这段代码的逻辑并没有问题，但性能有很大的问题:</p>
<ol>
<li>在读 Cargo.toml 时，整个主线程被阻塞，直到 Cargo.toml 读完，才能继续读下一个待处理的文件。</li>
<li>整个主线程，只有在运行 toml2yaml 的时间片内，才真正在执行计算任务，之前的读取文件以及之后的写入文件，CPU 都在闲置。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/38%EF%BD%9C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9AFuture%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E5%92%8Casyncawait%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F-4959308.jpg" alt="38｜异步处理：Future是什么？它和asyncawait是什么关系？" /></p>
<p>当然，你会辩解，在读文件的过程中，我们不得不等待，因为 toml2yaml 函数的执行有赖于读取文件的结果。</p>
<p>嗯没错，但是，这里还有很大的 CPU 浪费：我们读完第一个文件才开始读第二个文件，有没有可能两个文件同时读取呢？这样总共等待的时间是 max(time_for_file1, time_for_file2)，而非 time_for_file1 + time_for_file2 。</p>
<p>这并不难，我们可以把文件读取和写入的操作放入单独的线程中执行，比如（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::{anyhow, Result};
use serde_yaml::Value;
use std::{
    fs,
    thread::{self, JoinHandle},
};

/// 包装一下 JoinHandle，这样可以提供额外的方法
struct MyJoinHandle&lt;T&gt;(JoinHandle&lt;Result&lt;T&gt;&gt;);

impl&lt;T&gt; MyJoinHandle&lt;T&gt; {
    /// 等待 thread 执行完（类似 await）
    pub fn thread_await(self) -&gt; Result&lt;T&gt; {
        self.0.join().map_err(|_| anyhow!(&quot;failed&quot;))?
    }
}

fn main() -&gt; Result&lt;()&gt; {
    // 读取 Cargo.toml，IO 操作 1
    let t1 = thread_read(&quot;./Cargo.toml&quot;);
    // 读取 Cargo.lock，IO 操作 2
    let t2 = thread_read(&quot;./Cargo.lock&quot;);

    let content1 = t1.thread_await()?;
    let content2 = t2.thread_await()?;

    // 计算
    let yaml1 = toml2yaml(&amp;content1)?;
    let yaml2 = toml2yaml(&amp;content2)?;

    // 写入 /tmp/Cargo.yml，IO 操作 3
    let t3 = thread_write(&quot;/tmp/Cargo.yml&quot;, yaml1);
    // 写入 /tmp/Cargo.lock，IO 操作 4
    let t4 = thread_write(&quot;/tmp/Cargo.lock&quot;, yaml2);

    let yaml1 = t3.thread_await()?;
    let yaml2 = t4.thread_await()?;

    fs::write(&quot;/tmp/Cargo.yml&quot;, &amp;yaml1)?;
    fs::write(&quot;/tmp/Cargo.lock&quot;, &amp;yaml2)?;

    // 打印
    println!(&quot;{}&quot;, yaml1);
    println!(&quot;{}&quot;, yaml2);

    Ok(())
}

fn thread_read(filename: &amp;'static str) -&gt; MyJoinHandle&lt;String&gt; {
    let handle = thread::spawn(move || {
        let s = fs::read_to_string(filename)?;
        Ok::&lt;_, anyhow::Error&gt;(s)
    });
    MyJoinHandle(handle)
}

fn thread_write(filename: &amp;'static str, content: String) -&gt; MyJoinHandle&lt;String&gt; {
    let handle = thread::spawn(move || {
        fs::write(filename, &amp;content)?;
        Ok::&lt;_, anyhow::Error&gt;(content)
    });
    MyJoinHandle(handle)
}

fn toml2yaml(content: &amp;str) -&gt; Result&lt;String&gt; {
    let value: Value = toml::from_str(&amp;content)?;
    Ok(serde_yaml::to_string(&amp;value)?)
}
</code></pre></pre>
<blockquote>
<p>这样，读取或者写入多个文件的过程并发执行，使等待的时间大大缩短。</p>
</blockquote>
<ol>
<li>但是，如果要同时读取 100 个文件呢？</li>
</ol>
<ul>
<li>显然，创建 100 个线程来做这样的事情不是一个好主意。</li>
<li>在操作系统中，线程的数量是有限的，创建 / 阻塞 / 唤醒 / 销毁线程，都涉及不少的动作</li>
<li>每个线程也都会被分配一个不小的调用栈</li>
<li>所以从 CPU 和内存的角度来看，创建过多的线程会大大增加系统的开销。</li>
</ul>
<ol start="2">
<li>其实，绝大多数操作系统对 I/O 操作提供了非阻塞接口，也就是说: </li>
</ol>
<ul>
<li>你可以发起一个读取的指令</li>
<li>自己处理类似 EWOULDBLOCK这样的错误码</li>
<li>来更好地在同一个线程中处理多个文件的 IO</li>
<li>而不是依赖操作系统通过调度帮你完成这件事。</li>
</ul>
<ol start="3">
<li>不过这样就意味着，你需要:</li>
</ol>
<ul>
<li>定义合适的数据结构来追踪每个文件的读取</li>
<li>在用户态进行相应的调度</li>
<li>阻塞等待 IO 的数据结构的运行</li>
<li>让没有等待 IO 的数据结构得到机会使用 CPU</li>
<li>以及当 IO 操作结束后，恢复等待 IO 的数据结构的运行等等。</li>
</ul>
<blockquote>
<p>这样的操作粒度更小，可以最大程度利用 CPU 资源。
这就是类似 Future 这样的并发结构的主要用途。</p>
</blockquote>
<ol start="4">
<li>然而，如果这么处理，我们需要在用户态做很多事情,包括:</li>
</ol>
<ul>
<li>处理 IO 任务的事件通知</li>
<li>创建 Future</li>
<li>合理地调度 Future</li>
</ul>
<blockquote>
<p>这些事情，统统交给开发者做显然是不合理的。所以，Rust 提供了相应处理手段 async/await ：</p>
</blockquote>
<ul>
<li>async 来方便地生成 Future</li>
<li>await 来触发 Future 的调度和执行。</li>
</ul>
<hr />
<p>我们看看，同样的任务，如何用 async/await 更高效地处理（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use serde_yaml::Value;
use tokio::{fs, try_join};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // 读取 Cargo.toml，IO 操作 1
    let f1 = fs::read_to_string(&quot;./Cargo.toml&quot;);
    // 读取 Cargo.lock，IO 操作 2
    let f2 = fs::read_to_string(&quot;./Cargo.lock&quot;);
    let (content1, content2) = try_join!(f1, f2)?;

    // 计算
    let yaml1 = toml2yaml(&amp;content1)?;
    let yaml2 = toml2yaml(&amp;content2)?;

    // 写入 /tmp/Cargo.yml，IO 操作 3
    let f3 = fs::write(&quot;/tmp/Cargo.yml&quot;, &amp;yaml1);
    // 写入 /tmp/Cargo.lock，IO 操作 4
    let f4 = fs::write(&quot;/tmp/Cargo.lock&quot;, &amp;yaml2);
    try_join!(f3, f4)?;

    // 打印
    println!(&quot;{}&quot;, yaml1);
    println!(&quot;{}&quot;, yaml2);

    Ok(())
}

fn toml2yaml(content: &amp;str) -&gt; Result&lt;String&gt; {
    let value: Value = toml::from_str(&amp;content)?;
    Ok(serde_yaml::to_string(&amp;value)?)
}
</code></pre></pre>
<p>在这段代码里:</p>
<ol>
<li>我们使用了 tokio::fs，而不是 std::fs</li>
<li>tokio::fs 的文件操作都会返回一个 Future，然后可以 join 这些 Future，得到它们运行后的结果。</li>
<li>join / try_join 是用来轮询多个 Future 的宏:</li>
</ol>
<ul>
<li>它会依次处理每个 Future</li>
<li>遇到阻塞就处理下一个</li>
<li>直到所有 Future 产生结果。</li>
</ul>
<blockquote>
<p>整个等待文件读取的时间是 max(time_for_file1, time_for_file2)，性能和使用线程的版本几乎一致，但是消耗的资源（主要是线程）要少很多。</p>
</blockquote>
<p>建议你好好对比这三个版本的代码，写一写，运行一下，感受它们的处理逻辑。</p>
<p>注意在最后的 async/await 的版本中，我们不能把代码写成这样：</p>
<pre><pre class="playground"><code class="language-rust  editable">
// 读取 Cargo.toml，IO 操作 1
let content1 = fs::read_to_string(&quot;./Cargo.toml&quot;).await?;
// 读取 Cargo.lock，IO 操作 2
let content1 = fs::read_to_string(&quot;./Cargo.lock&quot;).await?;
</code></pre></pre>
<p>这样写的话，和第一版同步的版本没有区别，因为 await 会运行 Future 直到 Future 执行结束，所以依旧是先读取 Cargo.toml，再读取 Cargo.lock，并没有达到并发的效果。</p>
</div>
</details>
<h2 id="深入思路"><a class="header" href="#深入思路">深入思路</a></h2>
<details id="admonition-从async-fn了解到future的思路" class="admonition info">
<summary class="admonition-title">
<p>从async fn了解到future的思路</p>
<p><a class="admonition-anchor-link" href="5_2_future_async_await.html#admonition-从async-fn了解到future的思路"></a></p>
</summary>
<div>
<ol>
<li>拆解 async fn 有点奇怪的返回值结构</li>
<li>我们学习了 Reactor pattern</li>
<li>大致了解了 tokio 如何通过 executor 和 reactor 共同作用，完成 Future 的调度、执行、阻塞，以及唤醒。这是一个完整的循环，直到 Future 返回 Poll::Ready(T)。</li>
</ol>
</div>
</details>
<h2 id="深入了解"><a class="header" href="#深入了解">深入了解</a></h2>
<p>好，了解了 Future 在软件开发中的必要性，来深入研究一下 Future/async/await。</p>
<details id="admonition-异步函数async-fn其实是语法糖它有等价函数写法" class="admonition info">
<summary class="admonition-title">
<p>异步函数（async fn）其实是语法糖，它有等价函数写法。</p>
<p><a class="admonition-anchor-link" href="5_2_future_async_await.html#admonition-异步函数async-fn其实是语法糖它有等价函数写法"></a></p>
</summary>
<div>
<p>在前面代码撰写过程中，不知道你有没有发现，异步函数（async fn）的返回值是一个奇怪的 impl Future<Output> 的结构：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/38%EF%BD%9C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9AFuture%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E5%92%8Casyncawait%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F.png" alt="38｜异步处理：Future是什么？它和asyncawait是什么关系？" /></p>
<blockquote>
<p>我们知道，一般会用 impl 关键字为数据结构实现 trait，也就是说接在 impl 关键字后面的东西是一个 trait，所以，显然 Future 是一个 trait，并且还有一个关联类型 Output。</p>
</blockquote>
<p>来看 <a href="https://doc.rust-lang.org/std/future/trait.Future.html">Future 的定义</a>：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
</code></pre></pre>
<ol>
<li>除了 Output 外，它还有一个 poll() 方法，这个方法返回 <a href="https://doc.rust-lang.org/std/future/trait.Future.html">PollSelf::Output</a>。</li>
<li>而 Poll<T> 是个 enum，包含 Ready 和 Pending 两个状态。</li>
<li>显然，当 Future 返回 Pending 状态时，活还没干完，但干不下去了，需要阻塞一阵子，等某个事件将其唤醒；</li>
<li>当 Future 返回 Ready 状态时，Future 对应的值已经得到，此时可以返回了。</li>
</ol>
<blockquote>
<p>你看，这样一个简单的数据结构，就托起了庞大的 Rust 异步 async/await 处理的生态。</p>
</blockquote>
<p>回到 async fn 的返回值我们接着说，显然它是一个 impl Future.</p>
<blockquote>
<p>那么如果我们给一个普通的函数返回 impl Future<Output>，它的行为和 async fn 是不是一致呢？</p>
</blockquote>
<p>来写个简单的实验（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use futures::executor::block_on;
use std::future::Future;

#[tokio::main]
async fn main() {
    let name1 = &quot;Tyr&quot;.to_string();
    let name2 = &quot;Lindsey&quot;.to_string();

    say_hello1(&amp;name1).await;
    say_hello2(&amp;name2).await;

    // Future 除了可以用 await 来执行外，还可以直接用 executor 执行
    block_on(say_hello1(&amp;name1));
    block_on(say_hello2(&amp;name2));
}

async fn say_hello1(name: &amp;str) -&gt; usize {
    println!(&quot;Hello {}&quot;, name);
    42
}

// async fn 关键字相当于一个返回 impl Future&lt;Output&gt; 的语法糖
fn say_hello2&lt;'fut&gt;(name: &amp;'fut str) -&gt; impl Future&lt;Output = usize&gt; + 'fut {
    async move {
        println!(&quot;Hello {}&quot;, name);
        42
    }
}
</code></pre></pre>
<blockquote>
<p>运行这段代码你会发现，say_hello1 和 say_hello2 是等价的，二者都可以使用 await 来执行，也可以将其提供给一个 executor 来执行。</p>
</blockquote>
</div>
</details>
<h2 id="executor"><a class="header" href="#executor">executor</a></h2>
<details id="admonition-executor是什么--rust如何支持-rust常用的executor有哪些" class="admonition info">
<summary class="admonition-title">
<p>executor是什么-&gt; Rust如何支持-&gt;Rust常用的executor有哪些？</p>
<p><a class="admonition-anchor-link" href="5_2_future_async_await.html#admonition-executor是什么--rust如何支持-rust常用的executor有哪些"></a></p>
</summary>
<div>
<p>这里我们见到了一个新的名词：executor。</p>
<p>什么是 executor？</p>
<ol>
<li>你可以把 executor 大致想象成一个 Future 的调度器。</li>
<li>对于线程来说，操作系统负责调度；</li>
<li>但操作系统不会去调度用户态的协程（比如 Future），所以任何使用了协程来处理并发的程序，都需要有一个 executor 来负责协程的调度。</li>
</ol>
<p>很多在语言层面支持协程的编程语言，比如 Golang / Erlang，都自带一个用户态的调度器。</p>
<p>Rust 虽然也提供 Future 这样的协程，但它在语言层面并不提供 executor，把要不要使用 executor 和使用什么样的 executor 的自主权交给了开发者。</p>
<ul>
<li>好处是，当我的代码中不需要使用协程时，不需要引入任何运行时；</li>
<li>而需要使用协程时，可以在生态系统中选择最合适我应用的 executor。</li>
</ul>
<hr />
<p>常见的 executor 有：</p>
<ol>
<li>futures 库自带的很简单的 executor，上面的代码就使用了它的 block_on 函数；</li>
<li>tokio 提供的 executor，当使用 #[tokio::main] 时，就隐含引入了 tokio 的 executor；</li>
<li><a href="https://github.com/async-rs/async-std">async-std</a> 提供的 executor，和 tokio 类似；</li>
<li><a href="https://github.com/smol-rs/smol">smol 提供的 async-executor</a>，主要提供了 block_on。</li>
</ol>
<p>注意，上面的代码我们混用了 #[tokio::main] 和 futures:executor::block_on，这只是为了展示 Future 使用的不同方式，在正式代码里，不建议混用不同的 executor，会降低程序的性能，还可能引发奇怪的问题。</p>
</div>
</details>
<h2 id="reactor-pattern"><a class="header" href="#reactor-pattern">reactor pattern</a></h2>
<details id="admonition-reactor-pattern如何组成" class="admonition info">
<summary class="admonition-title">
<p>Reactor Pattern如何组成？</p>
<p><a class="admonition-anchor-link" href="5_2_future_async_await.html#admonition-reactor-pattern如何组成"></a></p>
</summary>
<div>
<p>当我们谈到 executor 时，就不得不提 reactor，它俩都是 Reactor Pattern 的组成部分，作为构建高性能事件驱动系统的一个很典型模式，Reactor pattern 它包含三部分：</p>
<ol>
<li>task，待处理的任务</li>
</ol>
<p>任务可以被打断，并且把控制权交给 executor，等待之后的调度；</p>
<ol start="2">
<li>executor，一个调度器。</li>
</ol>
<p>维护等待运行的任务（ready queue），以及被阻塞的任务（wait queue）；</p>
<ol start="3">
<li>reactor，维护事件队列。</li>
</ol>
<p>当事件来临时，通知 executor 唤醒某个任务等待运行。</p>
<ul>
<li>executor 会调度执行待处理的任务，当任务无法继续进行却又没有完成时，它会挂起任务，并设置好合适的唤醒条件。</li>
<li>之后，如果 reactor 得到了满足条件的事件，它会唤醒之前挂起的任务，然后 executor 就有机会继续执行这个任务。</li>
<li>这样一直循环下去，直到任务执行完毕。</li>
</ul>
</div>
</details>
<h2 id="怎么用-future-做异步处理"><a class="header" href="#怎么用-future-做异步处理">怎么用 Future 做异步处理？</a></h2>
<details id="admonition-rust如何基于reactor-pattern使用future做异步处理" class="admonition info">
<summary class="admonition-title">
<p>Rust如何基于Reactor pattern使用Future做异步处理</p>
<p><a class="admonition-anchor-link" href="5_2_future_async_await.html#admonition-rust如何基于reactor-pattern使用future做异步处理"></a></p>
</summary>
<div>
<p>理解了 Reactor pattern 后，Rust 使用 Future 做异步处理的整个结构就清晰了，我们以 tokio 为例：</p>
<ol>
<li>async/await 提供语法层面的支持</li>
<li>Future 是异步任务的数据结构</li>
<li>当 fut.await 时，executor 就会调度并执行它。</li>
</ol>
<hr />
<ul>
<li>tokio 的调度器（executor）会运行在多个线程上，运行线程自己的 ready queue 上的任务（Future）</li>
<li>如果没有，就去别的线程的调度器上“偷”一些过来运行。</li>
<li>当某个任务无法再继续取得进展，此时 Future 运行的结果是 Poll::Pending，那么调度器会挂起任务，并设置好合适的唤醒条件（Waker），等待被 reactor 唤醒。</li>
<li>而 reactor 会利用操作系统提供的异步 I/O，比如 epoll / kqueue / IOCP，来监听操作系统提供的 IO 事件，当遇到满足条件的事件时，就会调用 Waker.wake() 唤醒被挂起的 Future。这个 Future 会回到 ready queue 等待执行。</li>
</ul>
<hr />
<p>整个流程如下：</p>
<h2 id="-13"><a class="header" href="#-13"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/38%EF%BD%9C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9AFuture%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E5%92%8Casyncawait%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F.jpg" alt="38｜异步处理：Future是什么？它和asyncawait是什么关系？" /></a></h2>
<p>我们以一个具体的代码示例来进一步理解这个过程（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use futures::{SinkExt, StreamExt};
use tokio::net::TcpListener;
use tokio_util::codec::{Framed, LinesCodec};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let addr = &quot;0.0.0.0:8080&quot;;
    let listener = TcpListener::bind(addr).await?;
    println!(&quot;listen to: {}&quot;, addr);
    loop {
        let (stream, addr) = listener.accept().await?;
        println!(&quot;Accepted: {:?}&quot;, addr);
        tokio::spawn(async move {
            // 使用 LinesCodec 把 TCP 数据切成一行行字符串处理
            let framed = Framed::new(stream, LinesCodec::new());
            // split 成 writer 和 reader
            let (mut w, mut r) = framed.split();
            for line in r.next().await {
                // 每读到一行就加个前缀发回
                w.send(format!(&quot;I got: {}&quot;, line?)).await?;
            }
            Ok::&lt;_, anyhow::Error&gt;(())
        });
    }
}
</code></pre></pre>
<p>这是一个简单的 TCP 服务器:</p>
<ol>
<li>服务器每收到一个客户端的请求，就会用<a href="https://docs.rs/tokio/1.13.0/tokio/fn.spawn.html"> tokio::spawn </a>创建一个异步任务，放入 executor 中执行。</li>
<li>这个异步任务接受客户端发来的按行分隔（分隔符是 “\r\n”）的数据帧，服务器每收到一行，就加个前缀把内容也按行发回给客户端。</li>
<li>你可以用 telnet 和这个服务器交互：</li>
</ol>
<pre><code class="language-shell">❯ telnet localhost 8080
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
hello
I got: hello
Connection closed by foreign host.
</code></pre>
<ul>
<li>假设我们在客户端输入了很大的一行数据，服务器在做 r.next().await 在执行的时候，收不完一行的数据，因而这个 Future 返回 Poll::Pending，此时它被挂起。</li>
<li>当后续客户端的数据到达时，reactor 会知道这个 socket 上又有数据了，于是找到 socket 对应的 Future，将其唤醒，继续接收数据。</li>
<li>这样反复下去，最终 r.next().await 得到 Poll::Ready(Ok(line))，于是它返回 Ok(line)，程序继续往下走，进入到 w.send() 的阶段。</li>
</ul>
<blockquote>
<p>从这段代码中你可以看到，在 Rust 下使用异步处理是一件非常简单的事情</p>
</blockquote>
<ol>
<li>除了几个你可能不太熟悉的概念:</li>
</ol>
<ul>
<li>比如用于创建 Future 的 async 关键字</li>
<li>用于执行和等待 Future 执行完毕的 await 关键字</li>
<li>以及用于调度 Future 执行的运行时 #[tokio:main] </li>
</ul>
<ol start="2">
<li>整体的代码和使用线程处理的代码完全一致。所以，它的上手难度非常低，很容易使用。</li>
</ol>
</div>
</details>
<h2 id="使用-future-的注意事项"><a class="header" href="#使用-future-的注意事项">使用 Future 的注意事项</a></h2>
<details id="admonition-使用future处理异步任务的三个注意事项" class="admonition info">
<summary class="admonition-title">
<p>使用Future处理异步任务的三个注意事项</p>
<p><a class="admonition-anchor-link" href="5_2_future_async_await.html#admonition-使用future处理异步任务的三个注意事项"></a></p>
</summary>
<div>
<p>目前我们已经基本明白 Future 运行的基本原理了，也可以在程序的不同部分自如地使用 Future/async/await 来进行异步处理。</p>
<p>但是要注意，不是所有的应用场景都适合用 async/await，在使用的时候，有一些不容易注意到的坑需要我们妥善考虑。</p>
<ol>
<li>处理计算密集型任务时</li>
</ol>
<p>当你要处理的任务是 CPU 密集型，而非 IO 密集型，更适合使用线程，而非 Future。</p>
<p>这是因为 Future 的调度是协作式多任务（Cooperative Multitasking），也就是说，除非 Future 主动放弃 CPU，不然它就会一直被执行，直到运行结束。我们看一个例子（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use std::time::Duration;

// 强制 tokio 只使用一个工作线程，这样 task 2 不会跑到其它线程执行
#[tokio::main(worker_threads = 1)]
async fn main() -&gt; Result&lt;()&gt; {
    // 先开始执行 task 1 的话会阻塞，让 task 2 没有机会运行
    tokio::spawn(async move {
        eprintln!(&quot;task 1&quot;);
        // 试试把这句注释掉看看会产生什么结果
        // tokio::time::sleep(Duration::from_millis(1)).await;
        loop {}
    });

    tokio::spawn(async move {
        eprintln!(&quot;task 2&quot;);
    });

    tokio::time::sleep(Duration::from_millis(1)).await;
    Ok(())
}
</code></pre></pre>
<p>task 1 里有一个死循环，你可以把它想象成是执行时间很长又不包括 IO 处理的代码。运行这段代码，你会发现，task 2 没有机会得到执行。这是因为 task 1 不执行结束，或者不让出 CPU，task 2 没有机会被调度。</p>
<ol start="2">
<li>异步代码中使用 Mutex 时</li>
</ol>
<p>大部分时候，标准库的 Mutex 可以用在异步代码中，而且，这是推荐的用法。</p>
<p>然而，标准库的 MutexGuard 不能安全地跨越 await，所以，当我们需要获得锁之后执行异步操作，必须使用 tokio 自带的 Mutex，看下面的例子（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use std::{sync::Arc, time::Duration};
use tokio::sync::Mutex;

struct DB;

impl DB {
    // 假装在 commit 数据
    async fn commit(&amp;mut self) -&gt; Result&lt;usize&gt; {
        Ok(42)
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let db1 = Arc::new(Mutex::new(DB));
    let db2 = Arc::clone(&amp;db1);

    tokio::spawn(async move {
        let mut db = db1.lock().await;
        // 因为拿到的 MutexGuard 要跨越 await，所以不能用 std::sync::Mutex
        // 只能用 tokio::sync::Mutex
        let affected = db.commit().await?;
        println!(&quot;db1: Total affected rows: {}&quot;, affected);
        Ok::&lt;_, anyhow::Error&gt;(())
    });

    tokio::spawn(async move {
        let mut db = db2.lock().await;
        let affected = db.commit().await?;
        println!(&quot;db2: Total affected rows: {}&quot;, affected);

        Ok::&lt;_, anyhow::Error&gt;(())
    });

    // 让两个 task 有机会执行完
    tokio::time::sleep(Duration::from_millis(1)).await;

    Ok(())
}
</code></pre></pre>
<blockquote>
<p>这个例子模拟了一个数据库的异步 commit() 操作</p>
</blockquote>
<ul>
<li>如果我们需要在多个 tokio task 中使用这个 DB，需要使用 Arc&lt;Mutext<DB>&gt;。</li>
<li>然而，db1.lock() 拿到锁后，我们需要运行 db.commit().await，这是一个异步操作。</li>
<li>前面讲过，因为 tokio 实现了 work-stealing 调度，Future 有可能在不同的线程中执行，普通的 MutexGuard 编译直接就会出错，所以需要使用 tokio 的 Mutex。<a href="https://docs.rs/tokio/1.13.0/tokio/sync/struct.Mutex.html">更多信息可以看文档</a>。</li>
</ul>
<blockquote>
<p>在这个例子里，我们又见识到了 Rust 编译器的伟大之处：如果一件事，它觉得你不能做，会通过编译器错误阻止你，而不是任由编译通过，然后让程序在运行过程中听天由命，让你无休止地和捉摸不定的并发 bug 斗争。</p>
</blockquote>
<ol start="3">
<li>在线程和异步任务间做同步时</li>
</ol>
<p>在一个复杂的应用程序中，会兼有计算密集和 IO 密集的任务。</p>
<p>前面说了，要避免在 tokio 这样的异步运行时中运行大量计算密集型的任务，一来效率不高，二来还容易饿死其它任务。</p>
<p>所以，一般的做法是我们使用 channel 来在线程和 future 两者之间做同步。看一个例子：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::thread;

use anyhow::Result;
use blake3::Hasher;
use futures::{SinkExt, StreamExt};
use rayon::prelude::*;
use tokio::{
    net::TcpListener,
    sync::{mpsc, oneshot},
};
use tokio_util::codec::{Framed, LinesCodec};

pub const PREFIX_ZERO: &amp;[u8] = &amp;[0, 0, 0];

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let addr = &quot;0.0.0.0:8080&quot;;
    let listener = TcpListener::bind(addr).await?;
    println!(&quot;listen to: {}&quot;, addr);

    // 创建 tokio task 和 thread 之间的 channel
    let (sender, mut receiver) = mpsc::unbounded_channel::&lt;(String, oneshot::Sender&lt;String&gt;)&gt;();

    // 使用 thread 处理计算密集型任务
    thread::spawn(move || {
        // 读取从 tokio task 过来的 msg，注意这里用的是 blocking_recv，而非 await
        while let Some((line, reply)) = receiver.blocking_recv() {
            // 计算 pow
            let result = match pow(&amp;line) {
                Some((hash, nonce)) =&gt; format!(&quot;hash: {}, once: {}&quot;, hash, nonce),
                None =&gt; &quot;Not found&quot;.to_string(),
            };
            // 把计算结果从 oneshot channel 里发回
            if let Err(e) = reply.send(result) {
                println!(&quot;Failed to send: {}&quot;, e);
            }
        }
    });

    // 使用 tokio task 处理 IO 密集型任务
    loop {
        let (stream, addr) = listener.accept().await?;
        println!(&quot;Accepted: {:?}&quot;, addr);
        let sender1 = sender.clone();
        tokio::spawn(async move {
            // 使用 LinesCodec 把 TCP 数据切成一行行字符串处理
            let framed = Framed::new(stream, LinesCodec::new());
            // split 成 writer 和 reader
            let (mut w, mut r) = framed.split();
            for line in r.next().await {
                // 为每个消息创建一个 oneshot channel，用于发送回复
                let (reply, reply_receiver) = oneshot::channel();
                sender1.send((line?, reply))?;

                // 接收 pow 计算完成后的 hash 和 nonce
                if let Ok(v) = reply_receiver.await {
                    w.send(format!(&quot;Pow calculated: {}&quot;, v)).await?;
                }
            }
            Ok::&lt;_, anyhow::Error&gt;(())
        });
    }
}

// 使用 rayon 并发计算 u32 空间下所有 nonce，直到找到有头 N 个 0 的哈希
pub fn pow(s: &amp;str) -&gt; Option&lt;(String, u32)&gt; {
    let hasher = blake3_base_hash(s.as_bytes());
    let nonce = (0..u32::MAX).into_par_iter().find_any(|n| {
        let hash = blake3_hash(hasher.clone(), n).as_bytes().to_vec();
        &amp;hash[..PREFIX_ZERO.len()] == PREFIX_ZERO
    });
    nonce.map(|n| {
        let hash = blake3_hash(hasher, &amp;n).to_hex().to_string();
        (hash, n)
    })
}

// 计算携带 nonce 后的哈希
fn blake3_hash(mut hasher: blake3::Hasher, nonce: &amp;u32) -&gt; blake3::Hash {
    hasher.update(&amp;nonce.to_be_bytes()[..]);
    hasher.finalize()
}

// 计算数据的哈希
fn blake3_base_hash(data: &amp;[u8]) -&gt; Hasher {
    let mut hasher = Hasher::new();
    hasher.update(data);
    hasher
}
</code></pre></pre>
<p>在这个例子里:</p>
<ol>
<li>我们使用了之前撰写的 TCP server</li>
<li>只不过这次，客户端输入过来的一行文字，会被计算出一个 POW（Proof of Work）的哈希</li>
<li>调整 nonce，不断计算哈希，直到哈希的头三个字节全是零为止。</li>
<li>服务器要返回计算好的哈希和获得该哈希的 nonce。</li>
<li>这是一个典型的计算密集型任务，所以我们需要使用线程来处理它。</li>
<li>而在 tokio task 和 thread 间使用 channel 进行同步。我们使用了一个 ubounded MPSC channel 从 tokio task 侧往 thread 侧发送消息，每条消息都附带一个 oneshot channel 用于 thread 侧往 tokio task 侧发送数据。</li>
</ol>
<blockquote>
<p>建议你仔细读读这段代码，最好自己写一遍，感受一下使用 channel 在计算密集型和 IO 密集型任务同步的方式。</p>
</blockquote>
<p>如果你用 telnet 连接，发送 “hello world!”，会得到不同的哈希和 nonce，它们都是正确的结果：</p>
<pre><code class="language-shell">
❯ telnet localhost 8080
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
hello world!
Pow calculated: hash: 0000006e6e9370d0f60f06bdc288efafa203fd99b9af0480d040b2cc89c44df0, once: 403407307
Connection closed by foreign host.

❯ telnet localhost 8080
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
hello world!
Pow calculated: hash: 000000e23f0e9b7aeba9060a17ac676f3341284800a2db843e2f0e85f77f52dd, once: 36169623
Connection closed by foreign host.

</code></pre>
</div>
</details>
<h2 id="对比线程学习future"><a class="header" href="#对比线程学习future">对比线程学习Future</a></h2>
<details id="admonition-对比线程来学习future" class="admonition info">
<summary class="admonition-title">
<p>对比线程来学习future</p>
<p><a class="admonition-anchor-link" href="5_2_future_async_await.html#admonition-对比线程来学习future"></a></p>
</summary>
<div>
<p>在学习 Future 的使用时，估计你也发现了，我们可以对比线程来学习，可以看到，下列代码的结构多么相似：</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn thread_async() -&gt; JoinHandle&lt;usize&gt; {
    thread::spawn(move || {
        println!(&quot;hello thread!&quot;);
        42
    })
}

fn task_async() -&gt; impl Future&lt;Output = usize&gt; {
    async move {
        println!(&quot;hello async!&quot;);
        42
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="为什么标准库的-mutex-不能跨越-await"><a class="header" href="#为什么标准库的-mutex-不能跨越-await">为什么标准库的 Mutex 不能跨越 await？</a></h2>
<p>想想看，为什么标准库的 Mutex 不能跨越 await？</p>
<p>你可以把文中使用 tokio::sync::Mutex 的代码改成使用 std::sync::Mutex，并对使用的接口做相应的改动（把 lock().await 改成 lock().unwrap()），看看编译器会报什么错。</p>
<p>对着错误提示，你明白为什么了么？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait内部是怎么实现的"><a class="header" href="#asyncawait内部是怎么实现的">async/await内部是怎么实现的？</a></h1>
<!--ts-->
<ul>
<li><a href="5_3_deepin_async_await.html#asyncawait%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">async/await内部是怎么实现的？</a>
<ul>
<li><a href="5_3_deepin_async_await.html#contextpin">Context、Pin</a></li>
<li><a href="5_3_deepin_async_await.html#contextwaker-waker-%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6">Context::waker: Waker 的调用机制</a></li>
<li><a href="5_3_deepin_async_await.html#async-%E7%A9%B6%E7%AB%9F%E7%94%9F%E6%88%90%E4%BA%86%E4%BB%80%E4%B9%88">async 究竟生成了什么？</a></li>
<li><a href="5_3_deepin_async_await.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-pin">为什么需要 Pin？</a></li>
<li><a href="5_3_deepin_async_await.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">自引用数据结构</a></li>
<li><a href="5_3_deepin_async_await.html#unpin">Unpin</a></li>
<li><a href="5_3_deepin_async_await.html#boxt%E7%9A%84unpin%E6%80%9D%E8%80%83">Box&lt;T&gt;的Unpin思考</a></li>
<li><a href="5_3_deepin_async_await.html#async-%E4%BA%A7%E7%94%9F%E7%9A%84-future-%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B">async 产生的 Future 究竟是什么类型？</a></li>
<li><a href="5_3_deepin_async_await.html#%E5%9B%9E%E9%A1%BE%E6%95%B4%E7%90%86future%E7%9A%84contextpinunpin%E4%BB%A5%E5%8F%8Aasyncawait">回顾整理Future的Context、Pin/Unpin，以及async/await</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:24 UTC 2022 -->
<!--te-->
<details id="admonition-对-future-和-asyncawait-的基本概念有一个比较扎实的理解" class="admonition info">
<summary class="admonition-title">
<p>对 Future 和 async/await 的基本概念有一个比较扎实的理解</p>
<p><a class="admonition-anchor-link" href="5_3_deepin_async_await.html#admonition-对-future-和-asyncawait-的基本概念有一个比较扎实的理解"></a></p>
</summary>
<div>
<p>对 Future 和 async/await 的基本概念有一个比较扎实的理解:</p>
<ol>
<li>知道在什么情况下该使用 Future</li>
<li>什么情况下该使用 Thread</li>
<li>executor 和 reactor 是怎么联动最终让 Future 得到了一个结果。</li>
</ol>
</div>
</details>
<p>然而，我们并不清楚为什么 async fn 或者 async block 就能够产生 Future，也并不明白 Future 是怎么被 executor 处理的。继续深入下去，看看 async/await
这两个关键词究竟施了什么样的魔法，能够让一切如此简单又如此自然地运转起来。</p>
<h2 id="contextpin"><a class="header" href="#contextpin">Context、Pin</a></h2>
<details id="admonition-从future定义中的pin和context开始" class="admonition info">
<summary class="admonition-title">
<p>从Future定义中的Pin和Context开始</p>
<p><a class="admonition-anchor-link" href="5_3_deepin_async_await.html#admonition-从future定义中的pin和context开始"></a></p>
</summary>
<div>
<p>提前说明一下，我们会继续围绕着 Future 这个简约却又并不简单的接口，来探讨一些原理性的东西，主要是 Context 和 Pin 这两个结构：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
</code></pre></pre>
</div>
</details>
<h2 id="contextwaker-waker-的调用机制"><a class="header" href="#contextwaker-waker-的调用机制">Context::waker: Waker 的调用机制</a></h2>
<details id="admonition-context-就是-waker-的一个封装" class="admonition info">
<summary class="admonition-title">
<p>Context 就是 Waker 的一个封装</p>
<p><a class="admonition-anchor-link" href="5_3_deepin_async_await.html#admonition-context-就是-waker-的一个封装"></a></p>
</summary>
<div>
<p>先来看这个接口的 Context 是个什么东西。</p>
<ol>
<li>executor 通过调用 poll 方法来让 Future 继续往下执行</li>
<li>如果 poll 方法返回 Poll::Pending，就阻塞 Future</li>
<li>直到 reactor 收到了某个事件，然后调用 Waker.wake() 把 Future 唤醒。</li>
<li>这个 Waker 是哪来的呢？</li>
</ol>
<p>其实，它隐含在 Context 中：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct Context&lt;'a&gt; {
    waker: &amp;'a Waker,
    _marker: PhantomData&lt;fn(&amp;'a ()) -&gt; &amp;'a ()&gt;,
}
</code></pre></pre>
<p>所以，Context 就是 Waker 的一个封装。</p>
<p>如果你去看 Waker 的定义和相关的代码，会发现它非常抽象，内部使用了一个 vtable 来允许各种各样的 waker 的行为：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct RawWakerVTable {
    clone: unsafe fn(*const ()) -&gt; RawWaker,
    wake: unsafe fn(*const ()),
    wake_by_ref: unsafe fn(*const ()),
    drop: unsafe fn(*const ()),
}
</code></pre></pre>
<ol>
<li>这种手工生成 vtable 的做法，可以最大程度兼顾效率和灵活性。</li>
<li>Rust 自身并不提供异步运行时，它只在标准库里规定了一些基本的接口，至于怎么实现，可以由各个运行时（如 tokio）自行决定。</li>
<li>所以在标准库中，你只会看到这些接口的定义，以及“高层”接口的实现，比如 Waker 下的 wake 方法，只是调用了 vtable 里的 wake() 而已：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
impl Waker {
    /// Wake up the task associated with this `Waker`.
    #[inline]
    pub fn wake(self) {
        // The actual wakeup call is delegated through a virtual function call
        // to the implementation which is defined by the executor.
        let wake = self.waker.vtable.wake;
        let data = self.waker.data;

        // Don't call `drop` -- the waker will be consumed by `wake`.
        crate::mem::forget(self);

        // SAFETY: This is safe because `Waker::from_raw` is the only way
        // to initialize `wake` and `data` requiring the user to acknowledge
        // that the contract of `RawWaker` is upheld.
        unsafe { (wake)(data) };
    }
    ...
}
</code></pre></pre>
<blockquote>
<p>如果你想顺藤摸瓜找到 vtable 是怎么设置的，却发现一切线索都悄无声息地中断了，那是因为，具体的实现并不在标准库中，而是在第三方的异步运行时里，比如 tokio。</p>
</blockquote>
</div>
</details>
<p>不过，虽然我们开发时会使用 tokio，但阅读、理解代码时，我建议看 futures 库，比如 waker vtable 的定义。futures 库还有一个简单的 executor，也非常适合进一步通过代码理解 executor 的原理。</p>
<h2 id="async-究竟生成了什么"><a class="header" href="#async-究竟生成了什么">async 究竟生成了什么？</a></h2>
<p>我们接下来看 Pin。这是一个奇怪的数据结构，正常数据结构的方法都是直接使用 self / &amp;self / &amp;mut self，可是 poll() 却使用了 Pin&lt;&amp;mut self&gt;，为什么？</p>
<details id="admonition-rust-在编译-async-fn-或者-async-block-时就会生成类似的状态机的实现" class="admonition info">
<summary class="admonition-title">
<p>Rust 在编译 async fn 或者 async block 时，就会生成类似的状态机的实现</p>
<p><a class="admonition-anchor-link" href="5_3_deepin_async_await.html#admonition-rust-在编译-async-fn-或者-async-block-时就会生成类似的状态机的实现"></a></p>
</summary>
<div>
<p>为了讲明白 Pin，我们得往前追踪一步，看看产生 Future 的一个 async block/fn 内部究竟生成了什么样的代码？来看下面这个简单的 async 函数：</p>
<pre><pre class="playground"><code class="language-rust  editable">
async fn write_hello_file_async(name: &amp;str) -&gt; anyhow::Result&lt;()&gt; {
    let mut file = fs::File::create(name).await?;
    file.write_all(b&quot;hello world!&quot;).await?;

    Ok(())
}
</code></pre></pre>
<ol>
<li>首先它创建一个文件，然后往这个文件里写入 “hello world!”。</li>
<li>这个函数有两个 await，创建文件的时候会异步创建，写入文件的时候会异步写入。</li>
<li>最终，整个函数对外返回一个 Future。</li>
</ol>
<blockquote>
<p>其它人可以这样调用：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
write_hello_file_async(&quot;/tmp/hello&quot;).await?;
</code></pre></pre>
<p>我们知道，executor 处理 Future 时，会不断地调用它的 poll() 方法，于是，上面那句实际上相当于：</p>
<pre><pre class="playground"><code class="language-rust  editable">
match write_hello_file_async.poll(cx) {
    Poll::Ready(result) =&gt; return result,
    Poll::Pending =&gt; return Poll::Pending
}
</code></pre></pre>
<p>这是单个 await 的处理方法，那更加复杂的，一个函数中有若干个 await，该怎么处理呢？</p>
<p>以前面write_hello_file_async 函数的内部实现为例，显然，我们只有在处理完 create()，才能处理 write_all()，所以，应该是类似这样的代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">
let fut = fs::File::create(name);
match fut.poll(cx) {
    Poll::Ready(Ok(file)) =&gt; {
        let fut = file.write_all(b&quot;hello world!&quot;);
        match fut.poll(cx) {
            Poll::Ready(result) =&gt; return result,
            Poll::Pending =&gt; return Poll::Pending,
        }
    }
    Poll::Pending =&gt; return Poll::Pending,
}
</code></pre></pre>
<blockquote>
<p>但是，前面说过，async 函数返回的是一个 Future，所以，还需要把这样的代码封装在一个 Future 的实现里，对外提供出去。</p>
</blockquote>
<p>因此，我们需要实现一个数据结构，把内部的状态保存起来，并为这个数据结构实现 Future。比如：</p>
<pre><pre class="playground"><code class="language-rust  editable">
enum WriteHelloFile {
    // 初始阶段，用户提供文件名
    Init(String),
    // 等待文件创建，此时需要保存 Future 以便多次调用
    // 这是伪代码，impl Future 不能用在这里
    AwaitingCreate(impl Future&lt;Output = Result&lt;fs::File, std::io::Error&gt;&gt;),
    // 等待文件写入，此时需要保存 Future 以便多次调用
    AwaitingWrite(impl Future&lt;Output = Result&lt;(), std::io::Error&gt;&gt;),
    // Future 处理完毕
    Done,
}

impl WriteHelloFile {
    pub fn new(name: impl Into&lt;String&gt;) -&gt; Self {
        Self::Init(name.into())
    }
}

impl Future for WriteHelloFile {
    type Output = Result&lt;(), std::io::Error&gt;;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        todo!()
    }
}

fn write_hello_file_async(name: &amp;str) -&gt; WriteHelloFile {
    WriteHelloFile::new(name)
}
</code></pre></pre>
<p>这样，我们就把刚才的 write_hello_file_async 异步函数，转化成了一个返回 WriteHelloFile Future 的函数。</p>
<p>来看这个 Future 如何实现（详细注释了）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
impl Future for WriteHelloFile {
    type Output = Result&lt;(), std::io::Error&gt;;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let this = self.get_mut();
        loop {
            match this {
                // 如果状态是 Init，那么就生成 create Future，把状态切换到 AwaitingCreate
                WriteHelloFile::Init(name) =&gt; {
                    let fut = fs::File::create(name);
                    *self = WriteHelloFile::AwaitingCreate(fut);
                }
                // 如果状态是 AwaitingCreate，那么 poll create Future
                // 如果返回 Poll::Ready(Ok(_))，那么创建 write Future
                // 并把状态切换到 Awaiting
                WriteHelloFile::AwaitingCreate(fut) =&gt; match fut.poll(cx) {
                    Poll::Ready(Ok(file)) =&gt; {
                        let fut = file.write_all(b&quot;hello world!&quot;);
                        *self = WriteHelloFile::AwaitingWrite(fut);
                    }
                    Poll::Ready(Err(e)) =&gt; return Poll::Ready(Err(e)),
                    Poll::Pending =&gt; return Poll::Pending,
                },
                // 如果状态是 AwaitingWrite，那么 poll write Future
                // 如果返回 Poll::Ready(_)，那么状态切换到 Done，整个 Future 执行成功
                WriteHelloFile::AwaitingWrite(fut) =&gt; match fut.poll(cx) {
                    Poll::Ready(result) =&gt; {
                        *self = WriteHelloFile::Done;
                        return Poll::Ready(result);
                    }
                    Poll::Pending =&gt; return Poll::Pending,
                },
                // 整个 Future 已经执行完毕
                WriteHelloFile::Done =&gt; return Poll::Ready(Ok(())),
            }
        }
    }
}
</code></pre></pre>
<blockquote>
<p>这个 Future 完整实现的内部结构 ，其实就是一个状态机的迁移。</p>
</blockquote>
<p>这段（伪）代码和之前异步函数是等价的：</p>
<pre><pre class="playground"><code class="language-rust  editable">
async fn write_hello_file_async(name: &amp;str) -&gt; anyhow::Result&lt;()&gt; {
    let mut file = fs::File::create(name).await?;
    file.write_all(b&quot;hello world!&quot;).await?;

    Ok(())
}
</code></pre></pre>
<blockquote>
<p>Rust 在编译 async fn 或者 async block 时，就会生成类似的状态机的实现。你可以看到，看似简单的异步处理，内部隐藏了一套并不难理解、但是写起来很生硬很啰嗦的状态机管理代码。</p>
</blockquote>
</div>
</details>
<p>好搞明白这个问题，回到 pin 。刚才我们手写状态机代码的过程，能帮你理解为什么会需要 Pin 这个问题。</p>
<h2 id="为什么需要-pin"><a class="header" href="#为什么需要-pin">为什么需要 Pin？</a></h2>
<details id="admonition-什么场景下会出现自引用数据结构有什么问题需要pin解决" class="admonition info">
<summary class="admonition-title">
<p>什么场景下会出现自引用数据结构？有什么问题需要pin解决？</p>
<p><a class="admonition-anchor-link" href="5_3_deepin_async_await.html#admonition-什么场景下会出现自引用数据结构有什么问题需要pin解决"></a></p>
</summary>
<div>
<p>在上面实现 Future 的状态机中，我们引用了 file 这样一个局部变量：</p>
<pre><pre class="playground"><code class="language-rust  editable">
WriteHelloFile::AwaitingCreate(fut) =&gt; match fut.poll(cx) {
    Poll::Ready(Ok(file)) =&gt; {
        let fut = file.write_all(b&quot;hello world!&quot;);
        *self = WriteHelloFile::AwaitingWrite(fut);
    }
    Poll::Ready(Err(e)) =&gt; return Poll::Ready(Err(e)),
    Poll::Pending =&gt; return Poll::Pending,
}
</code></pre></pre>
<p>这个代码是有问题的，file 被 fut 引用，但 file 会在这个作用域被丢弃。</p>
<p>所以，我们需要把它保存在数据结构中：</p>
<pre><pre class="playground"><code class="language-rust  editable">
enum WriteHelloFile {
    // 初始阶段，用户提供文件名
    Init(String),
    // 等待文件创建，此时需要保存 Future 以便多次调用
    AwaitingCreate(impl Future&lt;Output = Result&lt;fs::File, std::io::Error&gt;&gt;),
    // 等待文件写入，此时需要保存 Future 以便多次调用
    AwaitingWrite(AwaitingWriteData),
    // Future 处理完毕
    Done,
}

struct AwaitingWriteData {
    fut: impl Future&lt;Output = Result&lt;(), std::io::Error&gt;&gt;,
    file: fs::File,
}
</code></pre></pre>
<ol>
<li>可以生成一个 AwaitingWriteData 数据结构，把 file 和 fut 都放进去</li>
<li>然后在 WriteHelloFile 中引用它。</li>
<li>此时，在同一个数据结构内部，fut 指向了对 file 的引用，这样的数据结构，叫自引用结构（Self-Referential Structure）。</li>
</ol>
<blockquote>
<p>自引用结构有一个很大的问题是：一旦它被移动，原本的指针就会指向旧的地址。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/39%EF%BD%9C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9Aasyncawait%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-4961729.jpg" alt="39｜异步处理：asyncawait内部是怎么实现的？" /></p>
<p>所以需要有某种机制来保证这种情况不会发生。</p>
<p>Pin 就是为这个目的而设计的一个数据结构: 我们可以 Pin 住指向一个 Future 的指针</p>
<p>看文稿中 Pin 的声明：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct Pin&lt;P&gt; {
    pointer: P,
}

impl&lt;P: Deref&gt; Deref for Pin&lt;P&gt; {
    type Target = P::Target;
    fn deref(&amp;self) -&gt; &amp;P::Target {
        Pin::get_ref(Pin::as_ref(self))
    }
}

impl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}
</code></pre></pre>
<ol>
<li>Pin 拿住的是一个可以解引用成 T 的指针类型 P，而不是直接拿原本的类型 T。</li>
<li>所以，对于 Pin 而言，你看到的都是 Pin&lt;Box<T>&gt;、Pin&lt;&amp;mut T&gt;，但不会是 Pin<T>。</li>
<li>因为 Pin 的目的是，把 T 的内存位置锁住，从而避免移动后自引用类型带来的引用失效问题。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/39%EF%BD%9C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9Aasyncawait%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-4961721.jpg" alt="39｜异步处理：asyncawait内部是怎么实现的？" /></p>
<p>这样数据结构可以正常访问，但是你无法直接拿到原来的数据结构进而移动它。</p>
</div>
</details>
<h2 id="自引用数据结构"><a class="header" href="#自引用数据结构">自引用数据结构</a></h2>
<details id="admonition-举例说明自引用类型存在什么潜在危害" class="admonition bug">
<summary class="admonition-title">
<p>举例说明自引用类型存在什么潜在危害</p>
<p><a class="admonition-anchor-link" href="5_3_deepin_async_await.html#admonition-举例说明自引用类型存在什么潜在危害"></a></p>
</summary>
<div>
<p>当然，自引用数据结构并非只在异步代码里出现，只不过异步代码在内部生成用状态机表述的 Future 时，很容易产生自引用结构。我们看一个和 Future 无关的例子（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[derive(Debug)]
struct SelfReference {
    name: String,
    // 在初始化后指向 name
    name_ptr: *const String,
}

impl SelfReference {
    pub fn new(name: impl Into&lt;String&gt;) -&gt; Self {
        SelfReference {
            name: name.into(),
            name_ptr: std::ptr::null(),
        }
    }

    pub fn init(&amp;mut self) {
        self.name_ptr = &amp;self.name as *const String;
    }

    pub fn print_name(&amp;self) {
        println!(
            &quot;struct {:p}: (name: {:p} name_ptr: {:p}), name: {}, name_ref: {}&quot;,
            self,
            &amp;self.name,
            self.name_ptr,
            self.name,
            // 在使用 ptr 是需要 unsafe
            // SAFETY: 这里 name_ptr 潜在不安全，会指向旧的位置
            unsafe { &amp;*self.name_ptr },
        );
    }
}

fn main() {
    let data = move_creates_issue();
    println!(&quot;data: {:?}&quot;, data);
    // 如果把下面这句注释掉，程序运行会直接 segment error
    // data.print_name();
    print!(&quot;\\n&quot;);
    mem_swap_creates_issue();
}

fn move_creates_issue() -&gt; SelfReference {
    let mut data = SelfReference::new(&quot;Tyr&quot;);
    data.init();

    // 不 move，一切正常
    data.print_name();

    let data = move_it(data);

    // move 之后，name_ref 指向的位置是已经失效的地址
    // 只不过现在 move 前的地址还没被回收挪作它用
    data.print_name();
    data
}

fn mem_swap_creates_issue() {
    let mut data1 = SelfReference::new(&quot;Tyr&quot;);
    data1.init();

    let mut data2 = SelfReference::new(&quot;Lindsey&quot;);
    data2.init();

    data1.print_name();
    data2.print_name();

    std::mem::swap(&amp;mut data1, &amp;mut data2);
    data1.print_name();
    data2.print_name();
}

fn move_it(data: SelfReference) -&gt; SelfReference {
    data
}
</code></pre></pre>
<ol>
<li>我们创建了一个自引用结构 SelfReference，它里面的 name_ref 指向了 name。</li>
<li>正常使用它时，没有任何问题</li>
<li>但一旦对这个结构做 move 操作，name_ref 指向的位置还会是 move 前 name 的地址，这就引发了问题。看下图：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/39%EF%BD%9C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9Aasyncawait%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-4961711.jpg" alt="39｜异步处理：asyncawait内部是怎么实现的？" /></p>
<p>同样的，如果我们使用 std::mem:swap，也会出现类似的问题，一旦 swap，两个数据的内容交换，然而，由于 name_ref 指向的地址还是旧的，所以整个指针体系都混乱了：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/39%EF%BD%9C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9Aasyncawait%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-4961697.jpg" alt="39｜异步处理：asyncawait内部是怎么实现的？" /></p>
<p>看代码的输出，辅助你理解：</p>
<pre><code class="language-shell">
struct 0x7ffeea91d6e8: (name: 0x7ffeea91d6e8 name_ptr: 0x7ffeea91d6e8), name: Tyr, name_ref: Tyr
struct 0x7ffeea91d760: (name: 0x7ffeea91d760 name_ptr: 0x7ffeea91d6e8), name: Tyr, name_ref: Tyr
data: SelfReference { name: &quot;Tyr&quot;, name_ptr: 0x7ffeea91d6e8 }

struct 0x7ffeea91d6f0: (name: 0x7ffeea91d6f0 name_ptr: 0x7ffeea91d6f0), name: Tyr, name_ref: Tyr
struct 0x7ffeea91d710: (name: 0x7ffeea91d710 name_ptr: 0x7ffeea91d710), name: Lindsey, name_ref: Lindsey
struct 0x7ffeea91d6f0: (name: 0x7ffeea91d6f0 name_ptr: 0x7ffeea91d710), name: Lindsey, name_ref: Tyr
struct 0x7ffeea91d710: (name: 0x7ffeea91d710 name_ptr: 0x7ffeea91d6f0), name: Tyr, name_ref: Lindsey
</code></pre>
<blockquote>
<p>可以看到，swap 之后，name_ref 指向的内容确实和 name 不一样了。这就是自引用结构带来的问题。</p>
</blockquote>
<p>你也许会奇怪，不是说 move 也会出问题么？为什么第二行打印 name_ref 还是指向了 “Tyr”？</p>
<p>这是因为 move 后，之前的内存失效，但是内存地址还没有被挪作它用，所以还能正常显示 “Tyr”。但这样的内存访问是不安全的，如果你把 main 中这句代码注释掉，程序就会 crash：</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let data = move_creates_issue();
    println!(&quot;data: {:?}&quot;, data);
    // 如果把下面这句注释掉，程序运行会直接 segment error
    // data.print_name();
    print!(&quot;\\n&quot;);
    mem_swap_creates_issue();
}
</code></pre></pre>
<blockquote>
<p>现在你应该了解到在 Rust 下，自引用类型带来的潜在危害了吧。</p>
</blockquote>
</div>
</details>
<details id="admonition-使用pin之后如何解决问题" class="admonition info">
<summary class="admonition-title">
<p>使用pin之后如何解决问题</p>
<p><a class="admonition-anchor-link" href="5_3_deepin_async_await.html#admonition-使用pin之后如何解决问题"></a></p>
</summary>
<div>
<p>所以，Pin 的出现，对解决这类问题很关键，如果你试图移动被 Pin 住的数据结构:</p>
<ul>
<li>要么，编译器会通过编译错误阻止你；</li>
<li>要么，你强行使用 unsafe Rust，自己负责其安全性。</li>
</ul>
<p>我们来看使用 Pin 后如何避免移动带来的问题：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::{marker::PhantomPinned, pin::Pin};

#[derive(Debug)]
struct SelfReference {
    name: String,
    // 在初始化后指向 name
    name_ptr: *const String,
    // PhantomPinned 占位符
    _marker: PhantomPinned,
}

impl SelfReference {
    pub fn new(name: impl Into&lt;String&gt;) -&gt; Self {
        SelfReference {
            name: name.into(),
            name_ptr: std::ptr::null(),
            _marker: PhantomPinned,
        }
    }

    pub fn init(self: Pin&lt;&amp;mut Self&gt;) {
        let name_ptr = &amp;self.name as *const String;
        // SAFETY: 这里并不会把任何数据从 &amp;mut SelfReference 中移走
        let this = unsafe { self.get_unchecked_mut() };
        this.name_ptr = name_ptr;
    }

    pub fn print_name(self: Pin&lt;&amp;Self&gt;) {
        println!(
            &quot;struct {:p}: (name: {:p} name_ptr: {:p}), name: {}, name_ref: {}&quot;,
            self,
            &amp;self.name,
            self.name_ptr,
            self.name,
            // 在使用 ptr 是需要 unsafe
            // SAFETY: 因为数据不会移动，所以这里 name_ptr 是安全的
            unsafe { &amp;*self.name_ptr },
        );
    }
}

fn main() {
    move_creates_issue();
}

fn move_creates_issue() {
    let mut data = SelfReference::new(&quot;Tyr&quot;);
    let mut data = unsafe { Pin::new_unchecked(&amp;mut data) };
    SelfReference::init(data.as_mut());

    // 不 move，一切正常
    data.as_ref().print_name();

    // 现在只能拿到 pinned 后的数据，所以 move 不了之前
    move_pinned(data.as_mut());
    println!(&quot;{:?} ({:p})&quot;, data, &amp;data);

    // 你无法拿回 Pin 之前的 SelfReference 结构，所以调用不了 move_it
    // move_it(data);
}

fn move_pinned(data: Pin&lt;&amp;mut SelfReference&gt;) {
    println!(&quot;{:?} ({:p})&quot;, data, &amp;data);
}

#[allow(dead_code)]
fn move_it(data: SelfReference) {
    println!(&quot;{:?} ({:p})&quot;, data, &amp;data);
}
</code></pre></pre>
<p>由于数据结构被包裹在 Pin 内部，所以在函数间传递时，变化的只是指向 data 的 Pin：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/39%EF%BD%9C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9Aasyncawait%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-4961106.jpg" alt="39｜异步处理：asyncawait内部是怎么实现的？" /></p>
</div>
</details>
<h2 id="unpin"><a class="header" href="#unpin">Unpin</a></h2>
<details id="admonition-了解pin的作用后unpin有什么用" class="admonition info">
<summary class="admonition-title">
<p>了解pin的作用后，Unpin有什么用？</p>
<p><a class="admonition-anchor-link" href="5_3_deepin_async_await.html#admonition-了解pin的作用后unpin有什么用"></a></p>
</summary>
<div>
<p>学习了 Pin，不知道你有没有想起 Unpin 。</p>
<p>那么，Unpin 是做什么的？</p>
<p>Pin 是为了让某个数据结构无法合法地移动，而 Unpin 则相当于声明数据结构是可以移动的，它的作用类似于 Send / Sync，通过类型约束来告诉编译器哪些行为是合法的、哪些不是。</p>
<p>在 Rust 中，绝大多数数据结构都是可以移动的，所以它们都自动实现了 <a href="https://doc.rust-lang.org/std/marker/trait.Unpin.html">Unpin</a>。</p>
<p>即便这些结构被 Pin 包裹，它们依旧可以进行移动，比如：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::mem;
use std::pin::Pin;

let mut string = &quot;this&quot;.to_string();
let mut pinned_string = Pin::new(&amp;mut string);

// We need a mutable reference to call `mem::replace`.
// We can obtain such a reference by (implicitly) invoking `Pin::deref_mut`,
// but that is only possible because `String` implements `Unpin`.
mem::replace(&amp;mut *pinned_string, &quot;other&quot;.to_string());
</code></pre></pre>
<p>当我们不希望一个数据结构被移动，可以使用 !Unpin。在 Rust 里，实现了 !Unpin 的，除了内部结构（比如 Future），主要就是 PhantomPinned：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct PhantomPinned;
impl !Unpin for PhantomPinned {}
</code></pre></pre>
<p>所以，如果你希望你的数据结构不能被移动，可以为其添加 PhantomPinned 字段来隐式声明 !Unpin。</p>
<p>当数据结构满足 Unpin 时，创建 Pin 以及使用 Pin（主要是 DerefMut）都可以使用安全接口，否则，需要使用 unsafe 接口：</p>
<pre><pre class="playground"><code class="language-rust  editable">
// 如果实现了 Unpin，可以通过安全接口创建和进行 DerefMut
impl&lt;P: Deref&lt;Target: Unpin&gt;&gt; Pin&lt;P&gt; {
    pub const fn new(pointer: P) -&gt; Pin&lt;P&gt; {
        // SAFETY: the value pointed to is `Unpin`, and so has no requirements
        // around pinning.
        unsafe { Pin::new_unchecked(pointer) }
    }
    pub const fn into_inner(pin: Pin&lt;P&gt;) -&gt; P {
        pin.pointer
    }
}

impl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}

// 如果没有实现 Unpin，只能通过 unsafe 接口创建，不能使用 DerefMut
impl&lt;P: Deref&gt; Pin&lt;P&gt; {
    pub const unsafe fn new_unchecked(pointer: P) -&gt; Pin&lt;P&gt; {
        Pin { pointer }
    }

    pub const unsafe fn into_inner_unchecked(pin: Pin&lt;P&gt;) -&gt; P {
        pin.pointer
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="boxt的unpin思考"><a class="header" href="#boxt的unpin思考">Box&lt;T&gt;的Unpin思考</a></h2>
<details id="admonition-如果一个数据结构-t-unpin我们为其生成-box那么-box-是-unpin-还是-unpin-的" class="admonition info">
<summary class="admonition-title">
<p>如果一个数据结构 T: !Unpin，我们为其生成 Box<T>，那么 Box<T> 是 Unpin 还是 !Unpin 的？</p>
<p><a class="admonition-anchor-link" href="5_3_deepin_async_await.html#admonition-如果一个数据结构-t-unpin我们为其生成-box那么-box-是-unpin-还是-unpin-的"></a></p>
</summary>
<div>
<p>Box<T>是Unpin，因为Box<T>实现了Unpin trait</p>
</div>
</details>
<h2 id="async-产生的-future-究竟是什么类型"><a class="header" href="#async-产生的-future-究竟是什么类型">async 产生的 Future 究竟是什么类型？</a></h2>
<details id="admonition-rust中future是一个traitasync返回的是一个实现了future的genfuture类型这里颇似python的yield如何变成协程的过程" class="admonition info">
<summary class="admonition-title">
<p>Rust中Future是一个trait，async返回的是一个实现了Future的GenFuture类型。这里颇似python的yield如何变成协程的过程。</p>
<p><a class="admonition-anchor-link" href="5_3_deepin_async_await.html#admonition-rust中future是一个traitasync返回的是一个实现了future的genfuture类型这里颇似python的yield如何变成协程的过程"></a></p>
</summary>
<div>
<p>现在，我们对 Future 的接口有了一个完整的认识，也知道 async 关键字的背后都发生了什么事情：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
</code></pre></pre>
<p>那么，当你写一个 async fn 或者使用了一个 async block 时，究竟得到了一个什么类型的数据呢？比如：</p>
<pre><pre class="playground"><code class="language-rust  editable">
let fut = async { 42 };
</code></pre></pre>
<p>你肯定能拍着胸脯说，这个我知道，不就是 impl Future&lt;Output = i32&gt; 么？</p>
<p>对，但是 impl Future 不是一个具体的类型啊，我们讲过，它相当于 T: Future，那么这个 T 究竟是什么呢？</p>
<p>我们来写段代码探索一下（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let fut = async { 42 };

    println!(&quot;type of fut is: {}&quot;, get_type_name(&amp;fut));
}

fn get_type_name&lt;T&gt;(_: &amp;T) -&gt; &amp;'static str {
    std::any::type_name::&lt;T&gt;()
}
</code></pre></pre>
<p>它的输出如下：</p>
<pre><code class="language-shell">
type of fut is: core::future::from_generator::GenFuture&lt;xxx::main::{{closure}}&gt;
</code></pre>
<p>实现 Future trait 的是一个叫 GenFuture 的结构，它内部有一个闭包。猜测这个闭包是 async { 42 } 产生的？</p>
<p>我们看 GenFuture 的定义（感兴趣可以在 Rust 源码中搜 from_generator），可以看到它是一个泛型结构，内部数据 T 要满足 Generator trait：</p>
<pre><pre class="playground"><code class="language-rust  editable">
struct GenFuture&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt;(T);

pub trait Generator&lt;R = ()&gt; {
    type Yield;
    type Return;
    fn resume(
        self: Pin&lt;&amp;mut Self&gt;, 
        arg: R
    ) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Generator.html">Generator</a> 是 Rust nightly 的一个 trait，还没有进入到标准库。大致看看官网展示的例子，它是怎么用的：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#![feature(generators, generator_trait)]

use std::ops::{Generator, GeneratorState};
use std::pin::Pin;

fn main() {
    let mut generator = || {
        yield 1;
        return &quot;foo&quot;
    };

    match Pin::new(&amp;mut generator).resume(()) {
        GeneratorState::Yielded(1) =&gt; {}
        _ =&gt; panic!(&quot;unexpected return from resume&quot;),
    }
    match Pin::new(&amp;mut generator).resume(()) {
        GeneratorState::Complete(&quot;foo&quot;) =&gt; {}
        _ =&gt; panic!(&quot;unexpected return from resume&quot;),
    }
}
</code></pre></pre>
<ol>
<li>可以看到，如果你创建一个闭包，里面有 yield 关键字，就会得到一个 Generator。</li>
<li>如果你在 Python 中使用过 yield，二者其实非常类似。</li>
<li>因为 Generator 是一个还没进入到稳定版的功能，大致了解一下就行，以后等它的 API 稳定后再仔细研究。</li>
</ol>
</div>
</details>
<h2 id="回顾整理future的contextpinunpin以及asyncawait"><a class="header" href="#回顾整理future的contextpinunpin以及asyncawait">回顾整理Future的Context、Pin/Unpin，以及async/await</a></h2>
<details id="admonition-回顾整理future的contextpinunpin以及asyncawait" class="admonition info">
<summary class="admonition-title">
<p>回顾整理Future的Context、Pin/Unpin，以及async/await</p>
<p><a class="admonition-anchor-link" href="5_3_deepin_async_await.html#admonition-回顾整理future的contextpinunpin以及asyncawait"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/39%EF%BD%9C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9Aasyncawait%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.jpg" alt="39｜异步处理：asyncawait内部是怎么实现的？" /></p>
<blockquote>
<p>并发任务运行在 Future 这样的协程上时，async/await 是产生和运行并发任务的手段，async 定义一个可以并发执行的 Future 任务，await 触发这个任务并发执行。具体来说：</p>
</blockquote>
<ol>
<li>当我们使用 async 关键字时，它会产生一个 impl Future 的结果。</li>
<li>对于一个 async block 或者 async fn 来说，内部的每个 await 都会被编译器捕捉，并成为返回的 Future 的 poll() 方法的内部状态机的一个状态。</li>
<li>Rust 的 Future 需要异步运行时来运行 Future</li>
</ol>
<ul>
<li>以 tokio 为例，它的 executor 会从 run queue 中取出 Future 进行 poll()</li>
<li>当 poll() 返回 Pending 时，这个 Future 会被挂起</li>
<li>直到 reactor 得到了某个事件，唤醒这个 Future，将其添加回 run queue 等待下次执行。</li>
<li>tokio 一般会在每个物理线程（或者 CPU core）下运行一个线程</li>
<li>每个线程有自己的 run queue 来处理 Future。</li>
<li>为了提供最大的吞吐量，tokio 实现了 work stealing scheduler，这样，当某个线程下没有可执行的 Future，它会从其它线程的 run queue 中“偷”一个执行。</li>
</ul>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vi-混合编程"><a class="header" href="#vi-混合编程">VI 混合编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kv-server设计与实现"><a class="header" href="#kv-server设计与实现">KV Server设计与实现</a></h1>
<!--ts-->
<ul>
<li><a href="kv_server_design.html#kv-server%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0">KV Server设计与实现</a></li>
<li><a href="kv_server_design.html#%E6%95%B4%E4%BD%93%E5%9B%9E%E9%A1%BE">整体回顾</a>
<ul>
<li><a href="kv_server_design.html#%E8%80%83%E8%99%91%E6%8F%90%E4%BE%9B%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE">考虑提供日志配置</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:33 UTC 2022 -->
<!--te-->
<h1 id="整体回顾"><a class="header" href="#整体回顾">整体回顾</a></h1>
<p>我们的 KV server 之旅就到此为止了。在整整 7 堂课里，我们一点点从零构造了一个完整的 KV server，包括注释在内，撰写了近三千行代码：</p>
<details id="admonition-使用tokei检查代码行数" class="admonition note">
<summary class="admonition-title">
<p>使用tokei检查代码行数 </p>
<p><a class="admonition-anchor-link" href="kv_server_design.html#admonition-使用tokei检查代码行数"></a></p>
</summary>
<div>
<pre><code class="language-shell">
❯ tokei .
-------------------------------------------------------------------------------
 Language            Files        Lines         Code     Comments       Blanks
-------------------------------------------------------------------------------
 Makefile                1           24           16            1            7
 Markdown                1            7            7            0            0
 Protocol Buffers        1          119           79           23           17
 Rust                   25         3366         2730          145          491
 TOML                    2          268          107          142           19
-------------------------------------------------------------------------------
 Total                  30         3784         2939          311          534
-------------------------------------------------------------------------------
</code></pre>
</div>
</details>
<details id="admonition-在这个系列里" class="admonition info">
<summary class="admonition-title">
<p>在这个系列里: </p>
<p><a class="admonition-anchor-link" href="kv_server_design.html#admonition-在这个系列里"></a></p>
</summary>
<div>
<ol>
<li>我们大量使用 trait 和泛型，构建了很多复杂的数据结构；</li>
<li>还为自己的类型实现了 AsyncRead / AsyncWrite / Stream / Sink 这些比较高阶的 trait</li>
<li>通过良好的设计，我们把网络层和业务层划分地非常清晰，网络层的变化不会影响到业务层，反之亦然：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/53f5e5cf68b4300c3231885b10c784f3.jpeg" alt="img" /></p>
<ol start="4">
<li>
<p>我们还模拟了比较真实的开发场景，通过大的需求变更，引发了一次不小的代码重构。</p>
</li>
<li>
<p>最终，通过性能测试，发现了一个客户端实现的小 bug。在处理这个 bug 的时候，我们欣喜地看到，Rust 有着非常强大的测试工具链，除了我们使用的单元测试、集成测试、性能测试，Rust 还支持模糊测试（fuzzy testing）和基于特性的测试（property testing）。</p>
</li>
<li>
<p>对于测试过程中发现的问题，Rust 有着非常完善的 tracing 工具链，可以和整个 opentelemetry 生态系统（包括 jaeger、prometheus 等工具）打通。我们就是通过使用 jaeger 找到并解决了问题。除此之外，Rust tracing 工具链还支持生成 <a href="https://github.com/tokio-rs/tracing/tree/master/tracing-flame">flamegraph</a>，篇幅关系，没有演示，你感兴趣的话可以试试。</p>
</li>
</ol>
</div>
</details>
<p>希望通过这个系列，你对如何使用 Rust 的特性来构造应用程序有了深度的认识。</p>
<blockquote>
<p>我相信，如果你能够跟得上这个系列的节奏，另外如果遇到新的库，用阅读代码的方式快速掌握，那么，大部分 Rust 开发中的挑战，对你而言都不是难事。</p>
</blockquote>
<h2 id="考虑提供日志配置"><a class="header" href="#考虑提供日志配置">考虑提供日志配置</a></h2>
<p>我们目前并未对日志做任何配置。一般来说，怎么做日志，会有相应的开关以及日志级别，如果希望能通过如下的配置记录日志，该怎么做？试试看：</p>
<pre><code class="language-toml">[log]
enable_log_file = true
enable_jaeger = false
log_level = 'info'
path = '/tmp/kv-log'
rotation = 'Daily'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一基本流程"><a class="header" href="#一基本流程">一、基本流程</a></h1>
<!--ts-->
<ul>
<li><a href="kv1_basic.html#%E4%B8%80%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B">一、基本流程</a>
<ul>
<li><a href="kv1_basic.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-kv-server-%E6%9D%A5%E5%AE%9E%E6%93%8D%E5%91%A2">为什么选 KV server 来实操呢？</a></li>
<li><a href="kv1_basic.html#%E5%85%88%E6%9D%A5%E4%B8%80%E4%B8%AA%E7%9F%AD%E5%B9%B3%E7%B3%99%E7%9A%84%E5%AE%9E%E7%8E%B0">先来一个短平糙的实现</a></li>
<li><a href="kv1_basic.html#%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1">架构和设计</a>
<ul>
<li><a href="kv1_basic.html#%E4%B8%BB%E4%BD%93%E4%BA%A4%E4%BA%92%E6%8E%A5%E5%8F%A3">主体交互接口</a></li>
<li><a href="kv1_basic.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E7%9A%84%E5%8D%8F%E8%AE%AE">客户端和服务器间的协议</a>
<ul>
<li><a href="kv1_basic.html#commandservice-trait">CommandService trait</a></li>
</ul>
</li>
<li><a href="kv1_basic.html#storage-trait">Storage trait</a></li>
<li><a href="kv1_basic.html#trait%E7%9A%84%E5%A5%BD%E5%A4%84">trait的好处</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:28 UTC 2022 -->
<!--te-->
<h2 id="为什么选-kv-server-来实操呢"><a class="header" href="#为什么选-kv-server-来实操呢">为什么选 KV server 来实操呢？</a></h2>
<p>因为它是一个足够简单又足够复杂的服务。</p>
<details id="admonition-基础需求梳理" class="admonition info">
<summary class="admonition-title">
<p>基础需求梳理 </p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-基础需求梳理"></a></p>
</summary>
<div>
<p>参考工作中用到的 Redis / Memcached 等服务，来梳理它的需求:</p>
<ol>
<li>
<p>最核心的功能是根据不同的命令进行诸如数据存贮、读取、监听等操作；</p>
</li>
<li>
<p>而客户端要能通过网络访问 KV server，发送包含命令的请求，得到结果；</p>
</li>
<li>
<p>数据要能根据需要，存储在内存中或者持久化到磁盘上。</p>
</li>
</ol>
</div>
</details>
<h2 id="先来一个短平糙的实现"><a class="header" href="#先来一个短平糙的实现">先来一个短平糙的实现</a></h2>
<p>如果是为了完成任务构建 KV server，其实最初的版本两三百行代码就可以搞定，但是这样的代码以后维护起来就是灾难。</p>
<details id="admonition-例子--一个过程式的意大利版本" class="admonition example">
<summary class="admonition-title">
<p>例子:  一个过程式的意大利版本 </p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-例子--一个过程式的意大利版本"></a></p>
</summary>
<div>
<p>我们看一个省却了不少细节的意大利面条式的版本，你可以随着我的注释重点看流程：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use async_prost::AsyncProstStream;
use dashmap::DashMap;
use futures::prelude::*;
use kv::{
    command_request::RequestData, CommandRequest, CommandResponse, Hset, KvError, Kvpair, Value,
};
use std::sync::Arc;
use tokio::net::TcpListener;
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // 初始化日志
    tracing_subscriber::fmt::init();

    let addr = &quot;127.0.0.1:9527&quot;;
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Start listening on {}&quot;, addr);

    // 使用 DashMap 创建放在内存中的 kv store
    let table: Arc&lt;DashMap&lt;String, Value&gt;&gt; = Arc::new(DashMap::new());

    loop {
        // 得到一个客户端请求
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Client {:?} connected&quot;, addr);

        // 复制 db，让它在 tokio 任务中可以使用
        let db = table.clone();

        // 创建一个 tokio 任务处理这个客户端
        tokio::spawn(async move {
            // 使用 AsyncProstStream 来处理 TCP Frame
            // Frame: 两字节 frame 长度，后面是 protobuf 二进制
            let mut stream =
                AsyncProstStream::&lt;_, CommandRequest, CommandResponse, _&gt;::from(stream).for_async();

            // 从 stream 里取下一个消息（拿出来后已经自动 decode 了）
            while let Some(Ok(msg)) = stream.next().await {
                info!(&quot;Got a new command: {:?}&quot;, msg);
                let resp: CommandResponse = match msg.request_data {
                    // 为演示我们就处理 HSET
                    Some(RequestData::Hset(cmd)) =&gt; hset(cmd, &amp;db),
                    // 其它暂不处理
                    _ =&gt; unimplemented!(),
                };

                info!(&quot;Got response: {:?}&quot;, resp);
                // 把 CommandResponse 发送给客户端
                stream.send(resp).await.unwrap();
            }
        });
    }
}

// 处理 hset 命令
fn hset(cmd: Hset, db: &amp;DashMap&lt;String, Value&gt;) -&gt; CommandResponse {
    match cmd.pair {
        Some(Kvpair {
            key,
            value: Some(v),
        }) =&gt; {
            // 往 db 里写入
            let old = db.insert(key, v).unwrap_or_default();
            // 把 value 转换成 CommandResponse
            old.into()
        }
        v =&gt; KvError::InvalidCommand(format!(&quot;hset: {:?}&quot;, v)).into(),
    }
}
</code></pre></pre>
<blockquote>
<p>这段代码非常地平铺直叙，从输入到输出，一蹴而就，如果这样写，任务确实能很快完成，但是它有种“完成之后，哪管洪水滔天”的感觉。</p>
</blockquote>
<p>你复制代码后，打开两个窗口，分别运行 </p>
<pre><code class="language-shell">cargo run --example naive_server
</code></pre>
<p>和 </p>
<pre><code class="language-shell">cargo run --example client
</code></pre>
<p>就可以看到运行 server 的窗口有如下打印：</p>
<pre><code class="language-shell">
Sep 19 22:25:34.016  INFO naive_server: Start listening on 127.0.0.1:9527
Sep 19 22:25:38.401  INFO naive_server: Client 127.0.0.1:51650 connected
Sep 19 22:25:38.401  INFO naive_server: Got a new command: CommandRequest { request_data: Some(Hset(Hset { table: &quot;table1&quot;, pair: Some(Kvpair { key: &quot;hello&quot;, value: Some(Value { value: Some(String(&quot;world&quot;)) }) }) })) }
Sep 19 22:25:38.401  INFO naive_server: Got response: CommandResponse { status: 200, message: &quot;&quot;, values: [Value { value: None }], pairs: [] }
</code></pre>
</div>
</details>
<details id="admonition-警告-耦合严重" class="admonition warning">
<summary class="admonition-title">
<p>警告⚠️： 耦合严重 </p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-警告-耦合严重"></a></p>
</summary>
<div>
<p>虽然整体功能算是搞定了，不过以后想继续为这个 KV server 增加新的功能，就需要来来回回改这段代码。</p>
<p>此外，也不好做单元测试，因为所有的逻辑都被压缩在一起了，没有“单元”可言。虽然未来可以逐步把不同的逻辑分离到不同的函数，使主流程尽可能简单一些。但是，它们依旧是耦合在一起的，如果不做大的重构，还是解决不了实质的问题。</p>
<p>所以不管用什么语言开发，这样的代码都是我们要极力避免的，不光自己不要这么写，code review 遇到别人这么写也要严格地揪出来。</p>
</div>
</details>
<h2 id="架构和设计"><a class="header" href="#架构和设计">架构和设计</a></h2>
<details id="admonition-那么怎样才算是好的实现呢" class="admonition success">
<summary class="admonition-title">
<p>那么，怎样才算是好的实现呢？</p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-那么怎样才算是好的实现呢"></a></p>
</summary>
<div>
<p>好的实现应该是:</p>
<ol>
<li>在分析完需求后，首先从系统的主流程开始，搞清楚从客户端的请求到最终客户端收到响应，都会经过哪些主要的步骤；</li>
<li>然后根据这些步骤，思考哪些东西需要延迟绑定，构建主要的接口和 trait；</li>
<li>等这些东西深思熟虑之后，最后再考虑实现。也就是所谓的“谋定而后动”。</li>
</ol>
</div>
</details>
<details id="admonition-主流程梳理图" class="admonition info">
<summary class="admonition-title">
<p>主流程梳理图 </p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-主流程梳理图"></a></p>
</summary>
<div>
<p>开头已经分析 KV server 这个需求，现在我们来梳理主流程。</p>
<p>你可以先自己想想，再参考示意图看看有没有缺漏：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/67894066ecedd65897d5644f949b8cdc.jpg" alt="img" /></p>
</div>
</details>
<details id="admonition-笔记这个流程中有一些关键问题需要进一步探索" class="admonition note">
<summary class="admonition-title">
<p>笔记：这个流程中有一些关键问题需要进一步探索 </p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-笔记这个流程中有一些关键问题需要进一步探索"></a></p>
</summary>
<div>
<ol>
<li>客户端和服务器用什么协议通信？TCP？gRPC？HTTP？支持一种还是多种？</li>
<li>客户端和服务器之间交互的应用层协议如何定义？怎么做序列化 / 反序列化？是用 Protobuf、JSON 还是 Redis RESP？或者也可以支持多种？</li>
<li>具体的处理逻辑中，需不需要加 hook，在处理过程中发布一些事件，让其他流程可以得到通知，进行额外的处理？这些 hook 可不可以提前终止整个流程的处理？</li>
<li>对于存储，要支持不同的存储引擎么？比如 MemDB（内存）、RocksDB（磁盘）、SledDB（磁盘）等。对于 MemDB，我们考虑支持 WAL（Write-Ahead Log） 和 snapshot 么？</li>
<li>整个系统可以配置么？比如服务使用哪个端口、哪个存储引擎？</li>
</ol>
</div>
</details>
<blockquote>
<p>如果你想做好架构，那么，问出这些问题，并且找到这些问题的答案就很重要。值得注意的是，这里面很多问题产品经理并不能帮你回答，或者 TA 的回答会将你带入歧路。作为一个架构师，我们需要对系统未来如何应对变化负责。</p>
</blockquote>
<details id="admonition-下面是我的思考你可以参考" class="admonition example">
<summary class="admonition-title">
<p>下面是我的思考，你可以参考： </p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-下面是我的思考你可以参考"></a></p>
</summary>
<div>
<ol>
<li>
<p>像 KV server 这样需要高性能的场景，通信应该优先考虑 TCP 协议。所以我们暂时只支持 TCP，未来可以根据需要支持更多的协议，如 HTTP2/gRPC。还有，未来可能对安全性有额外的要求，所以我们要保证 TLS 这样的安全协议可以即插即用。总之，网络层需要灵活。</p>
</li>
<li>
<p>应用层协议我们可以用 protobuf 定义。protobuf 直接解决了协议的定义以及如何序列化和反序列化。Redis 的 RESP 固然不错，但它的短板也显而易见，命令需要额外的解析，而且大量的 \r\n 来分隔命令或者数据，也有些浪费带宽。使用 JSON 的话更加浪费带宽，且 JSON 的解析效率不高，尤其是数据量很大的时候。</p>
</li>
</ol>
<p>protobuf 就很适合 KV server 这样的场景，灵活、可向后兼容式升级、解析效率很高、生成的二进制非常省带宽，唯一的缺点是需要额外的工具 protoc 来编译成不同的语言。虽然 protobuf 是首选，但也许未来为了和 Redis 客户端互通，还是要支持 RESP。</p>
<ol start="3">
<li>
<p>服务器支持的命令我们可以参考Redis 的命令集。第一版先来支持 HXXX 命令，比如 HSET、HMSET、HGET、HMGET 等。从命令到命令的响应，可以做个 trait 来抽象。</p>
</li>
<li>
<p>处理流程中计划加这些 hook：收到客户端的命令后 OnRequestReceived、处理完客户端的命令后 OnRequestExecuted、发送响应之前 BeforeResponseSend、发送响应之后 AfterResponseSend。这样，处理过程中的主要步骤都有事件暴露出去，让我们的 KV server 可以非常灵活，方便调用者在初始化服务的时候注入额外的处理逻辑。</p>
</li>
<li>
<p>存储必然需要足够灵活。可以对存储做个 trait 来抽象其基本的行为，一开始可以就只做 MemDB，未来肯定需要有支持持久化的存储。</p>
</li>
<li>
<p>需要支持配置，但优先级不高。等基本流程搞定，使用过程中发现足够的痛点，就可以考虑配置文件如何处理了。</p>
</li>
</ol>
<p>当这些问题都敲定下来，系统的基本思路就有了。</p>
</div>
</details>
<h3 id="主体交互接口"><a class="header" href="#主体交互接口">主体交互接口</a></h3>
<p>我们可以先把几个重要的接口定义出来，然后仔细审视这些接口。</p>
<details id="admonition-笔记最重要的几个接口就是三个主体交互的接口" class="admonition note">
<summary class="admonition-title">
<p>笔记：最重要的几个接口就是三个主体交互的接口</p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-笔记最重要的几个接口就是三个主体交互的接口"></a></p>
</summary>
<div>
<ul>
<li>客户端和服务器的接口或者说协议</li>
<li>服务器和命令处理流程的接口</li>
<li>服务器和存储的接口。</li>
</ul>
</div>
</details>
<h3 id="客户端和服务器间的协议"><a class="header" href="#客户端和服务器间的协议">客户端和服务器间的协议</a></h3>
<details id="admonition-首先是客户端和服务器之间的协议" class="admonition note">
<summary class="admonition-title">
<p>首先是客户端和服务器之间的协议。</p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-首先是客户端和服务器之间的协议"></a></p>
</summary>
<div>
<p>来试着用 protobuf 定义一下我们第一版支持的客户端命令：</p>
<pre><code class="language-protobuf">
syntax = &quot;proto3&quot;;

package abi;

// 来自客户端的命令请求
message CommandRequest {
  oneof request_data {
    Hget hget = 1;
    Hgetall hgetall = 2;
    Hmget hmget = 3;
    Hset hset = 4;
    Hmset hmset = 5;
    Hdel hdel = 6;
    Hmdel hmdel = 7;
    Hexist hexist = 8;
    Hmexist hmexist = 9;
  }
}

// 服务器的响应
message CommandResponse {
  // 状态码；复用 HTTP 2xx/4xx/5xx 状态码
  uint32 status = 1;
  // 如果不是 2xx，message 里包含详细的信息
  string message = 2;
  // 成功返回的 values
  repeated Value values = 3;
  // 成功返回的 kv pairs
  repeated Kvpair pairs = 4;
}

// 从 table 中获取一个 key，返回 value
message Hget {
  string table = 1;
  string key = 2;
}

// 从 table 中获取所有的 Kvpair
message Hgetall { string table = 1; }

// 从 table 中获取一组 key，返回它们的 value
message Hmget {
  string table = 1;
  repeated string keys = 2;
}

// 返回的值
message Value {
  oneof value {
    string string = 1;
    bytes binary = 2;
    int64 integer = 3;
    double float = 4;
    bool bool = 5;
  }
}

// 返回的 kvpair
message Kvpair {
  string key = 1;
  Value value = 2;
}

// 往 table 里存一个 kvpair，
// 如果 table 不存在就创建这个 table
message Hset {
  string table = 1;
  Kvpair pair = 2;
}

// 往 table 中存一组 kvpair，
// 如果 table 不存在就创建这个 table
message Hmset {
  string table = 1;
  repeated Kvpair pairs = 2;
}

// 从 table 中删除一个 key，返回它之前的值
message Hdel {
  string table = 1;
  string key = 2;
}

// 从 table 中删除一组 key，返回它们之前的值
message Hmdel {
  string table = 1;
  repeated string keys = 2;
}

// 查看 key 是否存在
message Hexist {
  string table = 1;
  string key = 2;
}

// 查看一组 key 是否存在
message Hmexist {
  string table = 1;
  repeated string keys = 2;
}
</code></pre>
</div>
</details>
<blockquote>
<p>通过 <a href="https://github.com/tokio-rs/prost">prost</a>，这个 protobuf 文件可以被编译成 Rust 代码（主要是 struct 和 enum），供我们使用。你应该还记得，thumbor
的开发时，已经见识到了 prost 处理 protobuf 的方式了。</p>
</blockquote>
<h4 id="commandservice-trait"><a class="header" href="#commandservice-trait">CommandService trait</a></h4>
<p>客户端和服务器间的协议敲定之后，就要思考如何处理请求的命令，返回响应。</p>
<ol>
<li>
<p>我们目前打算支持 9 种命令，未来可能支持更多命令。所以最好定义一个 trait 来统一处理所有的命令，返回处理结果。</p>
</li>
<li>
<p>在处理命令的时候，需要和存储发生关系，这样才能根据请求中携带的参数读取数据，或者把请求中的数据存入存储系统中。</p>
</li>
</ol>
<details id="admonition-3--所以这个-trait-可以这么定义" class="admonition note">
<summary class="admonition-title">
<ol start="3">
<li>所以，这个 trait 可以这么定义： </li>
</ol>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-3--所以这个-trait-可以这么定义"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">/// 对 Command 的处理的抽象
pub trait CommandService {
    /// 处理 Command，返回 Response
    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse;
}
</code></pre></pre>
<p>有了这个 trait，并且每一个命令都实现了这个 trait 后，dispatch 方法就可以是类似这样的代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">
// 从 Request 中得到 Response，目前处理 HGET/HGETALL/HSET
pub fn dispatch(cmd: CommandRequest, store: &amp;impl Storage) -&gt; CommandResponse {
    match cmd.request_data {
        Some(RequestData::Hget(param)) =&gt; param.execute(store),
        Some(RequestData::Hgetall(param)) =&gt; param.execute(store),
        Some(RequestData::Hset(param)) =&gt; param.execute(store),
        None =&gt; KvError::InvalidCommand(&quot;Request has no data&quot;.into()).into(),
        _ =&gt; KvError::Internal(&quot;Not implemented&quot;.into()).into(),
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-成功这样未来我们支持新命令时只需要做两件事" class="admonition success">
<summary class="admonition-title">
<p>成功：这样，未来我们支持新命令时，只需要做两件事</p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-成功这样未来我们支持新命令时只需要做两件事"></a></p>
</summary>
<div>
<ol>
<li>为命令实现 CommandService</li>
<li>在 dispatch 方法中添加新命令的支持。</li>
</ol>
</div>
</details>
<h3 id="storage-trait"><a class="header" href="#storage-trait">Storage trait</a></h3>
<details id="admonition-再来看为不同的存储而设计的-storage-trait它提供-kv-store-的主要接口" class="admonition note">
<summary class="admonition-title">
<p>再来看为不同的存储而设计的 Storage trait，它提供 KV store 的主要接口 </p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-再来看为不同的存储而设计的-storage-trait它提供-kv-store-的主要接口"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
/// 对存储的抽象，我们不关心数据存在哪儿，但需要定义外界如何和存储打交道
pub trait Storage {
    /// 从一个 HashTable 里获取一个 key 的 value
    fn get(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;
    /// 从一个 HashTable 里设置一个 key 的 value，返回旧的 value
    fn set(&amp;self, table: &amp;str, key: String, value: Value) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;
    /// 查看 HashTable 中是否有 key
    fn contains(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;bool, KvError&gt;;
    /// 从 HashTable 中删除一个 key
    fn del(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;
    /// 遍历 HashTable，返回所有 kv pair（这个接口不好）
    fn get_all(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;Kvpair&gt;, KvError&gt;;
    /// 遍历 HashTable，返回 kv pair 的 Iterator
    fn get_iter(&amp;self, table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt;;
}
</code></pre></pre>
</div>
</details>
<h3 id="trait的好处"><a class="header" href="#trait的好处">trait的好处</a></h3>
<p>在 CommandService trait 中已经看到，在处理客户端请求的时候，与之打交道的是 Storage trait，而非具体的某个 store。</p>
<p>这样做的好处是，未来根据业务的需要，在不同的场景下添加不同的 store，只需要为其实现 Storage trait 即可，不必修改 CommandService 有关的代码。</p>
<details id="admonition--比如在-hget-命令的实现时我们使用-storageget-方法从-table-中获取数据它跟某个具体的存储方案无关" class="admonition note">
<summary class="admonition-title">
<blockquote>
<p>比如在 HGET 命令的实现时，我们使用 Storage::get 方法，从 table 中获取数据，它跟某个具体的存储方案无关</p>
</blockquote>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition--比如在-hget-命令的实现时我们使用-storageget-方法从-table-中获取数据它跟某个具体的存储方案无关"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl CommandService for Hget {
    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {
        match store.get(&amp;self.table, &amp;self.key) {
            Ok(Some(v)) =&gt; v.into(),
            Ok(None) =&gt; KvError::NotFound(self.table, self.key).into(),
            Err(e) =&gt; e.into(),
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-为什么get_iter返回box" class="admonition tip">
<summary class="admonition-title">
<p>为什么get_iter返回Box<dyn Iterator>?</p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-为什么get_iter返回box"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">    /// 遍历 HashTable，返回 kv pair 的 Iterator
    fn get_iter(&amp;self, table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt;;
</code></pre></pre>
<p>Storage trait 里面的绝大多数方法相信你可以定义出来，但 get_iter() 这个接口可能你会比较困惑，因为它返回了一个 Box<dyn Iterator>，为什么？</p>
<p>这是一个 trait object。</p>
<p>这里我们想返回一个 iterator：</p>
<ol>
<li>调用者不关心它具体是什么类型，只要可以不停地调用 next() 方法取到下一个值就可以了。</li>
<li>不同的实现，可能返回不同的 iterator，如果要用同一个接口承载，我们需要使用 trait object。</li>
<li>在使用 trait object 时，因为 Iterator 是个带有关联类型的 trait，所以这里需要指明关联类型 Item 是什么类型，这样调用者才好拿到这个类型进行处理。</li>
</ol>
<blockquote>
<p>你也许会有疑问，set / del 明显是个会导致 self 修改的方法，为什么它的接口依旧使用的是 &amp;self 呢？</p>
</blockquote>
</div>
</details>
<details id="admonition-kv-server使用hashmap数据结构" class="admonition info">
<summary class="admonition-title">
<p>KV Server使用HashMap数据结构 </p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-kv-server使用hashmap数据结构"></a></p>
</summary>
<div>
<p>我们思考一下它的用法。对于 Storage trait，最简单的实现是 in-memory 的 HashMap。</p>
<p>由于我们支持的是 HSET / HGET 这样的命令，它们可以从不同的表中读取数据，所以需要嵌套的 HashMap，类似 HashMap&lt;String, HashMap&lt;String, Value&gt;&gt;。</p>
<p>另外，由于要在多线程 / 异步环境下读取和更新内存中的 HashMap，所以我们需要类似这样的结构：</p>
<pre><pre class="playground"><code class="language-rust  editable">Arc&lt;RwLock&lt;HashMap&lt;String, Arc&lt;RwLock&lt;HashMap&lt;String, Value&gt;&gt;&gt;&gt;&gt;&gt;
</code></pre></pre>
<blockquote>
<p>这个结构是一个多线程环境下具有内部可变性的数据结构，所以 get / set 的接口是 &amp;self 就足够了。</p>
</blockquote>
</div>
</details>
<details id="admonition-为什么返回值都用result" class="admonition question">
<summary class="admonition-title">
<p>为什么返回值都用Result&lt;T, E&gt;? </p>
<p><a class="admonition-anchor-link" href="kv1_basic.html#admonition-为什么返回值都用result"></a></p>
</summary>
<div>
<p>想一想，对于 Storage trait，为什么返回值都用了 Result&lt;T, E&gt;？在实现 MemTable 的时候，似乎所有返回都是 Ok(T) 啊？</p>
<blockquote>
<p>Storage作为trait，需要关注IO操作失败的错误情况，而MemTable实现，都是内存操作，几乎不会失败，所以返回Ok(T)就可以了</p>
</blockquote>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二实现并验证协议层"><a class="header" href="#二实现并验证协议层">二、实现并验证协议层</a></h1>
<!--ts-->
<ul>
<li><a href="kv2_protocols.html#%E4%BA%8C%E5%AE%9E%E7%8E%B0%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%8D%8F%E8%AE%AE%E5%B1%82">二、实现并验证协议层</a>
<ul>
<li><a href="kv2_protocols.html#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96">创建项目，添加依赖</a></li>
<li><a href="kv2_protocols.html#protobuf%E5%A4%84%E7%90%86">protobuf处理</a></li>
<li><a href="kv2_protocols.html#%E5%AE%9E%E7%8E%B0%E5%B9%B6%E9%AA%8C%E8%AF%81-storage-trait">实现并验证 Storage trait</a>
<ul>
<li><a href="kv2_protocols.html#%E6%9E%84%E5%BB%BAmemtable">构建MemTable</a></li>
<li><a href="kv2_protocols.html#%E6%B5%8B%E8%AF%95">测试</a></li>
</ul>
</li>
<li><a href="kv2_protocols.html#%E5%AE%9E%E7%8E%B0%E5%B9%B6%E9%AA%8C%E8%AF%81-commandservice-trait">实现并验证 CommandService trait</a>
<ul>
<li><a href="kv2_protocols.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%86%99">为什么要这么写？</a></li>
<li><a href="kv2_protocols.html#%E5%9C%A8-srcpbmodrs-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E5%A4%96%E5%9B%B4%E9%80%BB%E8%BE%91">在 src/pb/mod.rs 中添加相关的外围逻辑</a></li>
</ul>
</li>
<li><a href="kv2_protocols.html#%E6%9C%80%E5%90%8E%E7%9A%84%E6%8B%BC%E5%9B%BEservice-%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0">最后的拼图：Service 结构的实现</a>
<ul>
<li><a href="kv2_protocols.html#%E5%9B%B4%E7%BB%95%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95">围绕接口测试</a></li>
<li><a href="kv2_protocols.html#%E7%BB%A7%E7%BB%AD%E5%86%99%E4%BB%A3%E7%A0%81">继续写代码</a></li>
</ul>
</li>
<li><a href="kv2_protocols.html#%E6%96%B0%E7%9A%84-server">新的 server</a></li>
<li><a href="kv2_protocols.html#%E8%BF%90%E8%A1%8C">运行</a></li>
<li><a href="kv2_protocols.html#%E5%88%9D%E6%AD%A5%E6%84%9F%E5%8F%97rust%E6%92%B0%E5%86%99%E4%BB%A3%E7%A0%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">初步感受Rust撰写代码最佳实践</a></li>
<li><a href="kv2_protocols.html#%E4%B8%BA%E5%89%A9%E4%B8%8B6%E4%B8%AA%E5%91%BD%E4%BB%A4%E6%9E%84%E5%BB%BA%E6%B5%8B%E8%AF%95%E5%B9%B6%E5%AE%9E%E7%8E%B0">为剩下6个命令构建测试并实现</a></li>
<li><a href="kv2_protocols.html#%E8%80%83%E8%99%91%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91">考虑用线程池处理并发</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:28 UTC 2022 -->
<!--te-->
<p>还是按照上一讲定义接口的顺序来一个一个测试：首先我们来构建协议层。</p>
<h2 id="创建项目添加依赖"><a class="header" href="#创建项目添加依赖">创建项目，添加依赖</a></h2>
<details id="admonition-笔记" class="admonition note">
<summary class="admonition-title">
<p>笔记：</p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-笔记"></a></p>
</summary>
<div>
<ol>
<li>先创建一个项目：cargo new kv –lib</li>
<li>进入到项目目录，在 Cargo.toml 中添加依赖：</li>
</ol>
<pre><code class="language-toml">[package]
name = &quot;kv&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
bytes = &quot;1&quot; # 高效处理网络 buffer 的库
prost = &quot;0.8&quot; # 处理 protobuf 的代码
tracing = &quot;0.1&quot; # 日志处理

[dev-dependencies]
anyhow = &quot;1&quot; # 错误处理
async-prost = &quot;0.2.1&quot; # 支持把 protobuf 封装成 TCP frame
futures = &quot;0.3&quot; # 提供 Stream trait
tokio = { version = &quot;1&quot;, features = [&quot;rt&quot;, &quot;rt-multi-thread&quot;, &quot;io-util&quot;, &quot;macros&quot;, &quot;net&quot; ] } # 异步网络库
tracing-subscriber = &quot;0.2&quot; # 日志处理

[build-dependencies]
prost-build = &quot;0.8&quot; # 编译 protobuf
</code></pre>
</div>
</details>
<h2 id="protobuf处理"><a class="header" href="#protobuf处理">protobuf处理</a></h2>
<p>然后在项目根目录下创建 abi.proto，把上文中 protobuf 的代码放进去。</p>
<details id="admonition-在根目录下再创建-buildrs" class="admonition note">
<summary class="admonition-title">
<p>在根目录下，再创建 build.rs</p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-在根目录下再创建-buildrs"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let mut config = prost_build::Config::new();
    config.bytes(&amp;[&quot;.&quot;]);
    config.type_attribute(&quot;.&quot;, &quot;#[derive(PartialOrd)]&quot;);
    config
        .out_dir(&quot;src/pb&quot;)
        .compile_protos(&amp;[&quot;abi.proto&quot;], &amp;[&quot;.&quot;])
        .unwrap();
}
</code></pre></pre>
<ol>
<li>这里我们为编译出来的代码额外添加了一些属性。比如为 protobuf 的 bytes 类型生成 Bytes 而非缺省的 Vec<u8>，为所有类型加入 PartialOrd 派生宏。</li>
<li>关于 prost-build 的扩展，你可以看<a href="https://docs.rs/prost-build/0.8.0/prost_build/struct.Config.html">文档</a>。</li>
</ol>
</div>
</details>
<blockquote>
<p>记得创建 src/pb 目录，否则编不过。</p>
</blockquote>
<p>现在，在项目根目录下做 cargo build 会生成 src/pb/abi.rs 文件，里面包含所有 protobuf 定义的消息的 Rust 数据结构。</p>
<details id="admonition-我们创建-srcpbmodrs引入-abirs并做一些基本的类型转换" class="admonition note">
<summary class="admonition-title">
<p>我们创建 src/pb/mod.rs，引入 abi.rs，并做一些基本的类型转换</p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-我们创建-srcpbmodrs引入-abirs并做一些基本的类型转换"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub mod abi;

use abi::{command_request::RequestData, *};

impl CommandRequest {
    /// 创建 HSET 命令
    pub fn new_hset(table: impl Into&lt;String&gt;, key: impl Into&lt;String&gt;, value: Value) -&gt; Self {
        Self {
            request_data: Some(RequestData::Hset(Hset {
                table: table.into(),
                pair: Some(Kvpair::new(key, value)),
            })),
        }
    }
}

impl Kvpair {
    /// 创建一个新的 kv pair
    pub fn new(key: impl Into&lt;String&gt;, value: Value) -&gt; Self {
        Self {
            key: key.into(),
            value: Some(value),
        }
    }
}

/// 从 String 转换成 Value
impl From&lt;String&gt; for Value {
    fn from(s: String) -&gt; Self {
        Self {
            value: Some(value::Value::String(s)),
        }
    }
}

/// 从 &amp;str 转换成 Value
impl From&lt;&amp;str&gt; for Value {
    fn from(s: &amp;str) -&gt; Self {
        Self {
            value: Some(value::Value::String(s.into())),
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-最后在-srclibrs-中引入-pb-模块" class="admonition note">
<summary class="admonition-title">
<p>最后，在 src/lib.rs 中，引入 pb 模块 </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-最后在-srclibrs-中引入-pb-模块"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">mod pb;

pub use pb::abi::*;
</code></pre></pre>
</div>
</details>
<p>这样，我们就有了能把 KV server 最基本的 protobuf 接口运转起来的代码。</p>
<details id="admonition-使用示例examples" class="admonition example">
<summary class="admonition-title">
<p>使用示例：examples</p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-使用示例examples"></a></p>
</summary>
<div>
<p>在根目录下创建 examples，这样可以写一些代码测试客户端和服务器之间的协议。</p>
<ol>
<li>我们可以先创建一个 examples/client.rs 文件，写入如下代码：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use async_prost::AsyncProstStream;
use futures::prelude::*;
use kv::{CommandRequest, CommandResponse};
use tokio::net::TcpStream;
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();

    let addr = &quot;127.0.0.1:9527&quot;;
    // 连接服务器
    let stream = TcpStream::connect(addr).await?;

    // 使用 AsyncProstStream 来处理 TCP Frame
    let mut client =
        AsyncProstStream::&lt;_, CommandResponse, CommandRequest, _&gt;::from(stream).for_async();

    // 生成一个 HSET 命令
    let cmd = CommandRequest::new_hset(&quot;table1&quot;, &quot;hello&quot;, &quot;world&quot;.into());

    // 发送 HSET 命令
    client.send(cmd).await?;
    if let Some(Ok(data)) = client.next().await {
        info!(&quot;Got response {:?}&quot;, data);
    }

    Ok(())
}
</code></pre></pre>
<p>这段代码连接服务器的 9527 端口，发送一个 HSET 命令出去，然后等待服务器的响应。</p>
<ol start="2">
<li>同样的，我们创建一个 examples/dummy_server.rs 文件，写入代码：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use async_prost::AsyncProstStream;
use futures::prelude::*;
use kv::{CommandRequest, CommandResponse};
use tokio::net::TcpListener;
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();
    let addr = &quot;127.0.0.1:9527&quot;;
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Start listening on {}&quot;, addr);
    loop {
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Client {:?} connected&quot;, addr);
        tokio::spawn(async move {
            let mut stream =
                AsyncProstStream::&lt;_, CommandRequest, CommandResponse, _&gt;::from(stream).for_async();
            while let Some(Ok(msg)) = stream.next().await {
                info!(&quot;Got a new command: {:?}&quot;, msg);
                // 创建一个 404 response 返回给客户端
                let mut resp = CommandResponse::default();
                resp.status = 404;
                resp.message = &quot;Not found&quot;.to_string();
                stream.send(resp).await.unwrap();
            }
            info!(&quot;Client {:?} disconnected&quot;, addr);
        });
    }
}
</code></pre></pre>
</div>
</details>
<p>在这段代码里，服务器监听 9527 端口，对任何客户端的请求，一律返回 status = 404，message 是 “Not found” 的响应。</p>
<p>如果你对这两段代码中的异步和网络处理半懂不懂，没关系，你先把代码抄下来运行。今天的内容跟网络无关，你重点看处理流程就行。未来会讲到网络和异步处理的。</p>
<details id="admonition-运行测试" class="admonition success">
<summary class="admonition-title">
<p>运行测试 </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-运行测试"></a></p>
</summary>
<div>
<p>我们可以打开一个命令行窗口，运行：</p>
<pre><code class="language-shell">RUST_LOG=info cargo run --example dummy_server --quiet。
</code></pre>
<p>然后在另一个命令行窗口，运行：</p>
<pre><pre class="playground"><code class="language-rust  editable">RUST_LOG=info cargo run --example client --quiet
</code></pre></pre>
<p>此时，服务器和客户端都收到了彼此的请求和响应，协议层看上去运作良好。一旦验证通过，就你可以进入下一步，因为协议层的其它代码都只是工作量而已，在之后需要的时候可以慢慢实现。</p>
</div>
</details>
<h2 id="实现并验证-storage-trait"><a class="header" href="#实现并验证-storage-trait">实现并验证 Storage trait</a></h2>
<p>接下来构建 Storage trait。</p>
<p>我们上一讲谈到了如何使用嵌套的支持并发的 im-memory HashMap 来实现 storage trait。由于 Arc&lt;RwLock&lt;HashMap&lt;K, V&gt;&gt;&gt; 这样的支持并发的 HashMap 是一个刚需，Rust
生态有很多相关的 crate 支持，这里我们可以使用 dashmap 创建一个 MemTable 结构，来实现 Storage trait。</p>
<details id="admonition-实现" class="admonition note">
<summary class="admonition-title">
<p>实现 </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-实现"></a></p>
</summary>
<div>
<ol>
<li>先创建 src/storage 目录</li>
<li>然后创建 src/storage/mod.rs，把刚才讨论的 trait 代码放进去后</li>
<li>在 src/lib.rs 中引入 “mod storage”。此时会发现一个错误：并未定义 KvError。</li>
<li>创建 src/error.rs，使用<a href="https://github.com/dtolnay/thiserror">thiserror</a>的派生宏自定义错误类型，然后填入：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::Value;
use thiserror::Error;

#[derive(Error, Debug, PartialEq)]
pub enum KvError {
    #[error(&quot;Not found for table: {0}, key: {1}&quot;)]
    NotFound(String, String),

    #[error(&quot;Cannot parse command: `{0}`&quot;)]
    InvalidCommand(String),
    #[error(&quot;Cannot convert value {:0} to {1}&quot;)]
    ConvertError(Value, &amp;'static str),
    #[error(&quot;Cannot process command {0} with table: {1}, key: {2}. Error: {}&quot;)]
    StorageError(&amp;'static str, String, String, String),

    #[error(&quot;Failed to encode protobuf message&quot;)]
    EncodeError(#[from] prost::EncodeError),
    #[error(&quot;Failed to decode protobuf message&quot;)]
    DecodeError(#[from] prost::DecodeError),

    #[error(&quot;Internal error: {0}&quot;)]
    Internal(String),
}
</code></pre></pre>
<p>这些 error 的定义其实是在实现过程中逐步添加的，但为了讲解方便，先一次性添加。对于 Storage 的实现，我们只关心 StorageError，其它的 error 定义未来会用到。</p>
<ol start="5">
<li>同样，在 src/lib.rs 下引入 mod error，现在 src/lib.rs 是这个样子的：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
mod error;
mod pb;
mod storage;

pub use error::KvError;
pub use pb::abi::*;
pub use storage::*;
</code></pre></pre>
<p>src/storage/mod.rs 是这个样子的：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::{KvError, Kvpair, Value};

/// 对存储的抽象，我们不关心数据存在哪儿，但需要定义外界如何和存储打交道
pub trait Storage {
    /// 从一个 HashTable 里获取一个 key 的 value
    fn get(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;
    /// 从一个 HashTable 里设置一个 key 的 value，返回旧的 value
    fn set(&amp;self, table: &amp;str, key: String, value: Value) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;
    /// 查看 HashTable 中是否有 key
    fn contains(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;bool, KvError&gt;;
    /// 从 HashTable 中删除一个 key
    fn del(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;
    /// 遍历 HashTable，返回所有 kv pair（这个接口不好）
    fn get_all(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;Kvpair&gt;, KvError&gt;;
    /// 遍历 HashTable，返回 kv pair 的 Iterator
    fn get_iter(&amp;self, table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt;;
}
</code></pre></pre>
</div>
</details>
<details id="admonition-成功-通过-storage-trait-已经大概知道-memtable-怎么用所以可以先写段测试体验一下" class="admonition success">
<summary class="admonition-title">
<p>成功： 通过 Storage trait 已经大概知道 MemTable 怎么用，所以可以先写段测试体验一下 </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-成功-通过-storage-trait-已经大概知道-memtable-怎么用所以可以先写段测试体验一下"></a></p>
</summary>
<div>
<p>代码目前没有编译错误，可以在这个文件末尾添加测试代码，尝试使用这些接口了，当然，我们还没有构建 MemTable，但通过 Storage trait 已经大概知道 MemTable 怎么用，所以可以先写段测试体验一下：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn memtable_basic_interface_should_work() {
        let store = MemTable::new();
        test_basi_interface(store);
    }

    #[test]
    fn memtable_get_all_should_work() {
        let store = MemTable::new();
        test_get_all(store);
    }

    fn test_basi_interface(store: impl Storage) {
        // 第一次 set 会创建 table，插入 key 并返回 None（之前没值）
        let v = store.set(&quot;t1&quot;, &quot;hello&quot;.into(), &quot;world&quot;.into());
        assert!(v.unwrap().is_none());
        // 再次 set 同样的 key 会更新，并返回之前的值
        let v1 = store.set(&quot;t1&quot;, &quot;hello&quot;.into(), &quot;world1&quot;.into());
        assert_eq!(v1, Ok(Some(&quot;world&quot;.into())));

        // get 存在的 key 会得到最新的值
        let v = store.get(&quot;t1&quot;, &quot;hello&quot;);
        assert_eq!(v, Ok(Some(&quot;world1&quot;.into())));

        // get 不存在的 key 或者 table 会得到 None
        assert_eq!(Ok(None), store.get(&quot;t1&quot;, &quot;hello1&quot;));
        assert!(store.get(&quot;t2&quot;, &quot;hello1&quot;).unwrap().is_none());

        // contains 纯在的 key 返回 true，否则 false
        assert_eq!(store.contains(&quot;t1&quot;, &quot;hello&quot;), Ok(true));
        assert_eq!(store.contains(&quot;t1&quot;, &quot;hello1&quot;), Ok(false));
        assert_eq!(store.contains(&quot;t2&quot;, &quot;hello&quot;), Ok(false));

        // del 存在的 key 返回之前的值
        let v = store.del(&quot;t1&quot;, &quot;hello&quot;);
        assert_eq!(v, Ok(Some(&quot;world1&quot;.into())));

        // del 不存在的 key 或 table 返回 None
        assert_eq!(Ok(None), store.del(&quot;t1&quot;, &quot;hello1&quot;));
        assert_eq!(Ok(None), store.del(&quot;t2&quot;, &quot;hello&quot;));
    }

    fn test_get_all(store: impl Storage) {
        store.set(&quot;t2&quot;, &quot;k1&quot;.into(), &quot;v1&quot;.into()).unwrap();
        store.set(&quot;t2&quot;, &quot;k2&quot;.into(), &quot;v2&quot;.into()).unwrap();
        let mut data = store.get_all(&quot;t2&quot;).unwrap();
        data.sort_by(|a, b| a.partial_cmp(b).unwrap());
        assert_eq!(
            data,
            vec![
                Kvpair::new(&quot;k1&quot;, &quot;v1&quot;.into()),
                Kvpair::new(&quot;k2&quot;, &quot;v2&quot;.into())
            ]
        )
    }

    fn test_get_iter(store: impl Storage) {
        store.set(&quot;t2&quot;, &quot;k1&quot;.into(), &quot;v1&quot;.into()).unwrap();
        store.set(&quot;t2&quot;, &quot;k2&quot;.into(), &quot;v2&quot;.into()).unwrap();
        let mut data: Vec&lt;_&gt; = store.get_iter(&quot;t2&quot;).unwrap().collect();
        data.sort_by(|a, b| a.partial_cmp(b).unwrap());
        assert_eq!(
            data,
            vec![
                Kvpair::new(&quot;k1&quot;, &quot;v1&quot;.into()),
                Kvpair::new(&quot;k2&quot;, &quot;v2&quot;.into())
            ]
        )
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-这种在写实现之前写单元测试是标准的-tddtest-driven-development方式" class="admonition quote">
<summary class="admonition-title">
<p>这种在写实现之前写单元测试，是标准的 TDD（Test-Driven Development）方式。 </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-这种在写实现之前写单元测试是标准的-tddtest-driven-development方式"></a></p>
</summary>
<div>
<p>这种在写实现之前写单元测试，是标准的 TDD（Test-Driven Development）方式。</p>
<p>我个人不是 TDD 的狂热粉丝，但会在构建完 trait 后，为这个 trait 撰写测试代码，因为写测试代码是个很好的验证接口是否好用的时机。毕竟我们不希望实现 trait 之后，才发现 trait 的定义有瑕疵，需要修改，这个时候改动的代价就比较大了。</p>
<p>所以，当 trait 推敲完毕，就可以开始写使用 trait 的测试代码了。在使用过程中仔细感受，如果写测试用例时用得不舒服，或者为了使用它需要做很多繁琐的操作，那么可以重新审视 trait 的设计。</p>
<p>你如果仔细看单元测试的代码，就会发现我始终秉持测试 trait 接口的思想。尽管在测试中需要一个实际的数据结构进行 trait 方法的测试，但核心的测试代码都用的泛型函数，让这些代码只跟 trait 相关。</p>
<p>这样:</p>
<ul>
<li>一来可以避免某个具体 trait 实现的干扰</li>
<li>二来在之后想加入更多 trait 实现时，可以共享测试代码。</li>
<li>比如未来想支持 DiskTable，那么只消加几个测试例，调用已有的泛型函数即可。</li>
</ul>
</div>
</details>
<p>好，搞定测试，确认 trait 设计没有什么问题之后，我们来写具体实现。</p>
<h3 id="构建memtable"><a class="header" href="#构建memtable">构建MemTable</a></h3>
<details id="admonition-可以创建-srcstoragememoryrs-来构建-memtable" class="admonition note">
<summary class="admonition-title">
<p>可以创建 src/storage/memory.rs 来构建 MemTable： </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-可以创建-srcstoragememoryrs-来构建-memtable"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::{KvError, Kvpair, Storage, Value};
use dashmap::{mapref::one::Ref, DashMap};

/// 使用 DashMap 构建的 MemTable，实现了 Storage trait
#[derive(Clone, Debug, Default)]
pub struct MemTable {
    tables: DashMap&lt;String, DashMap&lt;String, Value&gt;&gt;,
}

impl MemTable {
    /// 创建一个缺省的 MemTable
    pub fn new() -&gt; Self {
        Self::default()
    }

    /// 如果名为 name 的 hash table 不存在，则创建，否则返回
    fn get_or_create_table(&amp;self, name: &amp;str) -&gt; Ref&lt;String, DashMap&lt;String, Value&gt;&gt; {
        match self.tables.get(name) {
            Some(table) =&gt; table,
            None =&gt; {
                let entry = self.tables.entry(name.into()).or_default();
                entry.downgrade()
            }
        }
    }
}

impl Storage for MemTable {
    fn get(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {
        let table = self.get_or_create_table(table);
        Ok(table.get(key).map(|v| v.value().clone()))
    }

    fn set(&amp;self, table: &amp;str, key: String, value: Value) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {
        let table = self.get_or_create_table(table);
        Ok(table.insert(key, value))
    }

    fn contains(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;bool, KvError&gt; {
        let table = self.get_or_create_table(table);
        Ok(table.contains_key(key))
    }

    fn del(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {
        let table = self.get_or_create_table(table);
        Ok(table.remove(key).map(|(_k, v)| v))
    }

    fn get_all(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;Kvpair&gt;, KvError&gt; {
        let table = self.get_or_create_table(table);
        Ok(table
            .iter()
            .map(|v| Kvpair::new(v.key(), v.value().clone()))
            .collect())
    }

    fn get_iter(&amp;self, _table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt; {
        todo!()
    }
}
</code></pre></pre>
<ol>
<li>
<p>除了 get_iter() 外，这个实现代码非常简单，相信你看一下 dashmap 的文档，也能很快写出来。</p>
</li>
<li>
<p>get_iter() 写起来稍微有些难度，我们先放下不表，后面讲。</p>
</li>
<li>
<p>如果你对此感兴趣，想挑战一下，欢迎尝试。</p>
</li>
</ol>
</div>
</details>
<p>实现完成之后，我们可以测试它是否符合预期。</p>
<details id="admonition-警告-要在-srcstoragemodrs-开头添加代码" class="admonition warning">
<summary class="admonition-title">
<p>警告⚠️： 要在 src/storage/mod.rs 开头添加代码 </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-警告-要在-srcstoragemodrs-开头添加代码"></a></p>
</summary>
<div>
<p>注意现在 src/storage/memory.rs 还没有被添加，所以 cargo 并不会编译它。要在 src/storage/mod.rs 开头添加代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">mod memory;

pub use memory::MemTable;
</code></pre></pre>
<p>这样代码就可以编译通过了。因为还没有实现 get_iter 方法，所以这个测试需要被注释掉：</p>
<pre><pre class="playground"><code class="language-rust  editable">// #[test]

// fn memtable_iter_should_work() {

// let store = MemTable::new();

// test_get_iter(store);

// }
</code></pre></pre>
</div>
</details>
<h3 id="测试"><a class="header" href="#测试">测试</a></h3>
<details id="admonition-如果你运行-cargo-test-可以看到测试都通过了" class="admonition success">
<summary class="admonition-title">
<p>如果你运行 cargo test ，可以看到测试都通过了：</p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-如果你运行-cargo-test-可以看到测试都通过了"></a></p>
</summary>
<div>
<pre><code class="language-shell">\&gt; cargo test

Compiling kv v0.1.0 (/Users/tchen/projects/mycode/rust/geek-time-rust-resources/21/kv)

Finished test [unoptimized + debuginfo] target(s) in 1.95s

Running unittests (/Users/tchen/.target/debug/deps/kv-8d746b0f387a5271)

running 2 tests

test storage::tests::memtable_basic_interface_should_work ... ok

test storage::tests::memtable_get_all_should_work ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in0.00s

Doc-tests kv

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in0.00s
</code></pre>
</div>
</details>
<h2 id="实现并验证-commandservice-trait"><a class="header" href="#实现并验证-commandservice-trait">实现并验证 CommandService trait</a></h2>
<details id="admonition-笔记-storage-trait-我们就算基本验证通过了现在再来验证-commandservice" class="admonition note">
<summary class="admonition-title">
<p>笔记： Storage trait 我们就算基本验证通过了，现在再来验证 CommandService </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-笔记-storage-trait-我们就算基本验证通过了现在再来验证-commandservice"></a></p>
</summary>
<div>
<p>Storage trait 我们就算基本验证通过了，现在再来验证 CommandService。</p>
<ol>
<li>我们创建 src/service 目录</li>
<li>以及 src/service/mod.rs </li>
<li>和 src/service/command_service.rs 文件</li>
<li>并在 src/service/mod.rs 写入：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::*;

mod command_service;

/// 对 Command 的处理的抽象
pub trait CommandService {
    /// 处理 Command，返回 Response
    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse;
}
</code></pre></pre>
<ol start="5">
<li>
<p>然后，在 src/service/command_service.rs 中，我们可以先写一些测试</p>
<p>为了简单起见，就列 HSET、HGET、HGETALL 三个命令：</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::*;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::command_request::RequestData;

    #[test]
    fn hset_should_work() {
        let store = MemTable::new();
        let cmd = CommandRequest::new_hset(&quot;t1&quot;, &quot;hello&quot;, &quot;world&quot;.into());
        let res = dispatch(cmd.clone(), &amp;store);
        assert_res_ok(res, &amp;[Value::default()], &amp;[]);

        let res = dispatch(cmd, &amp;store);
        assert_res_ok(res, &amp;[&quot;world&quot;.into()], &amp;[]);
    }

    #[test]
    fn hget_should_work() {
        let store = MemTable::new();
        let cmd = CommandRequest::new_hset(&quot;score&quot;, &quot;u1&quot;, 10.into());
        dispatch(cmd, &amp;store);
        let cmd = CommandRequest::new_hget(&quot;score&quot;, &quot;u1&quot;);
        let res = dispatch(cmd, &amp;store);
        assert_res_ok(res, &amp;[10.into()], &amp;[]);
    }

    #[test]
    fn hget_with_non_exist_key_should_return_404() {
        let store = MemTable::new();
        let cmd = CommandRequest::new_hget(&quot;score&quot;, &quot;u1&quot;);
        let res = dispatch(cmd, &amp;store);
        assert_res_error(res, 404, &quot;Not found&quot;);
    }

    #[test]
    fn hgetall_should_work() {
        let store = MemTable::new();
        let cmds = vec![
            CommandRequest::new_hset(&quot;score&quot;, &quot;u1&quot;, 10.into()),
            CommandRequest::new_hset(&quot;score&quot;, &quot;u2&quot;, 8.into()),
            CommandRequest::new_hset(&quot;score&quot;, &quot;u3&quot;, 11.into()),
            CommandRequest::new_hset(&quot;score&quot;, &quot;u1&quot;, 6.into()),
        ];
        for cmd in cmds {
            dispatch(cmd, &amp;store);
        }

        let cmd = CommandRequest::new_hgetall(&quot;score&quot;);
        let res = dispatch(cmd, &amp;store);
        let pairs = &amp;[
            Kvpair::new(&quot;u1&quot;, 6.into()),
            Kvpair::new(&quot;u2&quot;, 8.into()),
            Kvpair::new(&quot;u3&quot;, 11.into()),
        ];
        assert_res_ok(res, &amp;[], pairs);
    }

    // 从 Request 中得到 Response，目前处理 HGET/HGETALL/HSET
    fn dispatch(cmd: CommandRequest, store: &amp;impl Storage) -&gt; CommandResponse {
        match cmd.request_data.unwrap() {
            RequestData::Hget(v) =&gt; v.execute(store),
            RequestData::Hgetall(v) =&gt; v.execute(store),
            RequestData::Hset(v) =&gt; v.execute(store),
            _ =&gt; todo!(),
        }
    }

    // 测试成功返回的结果
    fn assert_res_ok(mut res: CommandResponse, values: &amp;[Value], pairs: &amp;[Kvpair]) {
        res.pairs.sort_by(|a, b| a.partial_cmp(b).unwrap());
        assert_eq!(res.status, 200);
        assert_eq!(res.message, &quot;&quot;);
        assert_eq!(res.values, values);
        assert_eq!(res.pairs, pairs);
    }

    // 测试失败返回的结果
    fn assert_res_error(res: CommandResponse, code: u32, msg: &amp;str) {
        assert_eq!(res.status, code);
        assert!(res.message.contains(msg));
        assert_eq!(res.values, &amp;[]);
        assert_eq!(res.pairs, &amp;[]);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-这些测试的作用就是验证产品需求比如" class="admonition tip">
<summary class="admonition-title">
<p>这些测试的作用就是验证产品需求，比如</p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-这些测试的作用就是验证产品需求比如"></a></p>
</summary>
<div>
<blockquote>
<p>这些测试的作用就是验证产品需求，比如：</p>
</blockquote>
<ul>
<li>
<p>HSET 成功返回上一次的值（这和 Redis 略有不同，Redis 返回表示多少 key 受影响的一个整数）</p>
</li>
<li>
<p>HGET 返回 Value</p>
</li>
<li>
<p>HGETALL 返回一组无序的 Kvpair</p>
</li>
</ul>
</div>
</details>
<details id="admonition-目前这些测试是无法编译通过的因为里面使用了一些未定义的方法" class="admonition failure">
<summary class="admonition-title">
<p>目前这些测试是无法编译通过的，因为里面使用了一些未定义的方法</p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-目前这些测试是无法编译通过的因为里面使用了一些未定义的方法"></a></p>
</summary>
<div>
<blockquote>
<p>目前这些测试是无法编译通过的，因为里面使用了一些未定义的方法，比如</p>
</blockquote>
<ul>
<li>10.into()：想把整数 10 转换成一个 Value</li>
<li>CommandRequest::new_hgetall(“score”)：想生成一个 HGETALL 命令。</li>
</ul>
</div>
</details>
<h3 id="为什么要这么写"><a class="header" href="#为什么要这么写">为什么要这么写？</a></h3>
<details id="admonition-因为如果是-commandservice-接口的使用者自然希望使用这个接口的时候调用的整体感觉非常简单明了" class="admonition abstract">
<summary class="admonition-title">
<p>因为如果是 CommandService 接口的使用者，自然希望使用这个接口的时候，调用的整体感觉非常简单明了 </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-因为如果是-commandservice-接口的使用者自然希望使用这个接口的时候调用的整体感觉非常简单明了"></a></p>
</summary>
<div>
<p>因为如果是 CommandService 接口的使用者，自然希望使用这个接口的时候，调用的整体感觉非常简单明了。</p>
<p>如果接口期待一个 Value，但在上下文中拿到的是 10、“hello” 这样的值，那我们作为设计者就要考虑为 Value 实现 From<T>，这样调用的时候最方便。同样的，对于生成 CommandRequest 这个数据结构，也可以添加一些辅助函数，来让调用更清晰。</p>
<blockquote>
<p>到现在为止我们写了两轮测试了，相信你对测试代码的作用有大概理解。我们来总结一下：</p>
</blockquote>
<ol>
<li>验证并帮助接口迭代</li>
<li>验证产品需求</li>
<li>通过使用核心逻辑，帮助我们更好地思考外围逻辑并反推其实现</li>
</ol>
<blockquote>
<p>前两点是最基本的，也是很多人对 TDD 的理解，其实还有更重要的也就是第三点。除了前面的辅助函数外，我们在测试代码中还看到了 dispatch 函数，它目前用来辅助测试。但紧接着你会发现，这样的辅助函数，可以合并到核心代码中。这才是“测试驱动开发”的实质。</p>
</blockquote>
</div>
</details>
<h3 id="在-srcpbmodrs-中添加相关的外围逻辑"><a class="header" href="#在-srcpbmodrs-中添加相关的外围逻辑">在 src/pb/mod.rs 中添加相关的外围逻辑</a></h3>
<details id="admonition-笔记好根据测试我们需要在-srcpbmodrs-中添加相关的外围逻辑" class="admonition note">
<summary class="admonition-title">
<p>笔记：好，根据测试，我们需要在 src/pb/mod.rs 中添加相关的外围逻辑</p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-笔记好根据测试我们需要在-srcpbmodrs-中添加相关的外围逻辑"></a></p>
</summary>
<div>
<ol>
<li>首先是 CommandRequest 的一些方法，之前写了 new_hset，现在再加入 new_hget 和 new_hgetall：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
impl CommandRequest {
    /// 创建 HGET 命令
    pub fn new_hget(table: impl Into&lt;String&gt;, key: impl Into&lt;String&gt;) -&gt; Self {
        Self {
            request_data: Some(RequestData::Hget(Hget {
                table: table.into(),
                key: key.into(),
            })),
        }
    }

    /// 创建 HGETALL 命令
    pub fn new_hgetall(table: impl Into&lt;String&gt;) -&gt; Self {
        Self {
            request_data: Some(RequestData::Hgetall(Hgetall {
                table: table.into(),
            })),
        }
    }

    /// 创建 HSET 命令
    pub fn new_hset(table: impl Into&lt;String&gt;, key: impl Into&lt;String&gt;, value: Value) -&gt; Self {
        Self {
            request_data: Some(RequestData::Hset(Hset {
                table: table.into(),
                pair: Some(Kvpair::new(key, value)),
            })),
        }
    }
}
</code></pre></pre>
<ol start="2">
<li>然后写对 Value 的 From<i64> 的实现：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
/// 从 i64转换成 Value
impl From&lt;i64&gt; for Value {
    fn from(i: i64) -&gt; Self {
        Self {
            value: Some(value::Value::Integer(i)),
        }
    }
}
</code></pre></pre>
<ol start="3">
<li>测试代码目前就可以编译通过了，然而测试显然会失败，因为还没有做具体的实现。我们在 src/service/command_service.rs 下添加 trait 的实现代码：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
impl CommandService for Hget {
    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {
        match store.get(&amp;self.table, &amp;self.key) {
            Ok(Some(v)) =&gt; v.into(),
            Ok(None) =&gt; KvError::NotFound(self.table, self.key).into(),
            Err(e) =&gt; e.into(),
        }
    }
}

impl CommandService for Hgetall {
    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {
        match store.get_all(&amp;self.table) {
            Ok(v) =&gt; v.into(),
            Err(e) =&gt; e.into(),
        }
    }
}

impl CommandService for Hset {
    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {
        match self.pair {
            Some(v) =&gt; match store.set(&amp;self.table, v.key, v.value.unwrap_or_default()) {
                Ok(Some(v)) =&gt; v.into(),
                Ok(None) =&gt; Value::default().into(),
                Err(e) =&gt; e.into(),
            },
            None =&gt; Value::default().into(),
        }
    }
}
</code></pre></pre>
<blockquote>
<p>这自然会引发更多的编译错误，因为我们很多地方都是用了 into() 方法，却没有实现相应的转换，比如，Value 到 CommandResponse 的转换、KvError 到 CommandResponse 的转换、Vec<Kvpair> 到 CommandResponse 的转换等等。</p>
</blockquote>
<ol start="4">
<li>所以在 src/pb/mod.rs 里继续补上相应的外围逻辑：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
/// 从 Value 转换成 CommandResponse
impl From&lt;Value&gt; for CommandResponse {
    fn from(v: Value) -&gt; Self {
        Self {
            status: StatusCode::OK.as_u16() as _,
            values: vec![v],
            ..Default::default()
        }
    }
}

/// 从 Vec&lt;Kvpair&gt; 转换成 CommandResponse
impl From&lt;Vec&lt;Kvpair&gt;&gt; for CommandResponse {
    fn from(v: Vec&lt;Kvpair&gt;) -&gt; Self {
        Self {
            status: StatusCode::OK.as_u16() as _,
            pairs: v,
            ..Default::default()
        }
    }
}

/// 从 KvError 转换成 CommandResponse
impl From&lt;KvError&gt; for CommandResponse {
    fn from(e: KvError) -&gt; Self {
        let mut result = Self {
            status: StatusCode::INTERNAL_SERVER_ERROR.as_u16() as _,
            message: e.to_string(),
            values: vec![],
            pairs: vec![],
        };

        match e {
            KvError::NotFound(_, _) =&gt; result.status = StatusCode::NOT_FOUND.as_u16() as _,
            KvError::InvalidCommand(_) =&gt; result.status = StatusCode::BAD_REQUEST.as_u16() as _,
            _ =&gt; {}
        }

        result
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-into和struct绕过孤儿原则" class="admonition quote">
<summary class="admonition-title">
<p>into()和struct绕过孤儿原则 </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-into和struct绕过孤儿原则"></a></p>
</summary>
<div>
<p>从前面写接口到这里具体实现，不知道你是否感受到了这样一种模式：</p>
<ul>
<li>在 Rust 下，但凡出现两个数据结构 v1 到 v2 的转换，你都可以先以 v1.into() 来表示这个逻辑，继续往下写代码</li>
<li>之后再去补 From<T> 的实现</li>
<li>如果 v1 和 v2 都不是你定义的数据结构，那么你需要把其中之一用 struct 包装一下，来绕过之前提到的孤儿规则。</li>
</ul>
</div>
</details>
<blockquote>
<p>现在代码应该可以编译通过并测试通过了，你可以 cargo test 测试一下。</p>
</blockquote>
<h2 id="最后的拼图service-结构的实现"><a class="header" href="#最后的拼图service-结构的实现">最后的拼图：Service 结构的实现</a></h2>
<p>好，所有的接口，包括客户端 / 服务器的协议接口、Storage trait 和 CommandService trait 都验证好了，接下来就是考虑如何用一个数据结构把所有这些东西串联起来。</p>
<details id="admonition-笔记-依旧从使用者的角度来看如何调用它为此我们在-srcservicemodrs-里添加如下的测试代码" class="admonition note">
<summary class="admonition-title">
<p>笔记： 依旧从使用者的角度来看如何调用它。为此，我们在 src/service/mod.rs 里添加如下的测试代码：</p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-笔记-依旧从使用者的角度来看如何调用它为此我们在-srcservicemodrs-里添加如下的测试代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
mod tests {
    use super::*;
    use crate::{MemTable, Value};

    #[test]
    fn service_should_works() {
        // 我们需要一个 service 结构至少包含 Storage
        let service = Service::new(MemTable::default());

        // service 可以运行在多线程环境下，它的 clone 应该是轻量级的
        let cloned = service.clone();

        // 创建一个线程，在 table t1 中写入 k1, v1
        let handle = thread::spawn(move || {
            let res = cloned.execute(CommandRequest::new_hset(&quot;t1&quot;, &quot;k1&quot;, &quot;v1&quot;.into()));
            assert_res_ok(res, &amp;[Value::default()], &amp;[]);
        });
        handle.join().unwrap();

        // 在当前线程下读取 table t1 的 k1，应该返回 v1
        let res = service.execute(CommandRequest::new_hget(&quot;t1&quot;, &quot;k1&quot;));
        assert_res_ok(res, &amp;[&quot;v1&quot;.into()], &amp;[]);
    }
}

#[cfg(test)]
use crate::{Kvpair, Value};

// 测试成功返回的结果
#[cfg(test)]
pub fn assert_res_ok(mut res: CommandResponse, values: &amp;[Value], pairs: &amp;[Kvpair]) {
    res.pairs.sort_by(|a, b| a.partial_cmp(b).unwrap());
    assert_eq!(res.status, 200);
    assert_eq!(res.message, &quot;&quot;);
    assert_eq!(res.values, values);
    assert_eq!(res.pairs, pairs);
}

// 测试失败返回的结果
#[cfg(test)]
pub fn assert_res_error(res: CommandResponse, code: u32, msg: &amp;str) {
    assert_eq!(res.status, code);
    assert!(res.message.contains(msg));
    assert_eq!(res.values, &amp;[]);
    assert_eq!(res.pairs, &amp;[]);
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>注意，这里的 assert_res_ok() 和 assert_res_error() 是从 src/service/command_service.rs 中挪过来的。在开发的过程中，不光产品代码需要不断重构，测试代码也需要重构来贯彻
DRY 思想。</p>
</blockquote>
<h3 id="围绕接口测试"><a class="header" href="#围绕接口测试">围绕接口测试</a></h3>
<details id="admonition-提示那什么样的测试代码是稳定的测试接口的代码是稳定的" class="admonition tip">
<summary class="admonition-title">
<p>提示：那什么样的测试代码是稳定的？测试接口的代码是稳定的。</p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-提示那什么样的测试代码是稳定的测试接口的代码是稳定的"></a></p>
</summary>
<div>
<p>我见过很多生产环境的代码，产品功能部分还说得过去，但测试代码像是个粪坑，经年累月地 copy/paste 使其臭气熏天，每个开发者在添加新功能的时候，都掩着鼻子往里扔一坨走人，使得维护难度越来越高，每次需求变动，都涉及一大坨测试代码的变动，这样非常不好。</p>
<p>测试代码的质量也要和产品代码的质量同等要求。好的开发者写的测试代码的可读性也是非常强的。你可以对比上面写的三段测试代码多多感受。</p>
<p>在撰写测试的时候，我们要特别注意：测试代码要围绕着系统稳定的部分，也就是接口，来测试，而尽可能少地测试实现。这是我对这么多年工作中血淋淋的教训的深刻总结。</p>
<p>因为产品代码和测试代码，两者总需要一个是相对稳定的，既然产品代码会不断地根据需求变动，测试代码就必然需要稳定一些。</p>
<p>那什么样的测试代码是稳定的？测试接口的代码是稳定的。只要接口不变，无论具体实现如何变化，哪怕今天引入一个新的算法，明天重写实现，测试代码依旧能够凛然不动，做好产品质量的看门狗。</p>
</div>
</details>
<h3 id="继续写代码"><a class="header" href="#继续写代码">继续写代码</a></h3>
<p>好，我们回来写代码。在这段测试中，已经敲定了 Service 这个数据结构的使用蓝图，它可以跨线程，可以调用 execute 来执行某个 CommandRequest 命令，返回 CommandResponse。</p>
<details id="admonition-根据这些想法在-srcservicemodrs-里添加-service-的声明和实现" class="admonition note">
<summary class="admonition-title">
<p>根据这些想法，在 src/service/mod.rs 里添加 Service 的声明和实现：</p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-根据这些想法在-srcservicemodrs-里添加-service-的声明和实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
/// Service 数据结构
pub struct Service&lt;Store = MemTable&gt; {
    inner: Arc&lt;ServiceInner&lt;Store&gt;&gt;,
}

impl&lt;Store&gt; Clone for Service&lt;Store&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self {
      inner: Arc::clone(&amp;self.inner),
        }
    }
}

/// Service 内部数据结构
pub struct ServiceInner&lt;Store&gt; {
    store: Store,
}

impl&lt;Store: Storage&gt; Service&lt;Store&gt; {
    pub fn new(store: Store) -&gt; Self {
        Self {
            inner: Arc::new(ServiceInner { store }),
        }
    }

    pub fn execute(&amp;self, cmd: CommandRequest) -&gt; CommandResponse {
        debug!(&quot;Got request: {:?}&quot;, cmd);
        // TODO: 发送 on_received 事件
        let res = dispatch(cmd, &amp;self.inner.store);
        debug!(&quot;Executed response: {:?}&quot;, res);
        // TODO: 发送 on_executed 事件

        res
    }
}

// 从 Request 中得到 Response，目前处理 HGET/HGETALL/HSET
pub fn dispatch(cmd: CommandRequest, store: &amp;impl Storage) -&gt; CommandResponse {
    match cmd.request_data {
        Some(RequestData::Hget(param)) =&gt; param.execute(store),
        Some(RequestData::Hgetall(param)) =&gt; param.execute(store),
        Some(RequestData::Hset(param)) =&gt; param.execute(store),
        None =&gt; KvError::InvalidCommand(&quot;Request has no data&quot;.into()).into(),
        _ =&gt; KvError::Internal(&quot;Not implemented&quot;.into()).into(),
    }
}
</code></pre></pre>
<blockquote>
<p>这段代码有几个地方值得注意：</p>
</blockquote>
<ul>
<li>
<p>首先 Service 结构内部有一个 ServiceInner 存放实际的数据结构，Service 只是用 Arc 包裹了 ServiceInner。这也是 Rust 的一个惯例，把需要在多线程下 clone 的主体和其内部结构分开，这样代码逻辑更加清晰。</p>
</li>
<li>
<p>execute() 方法目前就是调用了 dispatch，但它未来潜在可以做一些事件分发。这样处理体现了 SRP（Single Responsibility Principle）原则。</p>
</li>
<li>
<p>dispatch 其实就是把测试代码的 dispatch 逻辑移动过来改动了一下。</p>
</li>
</ul>
<blockquote>
<p>再一次，我们重构了测试代码，把它的辅助函数变成了产品代码的一部分。现在，你可以运行 cargo test 测试一下，如果代码无法编译，可能是缺一些 use 代码，比如：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::{
    command_request::RequestData, CommandRequest, CommandResponse, KvError, MemTable, Storage,
};
use std::sync::Arc;
use tracing::debug;
</code></pre></pre>
</div>
</details>
<h2 id="新的-server"><a class="header" href="#新的-server">新的 server</a></h2>
<details id="admonition-现在处理逻辑已经都完成了可以写个新的-example-测试服务器代码" class="admonition note">
<summary class="admonition-title">
<p>现在处理逻辑已经都完成了，可以写个新的 example 测试服务器代码。 </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-现在处理逻辑已经都完成了可以写个新的-example-测试服务器代码"></a></p>
</summary>
<div>
<ol>
<li>把之前的 examples/dummy_server.rs 复制一份，成为 examples/server.rs，然后引入 Service，主要的改动就三句：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
// main 函数开头，初始化 service
let service: Service = Service::new(MemTable::new());
// tokio::spawn 之前，复制一份 service
let svc = service.clone();
// while loop 中，使用 svc 来执行 cmd
let res = svc.execute(cmd);
</code></pre></pre>
<ol start="2">
<li>你可以试着自己修改。完整的代码如下：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use async_prost::AsyncProstStream;
use futures::prelude::*;
use kv::{CommandRequest, CommandResponse, MemTable, Service};
use tokio::net::TcpListener;
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();
    let service: Service = Service::new(MemTable::new());
    let addr = &quot;127.0.0.1:9527&quot;;
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Start listening on {}&quot;, addr);
    loop {
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Client {:?} connected&quot;, addr);
        let svc = service.clone();
        tokio::spawn(async move {
            let mut stream =
                AsyncProstStream::&lt;_, CommandRequest, CommandResponse, _&gt;::from(stream).for_async();
            while let Some(Ok(cmd)) = stream.next().await {
                let res = svc.execute(cmd);
                stream.send(res).await.unwrap();
            }
            info!(&quot;Client {:?} disconnected&quot;, addr);
        });
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="运行"><a class="header" href="#运行">运行</a></h2>
<details id="admonition-使用两个窗口分别模拟服务端与客户端" class="admonition success">
<summary class="admonition-title">
<p>使用两个窗口分别模拟服务端与客户端 </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-使用两个窗口分别模拟服务端与客户端"></a></p>
</summary>
<div>
<p>完成之后，打开一个命令行窗口，运行：</p>
<pre><pre class="playground"><code class="language-rust  editable">RUST_LOG=info cargo run --example server --quiet
</code></pre></pre>
<p>然后在另一个命令行窗口，运行：</p>
<pre><pre class="playground"><code class="language-rust  editable">RUST_LOG=info cargo run --example server --quiet
</code></pre></pre>
</div>
</details>
<p>此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。</p>
<p>我们的 KV server 第一版的基本功能就完工了！当然，目前还只处理了 3 个命令，剩下 6 个需要你自己完成。</p>
<h2 id="初步感受rust撰写代码最佳实践"><a class="header" href="#初步感受rust撰写代码最佳实践">初步感受Rust撰写代码最佳实践</a></h2>
<details id="admonition-有两点我们一定要认真领会" class="admonition quote">
<summary class="admonition-title">
<p>有两点我们一定要认真领会 </p>
<p><a class="admonition-anchor-link" href="kv2_protocols.html#admonition-有两点我们一定要认真领会"></a></p>
</summary>
<div>
<p>KV server 并不是一个很难的项目，但想要把它写好，并不简单。如果你跟着讲解一步步走下来，可以感受到一个有潜在生产环境质量的 Rust 项目应该如何开发。在这两讲内容中，有两点我们一定要认真领会。</p>
<ol>
<li>
<p>你要对需求有一个清晰的把握，找出其中不稳定的部分（variant）和比较稳定的部分（invariant）。在 KV server 中，不稳定的部分是，对各种新的命令的支持，以及对不同的 storage 的支持。所以需要构建接口来消弭不稳定的因素，让不稳定的部分可以用一种稳定的方式来管理。</p>
</li>
<li>
<p>代码和测试可以围绕着接口螺旋前进，使用 TDD 可以帮助我们进行这种螺旋式的迭代。在一个设计良好的系统中：接口是稳定的，测试接口的代码是稳定的，实现可以是不稳定的。在迭代开发的过程中，我们要不断地重构，让测试代码和产品代码都往最优的方向发展。</p>
</li>
</ol>
<p>纵观我们写的 KV server，包括测试在内，你很难发现有函数或者方法超过 50 行，代码可读性非常强，几乎不需要注释，就可以理解。另外因为都是用接口做的交互，未来维护和添加新的功能，也基本上满足 OCP 原则，除了 dispatch 函数需要很小的修改外，其它新的代码都是在实现一些接口而已。</p>
<blockquote>
<p>相信你能初步感受到在 Rust 下撰写代码的最佳实践。如果你之前用其他语言，已经采用了类似的最佳实践，那么可以感受一下同样的实践在 Rust 下使用的那种优雅；如果你之前由于种种原因，写的是类似之前意大利面条似的代码，那在开发 Rust 程序时，你可以试着接纳这种更优雅的开发方式。</p>
</blockquote>
<p>毕竟，现在我们手中有了更先进的武器，就可以用更先进的打法。</p>
</div>
</details>
<h2 id="为剩下6个命令构建测试并实现"><a class="header" href="#为剩下6个命令构建测试并实现">为剩下6个命令构建测试并实现</a></h2>
<p>为剩下 6 个命令 HMGET、HMSET、HDEL、HMDEL、HEXIST、HMEXIST 构建测试，并实现它们。在测试和实现过程中，你也许需要添加更多的 From<T> 的实现。</p>
<h2 id="考虑用线程池处理并发"><a class="header" href="#考虑用线程池处理并发">考虑用线程池处理并发</a></h2>
<p>虽然我们的 KV server 使用了 concurrent hashmap 来处理并发，但这并不一定是最好的选择。</p>
<p>我们也可以创建一个线程池，每个线程有自己的 HashMap。当 HGET/HSET 等命令来临时，可以对 key 做个哈希，然后分派到 “拥有” 那个 key
的线程，这样，可以避免在处理的时候加锁，提高系统的吞吐。你可以想想如果用这种方式处理，该怎么做。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三高级trait技巧"><a class="header" href="#三高级trait技巧">三、高级trait技巧</a></h1>
<!--ts-->
<ul>
<li><a href="kv3_advanced_traits.html#%E4%B8%89%E9%AB%98%E7%BA%A7trait%E6%8A%80%E5%B7%A7">三、高级trait技巧</a>
<ul>
<li><a href="kv3_advanced_traits.html#%E5%A4%84%E7%90%86-iterator">处理 Iterator</a></li>
<li><a href="kv3_advanced_traits.html#%E6%94%AF%E6%8C%81%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5">支持事件通知</a>
<ul>
<li><a href="kv3_advanced_traits.html#%E5%85%88%E7%9C%8B%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C">先看事件处理函数如何注册。</a>
<ul>
<li><a href="kv3_advanced_traits.html#%E6%80%9D%E8%B7%AF">思路</a></li>
<li><a href="kv3_advanced_traits.html#%E5%85%88%E5%86%99%E6%B5%8B%E8%AF%95">先写测试</a></li>
<li><a href="kv3_advanced_traits.html#fn_received%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8">fn_received的链式调用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="kv3_advanced_traits.html#%E4%B8%BA%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0-storage-trait">为持久化数据库实现 Storage trait</a>
<ul>
<li><a href="kv3_advanced_traits.html#%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9">方案选择</a></li>
<li><a href="kv3_advanced_traits.html#%E4%B8%BAsled%E5%AE%9E%E7%8E%B0storage-trait%E5%B9%B6%E6%B5%8B%E8%AF%95%E9%80%9A%E8%BF%87">为sled实现Storage trait，并测试通过</a></li>
</ul>
</li>
<li><a href="kv3_advanced_traits.html#%E6%9E%84%E5%BB%BA%E6%96%B0%E7%9A%84-kv-server">构建新的 KV server</a></li>
<li><a href="kv3_advanced_traits.html#%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A4%E8%AF%86trait%E7%9A%84%E5%A8%81%E5%8A%9B">进一步认识trait的威力</a></li>
<li><a href="kv3_advanced_traits.html#%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E6%9B%B4%E5%A4%9A%E7%94%A8%E4%BA%8E%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81">泛型结构和生命周期标注更多用于阅读源码</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:29 UTC 2022 -->
<!--te-->
<p>前面已经完成了 KV store 的基本功能，但留了两个小尾巴：</p>
<ol>
<li>
<p>Storage trait 的 get_iter() 方法没有实现；</p>
</li>
<li>
<p>Service 的 execute() 方法里面还有一些 TODO，需要处理事件的通知。</p>
</li>
</ol>
<p>我们一个个来解决。先看 get_iter() 方法。</p>
<h2 id="处理-iterator"><a class="header" href="#处理-iterator">处理 Iterator</a></h2>
<details id="admonition-1-在开始撰写代码之前先把之前在-srcstoragemodrs-里注掉的测试加回来" class="admonition note">
<summary class="admonition-title">
<ol>
<li>在开始撰写代码之前，先把之前在 src/storage/mod.rs 里注掉的测试，加回来：</li>
</ol>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-1-在开始撰写代码之前先把之前在-srcstoragemodrs-里注掉的测试加回来"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[test]
fn memtable_iter_should_work() {
    let store = MemTable::new();
    test_get_iter(store);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-2-然后在-srcstorgememoryrs-里尝试实现它" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>然后在 src/storge/memory.rs 里尝试实现它。</li>
</ol>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-2-然后在-srcstorgememoryrs-里尝试实现它"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl Storage for MemTable {
    ...
    fn get_iter(&amp;self, table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt; {
        // 使用 clone() 来获取 table 的 snapshot
        let table = self.get_or_create_table(table).clone();
        let iter = table
            .iter()
            .map(|v| Kvpair::new(v.key(), v.value().clone()));
        Ok(Box::new(iter)) // &lt;-- 编译出错
    }
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>很不幸的，编译器提示我们 Box::new(iter) 不行，“cannot return value referencing local variable table” 。</p>
</blockquote>
<blockquote>
<p>这让人很不爽，究其原因，table.iter() 使用了 table 的引用，我们返回 iter，但 iter 引用了作为局部变量的 table，所以无法编译通过。</p>
</blockquote>
<ol start="3">
<li>此刻，我们需要有一个能够完全占有 table 的迭代器。</li>
</ol>
<details id="admonition---rust-标准库里提供了一个-trait-intoiterator它可以把数据结构的所有权转移到-iterator-中看它的声明代码" class="admonition note">
<summary class="admonition-title">
<ul>
<li>Rust 标准库里提供了一个 trait IntoIterator，它可以把数据结构的所有权转移到 Iterator 中，看它的声明（代码）：</li>
</ul>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition---rust-标准库里提供了一个-trait-intoiterator它可以把数据结构的所有权转移到-iterator-中看它的声明代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;

    fn into_iter(self) -&gt; Self::IntoIter;
}
</code></pre></pre>
</div>
</details>
<ul>
<li>绝大多数的集合类数据结构<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html#implementors">都实现了它</a>。</li>
</ul>
<details id="admonition---dashmap-也实现了它所以我们可以用-tableinto_iter-把-table-的所有权转移给-iter" class="admonition note">
<summary class="admonition-title">
<ul>
<li>DashMap 也实现了它，所以我们可以用 table.into_iter() 把 table 的所有权转移给 iter： </li>
</ul>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition---dashmap-也实现了它所以我们可以用-tableinto_iter-把-table-的所有权转移给-iter"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl Storage for MemTable {
    ...
    fn get_iter(&amp;self, table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt; {
        // 使用 clone() 来获取 table 的 snapshot
        let table = self.get_or_create_table(table).clone();
        let iter = table.into_iter().map(|data| data.into());
        Ok(Box::new(iter))
    }
}
</code></pre></pre>
</div>
</details>
<ul>
<li>这里又遇到了数据转换: 从 DashMap 中 iterate 出来的值 (String, Value) 需要转换成 Kvpair，我们依旧用 into() 来完成这件事。</li>
</ul>
<details id="admonition--为此需要为-kvpair-实现这个简单的-fromtrait" class="admonition note">
<summary class="admonition-title">
<blockquote>
<p>为此，需要为 Kvpair 实现这个简单的 Fromtrait：</p>
</blockquote>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition--为此需要为-kvpair-实现这个简单的-fromtrait"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl From&lt;(String, Value)&gt; for Kvpair {
    fn from(data: (String, Value)) -&gt; Self {
        Kvpair::new(data.0, data.1)
    }
}
</code></pre></pre>
</div>
</details>
<p>这两段代码都放在 src/storage/memory.rs 下。</p>
<p>Bingo！这个代码可以编译通过。现在如果运行 cargo test 进行测试的话，对 get_iter() 接口的测试也能通过。</p>
<ol start="3">
<li>对get_iter()进行抽象</li>
</ol>
<blockquote>
<p>虽然这个代码可以通过测试，并且本身也非常精简，我们还是有必要思考一下，如果以后想为更多的 data store 实现 Storage trait，都会怎样处理 get_iter() 方法？</p>
</blockquote>
<p>我们会：</p>
<ul>
<li>拿到一个关于某个 table 下的拥有所有权的 Iterator</li>
<li>对 Iterator 做 map</li>
<li>将 map 出来的每个 item 转换成 Kvpair</li>
</ul>
<p>这里的第 2 步对于每个 Storage trait 的 get_iter() 方法的实现来说，都是相同的。</p>
<p>有没有可能把它封装起来呢？使得 Storage trait 的实现者只需要提供它们自己的拥有所有权的 Iterator，并对 Iterator 里的 Item 类型提供 Into<Kvpair> ？</p>
<details id="admonition-笔记-这样我们在-srcstoragememoryrs-里对-get_iter-的实现就可以直接使用-storageiter" class="admonition note">
<summary class="admonition-title">
<p>笔记： 这样，我们在 src/storage/memory.rs 里对 get_iter() 的实现，就可以直接使用 StorageIter</p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-笔记-这样我们在-srcstoragememoryrs-里对-get_iter-的实现就可以直接使用-storageiter"></a></p>
</summary>
<div>
<p>来尝试一下，在 src/storage/mod.rs 中，构建一个 StorageIter，并实现 Iterator trait：</p>
<pre><pre class="playground"><code class="language-rust  editable">
/// 提供 Storage iterator，这样 trait 的实现者只需要
/// 把它们的 iterator 提供给 StorageIter，然后它们保证
/// next() 传出的类型实现了 Into&lt;Kvpair&gt; 即可
pub struct StorageIter&lt;T&gt; {
    data: T,
}

impl&lt;T&gt; StorageIter&lt;T&gt; {
    pub fn new(data: T) -&gt; Self {
        Self { data }
    }
}

impl&lt;T&gt; Iterator for StorageIter&lt;T&gt;
where
    T: Iterator,
    T::Item: Into&lt;Kvpair&gt;,
{
    type Item = Kvpair;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.data.next().map(|v| v.into())
    }
}
</code></pre></pre>
<blockquote>
<p>这样，我们在 src/storage/memory.rs 里对 get_iter() 的实现，就可以直接使用 StorageIter 了。</p>
</blockquote>
</div>
</details>
<details id="admonition---不过还要为-dashmap-的-iterator-每次调用-next-得到的值-string-value-做个到-kvpair-的转换" class="admonition note">
<summary class="admonition-title">
<ul>
<li>不过，还要为 DashMap 的 Iterator 每次调用 next() 得到的值 (String, Value) ，做个到 Kvpair 的转换：</li>
</ul>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition---不过还要为-dashmap-的-iterator-每次调用-next-得到的值-string-value-做个到-kvpair-的转换"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl Storage for MemTable {
    ...
    fn get_iter(&amp;self, table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt; {
        // 使用 clone() 来获取 table 的 snapshot
          let table = self.get_or_create_table(table).clone();
          let iter = StorageIter::new(table.into_iter()); // 这行改掉了
          Ok(Box::new(iter))
      }
}
</code></pre></pre>
</div>
</details>
<p>我们可以再次使用 cargo test 测试，同样通过！</p>
<details id="admonition-辛辛苦苦又写了-20-行代码创建了一个新的数据结构就是为了-get_iter-方法里的一行代码改得更漂亮何苦呢" class="admonition abstract">
<summary class="admonition-title">
<p>辛辛苦苦又写了 20 行代码，创建了一个新的数据结构，就是为了 get_iter() 方法里的一行代码改得更漂亮？何苦呢？</p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-辛辛苦苦又写了-20-行代码创建了一个新的数据结构就是为了-get_iter-方法里的一行代码改得更漂亮何苦呢"></a></p>
</summary>
<div>
<p>如果回顾刚才撰写的代码，你可能会哑然一笑：我辛辛苦苦又写了 20 行代码，创建了一个新的数据结构，就是为了 get_iter() 方法里的一行代码改得更漂亮？何苦呢？</p>
<p>的确，在这个 KV server 的例子里，这样的抽象收益不大。</p>
<blockquote>
<p>但是，如果刚才那个步骤不是 3 步，而是 5 步 /10 步，其中大量的步骤都是相同的，也就是说，我们每实现一个新的 store，就要撰写相同的代码逻辑，那么，这个抽象就非常有必要了。</p>
</blockquote>
</div>
</details>
<h2 id="支持事件通知"><a class="header" href="#支持事件通知">支持事件通知</a></h2>
<p>好，我们再来看事件通知。</p>
<details id="admonition-在-srcservicemodrs-中以下代码如无特殊声明都是在-srcservicemodrs-中目前的-execute-方法还有很多-todo-需要解决" class="admonition info">
<summary class="admonition-title">
<p>在 src/service/mod.rs 中（以下代码，如无特殊声明，都是在 src/service/mod.rs 中），目前的 execute() 方法还有很多 TODO 需要解决： </p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-在-srcservicemodrs-中以下代码如无特殊声明都是在-srcservicemodrs-中目前的-execute-方法还有很多-todo-需要解决"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn execute(&amp;self, cmd: CommandRequest) -&gt; CommandResponse {
    debug!(&quot;Got request: {:?}&quot;, cmd);
    // TODO: 发送 on_received 事件
    let res = dispatch(cmd, &amp;self.inner.store);
    debug!(&quot;Executed response: {:?}&quot;, res);
    // TODO: 发送 on_executed 事件

    res
}
</code></pre></pre>
</div>
</details>
<details id="admonition--为了解决这些-todo我们需要提供事件通知的机制" class="admonition tip">
<summary class="admonition-title">
<blockquote>
<p>为了解决这些 TODO，我们需要提供事件通知的机制： </p>
</blockquote>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition--为了解决这些-todo我们需要提供事件通知的机制"></a></p>
</summary>
<div>
<ul>
<li>
<p>在创建 Service 时，注册相应的事件处理函数；</p>
</li>
<li>
<p>在 execute() 方法执行时，做相应的事件通知，使得注册的事件处理函数可以得到执行。</p>
</li>
</ul>
</div>
</details>
<h3 id="先看事件处理函数如何注册"><a class="header" href="#先看事件处理函数如何注册">先看事件处理函数如何注册。</a></h3>
<h4 id="思路"><a class="header" href="#思路">思路</a></h4>
<p>如果想要能够注册，那么倒推也就是，Service/ServiceInner 数据结构就需要有地方能够承载事件注册函数。</p>
<details id="admonition-可以尝试着把它加在-serviceinner-结构里" class="admonition note">
<summary class="admonition-title">
<p>可以尝试着把它加在 ServiceInner 结构里： </p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-可以尝试着把它加在-serviceinner-结构里"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
/// Service 内部数据结构
pub struct ServiceInner&lt;Store&gt; {
    store: Store,
    on_received: Vec&lt;fn(&amp;CommandRequest)&gt;,
    on_executed: Vec&lt;fn(&amp;CommandResponse)&gt;,
    on_before_send: Vec&lt;fn(&amp;mut CommandResponse)&gt;,
    on_after_send: Vec&lt;fn()&gt;,
}
</code></pre></pre>
</div>
</details>
<details id="admonition-按照-前面的设计我们提供了四个事件" class="admonition info">
<summary class="admonition-title">
<p>按照 前面的设计，我们提供了四个事件： </p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-按照-前面的设计我们提供了四个事件"></a></p>
</summary>
<div>
<ul>
<li>on_received：</li>
</ul>
<p>当服务器收到 CommandRequest 时触发；</p>
<ul>
<li>on_executed:</li>
</ul>
<p>当服务器处理完 CommandRequest 得到 CommandResponse 时触发；</p>
<ul>
<li>on_before_send：</li>
</ul>
<p>在服务器发送 CommandResponse 之前触发。注意这个接口提供的是 &amp;mut CommandResponse，这样事件的处理者可以根据需要，在发送前，修改 CommandResponse。</p>
<ul>
<li>on_after_send</li>
</ul>
<p>在服务器发送完 CommandResponse 后触发。</p>
</div>
</details>
<h4 id="先写测试"><a class="header" href="#先写测试">先写测试</a></h4>
<details id="admonition-在撰写事件注册的代码之前还是先写个测试从使用者的角度考虑如何进行注册" class="admonition note">
<summary class="admonition-title">
<p>在撰写事件注册的代码之前，还是先写个测试，从使用者的角度，考虑如何进行注册： </p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-在撰写事件注册的代码之前还是先写个测试从使用者的角度考虑如何进行注册"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[test]
fn event_registration_should_work() {
    fn b(cmd: &amp;CommandRequest) {
        info!(&quot;Got {:?}&quot;, cmd);
    }
    fn c(res: &amp;CommandResponse) {
        info!(&quot;{:?}&quot;, res);
    }
    fn d(res: &amp;mut CommandResponse) {
        res.status = StatusCode::CREATED.as_u16() as _;
    }
    fn e() {
        info!(&quot;Data is sent&quot;);
    }

    let service: Service = ServiceInner::new(MemTable::default())
        .fn_received(|_: &amp;CommandRequest| {})
        .fn_received(b)
        .fn_executed(c)
        .fn_before_send(d)
        .fn_after_send(e)
        .into();

    let res = service.execute(CommandRequest::new_hset(&quot;t1&quot;, &quot;k1&quot;, &quot;v1&quot;.into()));
    assert_eq!(res.status, StatusCode::CREATED.as_u16() as _);
    assert_eq!(res.message, &quot;&quot;);
    assert_eq!(res.values, vec![Value::default()]);
}
</code></pre></pre>
<hr />
<p>从测试代码中可以看到:</p>
<ol>
<li>我们希望通过 ServiceInner 结构，不断调用 fn_xxx 方法，为 ServiceInner 注册相应的事件处理函数；</li>
<li>添加完毕后，通过 into() 方法，我们再把 ServiceInner 转换成 Service。</li>
<li>这是一个经典的构造者模式（Builder Pattern），在很多 Rust 代码中，都能看到它的身影。</li>
</ol>
</div>
</details>
<h4 id="fn_received的链式调用"><a class="header" href="#fn_received的链式调用">fn_received的链式调用</a></h4>
<details id="admonition-那么诸如-fn_received-这样的方法有什么魔力呢它为什么可以一路做链式调用呢" class="admonition question">
<summary class="admonition-title">
<p>那么，诸如 fn_received() 这样的方法有什么魔力呢？它为什么可以一路做链式调用呢？</p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-那么诸如-fn_received-这样的方法有什么魔力呢它为什么可以一路做链式调用呢"></a></p>
</summary>
<div>
<blockquote>
<p>答案很简单，它把 self 的所有权拿过来，处理完之后，再返回 self。</p>
</blockquote>
</div>
</details>
<details id="admonition-所以我们继续添加如下代码" class="admonition note">
<summary class="admonition-title">
<p>所以，我们继续添加如下代码：</p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-所以我们继续添加如下代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;Store: Storage&gt; ServiceInner&lt;Store&gt; {
    pub fn new(store: Store) -&gt; Self {
        Self {
            store,
            on_received: Vec::new(),
            on_executed: Vec::new(),
            on_before_send: Vec::new(),
            on_after_send: Vec::new(),
        }
    }

    pub fn fn_received(mut self, f: fn(&amp;CommandRequest)) -&gt; Self {
        self.on_received.push(f);
        self
    }

    pub fn fn_executed(mut self, f: fn(&amp;CommandResponse)) -&gt; Self {
        self.on_executed.push(f);
        self
    }

    pub fn fn_before_send(mut self, f: fn(&amp;mut CommandResponse)) -&gt; Self {
        self.on_before_send.push(f);
        self
    }

    pub fn fn_after_send(mut self, f: fn()) -&gt; Self {
        self.on_after_send.push(f);
        self
    }
}
</code></pre></pre>
<blockquote>
<p>这样处理之后呢，Service 之前的 new() 方法就没有必要存在了，可以把它删除。</p>
</blockquote>
</div>
</details>
<details id="admonition-同时我们需要为-service-类型提供一个-from-的实现" class="admonition note">
<summary class="admonition-title">
<p>同时，我们需要为 Service 类型提供一个 From<ServiceInner> 的实现： </p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-同时我们需要为-service-类型提供一个-from-的实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;Store: Storage&gt; From&lt;ServiceInner&lt;Store&gt;&gt; for Service&lt;Store&gt; {
    fn from(inner: ServiceInner&lt;Store&gt;) -&gt; Self {
        Self {
            inner: Arc::new(inner),
        }
    }
}
</code></pre></pre>
<p>目前，代码中几处使用了 Service::new() 的地方需要改成使用 ServiceInner::new()，比如：</p>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;Store: Storage&gt; From&lt;ServiceInner&lt;Store&gt;&gt; for Service&lt;Store&gt; {
    fn from(inner: ServiceInner&lt;Store&gt;) -&gt; Self {
        Self {
            inner: Arc::new(inner),
        }
    }
}
</code></pre></pre>
</div>
</details>
<p>全部改动完成后，代码可以编译通过。</p>
<p>然而，如果运行 cargo test，新加的测试会失败：</p>
<pre><pre class="playground"><code class="language-rust  editable">
test service::tests::event_registration_should_work ... FAILED
</code></pre></pre>
<ol>
<li>这是因为，我们虽然完成了事件处理函数的注册，但现在还没有发事件通知。</li>
<li>另外因为我们的事件包括不可变事件（比如 on_received）和可变事件（比如 on_before_send），所以事件通知需要把二者分开。</li>
</ol>
<details id="admonition-来定义两个-traitnotify-和-notifymut" class="admonition note">
<summary class="admonition-title">
<p>来定义两个 trait：Notify 和 NotifyMut： </p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-来定义两个-traitnotify-和-notifymut"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
/// 事件通知（不可变事件）
pub trait Notify&lt;Arg&gt; {
    fn notify(&amp;self, arg: &amp;Arg);
}

/// 事件通知（可变事件）
pub trait NotifyMut&lt;Arg&gt; {
    fn notify(&amp;self, arg: &amp;mut Arg);
}
</code></pre></pre>
<p>这两个 trait 是泛型 trait，其中的 Arg 参数，对应事件注册函数里的 arg，比如：</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn(&amp;CommandRequest);
</code></pre></pre>
</div>
</details>
<details id="admonition-由此我们可以特地为-vec-和-vec-实现事件处理它们涵盖了目前支持的几种事件" class="admonition note">
<summary class="admonition-title">
<p>由此，我们可以特地为 Vec&lt;fn(&amp;Arg)&gt; 和 Vec&lt;fn(&amp;mut Arg)&gt; 实现事件处理，它们涵盖了目前支持的几种事件： </p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-由此我们可以特地为-vec-和-vec-实现事件处理它们涵盖了目前支持的几种事件"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;Arg&gt; Notify&lt;Arg&gt; for Vec&lt;fn(&amp;Arg)&gt; {
    #[inline]
    fn notify(&amp;self, arg: &amp;Arg) {
        for f in self {
            f(arg)
        }
    }
}

impl&lt;Arg&gt; NotifyMut&lt;Arg&gt; for Vec&lt;fn(&amp;mut Arg)&gt; {
  #[inline]
    fn notify(&amp;self, arg: &amp;mut Arg) {
        for f in self {
            f(arg)
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-notify--notifymut-trait-实现好之后我们就可以修改-execute-方法了" class="admonition note">
<summary class="admonition-title">
<p>Notify / NotifyMut trait 实现好之后，我们就可以修改 execute() 方法了： </p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-notify--notifymut-trait-实现好之后我们就可以修改-execute-方法了"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;Store: Storage&gt; Service&lt;Store&gt; {
    pub fn execute(&amp;self, cmd: CommandRequest) -&gt; CommandResponse {
        debug!(&quot;Got request: {:?}&quot;, cmd);
        self.inner.on_received.notify(&amp;cmd);
        let mut res = dispatch(cmd, &amp;self.inner.store);
        debug!(&quot;Executed response: {:?}&quot;, res);
        self.inner.on_executed.notify(&amp;res);
        self.inner.on_before_send.notify(&amp;mut res);
        if !self.inner.on_before_send.is_empty() {
            debug!(&quot;Modified response: {:?}&quot;, res);
        }

        res
    }
}
</code></pre></pre>
</div>
</details>
<p>现在，相应的事件就可以被通知到相应的处理函数中了。</p>
<blockquote>
<p>这个通知机制目前还是同步的函数调用，未来如果需要，我们可以将其改成消息传递，进行异步处理。</p>
</blockquote>
<p>好，现在测试应该可以工作了，cargo test 所有的测试都通过。</p>
<h2 id="为持久化数据库实现-storage-trait"><a class="header" href="#为持久化数据库实现-storage-trait">为持久化数据库实现 Storage trait</a></h2>
<h3 id="方案选择"><a class="header" href="#方案选择">方案选择</a></h3>
<details id="admonition-持久化的两个方案-选择-为-sled-实现-storage-trait让它能够适配我们的-kv-server" class="admonition info">
<summary class="admonition-title">
<p>持久化的两个方案, 选择 <strong>为 sled 实现 Storage trait</strong>，让它能够适配我们的 KV server </p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-持久化的两个方案-选择-为-sled-实现-storage-trait让它能够适配我们的-kv-server"></a></p>
</summary>
<div>
<p>到目前为止，我们的 KV store 还都是一个在内存中的 KV store。一旦终止应用程序，用户存储的所有 key / value 都会消失。我们希望存储能够持久化。</p>
<ol>
<li>一个方案是为 MemTable 添加 WAL 和 disk snapshot 支持，让用户发送的所有涉及更新的命令都按顺序存储在磁盘上，同时定期做 snapshot，便于数据的快速恢复；</li>
<li>另一个方案是使用已有的 KV store，比如 RocksDB，或者 <a href="https://github.com/spacejam/sled">sled</a>。</li>
</ol>
<ul>
<li>RocksDB 是 Facebook 在 Google 的 levelDB 基础上开发的嵌入式 KV store，用 C++ 编写</li>
<li>而 sled 是 Rust 社区里涌现的优秀的 KV store，对标 RocksDB。</li>
<li>二者功能很类似，从演示的角度，sled 使用起来更简单，更加适合今天的内容</li>
<li>如果在生产环境中使用，RocksDB 更加合适，因为它在各种复杂的生产环境中经历了千锤百炼。</li>
</ul>
<blockquote>
<p>所以，我们今天就尝试<strong>为 sled 实现 Storage trait</strong>，让它能够适配我们的 KV server。</p>
</blockquote>
</div>
</details>
<h3 id="为sled实现storage-trait并测试通过"><a class="header" href="#为sled实现storage-trait并测试通过">为sled实现Storage trait，并测试通过</a></h3>
<details id="admonition-为sled实现storage-trait并测试通过" class="admonition note">
<summary class="admonition-title">
<p>为sled实现Storage trait，并测试通过</p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-为sled实现storage-trait并测试通过"></a></p>
</summary>
<div>
<ol>
<li>首先在 Cargo.toml 里引入 sled：</li>
</ol>
<pre><code class="language-toml">sled = &quot;0.34&quot; # sled db
</code></pre>
<ol start="2">
<li>然后创建 src/storage/sleddb.rs，并添加如下代码：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use sled::{Db, IVec};
use std::{convert::TryInto, path::Path, str};

use crate::{KvError, Kvpair, Storage, StorageIter, Value};

#[derive(Debug)]
pub struct SledDb(Db);

impl SledDb {
    pub fn new(path: impl AsRef&lt;Path&gt;) -&gt; Self {
        Self(sled::open(path).unwrap())
    }

    // 在 sleddb 里，因为它可以 scan_prefix，我们用 prefix
    // 来模拟一个 table。当然，还可以用其它方案。
    fn get_full_key(table: &amp;str, key: &amp;str) -&gt; String {
        format!(&quot;{}:{}&quot;, table, key)
    }

    // 遍历 table 的 key 时，我们直接把 prefix: 当成 table
    fn get_table_prefix(table: &amp;str) -&gt; String {
        format!(&quot;{}:&quot;, table)
    }
}

/// 把 Option&lt;Result&lt;T, E&gt;&gt; flip 成 Result&lt;Option&lt;T&gt;, E&gt;
/// 从这个函数里，你可以看到函数式编程的优雅
fn flip&lt;T, E&gt;(x: Option&lt;Result&lt;T, E&gt;&gt;) -&gt; Result&lt;Option&lt;T&gt;, E&gt; {
    x.map_or(Ok(None), |v| v.map(Some))
}

impl Storage for SledDb {
    fn get(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {
        let name = SledDb::get_full_key(table, key);
        let result = self.0.get(name.as_bytes())?.map(|v| v.as_ref().try_into());
        flip(result)
    }

    fn set(&amp;self, table: &amp;str, key: String, value: Value) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {
        let name = SledDb::get_full_key(table, &amp;key);
        let data: Vec&lt;u8&gt; = value.try_into()?;

        let result = self.0.insert(name, data)?.map(|v| v.as_ref().try_into());
        flip(result)
    }

    fn contains(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;bool, KvError&gt; {
        let name = SledDb::get_full_key(table, &amp;key);

        Ok(self.0.contains_key(name)?)
    }

    fn del(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {
        let name = SledDb::get_full_key(table, &amp;key);

        let result = self.0.remove(name)?.map(|v| v.as_ref().try_into());
        flip(result)
    }

    fn get_all(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;Kvpair&gt;, KvError&gt; {
        let prefix = SledDb::get_table_prefix(table);
        let result = self.0.scan_prefix(prefix).map(|v| v.into()).collect();

        Ok(result)
    }

    fn get_iter(&amp;self, table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt; {
        let prefix = SledDb::get_table_prefix(table);
        let iter = StorageIter::new(self.0.scan_prefix(prefix));
        Ok(Box::new(iter))
    }
}

impl From&lt;Result&lt;(IVec, IVec), sled::Error&gt;&gt; for Kvpair {
    fn from(v: Result&lt;(IVec, IVec), sled::Error&gt;) -&gt; Self {
        match v {
            Ok((k, v)) =&gt; match v.as_ref().try_into() {
                Ok(v) =&gt; Kvpair::new(ivec_to_key(k.as_ref()), v),
                Err(_) =&gt; Kvpair::default(),
            },
            _ =&gt; Kvpair::default(),
        }
    }
}

fn ivec_to_key(ivec: &amp;[u8]) -&gt; &amp;str {
    let s = str::from_utf8(ivec).unwrap();
    let mut iter = s.split(&quot;:&quot;);
    iter.next();
    iter.next().unwrap()
}
</code></pre></pre>
<p>这段代码主要就是在实现 Storage trait。每个方法都很简单，就是在 sled 提供的功能上增加了一次封装。如果你对代码中某个调用有疑虑，可以参考 sled 的文档。</p>
<ol start="3">
<li>在 src/storage/mod.rs 里引入 sleddb，我们就可以加上相关的测试，测试新的 Storage 实现啦：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
mod sleddb;

pub use sleddb::SledDb;

#[cfg(test)]
mod tests {
    use tempfile::tempdir;

    use super::*;

    ...

    #[test]
    fn sleddb_basic_interface_should_work() {
        let dir = tempdir().unwrap();
        let store = SledDb::new(dir);
        test_basi_interface(store);
    }

    #[test]
    fn sleddb_get_all_should_work() {
        let dir = tempdir().unwrap();
        let store = SledDb::new(dir);
        test_get_all(store);
    }

    #[test]
    fn sleddb_iter_should_work() {
        let dir = tempdir().unwrap();
        let store = SledDb::new(dir);
        test_get_iter(store);
    }
}
</code></pre></pre>
<ol start="4">
<li>因为 SledDb 创建时需要指定一个目录，所以要在测试中使用 <a href="https://github.com/Stebalien/tempfile">tempfile 库</a>，它能让文件资源在测试结束时被回收。</li>
</ol>
<p>我们在 Cargo.toml 中引入它：</p>
<pre><code class="language-toml">
[dev-dependencies]
...
Tempfile = &quot;3&quot; # 处理临时目录和临时文件
...
</code></pre>
</div>
</details>
<p>代码目前就可以编译通过了。如果你运行 cargo test 测试，会发现所有测试都正常通过！</p>
<h2 id="构建新的-kv-server"><a class="header" href="#构建新的-kv-server">构建新的 KV server</a></h2>
<details id="admonition-完成-sleddb-和事件通知相关的实现之后我们可以尝试构建支持事件通知并且使用-sleddb-的-kv-server" class="admonition note">
<summary class="admonition-title">
<p>完成 SledDb 和事件通知相关的实现之后，我们可以尝试构建支持事件通知，并且使用 SledDb 的 KV server。</p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-完成-sleddb-和事件通知相关的实现之后我们可以尝试构建支持事件通知并且使用-sleddb-的-kv-server"></a></p>
</summary>
<div>
<p>把 examples/server.rs 拷贝出 examples/server_with_sled.rs，然后修改 let service 那一行：</p>
<pre><pre class="playground"><code class="language-rust  editable">
// let service: Service = ServiceInner::new(MemTable::new()).into();
let service: Service&lt;SledDb&gt; = ServiceInner::new(SledDb::new(&quot;/tmp/kvserver&quot;))
    .fn_before_send(|res| match res.message.as_ref() {
        &quot;&quot; =&gt; res.message = &quot;altered. Original message is empty.&quot;.into(),
        s =&gt; res.message = format!(&quot;altered: {}&quot;, s),
    })
    .into();
</code></pre></pre>
<p>当然，需要引入 SledDb 让编译通过。</p>
<blockquote>
<p>你看，只需要在创建 KV server 时使用 SledDb，就可以实现 data store 的切换，未来还可以进一步通过配置文件，来选择使用什么样的 store。非常方便。</p>
</blockquote>
<p>新的 examples/server_with_sled.rs 的完整的代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use async_prost::AsyncProstStream;
use futures::prelude::*;
use kv1::{CommandRequest, CommandResponse, Service, ServiceInner, SledDb};
use tokio::net::TcpListener;
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();
    let service: Service&lt;SledDb&gt; = ServiceInner::new(SledDb::new(&quot;/tmp/kvserver&quot;))
        .fn_before_send(|res| match res.message.as_ref() {
            &quot;&quot; =&gt; res.message = &quot;altered. Original message is empty.&quot;.into(),
            s =&gt; res.message = format!(&quot;altered: {}&quot;, s),
        })
        .into();
    let addr = &quot;127.0.0.1:9527&quot;;
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Start listening on {}&quot;, addr);
    loop {
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Client {:?} connected&quot;, addr);
        let svc = service.clone();
        tokio::spawn(async move {
            let mut stream =
                AsyncProstStream::&lt;_, CommandRequest, CommandResponse, _&gt;::from(stream).for_async();
            while let Some(Ok(cmd)) = stream.next().await {
                info!(&quot;Got a new command: {:?}&quot;, cmd);
                let res = svc.execute(cmd);
                stream.send(res).await.unwrap();
            }
            info!(&quot;Client {:?} disconnected&quot;, addr);
        });
    }
}
</code></pre></pre>
<p>它和之前的 server 几乎一样，只有 11 行生成 service 的代码应用了新的 storage，并且引入了事件通知。</p>
</div>
</details>
<details id="admonition-测试" class="admonition success">
<summary class="admonition-title">
<p>测试 </p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-测试"></a></p>
</summary>
<div>
<ul>
<li>完成之后，我们可以打开一个命令行窗口，运行：</li>
</ul>
<pre><code class="language-shell">RUST_LOG=info cargo run --example server_with_sled --quiet
</code></pre>
<ul>
<li>然后在另一个命令行窗口，运行：</li>
</ul>
<pre><code class="language-shell">RUST_LOG=info cargo run --example client --quiet。
</code></pre>
<ul>
<li>
<p>此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。</p>
</li>
<li>
<p>如果你停掉服务器，再次运行，然后再运行客户端，会发现，客户端在尝试 HSET 时得到了服务器旧的值，我们的新版 KV server 可以对数据进行持久化了。</p>
</li>
<li>
<p>此外，如果你注意看 client 的日志，会发现原本应该是空字符串的 messag 包含了 “altered. Original message is empty.”：</p>
</li>
</ul>
<pre><code class="language-shell">
❯ RUST_LOG=info cargo run --example client --quiet
Sep 23 22:09:12.215  INFO client: Got response CommandResponse { status: 200, message: &quot;altered. Original message is empty.&quot;, values: [Value { value: Some(String(&quot;world&quot;)) }], pairs: [] }
</code></pre>
<p>这是因为，我们的服务器注册了 fn_before_send 的事件通知，对返回的数据做了修改。</p>
</div>
</details>
<p>未来我们可以用这些事件做很多事情，比如监控数据的发送，甚至写 WAL。</p>
<h2 id="进一步认识trait的威力"><a class="header" href="#进一步认识trait的威力">进一步认识trait的威力</a></h2>
<details id="admonition-前面我们进一步认识到了-trait-的威力" class="admonition abstract">
<summary class="admonition-title">
<p>前面我们进一步认识到了 trait 的威力:</p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-前面我们进一步认识到了-trait-的威力"></a></p>
</summary>
<div>
<p>前面我们进一步认识到了 trait 的威力: </p>
<blockquote>
<p>当为系统设计了合理的 trait ，整个系统的可扩展性就大大增强，之后在添加新的功能的时候，并不需要改动多少已有的代码。</p>
</blockquote>
<p>在使用 trait 做抽象时，我们要衡量：</p>
<ol>
<li>这么做的好处是什么</li>
<li>它未来可以为实现者带来什么帮助</li>
<li>就像我们撰写的 StorageIter，它实现了 Iterator trait，并封装了 map 的处理逻辑，让这个公共的步骤可以在 Storage trait 中复用。</li>
</ol>
</div>
</details>
<details id="admonition-进一步熟悉如何为带泛型参数的数据结构实现-trait" class="admonition note">
<summary class="admonition-title">
<p>进一步熟悉如何为带泛型参数的数据结构实现 trait </p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-进一步熟悉如何为带泛型参数的数据结构实现-trait"></a></p>
</summary>
<div>
<p>除此之外，也进一步熟悉如何为带泛型参数的数据结构实现 trait:</p>
<blockquote>
<p>我们不仅可以为具体的数据结构实现 trait，也可以为更笼统的泛型参数实现 trait。</p>
</blockquote>
<p>除了文中这个例子：</p>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;Arg&gt; Notify&lt;Arg&gt; for Vec&lt;fn(&amp;Arg)&gt; {
    #[inline]
    fn notify(&amp;self, arg: &amp;Arg) {
        for f in self {
            f(arg)
        }
    }
}
</code></pre></pre>
<p>其实之前还见到过：</p>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}
</code></pre></pre>
<p>也是一样的道理。</p>
</div>
</details>
<h2 id="泛型结构和生命周期标注更多用于阅读源码"><a class="header" href="#泛型结构和生命周期标注更多用于阅读源码">泛型结构和生命周期标注更多用于阅读源码</a></h2>
<p>我们目前完成了一个功能比较完整的 KV server 的核心逻辑，但是，整体的代码似乎没有太多复杂的生命周期标注，或者太过抽象的泛型结构。</p>
<blockquote>
<p>是的，别看我们在介绍 Rust 的基础知识时，扎的比较深，但是大多数写代码的时候，并不会用到那么深的知识。
Rust 编译器会尽最大的努力，让你的代码简单。如果你用 clippy 这样的 linter 的话，它还会进一步给你提一些建议，让你的代码更加简单。</p>
</blockquote>
<details id="admonition-那么为什么我们还要讲那么深入呢" class="admonition question">
<summary class="admonition-title">
<p>那么，为什么我们还要讲那么深入呢？</p>
<p><a class="admonition-anchor-link" href="kv3_advanced_traits.html#admonition-那么为什么我们还要讲那么深入呢"></a></p>
</summary>
<div>
<p>这是因为我们在写代码的时候不可避免地要引入第三方库，你也看到了，在写这个项目的时候用了不少依赖。
当你使用这些库的时候，又不可避免地要阅读一些它们的源码，而这些源码，可能有各种各样复杂的写法。
这也是为什么在开头我会说，现阶段能看懂包含泛型的代码就可以了。</p>
<p>深入地了解 Rust 的基础知识:</p>
<ol>
<li>可以帮我们更快更清晰地阅读源码</li>
<li>而更快更清晰地读懂别人的源码，又可以更快地帮助我们用好别人的库，从而写好我们的代码。</li>
</ol>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="四网络处理"><a class="header" href="#四网络处理">四、网络处理</a></h1>
<!--ts-->
<ul>
<li><a href="kv4_network.html#%E5%9B%9B%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86">四、网络处理</a>
<ul>
<li><a href="kv4_network.html#async-prost">async-prost</a></li>
<li><a href="kv4_network.html#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E7%9A%84-frame">如何定义协议的 Frame？</a></li>
<li><a href="kv4_network.html#%E5%A6%82%E4%BD%95%E6%92%B0%E5%86%99%E5%A4%84%E7%90%86-frame-%E7%9A%84%E4%BB%A3%E7%A0%81">如何撰写处理 Frame 的代码？</a></li>
<li><a href="kv4_network.html#%E8%AE%A9%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8F%AF%E4%BB%A5%E5%83%8F-asyncprost-%E9%82%A3%E6%A0%B7%E6%96%B9%E4%BE%BF%E4%BD%BF%E7%94%A8">让网络层可以像 AsyncProst 那样方便使用</a></li>
<li><a href="kv4_network.html#%E6%AD%A3%E5%BC%8F%E5%88%9B%E5%BB%BA-kv-server-%E5%92%8C-kv-client">正式创建 kv-server 和 kv-client</a></li>
<li><a href="kv4_network.html#%E5%9B%9E%E9%A1%BE%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91">回顾网络开发</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:30 UTC 2022 -->
<!--te-->
<h2 id="async-prost"><a class="header" href="#async-prost">async-prost</a></h2>
<p>之前一直在使用一个神秘的 <a href="https://github.com/tyrchen/async-prost">async-prost 库</a>，我们神奇地完成了 TCP frame 的封包和解包。</p>
<details id="admonition-是怎么完成的呢" class="admonition question">
<summary class="admonition-title">
<p>是怎么完成的呢？</p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-是怎么完成的呢"></a></p>
</summary>
<div>
<p>async-prost 是<a href="https://github.com/jonhoo/async-bincode">仿照 Jonhoo 的 async-bincode</a> 做的一个处理 protobuf frame 的库，它可以和各种网络协议适配，包括 TCP / WebSocket / HTTP2 等。</p>
<blockquote>
<p>由于考虑通用性，它的抽象级别比较高，用了大量的泛型参数</p>
</blockquote>
<hr />
<p>主流程如下图所示：</p>
<h2 id="-14"><a class="header" href="#-14"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/5afafe8646ee8b05b69a463ab5f5554f.png" alt="img" /></a></h2>
<p>主要的思路:</p>
<ol>
<li>在序列化数据的时候，添加一个头部来提供 frame 的长度</li>
<li>反序列化的时候，先读出头部，获得长度，再读取相应的数据。</li>
</ol>
</div>
</details>
<blockquote>
<p>这里试着不依赖 async-prost，自己处理封包和解包的逻辑。
如果你掌握了这个能力，配合 protobuf，就可以设计出任何可以承载实际业务的协议了。</p>
</blockquote>
<h2 id="如何定义协议的-frame"><a class="header" href="#如何定义协议的-frame">如何定义协议的 Frame？</a></h2>
<p>protobuf 帮我们解决了协议消息如何定义的问题，然而一个消息和另一个消息之间如何区分，是个伤脑筋的事情。</p>
<details id="admonition-我们需要定义合适的分隔符" class="admonition info">
<summary class="admonition-title">
<p>我们需要定义合适的分隔符。 </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-我们需要定义合适的分隔符"></a></p>
</summary>
<div>
<blockquote>
<p>分隔符 + 消息数据，就是一个 Frame。</p>
</blockquote>
<ol>
<li>很多基于 TCP 的协议会使用 \r\n 做分隔符，比如 FTP；</li>
<li>也有使用消息长度做分隔符的，比如 gRPC；</li>
<li>还有混用两者的，比如 Redis 的 RESP；</li>
<li>更复杂的如 HTTP，header 之间使用 \r\n 分隔，header / body 之间使用 \r\n\r\n，header 中会提供 body 的长度等等。</li>
</ol>
<ul>
<li>“\r\n” 这样的分隔符，适合协议报文是 ASCII 数据；</li>
<li>而通过长度进行分隔，适合协议报文是二进制数据</li>
<li>我们的 KV Server 承载的 protobuf 是二进制，所以就在 payload 之前放一个长度，来作为 frame 的分隔。</li>
</ul>
<p>这个长度取什么大小呢？</p>
<ul>
<li>如果使用 2 个字节，那么 payload 最大是 64k；</li>
<li>如果使用 4 个字节，payload 可以到 4G。</li>
<li>一般的应用取 4 个字节就足够了。</li>
<li>如果你想要更灵活些，也可以使用 <a href="https://en.wikipedia.org/wiki/Variable-length_quantity">varint</a>。</li>
</ul>
</div>
</details>
<p>tokio 有个 tokio-util 库，已经帮我们处理了和 frame 相关的封包解包的主要需求，包括 LinesDelimited（处理 \r\n 分隔符）和 LengthDelimited（处理长度分隔符）。</p>
<details id="admonition-我们可以使用它的-lengthdelimitedcodec-尝试一下" class="admonition note">
<summary class="admonition-title">
<p>我们可以使用它的 LengthDelimitedCodec 尝试一下。 </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-我们可以使用它的-lengthdelimitedcodec-尝试一下"></a></p>
</summary>
<div>
<ol>
<li>首先在 Cargo.toml 里添加依赖：</li>
</ol>
<pre><code class="language-toml">
[dev-dependencies]
...
tokio-util = { version = &quot;0.6&quot;, features = [&quot;codec&quot;]}
...
</code></pre>
<ol start="2">
<li>然后创建 examples/server_with_codec.rs 文件，添入如下代码：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use futures::prelude::*;
use kv2::{CommandRequest, MemTable, Service, ServiceInner};
use prost::Message;
use tokio::net::TcpListener;
use tokio_util::codec::{Framed, LengthDelimitedCodec};
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();
    let service: Service = ServiceInner::new(MemTable::new()).into();
    let addr = &quot;127.0.0.1:9527&quot;;
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Start listening on {}&quot;, addr);
    loop {
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Client {:?} connected&quot;, addr);
        let svc = service.clone();
        tokio::spawn(async move {
            let mut stream = Framed::new(stream, LengthDelimitedCodec::new());
            while let Some(Ok(mut buf)) = stream.next().await {
                let cmd = CommandRequest::decode(&amp;buf[..]).unwrap();
                info!(&quot;Got a new command: {:?}&quot;, cmd);
                let res = svc.execute(cmd);
                buf.clear();
                res.encode(&amp;mut buf).unwrap();
                stream.send(buf.freeze()).await.unwrap();
            }
            info!(&quot;Client {:?} disconnected&quot;, addr);
        });
    }
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>你可以对比一下它和之前的 examples/server.rs 的差别，主要改动了这一行：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
// let mut stream = AsyncProstStream::&lt;_, CommandRequest, CommandResponse, _&gt;::from(stream).for_async();
let mut stream = Framed::new(stream, LengthDelimitedCodec::new());
</code></pre></pre>
<details id="admonition-测试" class="admonition success">
<summary class="admonition-title">
<p>测试 </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-测试"></a></p>
</summary>
<div>
<ul>
<li>完成之后，我们打开一个命令行窗口，运行：</li>
</ul>
<pre><code class="language-shell">RUST_LOG=info cargo run --example server_with_codec --quiet
</code></pre>
<ul>
<li>然后在另一个命令行窗口，运行：</li>
</ul>
<pre><code class="language-shell">RUST_LOG=info cargo run --example client --quiet
</code></pre>
<ul>
<li>此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常</li>
</ul>
</div>
</details>
<details id="admonition-你这会是不是有点疑惑为什么客户端没做任何修改也能和服务器通信" class="admonition question">
<summary class="admonition-title">
<p>你这会是不是有点疑惑，为什么客户端没做任何修改也能和服务器通信？ </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-你这会是不是有点疑惑为什么客户端没做任何修改也能和服务器通信"></a></p>
</summary>
<div>
<p>那是因为在目前的使用场景下，使用 AsyncProst 的客户端兼容 LengthDelimitedCodec。</p>
</div>
</details>
<h2 id="如何撰写处理-frame-的代码"><a class="header" href="#如何撰写处理-frame-的代码">如何撰写处理 Frame 的代码？</a></h2>
<details id="admonition-按照前面分析我们在-protobuf-payload-前加一个-4-字节的长度" class="admonition info">
<summary class="admonition-title">
<p>按照前面分析，我们在 protobuf payload 前加一个 4 字节的长度。 </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-按照前面分析我们在-protobuf-payload-前加一个-4-字节的长度"></a></p>
</summary>
<div>
<p>这样对端读取数据时，可以先读 4 字节，然后根据读到的长度，进一步读取满足这个长度的数据，之后就可以用相应的数据结构解包了。</p>
<blockquote>
<p>为了更贴近实际，我们把 4 字节长度的最高位拿出来作为是否压缩的信号.
如果设置了，代表后续的 payload 是 gzip 压缩过的 protobuf，否则直接是 protobuf：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/712735ae12d0cdf39b3dcf5bb242f103.jpg" alt="img" /></p>
</div>
</details>
<details id="admonition-实现处理-frame-的代码-commandrequest--commandresponse-做-frame-级别的处理" class="admonition note">
<summary class="admonition-title">
<p>实现处理 Frame 的代码: CommandRequest / CommandResponse 做 frame 级别的处理</p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-实现处理-frame-的代码-commandrequest--commandresponse-做-frame-级别的处理"></a></p>
</summary>
<div>
<ol>
<li>按照惯例，还是先来定义处理这个逻辑的 trait：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait FrameCoder
where
    Self: Message + Sized + Default,
{
    /// 把一个 Message encode 成一个 frame
    fn encode_frame(&amp;self, buf: &amp;mut BytesMut) -&gt; Result&lt;(), KvError&gt;;
    /// 把一个完整的 frame decode 成一个 Message
    fn decode_frame(buf: &amp;mut BytesMut) -&gt; Result&lt;Self, KvError&gt;;
}
</code></pre></pre>
<p>定义了两个方法：</p>
<ul>
<li>
<p>encode_frame() 可以把诸如 CommandRequest 这样的消息封装成一个 frame，写入传进来的 BytesMut；</p>
</li>
<li>
<p>decode_frame() 可以把收到的一个完整的、放在 BytesMut 中的数据，解封装成诸如 CommandRequest 这样的消息。</p>
</li>
<li>
<p>如果要实现这个 trait，Self 需要实现了 prost::Message，大小是固定的，并且实现了 Default（prost 的需求）。</p>
</li>
</ul>
<hr />
<ol start="2">
<li>好，我们再写实现代码。</li>
</ol>
<ul>
<li>
<p>首先创建 src/network 目录，并在其下添加两个文件mod.rs和 frame.rs。</p>
</li>
<li>
<p>然后在 src/network/mod.rs 里引入 src/network/frame.rs：</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">
mod frame;
pub use frame::FrameCoder;
</code></pre></pre>
<ul>
<li>同时在 lib.rs 里引入 network：</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">
mod network;
pub use network::*;
</code></pre></pre>
<ul>
<li>
<p>因为要处理 gzip 压缩，还需要在 Cargo.toml 中引入 <a href="https://github.com/rust-lang/flate2-rs">flate2</a></p>
</li>
<li>
<p>同时，因为今天这一讲引入了网络相关的操作和数据结构，我们需要把 tokio 从 dev-dependencies 移到 dependencies 里，为简单起见，就用 full features：</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">
[dependencies]
...
flate2 = &quot;1&quot; # gzip 压缩
...
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] } # 异步网络库
...
</code></pre></pre>
<ul>
<li>然后，在 src/network/frame.rs 里添加 trait 和实现 trait 的代码：</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">
use std::io::{Read, Write};

use crate::{CommandRequest, CommandResponse, KvError};
use bytes::{Buf, BufMut, BytesMut};
use flate2::{read::GzDecoder, write::GzEncoder, Compression};
use prost::Message;
use tokio::io::{AsyncRead, AsyncReadExt};
use tracing::debug;

/// 长度整个占用 4 个字节
pub const LEN_LEN: usize = 4;
/// 长度占 31 bit，所以最大的 frame 是 2G
const MAX_FRAME: usize = 2 * 1024 * 1024 * 1024;
/// 如果 payload 超过了 1436 字节，就做压缩
const COMPRESSION_LIMIT: usize = 1436;
/// 代表压缩的 bit（整个长度 4 字节的最高位）
const COMPRESSION_BIT: usize = 1 &lt;&lt; 31;

/// 处理 Frame 的 encode/decode
pub trait FrameCoder
where
    Self: Message + Sized + Default,
{
    /// 把一个 Message encode 成一个 frame
    fn encode_frame(&amp;self, buf: &amp;mut BytesMut) -&gt; Result&lt;(), KvError&gt; {
        let size = self.encoded_len();

        if size &gt;= MAX_FRAME {
            return Err(KvError::FrameError);
        }

        // 我们先写入长度，如果需要压缩，再重写压缩后的长度
        buf.put_u32(size as _);

        if size &gt; COMPRESSION_LIMIT {
            let mut buf1 = Vec::with_capacity(size);
            self.encode(&amp;mut buf1)?;

            // BytesMut 支持逻辑上的 split（之后还能 unsplit）
            // 所以我们先把长度这 4 字节拿走，清除
            let payload = buf.split_off(LEN_LEN);
            buf.clear();

            // 处理 gzip 压缩，具体可以参考 flate2 文档
            let mut encoder = GzEncoder::new(payload.writer(), Compression::default());
            encoder.write_all(&amp;buf1[..])?;

            // 压缩完成后，从 gzip encoder 中把 BytesMut 再拿回来
            let payload = encoder.finish()?.into_inner();
            debug!(&quot;Encode a frame: size {}({})&quot;, size, payload.len());

            // 写入压缩后的长度
            buf.put_u32((payload.len() | COMPRESSION_BIT) as _);

            // 把 BytesMut 再合并回来
            buf.unsplit(payload);

            Ok(())
        } else {
            self.encode(buf)?;
            Ok(())
        }
    }

    /// 把一个完整的 frame decode 成一个 Message
    fn decode_frame(buf: &amp;mut BytesMut) -&gt; Result&lt;Self, KvError&gt; {
        // 先取 4 字节，从中拿出长度和 compression bit
        let header = buf.get_u32() as usize;
        let (len, compressed) = decode_header(header);
        debug!(&quot;Got a frame: msg len {}, compressed {}&quot;, len, compressed);

        if compressed {
            // 解压缩
            let mut decoder = GzDecoder::new(&amp;buf[..len]);
            let mut buf1 = Vec::with_capacity(len * 2);
            decoder.read_to_end(&amp;mut buf1)?;
            buf.advance(len);

            // decode 成相应的消息
            Ok(Self::decode(&amp;buf1[..buf1.len()])?)
        } else {
            let msg = Self::decode(&amp;buf[..len])?;
            buf.advance(len);
            Ok(msg)
        }
    }
}

impl FrameCoder for CommandRequest {}
impl FrameCoder for CommandResponse {}

fn decode_header(header: usize) -&gt; (usize, bool) {
    let len = header &amp; !COMPRESSION_BIT;
    let compressed = header &amp; COMPRESSION_BIT == COMPRESSION_BIT;
    (len, compressed)
}
</code></pre></pre>
<p>这段代码本身并不难理解。</p>
<ul>
<li>我们直接为 FrameCoder 提供了缺省实现</li>
<li>然后 CommandRequest / CommandResponse 做了空实现</li>
<li>其中使用了之前介绍过的 bytes 库里的 BytesMut，以及新引入的 GzEncoder / GzDecoder。</li>
<li>你可以按照阅读源码的方式，了解这几个数据类型的用法。</li>
<li>最后还写了个辅助函数 decode_header()，让 decode_frame() 的代码更直观一些。</li>
</ul>
</div>
</details>
<details id="admonition-为什么-compression_limit-设成-1436" class="admonition question">
<summary class="admonition-title">
<p>为什么 COMPRESSION_LIMIT 设成 1436？ </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-为什么-compression_limit-设成-1436"></a></p>
</summary>
<div>
<ul>
<li>这是因为以太网的 MTU 是 1500，除去 IP 头 20 字节、TCP 头 20 字节，还剩 1460；</li>
<li>一般 TCP 包会包含一些 Option（比如 timestamp），IP 包也可能包含，所以我们预留 20 字节；</li>
<li>再减去 4 字节的长度，就是 1436，不用分片的最大消息长度。</li>
<li>如果大于这个，很可能会导致分片，我们就干脆压缩一下。</li>
</ul>
</div>
</details>
<blockquote>
<p>现在，CommandRequest / CommandResponse 就可以做 frame 级别的处理了，我们写一些测试验证是否工作。</p>
</blockquote>
<details id="admonition-成功测试代码涉及from和into" class="admonition success">
<summary class="admonition-title">
<p>成功：测试代码，涉及From和Into</p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-成功测试代码涉及from和into"></a></p>
</summary>
<div>
<p>还是在 src/network/frame.rs 里，添加测试代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
mod tests {
    use super::*;
    use crate::Value;
    use bytes::Bytes;

    #[test]
    fn command_request_encode_decode_should_work() {
        let mut buf = BytesMut::new();

        let cmd = CommandRequest::new_hdel(&quot;t1&quot;, &quot;k1&quot;);
        cmd.encode_frame(&amp;mut buf).unwrap();

        // 最高位没设置
        assert_eq!(is_compressed(&amp;buf), false);

        let cmd1 = CommandRequest::decode_frame(&amp;mut buf).unwrap();
        assert_eq!(cmd, cmd1);
    }

    #[test]
    fn command_response_encode_decode_should_work() {
        let mut buf = BytesMut::new();

        let values: Vec&lt;Value&gt; = vec![1.into(), &quot;hello&quot;.into(), b&quot;data&quot;.into()];
        let res: CommandResponse = values.into();
        res.encode_frame(&amp;mut buf).unwrap();

        // 最高位没设置
        assert_eq!(is_compressed(&amp;buf), false);

        let res1 = CommandResponse::decode_frame(&amp;mut buf).unwrap();
        assert_eq!(res, res1);
    }

    #[test]
    fn command_response_compressed_encode_decode_should_work() {
        let mut buf = BytesMut::new();

        let value: Value = Bytes::from(vec![0u8; COMPRESSION_LIMIT + 1]).into();
        let res: CommandResponse = value.into();
        res.encode_frame(&amp;mut buf).unwrap();

        // 最高位设置了
        assert_eq!(is_compressed(&amp;buf), true);

        let res1 = CommandResponse::decode_frame(&amp;mut buf).unwrap();
        assert_eq!(res, res1);
    }

    fn is_compressed(data: &amp;[u8]) -&gt; bool {
        if let &amp;[v] = &amp;data[..1] {
            v &gt;&gt; 7 == 1
        } else {
            false
        }
    }
}
</code></pre></pre>
<blockquote>
<p>这个测试代码里面有从 [u8; N] 到 Value（b“data“.into()） 以及从 Bytes 到 Value 的转换</p>
</blockquote>
<ul>
<li>所以我们需要在 src/pb/mod.rs 里添加 From trait 的相应实现：</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;const N: usize&gt; From&lt;&amp;[u8; N]&gt; for Value {
    fn from(buf: &amp;[u8; N]) -&gt; Self {
        Bytes::copy_from_slice(&amp;buf[..]).into()
    }
}

impl From&lt;Bytes&gt; for Value {
    fn from(buf: Bytes) -&gt; Self {
        Self {
            value: Some(value::Value::Binary(buf)),
        }
    }
}
</code></pre></pre>
<p>运行 cargo test ，所有测试都可以通过。</p>
</div>
</details>
<p>到这里，我们就完成了 Frame 的序列化（encode_frame）和反序列化（decode_frame），并且用测试确保它的正确性。</p>
<blockquote>
<p>做网络开发的时候，要尽可能把实现逻辑和 IO 分离，这样有助于可测性以及应对未来 IO 层的变更。</p>
</blockquote>
<p>目前，这个代码没有触及任何和 socket IO 相关的内容，只是纯逻辑，接下来我们要将它和我们用于处理服务器客户端的 TcpStream 联系起来。</p>
<p>在进一步写网络相关的代码前，还有一个问题需要解决：</p>
<details id="admonition-decode_frame-函数使用的-bytesmut是如何从-socket-里拿出来的" class="admonition question">
<summary class="admonition-title">
<p>decode_frame() 函数使用的 BytesMut，是如何从 socket 里拿出来的？</p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-decode_frame-函数使用的-bytesmut是如何从-socket-里拿出来的"></a></p>
</summary>
<div>
<p>显然，先读 4 个字节，取出长度 N，然后再读 N 个字节。</p>
<p>这个细节和 frame 关系很大，所以还需要在 src/network/frame.rs 里写个辅助函数 read_frame()：</p>
<pre><pre class="playground"><code class="language-rust  editable">
/// 从 stream 中读取一个完整的 frame
pub async fn read_frame&lt;S&gt;(stream: &amp;mut S, buf: &amp;mut BytesMut) -&gt; Result&lt;(), KvError&gt;
where
    S: AsyncRead + Unpin + Send,
{
    let header = stream.read_u32().await? as usize;
    let (len, _compressed) = decode_header(header);
    // 如果没有这么大的内存，就分配至少一个 frame 的内存，保证它可用
    buf.reserve(LEN_LEN + len);
    buf.put_u32(header as _);
    // advance_mut 是 unsafe 的原因是，从当前位置 pos 到 pos + len，
    // 这段内存目前没有初始化。我们就是为了 reserve 这段内存，然后从 stream
    // 里读取，读取完，它就是初始化的。所以，我们这么用是安全的
    unsafe { buf.advance_mut(len) };
    stream.read_exact(&amp;mut buf[LEN_LEN..]).await?;
    Ok(())
}
</code></pre></pre>
<ul>
<li>在写 read_frame() 时，我们不希望它只能被用于 TcpStream，这样太不灵活，所以用了泛型参数 S</li>
<li>要求传入的 S 必须满足 AsyncRead + Unpin + Send。</li>
</ul>
</div>
</details>
<details id="admonition-要求传入的-s-必须满足-asyncread--unpin--send-我们来看看这-3-个约束" class="admonition info">
<summary class="admonition-title">
<p>要求传入的 S 必须满足 AsyncRead + Unpin + Send, 我们来看看这 3 个约束: </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-要求传入的-s-必须满足-asyncread--unpin--send-我们来看看这-3-个约束"></a></p>
</summary>
<div>
<ol>
<li><a href="https://docs.rs/tokio/1.12.0/tokio/io/trait.AsyncRead.html">AsyncRead 是 tokio 下的一个 trait</a>，用于做异步读取，它有一个方法 poll_read()：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait AsyncRead {
    fn poll_read(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        buf: &amp;mut ReadBuf&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;()&gt;&gt;;
}
</code></pre></pre>
<p>一旦某个数据结构实现了 AsyncRead，它就可以使用 AsyncReadExt 提供的多达 29 个辅助方法。这是因为任何实现了 AsyncRead 的数据结构，都自动实现了 AsyncReadExt：</p>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;R: AsyncRead + ?Sized&gt; AsyncReadExt for R {}
</code></pre></pre>
<p>我们虽然还没有正式学怎么做异步处理，但是之前已经看到了很多 async/await 的代码。</p>
<blockquote>
<p>异步处理，目前你可以把它想象成一个<strong>内部有个状态机的数据结构</strong>:</p>
</blockquote>
<ul>
<li>异步运行时根据需要不断地对其做 poll 操作，直到它返回 Poll::Ready，说明得到了处理结果；</li>
<li>如果它返回 Poll::Pending，说明目前还无法继续，异步运行时会将其挂起，等下次某个事件将这个任务唤醒。</li>
</ul>
<p>对于 Socket 来说，读取 socket 就是一个不断 poll_read() 的过程，直到读到了满足 ReadBuf 需要的内容。</p>
<ol start="2">
<li>
<p>至于 Send 约束，很好理解， 需要能在不同线程间移动所有权。</p>
</li>
<li>
<p>对于 Unpin 约束</p>
</li>
</ol>
<p>如果编译器抱怨一个泛型参数 “cannot be unpinned” ，一般来说，这个泛型参数需要加 Unpin 的约束。你可以试着把 Unpin 去掉，看看编译器的报错。</p>
</div>
</details>
<p>好，既然又写了一些代码，自然需为其撰写相应的测试。</p>
<p>但是，要测 read_frame() 函数，需要一个支持 AsyncRead 的数据结构，虽然 TcpStream 支持它，但是我们不应该在单元测试中引入太过复杂的行为。</p>
<details id="admonition-为了测试-read_frame-而建立-tcp-连接显然没有必要怎么办" class="admonition question">
<summary class="admonition-title">
<p>为了测试 read_frame() 而建立 TCP 连接，显然没有必要。怎么办？ </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-为了测试-read_frame-而建立-tcp-连接显然没有必要怎么办"></a></p>
</summary>
<div>
<blockquote>
<p>我们聊过测试代码和产品代码同等的重要性，所以，在开发中，也要为测试代码创建合适的生态环境，让测试简洁、可读性强。</p>
</blockquote>
<p>那这里，我们就创建一个简单的数据结构，使其实现 AsyncRead，这样就可以“单元”测试 read_frame() 了。</p>
<p>在 src/network/frame.rs 里的 mod tests 下加入：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
mod tests {
    struct DummyStream {
        buf: BytesMut,
    }

    impl AsyncRead for DummyStream {
        fn poll_read(
            self: std::pin::Pin&lt;&amp;mut Self&gt;,
            _cx: &amp;mut std::task::Context&lt;'_&gt;,
            buf: &amp;mut tokio::io::ReadBuf&lt;'_&gt;,
        ) -&gt; std::task::Poll&lt;std::io::Result&lt;()&gt;&gt; {
            // 看看 ReadBuf 需要多大的数据
            let len = buf.capacity();

            // split 出这么大的数据
            let data = self.get_mut().buf.split_to(len);

            // 拷贝给 ReadBuf
            buf.put_slice(&amp;data);

            // 直接完工
            std::task::Poll::Ready(Ok(()))
        }
    }
}
</code></pre></pre>
</div>
</details>
<p>因为只需要保证 AsyncRead 接口的正确性，所以不需要太复杂的逻辑. 我们就放一个 buffer，poll_read() 需要读多大的数据，我们就给多大的数据。</p>
<details id="admonition-有了这个-dummystream就可以测试-read_frame-了" class="admonition note">
<summary class="admonition-title">
<p>有了这个 DummyStream，就可以测试 read_frame() 了： </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-有了这个-dummystream就可以测试-read_frame-了"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[tokio::test]
async fn read_frame_should_work() {
    let mut buf = BytesMut::new();
    let cmd = CommandRequest::new_hdel(&quot;t1&quot;, &quot;k1&quot;);
    cmd.encode_frame(&amp;mut buf).unwrap();
    let mut stream = DummyStream { buf };

    let mut data = BytesMut::new();
    read_frame(&amp;mut stream, &amp;mut data).await.unwrap();

    let cmd1 = CommandRequest::decode_frame(&amp;mut data).unwrap();
    assert_eq!(cmd, cmd1);
}
</code></pre></pre>
</div>
</details>
<p>运行 “cargo test”，测试通过。</p>
<blockquote>
<p>如果你的代码无法编译，可以看看编译错误，是不是缺了一些 use 语句来把某些数据结构和 trait 引入。</p>
</blockquote>
<h2 id="让网络层可以像-asyncprost-那样方便使用"><a class="header" href="#让网络层可以像-asyncprost-那样方便使用">让网络层可以像 AsyncProst 那样方便使用</a></h2>
<p>现在，我们的 frame 已经可以正常工作了。</p>
<blockquote>
<p>接下来要构思一下，服务端和客户端该如何封装。</p>
</blockquote>
<details id="admonition-1-对于服务器我们期望可以对-accept-下来的-tcpstream-提供一个-process-方法处理协议的细节" class="admonition note">
<summary class="admonition-title">
<ol>
<li>对于服务器，我们期望可以对 accept 下来的 TcpStream 提供一个 process() 方法，处理协议的细节：</li>
</ol>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-1-对于服务器我们期望可以对-accept-下来的-tcpstream-提供一个-process-方法处理协议的细节"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();
    let addr = &quot;127.0.0.1:9527&quot;;
    let service: Service = ServiceInner::new(MemTable::new()).into();
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Start listening on {}&quot;, addr);
    loop {
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Client {:?} connected&quot;, addr);
        let stream = ProstServerStream::new(stream, service.clone());
        tokio::spawn(async move { stream.process().await });
    }
}
</code></pre></pre>
<p>这个 process() 方法，实际上就是对 examples/server.rs 中 tokio::spawn 里的 while loop 的封装：</p>
<pre><pre class="playground"><code class="language-rust  editable">
while let Some(Ok(cmd)) = stream.next().await {
    info!(&quot;Got a new command: {:?}&quot;, cmd);
    let res = svc.execute(cmd);
    stream.send(res).await.unwrap();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-2-对客户端我们也希望可以直接-execute-一个命令就能得到结果" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>对客户端，我们也希望可以直接 execute() 一个命令，就能得到结果：</li>
</ol>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-2-对客户端我们也希望可以直接-execute-一个命令就能得到结果"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();

    let addr = &quot;127.0.0.1:9527&quot;;
    // 连接服务器
    let stream = TcpStream::connect(addr).await?;

    let mut client = ProstClientStream::new(stream);

    // 生成一个 HSET 命令
    let cmd = CommandRequest::new_hset(&quot;table1&quot;, &quot;hello&quot;, &quot;world&quot;.to_string().into());

    // 发送 HSET 命令
    let data = client.execute(cmd).await?;
    info!(&quot;Got response {:?}&quot;, data);

    Ok(())
}
</code></pre></pre>
<p>这个 execute()，实际上就是对 examples/client.rs 中发送和接收代码的封装：</p>
<pre><pre class="playground"><code class="language-rust  editable">
client.send(cmd).await?;
if let Some(Ok(data)) = client.next().await {
    info!(&quot;Got response {:?}&quot;, data);
}
</code></pre></pre>
<p>这样的代码，看起来很简洁，维护起来也很方便。</p>
</div>
</details>
<ol start="3">
<li>好，先看服务器处理一个 TcpStream 的数据结构，它需要包含 TcpStream，还有我们之前创建的用于处理客户端命令的 Service。</li>
</ol>
<details id="admonition-所以让服务器处理-tcpstream-的结构包含这两部分" class="admonition note">
<summary class="admonition-title">
<p>所以，让服务器处理 TcpStream 的结构包含这两部分： </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-所以让服务器处理-tcpstream-的结构包含这两部分"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct ProstServerStream&lt;S&gt; {
    inner: S,
    service: Service,
}
</code></pre></pre>
<ul>
<li>这里，依旧使用了泛型参数 S。</li>
<li>未来，如果要支持 WebSocket，或者在 TCP 之上支持 TLS，它都可以让我们无需改变这一层的代码。</li>
</ul>
</div>
</details>
<ol start="4">
<li>接下来就是具体的实现。</li>
</ol>
<p>有了 frame 的封装，服务器的 process() 方法和客户端的 execute() 方法都很容易实现。</p>
<details id="admonition-我们直接在-srcnetworkmodrs-里添加完整代码" class="admonition note">
<summary class="admonition-title">
<p>我们直接在 src/network/mod.rs 里添加完整代码： </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-我们直接在-srcnetworkmodrs-里添加完整代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
mod frame;
use bytes::BytesMut;
pub use frame::{read_frame, FrameCoder};
use tokio::io::{AsyncRead, AsyncWrite, AsyncWriteExt};
use tracing::info;

use crate::{CommandRequest, CommandResponse, KvError, Service};

/// 处理服务器端的某个 accept 下来的 socket 的读写
pub struct ProstServerStream&lt;S&gt; {
    inner: S,
    service: Service,
}

/// 处理客户端 socket 的读写
pub struct ProstClientStream&lt;S&gt; {
    inner: S,
}

impl&lt;S&gt; ProstServerStream&lt;S&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send,
{
    pub fn new(stream: S, service: Service) -&gt; Self {
        Self {
            inner: stream,
            service,
        }
    }

    pub async fn process(mut self) -&gt; Result&lt;(), KvError&gt; {
        while let Ok(cmd) = self.recv().await {
            info!(&quot;Got a new command: {:?}&quot;, cmd);
            let res = self.service.execute(cmd);
            self.send(res).await?;
        }
        // info!(&quot;Client {:?} disconnected&quot;, self.addr);
        Ok(())
    }

    async fn send(&amp;mut self, msg: CommandResponse) -&gt; Result&lt;(), KvError&gt; {
        let mut buf = BytesMut::new();
        msg.encode_frame(&amp;mut buf)?;
        let encoded = buf.freeze();
        self.inner.write_all(&amp;encoded[..]).await?;
        Ok(())
    }

    async fn recv(&amp;mut self) -&gt; Result&lt;CommandRequest, KvError&gt; {
        let mut buf = BytesMut::new();
        let stream = &amp;mut self.inner;
        read_frame(stream, &amp;mut buf).await?;
        CommandRequest::decode_frame(&amp;mut buf)
    }
}

impl&lt;S&gt; ProstClientStream&lt;S&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send,
{
    pub fn new(stream: S) -&gt; Self {
        Self { inner: stream }
    }

    pub async fn execute(&amp;mut self, cmd: CommandRequest) -&gt; Result&lt;CommandResponse, KvError&gt; {
        self.send(cmd).await?;
        Ok(self.recv().await?)
    }

    async fn send(&amp;mut self, msg: CommandRequest) -&gt; Result&lt;(), KvError&gt; {
        let mut buf = BytesMut::new();
        msg.encode_frame(&amp;mut buf)?;
        let encoded = buf.freeze();
        self.inner.write_all(&amp;encoded[..]).await?;
        Ok(())
    }

    async fn recv(&amp;mut self) -&gt; Result&lt;CommandResponse, KvError&gt; {
        let mut buf = BytesMut::new();
        let stream = &amp;mut self.inner;
        read_frame(stream, &amp;mut buf).await?;
        CommandResponse::decode_frame(&amp;mut buf)
    }
}
</code></pre></pre>
</div>
</details>
<p>这段代码不难阅读，基本上和 frame 的测试代码大同小异。</p>
<details id="admonition-5-当然了我们还是需要写段代码来测试客户端和服务器交互的整个流程" class="admonition note">
<summary class="admonition-title">
<ol start="5">
<li>当然了，我们还是需要写段代码来测试客户端和服务器交互的整个流程： </li>
</ol>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-5-当然了我们还是需要写段代码来测试客户端和服务器交互的整个流程"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
mod tests {
    use anyhow::Result;
    use bytes::Bytes;
    use std::net::SocketAddr;
    use tokio::net::{TcpListener, TcpStream};

    use crate::{assert_res_ok, MemTable, ServiceInner, Value};

    use super::*;

    #[tokio::test]
    async fn client_server_basic_communication_should_work() -&gt; anyhow::Result&lt;()&gt; {
        let addr = start_server().await?;

        let stream = TcpStream::connect(addr).await?;
        let mut client = ProstClientStream::new(stream);

        // 发送 HSET，等待回应

        let cmd = CommandRequest::new_hset(&quot;t1&quot;, &quot;k1&quot;, &quot;v1&quot;.into());
        let res = client.execute(cmd).await.unwrap();

        // 第一次 HSET 服务器应该返回 None
        assert_res_ok(res, &amp;[Value::default()], &amp;[]);

        // 再发一个 HSET
        let cmd = CommandRequest::new_hget(&quot;t1&quot;, &quot;k1&quot;);
        let res = client.execute(cmd).await?;

        // 服务器应该返回上一次的结果
        assert_res_ok(res, &amp;[&quot;v1&quot;.into()], &amp;[]);

        Ok(())
    }

    #[tokio::test]
    async fn client_server_compression_should_work() -&gt; anyhow::Result&lt;()&gt; {
        let addr = start_server().await?;

        let stream = TcpStream::connect(addr).await?;
        let mut client = ProstClientStream::new(stream);

        let v: Value = Bytes::from(vec![0u8; 16384]).into();
        let cmd = CommandRequest::new_hset(&quot;t2&quot;, &quot;k2&quot;, v.clone().into());
        let res = client.execute(cmd).await?;

        assert_res_ok(res, &amp;[Value::default()], &amp;[]);

        let cmd = CommandRequest::new_hget(&quot;t2&quot;, &quot;k2&quot;);
        let res = client.execute(cmd).await?;

        assert_res_ok(res, &amp;[v.into()], &amp;[]);

        Ok(())
    }

    async fn start_server() -&gt; Result&lt;SocketAddr&gt; {
        let listener = TcpListener::bind(&quot;127.0.0.1:0&quot;).await.unwrap();
        let addr = listener.local_addr().unwrap();

        tokio::spawn(async move {
            loop {
                let (stream, _) = listener.accept().await.unwrap();
                let service: Service = ServiceInner::new(MemTable::new()).into();
                let server = ProstServerStream::new(stream, service);
                tokio::spawn(server.process());
            }
        });

        Ok(addr)
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="正式创建-kv-server-和-kv-client"><a class="header" href="#正式创建-kv-server-和-kv-client">正式创建 kv-server 和 kv-client</a></h2>
<p>我们之前写了很多代码，真正可运行的 server/client 都是 examples 下的代码。</p>
<p>现在我们终于要正式创建 kv-server / kv-client 了。</p>
<ol>
<li>首先在 Cargo.toml 中，加入两个可执行文件：kvs（kv-server）和 kvc（kv-client）。还需要把一些依赖移动到 dependencies 下。</li>
</ol>
<details id="admonition-2-修改之后cargotoml-长这个样子" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>修改之后，Cargo.toml 长这个样子：</li>
</ol>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-2-修改之后cargotoml-长这个样子"></a></p>
</summary>
<div>
<pre><code class="language-toml">
[package]
name = &quot;kv2&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[[bin]]
name = &quot;kvs&quot;
path = &quot;src/server.rs&quot;

[[bin]]
name = &quot;kvc&quot;
path = &quot;src/client.rs&quot;

[dependencies]
anyhow = &quot;1&quot; # 错误处理
bytes = &quot;1&quot; # 高效处理网络 buffer 的库
dashmap = &quot;4&quot; # 并发 HashMap
flate2 = &quot;1&quot; # gzip 压缩
http = &quot;0.2&quot; # 我们使用 HTTP status code 所以引入这个类型库
prost = &quot;0.8&quot; # 处理 protobuf 的代码
sled = &quot;0.34&quot; # sled db
thiserror = &quot;1&quot; # 错误定义和处理
tokio = { version = &quot;1&quot;, features = [&quot;full&quot; ] } # 异步网络库
tracing = &quot;0.1&quot; # 日志处理
tracing-subscriber = &quot;0.2&quot; # 日志处理

[dev-dependencies]
async-prost = &quot;0.2.1&quot; # 支持把 protobuf 封装成 TCP frame
futures = &quot;0.3&quot; # 提供 Stream trait
tempfile = &quot;3&quot; # 处理临时目录和临时文件
tokio-util = { version = &quot;0.6&quot;, features = [&quot;codec&quot;]}

[build-dependencies]
prost-build = &quot;0.8&quot; # 编译 protobuf
</code></pre>
</div>
</details>
<ol start="3">
<li>然后，创建 src/client.rs 和 src/server.rs，分别写入下面的代码。</li>
</ol>
<details id="admonition-srcclientrs" class="admonition note">
<summary class="admonition-title">
<p>src/client.rs：</p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-srcclientrs"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use kv2::{CommandRequest, ProstClientStream};
use tokio::net::TcpStream;
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();

    let addr = &quot;127.0.0.1:9527&quot;;
    // 连接服务器
    let stream = TcpStream::connect(addr).await?;

    let mut client = ProstClientStream::new(stream);

    // 生成一个 HSET 命令
    let cmd = CommandRequest::new_hset(&quot;table1&quot;, &quot;hello&quot;, &quot;world&quot;.to_string().into());

    // 发送 HSET 命令
    let data = client.execute(cmd).await?;
    info!(&quot;Got response {:?}&quot;, data);

    Ok(())
}
</code></pre></pre>
</div>
</details>
<p>这和之前的 client / server 的代码几乎一致，不同的是，我们使用了自己撰写的 frame 处理方法。</p>
<details id="admonition-测试成功" class="admonition success">
<summary class="admonition-title">
<p>测试成功：</p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-测试成功"></a></p>
</summary>
<div>
<ul>
<li>完成之后，我们可以打开一个命令行窗口，运行：</li>
</ul>
<pre><code class="language-shell">RUST_LOG=info cargo run --bin kvs --quiet
</code></pre>
<ul>
<li>然后在另一个命令行窗口，运行：</li>
</ul>
<pre><code class="language-shell">RUST_LOG=info cargo run --bin kvc --quiet
</code></pre>
</div>
</details>
<ul>
<li>此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。现在，我们的 KV server 越来越像回事了！</li>
</ul>
<h2 id="回顾网络开发"><a class="header" href="#回顾网络开发">回顾网络开发</a></h2>
<p>网络开发是 Rust 下一个很重要的应用场景。tokio 为我们提供了很棒的异步网络开发的支持。</p>
<details id="admonition-网络开发的提示1-frame如何封装2-自定义测试数据结构3-单元测试覆盖率" class="admonition tip">
<summary class="admonition-title">
<p>网络开发的提示：1. frame如何封装；2. 自定义测试数据结构；3. 单元测试覆盖率 </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-网络开发的提示1-frame如何封装2-自定义测试数据结构3-单元测试覆盖率"></a></p>
</summary>
<div>
<p>在开发网络协议时，你要确定你的 frame 如何封装：</p>
<ul>
<li>一般来说，长度 + protobuf 足以应付绝大多数复杂的协议需求。</li>
<li>我们虽然详细介绍了自己该如何处理用长度封装 frame 的方法，其实 tokio-util 提供了 <a href="https://docs.rs/tokio-util/0.6.8/tokio_util/codec/length_delimited/index.html">LengthDelimitedCodec</a>，可以完成今天关于 frame 部分的处理。如果你自己撰写网络程序，可以直接使用它。</li>
</ul>
<p>在网络开发的时候，如何做单元测试是一大痛点，我们可以根据其实现的接口，围绕着接口来构建测试数据结构，比如 TcpStream 实现了 AsycnRead / AsyncWrite。</p>
<p>考虑简洁和可读，为了测试 read_frame() ，我们构建了 DummyStream 来协助测试。你也可以用类似的方式处理你所做项目的测试需求。</p>
<p>结构良好架构清晰的代码，一定是容易测试的代码，纵观整个项目，从 CommandService trait 和 Storage trait 的测试，一路到现在网络层的测试。如果使用 <a href="https://github.com/xd009642/tarpaulin">tarpaulin </a>来看测试覆盖率，你会发现，这个项目目前已经有 89% 了，如果不算 src/server.rs 和 src/client.rs 的话，有接近 92% 的测试覆盖率。即便在生产环境的代码里，这也算是很高质量的测试覆盖率了。</p>
<pre><code class="language-shell">INFO cargo_tarpaulin::report: Coverage Results:
|| Tested/Total Lines:
|| src/client.rs: 0/9 +0.00%
|| src/network/frame.rs: 80/82 +0.00%
|| src/network/mod.rs: 65/66 +4.66%
|| src/pb/mod.rs: 54/75 +0.00%
|| src/server.rs: 0/11 +0.00%
|| src/service/command_service.rs: 120/129 +0.00%
|| src/service/mod.rs: 79/84 +0.00%
|| src/storage/memory.rs: 34/37 +0.00%
|| src/storage/mod.rs: 58/58 +0.00%
|| src/storage/sleddb.rs: 40/43 +0.00%
||
89.23% coverage, 530/594 lines covered
</code></pre>
</div>
</details>
<details id="admonition-考虑支持gziplz4和zstd" class="admonition question">
<summary class="admonition-title">
<p>考虑支持gzip、lz4和zstd</p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-考虑支持gziplz4和zstd"></a></p>
</summary>
<div>
<p>在设计 frame 的时候，如果我们的压缩方法不止 gzip 一种，而是服务器或客户端都会根据各自的情况，在需要的时候做某种算法的压缩。假设服务器和客户端都支持 gzip、lz4 和 zstd 这三种压缩算法。那么 frame 该如何设计呢？需要用几个 bit 来存放压缩算法的信息？</p>
<p>目前我们的 client 只适合测试，你可以将其修改成一个完整的命令行程序么？小提示，可以使用 clap 或 structopt，用户可以输入不同的命令；或者做一个交互式的命令行，使用 shellfish 或 rustyline，就像 redis-cli 那样。</p>
<p>试着使用 LengthDelimitedCodec 来重写 frame 这一层。</p>
</div>
</details>
<details id="admonition-关于tarpaulin" class="admonition info">
<summary class="admonition-title">
<p>关于tarpaulin </p>
<p><a class="admonition-anchor-link" href="kv4_network.html#admonition-关于tarpaulin"></a></p>
</summary>
<div>
<p>arpaulin 是 Rust 下做测试覆盖率的工具。因为使用了操作系统和 CPU 的特殊指令追踪代码的执行，所以它目前只支持 x86_64 / Linux。测试覆盖率一般在 CI 中使用，所以有 Linux 的支持也足够了。</p>
<p>一般来说，我们在生产环境中运行的代码，都要求至少有 80% 以上的测试覆盖率。为项目构建足够好的测试覆盖率并不容易，因为这首先意味着写出来的代码要容易测试。所以，对于新的项目，最好一开始就在 CI 中为测试覆盖率设置一个门槛，这样可以倒逼着大家保证单元测试的数量。同时，单元测试又会倒逼代码要有良好的结构和良好的接口，否则不容易测试。</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="五网络安全生成-x509-证书"><a class="header" href="#五网络安全生成-x509-证书">五、网络安全：生成 x509 证书</a></h1>
<!--ts-->
<ul>
<li><a href="kv5_network_security.html#%E4%BA%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%94%9F%E6%88%90-x509-%E8%AF%81%E4%B9%A6">五、网络安全：生成 x509 证书</a>
<ul>
<li><a href="kv5_network_security.html#%E5%9C%A8-kv-server-%E4%B8%AD%E4%BD%BF%E7%94%A8-tls">在 KV server 中使用 TLS</a>
<ul>
<li><a href="kv5_network_security.html#%E5%AE%9E%E7%8E%B0tls">实现TLS</a></li>
</ul>
</li>
<li><a href="kv5_network_security.html#%E8%AE%A9-kv-clientserver-%E6%94%AF%E6%8C%81-tls">让 KV client/server 支持 TLS</a></li>
<li><a href="kv5_network_security.html#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9B%9E%E9%A1%BE">网络安全开发回顾</a></li>
<li><a href="kv5_network_security.html#%E8%80%83%E8%99%91%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81">考虑双向验证</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:30 UTC 2022 -->
<!--te-->
<details id="admonition-那么当我们的应用架构在-tcp-上时如何使用-tls-来保证客户端和服务器间的安全性呢" class="admonition question">
<summary class="admonition-title">
<p>那么，当我们的应用架构在 TCP 上时，如何使用 TLS 来保证客户端和服务器间的安全性呢？</p>
<p><a class="admonition-anchor-link" href="kv5_network_security.html#admonition-那么当我们的应用架构在-tcp-上时如何使用-tls-来保证客户端和服务器间的安全性呢"></a></p>
</summary>
<div>
<p>想要使用 TLS，我们首先需要 <a href="https://en.wikipedia.org/wiki/X.509">x509 证书</a>。TLS 需要 x509 证书让客户端验证服务器是否是一个受信的服务器，甚至服务器验证客户端，确认对方是一个受信的客户端。</p>
<p>为了测试方便，我们要有能力生成自己的 CA 证书、服务端证书，甚至客户端证书。证书生成的细节今天就不详细介绍了，我之前做了<a href="https://github.com/tyrchen/certify">一个叫 certify 的库</a>，可以用来生成各种证书。</p>
</div>
</details>
<details id="admonition-使用与测试生成证书" class="admonition note">
<summary class="admonition-title">
<p>使用与测试：生成证书</p>
<p><a class="admonition-anchor-link" href="kv5_network_security.html#admonition-使用与测试生成证书"></a></p>
</summary>
<div>
<ol>
<li>我们可以在 Cargo.toml 里加入这个库：</li>
</ol>
<pre><code class="language-toml">
[dev-dependencies]
...
certify = &quot;0.3&quot;
...
</code></pre>
<ol start="2">
<li>然后在根目录下创建 fixtures 目录存放证书</li>
<li>再创建 examples/gen_cert.rs 文件，添入如下代码：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use certify::{generate_ca, generate_cert, load_ca, CertType, CA};
use tokio::fs;

struct CertPem {
    cert_type: CertType,
    cert: String,
    key: String,
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let pem = create_ca()?;
    gen_files(&amp;pem).await?;
    let ca = load_ca(&amp;pem.cert, &amp;pem.key)?;
    let pem = create_cert(&amp;ca, &amp;[&quot;kvserver.acme.inc&quot;], &quot;Acme KV server&quot;, false)?;
    gen_files(&amp;pem).await?;
    let pem = create_cert(&amp;ca, &amp;[], &quot;awesome-device-id&quot;, true)?;
    gen_files(&amp;pem).await?;
    Ok(())
}

fn create_ca() -&gt; Result&lt;CertPem&gt; {
    let (cert, key) = generate_ca(
        &amp;[&quot;acme.inc&quot;],
        &quot;CN&quot;,
        &quot;Acme Inc.&quot;,
        &quot;Acme CA&quot;,
        None,
        Some(10 * 365),
    )?;
    Ok(CertPem {
        cert_type: CertType::CA,
        cert,
        key,
    })
}

fn create_cert(ca: &amp;CA, domains: &amp;[&amp;str], cn: &amp;str, is_client: bool) -&gt; Result&lt;CertPem&gt; {
    let (days, cert_type) = if is_client {
        (Some(365), CertType::Client)
    } else {
        (Some(5 * 365), CertType::Server)
    };
    let (cert, key) = generate_cert(ca, domains, &quot;CN&quot;, &quot;Acme Inc.&quot;, cn, None, is_client, days)?;

    Ok(CertPem {
        cert_type,
        cert,
        key,
    })
}

async fn gen_files(pem: &amp;CertPem) -&gt; Result&lt;()&gt; {
    let name = match pem.cert_type {
        CertType::Client =&gt; &quot;client&quot;,
        CertType::Server =&gt; &quot;server&quot;,
        CertType::CA =&gt; &quot;ca&quot;,
    };
    fs::write(format!(&quot;fixtures/{}.cert&quot;, name), pem.cert.as_bytes()).await?;
    fs::write(format!(&quot;fixtures/{}.key&quot;, name), pem.key.as_bytes()).await?;
    Ok(())
}
</code></pre></pre>
<p>这个代码很简单:</p>
<ul>
<li>它先生成了一个 CA 证书</li>
<li>然后再生成服务器和客户端证书，全部存入刚创建的 fixtures 目录下。</li>
<li>你需要 <code>cargo run --examples gen_cert</code> 运行一下这个命令，待会我们会在测试中用到这些证书和密钥。</li>
</ul>
</div>
</details>
<h2 id="在-kv-server-中使用-tls"><a class="header" href="#在-kv-server-中使用-tls">在 KV server 中使用 TLS</a></h2>
<details id="admonition-tls-是目前最主要的应用层安全协议" class="admonition info">
<summary class="admonition-title">
<p>TLS 是目前最主要的应用层安全协议 </p>
<p><a class="admonition-anchor-link" href="kv5_network_security.html#admonition-tls-是目前最主要的应用层安全协议"></a></p>
</summary>
<div>
<p>TLS 是目前最主要的应用层安全协议，被广泛用于保护架构在 TCP 之上的，比如 MySQL、HTTP 等各种协议。一个网络应用，即便是在内网使用，如果没有安全协议来保护，都是很危险的。</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/71befa0bbf5225582dd01a7330c641f7.png" alt="img" /></p>
<p>对于 KV server 来说，使用 TLS 之后，整个协议的数据封装如下图所示：</p>
<p><img src="/Users/kuanhsiaokuo/Migrations/writing_materials/077659d231dd45b1617ed3707c74cf13.jpg" alt="img" /></p>
</div>
</details>
<p>所以今天要做的就是在上一讲的网络处理的基础上，添加 TLS 支持，使得 KV server 的客户端服务器之间的通讯被严格保护起来，确保最大程度的安全，免遭第三方的偷窥、篡改以及仿造。</p>
<h3 id="实现tls"><a class="header" href="#实现tls">实现TLS</a></h3>
<p>好，接下来我们看看 TLS 怎么实现。</p>
<p>估计很多人一听 TLS 或者 SSL，就头皮发麻，因为之前跟 <a href="https://www.openssl.org">openssl</a> 打交道有过很多不好的经历。openssl 的代码库太庞杂，API 不友好，编译链接都很费劲。</p>
<details id="admonition-不过在-rust-下使用-tls-的体验还是很不错的" class="admonition info">
<summary class="admonition-title">
<p>不过，在 Rust 下使用 TLS 的体验还是很不错的： </p>
<p><a class="admonition-anchor-link" href="kv5_network_security.html#admonition-不过在-rust-下使用-tls-的体验还是很不错的"></a></p>
</summary>
<div>
<ul>
<li>Rust 对 openssl 有很不错的封装: <a href="https://github.com/sfackler/rust-openssl">rust-openssl</a></li>
<li>也有不依赖 openssl 用 Rust 撰写的 <a href="https://github.com/rustls/rustls">rustls</a></li>
<li>tokio 进一步提供了<a href="https://github.com/tokio-rs/tls">符合 tokio 生态圈的 tls 支持</a>，有 openssl 版本和 rustls 版本可选。</li>
</ul>
</div>
</details>
<p>我们今天就用 <a href="https://github.com/tokio-rs/tls/tree/master/tokio-rustls">tokio-rustls</a> 来撰写 TLS 的支持。</p>
<blockquote>
<p>相信你在实现过程中可以看到，在应用程序中加入 TLS 协议来保护网络层，是多么轻松的一件事情。</p>
</blockquote>
<details id="admonition-1-先在-cargotoml-中添加-tokio-rustls" class="admonition note">
<summary class="admonition-title">
<ol>
<li>先在 Cargo.toml 中添加 tokio-rustls：</li>
</ol>
<p><a class="admonition-anchor-link" href="kv5_network_security.html#admonition-1-先在-cargotoml-中添加-tokio-rustls"></a></p>
</summary>
<div>
<pre><code class="language-toml">
[dev-dependencies]
...
certify = &quot;0.3&quot;
...
</code></pre>
</div>
</details>
<details id="admonition-2-然后创建-srcnetworktlsrs撰写如下代码-记得在-srcnetworkmodrs-中引入这个文件" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>然后创建 src/network/tls.rs，撰写如下代码, 记得在 src/network/mod.rs 中引入这个文件 </li>
</ol>
<p><a class="admonition-anchor-link" href="kv5_network_security.html#admonition-2-然后创建-srcnetworktlsrs撰写如下代码-记得在-srcnetworkmodrs-中引入这个文件"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::io::Cursor;
use std::sync::Arc;

use tokio::io::{AsyncRead, AsyncWrite};
use tokio_rustls::rustls::{internal::pemfile, Certificate, ClientConfig, ServerConfig};
use tokio_rustls::rustls::{AllowAnyAuthenticatedClient, NoClientAuth, PrivateKey, RootCertStore};
use tokio_rustls::webpki::DNSNameRef;
use tokio_rustls::TlsConnector;
use tokio_rustls::{
    client::TlsStream as ClientTlsStream, server::TlsStream as ServerTlsStream, TlsAcceptor,
};

use crate::KvError;

/// KV Server 自己的 ALPN (Application-Layer Protocol Negotiation)
const ALPN_KV: &amp;str = &quot;kv&quot;;

/// 存放 TLS ServerConfig 并提供方法 accept 把底层的协议转换成 TLS
#[derive(Clone)]
pub struct TlsServerAcceptor {
    inner: Arc&lt;ServerConfig&gt;,
}

/// 存放 TLS Client 并提供方法 connect 把底层的协议转换成 TLS
#[derive(Clone)]
pub struct TlsClientConnector {
    pub config: Arc&lt;ClientConfig&gt;,
    pub domain: Arc&lt;String&gt;,
}

impl TlsClientConnector {
    /// 加载 client cert / CA cert，生成 ClientConfig
    pub fn new(
        domain: impl Into&lt;String&gt;,
        identity: Option&lt;(&amp;str, &amp;str)&gt;,
        server_ca: Option&lt;&amp;str&gt;,
    ) -&gt; Result&lt;Self, KvError&gt; {
        let mut config = ClientConfig::new();

        // 如果有客户端证书，加载之
        if let Some((cert, key)) = identity {
            let certs = load_certs(cert)?;
            let key = load_key(key)?;
            config.set_single_client_cert(certs, key)?;
        }

        // 加载本地信任的根证书链
        config.root_store = match rustls_native_certs::load_native_certs() {
            Ok(store) | Err((Some(store), _)) =&gt; store,
            Err((None, error)) =&gt; return Err(error.into()),
        };

        // 如果有签署服务器的 CA 证书，则加载它，这样服务器证书不在根证书链
        // 但是这个 CA 证书能验证它，也可以
        if let Some(cert) = server_ca {
            let mut buf = Cursor::new(cert);
            config.root_store.add_pem_file(&amp;mut buf).unwrap();
        }

        Ok(Self {
            config: Arc::new(config),
            domain: Arc::new(domain.into()),
        })
    }

    /// 触发 TLS 协议，把底层的 stream 转换成 TLS stream
    pub async fn connect&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ClientTlsStream&lt;S&gt;, KvError&gt;
    where
        S: AsyncRead + AsyncWrite + Unpin + Send,
    {
        let dns = DNSNameRef::try_from_ascii_str(self.domain.as_str())
            .map_err(|_| KvError::Internal(&quot;Invalid DNS name&quot;.into()))?;

        let stream = TlsConnector::from(self.config.clone())
            .connect(dns, stream)
            .await?;

        Ok(stream)
    }
}

impl TlsServerAcceptor {
    /// 加载 server cert / CA cert，生成 ServerConfig
    pub fn new(cert: &amp;str, key: &amp;str, client_ca: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self, KvError&gt; {
        let certs = load_certs(cert)?;
        let key = load_key(key)?;

        let mut config = match client_ca {
            None =&gt; ServerConfig::new(NoClientAuth::new()),
            Some(cert) =&gt; {
                // 如果客户端证书是某个 CA 证书签发的，则把这个 CA 证书加载到信任链中
                let mut cert = Cursor::new(cert);
                let mut client_root_cert_store = RootCertStore::empty();
                client_root_cert_store
                    .add_pem_file(&amp;mut cert)
                    .map_err(|_| KvError::CertifcateParseError(&quot;CA&quot;, &quot;cert&quot;))?;

                let client_auth = AllowAnyAuthenticatedClient::new(client_root_cert_store);
                ServerConfig::new(client_auth)
            }
        };

        // 加载服务器证书
        config
            .set_single_cert(certs, key)
            .map_err(|_| KvError::CertifcateParseError(&quot;server&quot;, &quot;cert&quot;))?;
        config.set_protocols(&amp;[Vec::from(&amp;ALPN_KV[..])]);

        Ok(Self {
            inner: Arc::new(config),
        })
    }

    /// 触发 TLS 协议，把底层的 stream 转换成 TLS stream
    pub async fn accept&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ServerTlsStream&lt;S&gt;, KvError&gt;
    where
        S: AsyncRead + AsyncWrite + Unpin + Send,
    {
        let acceptor = TlsAcceptor::from(self.inner.clone());
        Ok(acceptor.accept(stream).await?)
    }
}

fn load_certs(cert: &amp;str) -&gt; Result&lt;Vec&lt;Certificate&gt;, KvError&gt; {
    let mut cert = Cursor::new(cert);
    pemfile::certs(&amp;mut cert).map_err(|_| KvError::CertifcateParseError(&quot;server&quot;, &quot;cert&quot;))
}

fn load_key(key: &amp;str) -&gt; Result&lt;PrivateKey, KvError&gt; {
    let mut cursor = Cursor::new(key);

    // 先尝试用 PKCS8 加载私钥
    if let Ok(mut keys) = pemfile::pkcs8_private_keys(&amp;mut cursor) {
        if !keys.is_empty() {
            return Ok(keys.remove(0));
        }
    }

    // 再尝试加载 RSA key
    cursor.set_position(0);
    if let Ok(mut keys) = pemfile::rsa_private_keys(&amp;mut cursor) {
        if !keys.is_empty() {
            return Ok(keys.remove(0));
        }
    }

    // 不支持的私钥类型
    Err(KvError::CertifcateParseError(&quot;private&quot;, &quot;key&quot;))
}
</code></pre></pre>
<ul>
<li>这个代码创建了两个数据结构 TlsServerAcceptor / TlsClientConnector。</li>
<li>虽然它有 100 多行，但主要的工作其实就是根据提供的证书，来生成 tokio-tls 需要的 ServerConfig / ClientConfig。</li>
<li>因为 TLS 需要验证证书的 CA，所以还需要加载 CA 证书。虽然平时在做 Web 开发时，我们都只使用服务器证书，但其实 TLS 支持双向验证，服务器也可以验证客户端的证书是否是它认识的 CA 签发的。</li>
</ul>
</div>
</details>
<blockquote>
<p>处理完 config 后，这段代码的核心逻辑其实就是客户端的 connect() 方法和服务器的 accept() 方法，它们都接受一个满足 AsyncRead + AsyncWrite + Unpin + Send 的 stream。</p>
</blockquote>
<details id="admonition-3-考虑到通用性我们不希望-tls-代码只能接受-tcpstream所以这里提供了一个泛型参数-s" class="admonition note">
<summary class="admonition-title">
<ol start="3">
<li>考虑到通用性，我们不希望 TLS 代码只能接受 TcpStream，所以这里提供了一个泛型参数 S：</li>
</ol>
<p><a class="admonition-anchor-link" href="kv5_network_security.html#admonition-3-考虑到通用性我们不希望-tls-代码只能接受-tcpstream所以这里提供了一个泛型参数-s"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
/// 触发 TLS 协议，把底层的 stream 转换成 TLS stream
pub async fn connect&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ClientTlsStream&lt;S&gt;, KvError&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send,
{
    let dns = DNSNameRef::try_from_ascii_str(self.domain.as_str())
        .map_err(|_| KvError::Internal(&quot;Invalid DNS name&quot;.into()))?;

    let stream = TlsConnector::from(self.config.clone())
        .connect(dns, stream)
        .await?;

    Ok(stream)
}

/// 触发 TLS 协议，把底层的 stream 转换成 TLS stream
pub async fn accept&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ServerTlsStream&lt;S&gt;, KvError&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send,
{
    let acceptor = TlsAcceptor::from(self.inner.clone());
    Ok(acceptor.accept(stream).await?)
}
</code></pre></pre>
<ul>
<li>在使用 TlsConnector 或者 TlsAcceptor 处理完 connect/accept 后，我们得到了一个 TlsStream</li>
<li>它也满足 AsyncRead + AsyncWrite + Unpin + Send</li>
<li>后续的操作就可以在其上完成了。</li>
<li>百来行代码就搞定了 TLS，是不是很轻松？</li>
</ul>
</div>
</details>
<details id="admonition-4-我们来顺着往下写段测试" class="admonition note">
<summary class="admonition-title">
<ol start="4">
<li>我们来顺着往下写段测试： </li>
</ol>
<p><a class="admonition-anchor-link" href="kv5_network_security.html#admonition-4-我们来顺着往下写段测试"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
mod tests {

    use std::net::SocketAddr;

    use super::*;
    use anyhow::Result;
    use tokio::{
        io::{AsyncReadExt, AsyncWriteExt},
        net::{TcpListener, TcpStream},
    };

    const CA_CERT: &amp;str = include_str!(&quot;../../fixtures/ca.cert&quot;);
    const CLIENT_CERT: &amp;str = include_str!(&quot;../../fixtures/client.cert&quot;);
    const CLIENT_KEY: &amp;str = include_str!(&quot;../../fixtures/client.key&quot;);
    const SERVER_CERT: &amp;str = include_str!(&quot;../../fixtures/server.cert&quot;);
    const SERVER_KEY: &amp;str = include_str!(&quot;../../fixtures/server.key&quot;);

    #[tokio::test]
    async fn tls_should_work() -&gt; Result&lt;()&gt; {
        let ca = Some(CA_CERT);

        let addr = start_server(None).await?;

        let connector = TlsClientConnector::new(&quot;kvserver.acme.inc&quot;, None, ca)?;
        let stream = TcpStream::connect(addr).await?;
        let mut stream = connector.connect(stream).await?;
        stream.write_all(b&quot;hello world!&quot;).await?;
        let mut buf = [0; 12];
        stream.read_exact(&amp;mut buf).await?;
        assert_eq!(&amp;buf, b&quot;hello world!&quot;);

        Ok(())
    }

    #[tokio::test]
    async fn tls_with_client_cert_should_work() -&gt; Result&lt;()&gt; {
        let client_identity = Some((CLIENT_CERT, CLIENT_KEY));
        let ca = Some(CA_CERT);

        let addr = start_server(ca.clone()).await?;

        let connector = TlsClientConnector::new(&quot;kvserver.acme.inc&quot;, client_identity, ca)?;
        let stream = TcpStream::connect(addr).await?;
        let mut stream = connector.connect(stream).await?;
        stream.write_all(b&quot;hello world!&quot;).await?;
        let mut buf = [0; 12];
        stream.read_exact(&amp;mut buf).await?;
        assert_eq!(&amp;buf, b&quot;hello world!&quot;);

        Ok(())
    }

    #[tokio::test]
    async fn tls_with_bad_domain_should_not_work() -&gt; Result&lt;()&gt; {
        let addr = start_server(None).await?;

        let connector = TlsClientConnector::new(&quot;kvserver1.acme.inc&quot;, None, Some(CA_CERT))?;
        let stream = TcpStream::connect(addr).await?;
        let result = connector.connect(stream).await;

        assert!(result.is_err());

        Ok(())
    }

    async fn start_server(ca: Option&lt;&amp;str&gt;) -&gt; Result&lt;SocketAddr&gt; {
        let acceptor = TlsServerAcceptor::new(SERVER_CERT, SERVER_KEY, ca)?;

        let echo = TcpListener::bind(&quot;127.0.0.1:0&quot;).await.unwrap();
        let addr = echo.local_addr().unwrap();

        tokio::spawn(async move {
            let (stream, _) = echo.accept().await.unwrap();
            let mut stream = acceptor.accept(stream).await.unwrap();
            let mut buf = [0; 12];
            stream.read_exact(&amp;mut buf).await.unwrap();
            stream.write_all(&amp;buf).await.unwrap();
        });

        Ok(addr)
    }
}
</code></pre></pre>
<ul>
<li>这段测试代码使用了 include_str! 宏，在编译期把文件加载成字符串放在 RODATA 段。</li>
<li>我们测试了三种情况：标准的 TLS 连接、带有客户端证书的 TLS 连接，以及客户端提供了错的域名的情况。</li>
<li>运行 cargo test ，所有测试都能通过。</li>
</ul>
</div>
</details>
<h2 id="让-kv-clientserver-支持-tls"><a class="header" href="#让-kv-clientserver-支持-tls">让 KV client/server 支持 TLS</a></h2>
<p>在 TLS 的测试都通过后，就可以添加 kvs 和 kvc 对 TLS 的支持了。</p>
<p>由于我们一路以来良好的接口设计，尤其是 ProstClientStream / ProstServerStream 都接受泛型参数，使得 TLS 的代码可以无缝嵌入。</p>
<details id="admonition-和上一版项目相比更新后的客户端和服务器代码各自仅仅多了一行就把-tcpstream-封装成了-tlsstream" class="admonition note">
<summary class="admonition-title">
<p>和上一版项目相比，更新后的客户端和服务器代码，各自仅仅多了一行，就把 TcpStream 封装成了 TlsStream。 </p>
<p><a class="admonition-anchor-link" href="kv5_network_security.html#admonition-和上一版项目相比更新后的客户端和服务器代码各自仅仅多了一行就把-tcpstream-封装成了-tlsstream"></a></p>
</summary>
<div>
<ol>
<li>比如客户端：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
// 新加的代码
let connector = TlsClientConnector::new(&quot;kvserver.acme.inc&quot;, None, Some(ca_cert))?;

let stream = TcpStream::connect(addr).await?;

// 新加的代码
let stream = connector.connect(stream).await?;

let mut client = ProstClientStream::new(stream);
</code></pre></pre>
<p>仅仅需要把传给 ProstClientStream 的 stream，从 TcpStream 换成生成的 TlsStream，就无缝支持了 TLS。</p>
<ol start="2">
<li>我们看完整的代码，src/server.rs：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use kv3::{MemTable, ProstServerStream, Service, ServiceInner, TlsServerAcceptor};
use tokio::net::TcpListener;
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();
    let addr = &quot;127.0.0.1:9527&quot;;

    // 以后从配置文件取
    let server_cert = include_str!(&quot;../fixtures/server.cert&quot;);
    let server_key = include_str!(&quot;../fixtures/server.key&quot;);

    let acceptor = TlsServerAcceptor::new(server_cert, server_key, None)?;
    let service: Service = ServiceInner::new(MemTable::new()).into();
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Start listening on {}&quot;, addr);
    loop {
        let tls = acceptor.clone();
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Client {:?} connected&quot;, addr);
        let stream = tls.accept(stream).await?;
        let stream = ProstServerStream::new(stream, service.clone());
        tokio::spawn(async move { stream.process().await });
    }
}
</code></pre></pre>
<ol start="3">
<li>src/client.rs：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use kv3::{CommandRequest, ProstClientStream, TlsClientConnector};
use tokio::net::TcpStream;
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();

    // 以后用配置替换
    let ca_cert = include_str!(&quot;../fixtures/ca.cert&quot;);

    let addr = &quot;127.0.0.1:9527&quot;;
    // 连接服务器
    let connector = TlsClientConnector::new(&quot;kvserver.acme.inc&quot;, None, Some(ca_cert))?;
    let stream = TcpStream::connect(addr).await?;
    let stream = connector.connect(stream).await?;

    let mut client = ProstClientStream::new(stream);

    // 生成一个 HSET 命令
    let cmd = CommandRequest::new_hset(&quot;table1&quot;, &quot;hello&quot;, &quot;world&quot;.to_string().into());

    // 发送 HSET 命令
    let data = client.execute(cmd).await?;
    info!(&quot;Got response {:?}&quot;, data);

    Ok(())
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>这就是使用 trait 做面向接口编程的巨大威力，系统的各个组件可以来自不同的 crates，但只要其接口一致（或者我们创建 adapter 使其接口一致），就可以无缝插入。</p>
</blockquote>
<details id="admonition-测试通过" class="admonition success">
<summary class="admonition-title">
<p>测试通过 </p>
<p><a class="admonition-anchor-link" href="kv5_network_security.html#admonition-测试通过"></a></p>
</summary>
<div>
<ul>
<li>完成之后，打开一个命令行窗口，运行：</li>
</ul>
<pre><code class="language-shell">RUST_LOG=info cargo run --bin kvs --quiet
</code></pre>
<ul>
<li>然后在另一个命令行窗口，运行：</li>
</ul>
<pre><code class="language-shell">RUST_LOG=info cargo run --bin kvc --quie
</code></pre>
</div>
</details>
<p>此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。</p>
<p>现在，我们的 KV server 已经具备足够的安全性了！</p>
<p>以后，等我们使用配置文件，就可以根据配置文件读取证书和私钥。这样可以在部署的时候，才从 vault 中获取私钥，既保证灵活性，又能保证系统自身的安全。</p>
<h2 id="网络安全开发回顾"><a class="header" href="#网络安全开发回顾">网络安全开发回顾</a></h2>
<p>网络安全是开发网络相关的应用程序中非常重要的一个环节。虽然 KV Server 这样的服务基本上会运行在云端受控的网络环境中，不会对 internet 提供服务，然而云端内部的安全性也不容忽视。你不希望数据在流动的过程中被篡改。</p>
<p>TLS 很好地解决了安全性的问题，可以保证整个传输过程中数据的机密性和完整性。如果使用客户端证书的话，还可以做一定程度的客户端合法性的验证。比如你可以在云端为所有有权访问 KV server
的客户端签发客户端证书，这样，只要客户端的私钥不泄露，就只有拥有证书的客户端才能访问 KV server。</p>
<p>不知道你现在有没有觉得，在 Rust 下使用 TLS 是非常方便的一件事情。并且，我们构建的 ProstServerStream / ProstClientStream，因为有足够好的抽象，可以在 TcpStream 和 TlsStream
之间游刃有余地切换。当你构建好相关的代码，只需要把 TcpStream 换成 TlsStream，KV server 就可以无缝切换到一个安全的网络协议栈。</p>
<h2 id="考虑双向验证"><a class="header" href="#考虑双向验证">考虑双向验证</a></h2>
<p>目前我们的 kvc / kvs 只做了单向的验证，如果服务器要验证客户端的证书，该怎么做？如果你没有头绪，可以再仔细看看测试 TLS 的代码，然后改动 kvc/kvs 使得双向验证也能通过吧。</p>
<p>除了 TLS，另外一个被广泛使用的处理应用层安全的协议是 <a href="https://noiseprotocol.org">noise protocol</a>
。你可以阅读<a href="https://zhuanlan.zhihu.com/p/96944134">陈天的这篇文章</a>了解 noise protocol。Rust 下有<a href="https://github.com/mcginty/snow"> snow </a>
这个很优秀的库处理 noise
protocol。对于有余力的同学，你们可以看看它的文档，尝试着写段<a href="https://github.com/seanmonstar/reqwest/blob/master/src/tls.rs">类似reqwest的 tls.rs 的代码</a>
，让我们的 kvs / kvc 可以使用 noise protocol。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="六异步处理"><a class="header" href="#六异步处理">六、异步处理</a></h1>
<!--ts-->
<ul>
<li><a href="kv6_async_refactor.html#%E5%85%AD%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86">六、异步处理</a>
<ul>
<li><a href="kv6_async_refactor.html#%E5%9B%9E%E9%A1%BE%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B">回顾构建过程</a></li>
<li><a href="kv6_async_refactor.html#%E5%BC%80%E5%A7%8B%E5%81%9A%E5%BC%82%E6%AD%A5%E9%87%8D%E6%9E%84">开始做异步重构</a></li>
<li><a href="kv6_async_refactor.html#%E5%88%9B%E5%BB%BA-proststream">创建 ProstStream</a>
<ul>
<li><a href="kv6_async_refactor.html#%E6%B5%8B%E8%AF%95">测试！</a></li>
</ul>
</li>
<li><a href="kv6_async_refactor.html#%E4%BD%BF%E7%94%A8-proststream">使用 ProstStream</a></li>
<li><a href="kv6_async_refactor.html#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E5%9B%9E%E9%A1%BE%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">异步处理回顾：单元测试的重要性</a></li>
<li><a href="kv6_async_refactor.html#%E6%80%9D%E8%80%83%E9%A2%98">思考题</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:31 UTC 2022 -->
<!--te-->
<h2 id="回顾构建过程"><a class="header" href="#回顾构建过程">回顾构建过程</a></h2>
<p>之前已经完成了一个相对完善的 KV server。</p>
<details id="admonition-还记得是怎么一步步构建这个服务的么" class="admonition question">
<summary class="admonition-title">
<p>还记得是怎么一步步构建这个服务的么？</p>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-还记得是怎么一步步构建这个服务的么"></a></p>
</summary>
<div>
<ol>
<li>搭好 KV server 的基础功能：</li>
</ol>
<ul>
<li>构造了客户端和服务器间交互的 protobuf</li>
<li>然后设计CommandService trait 和 Storage trait，分别处理客户端命令和存储。</li>
</ul>
<ol start="2">
<li>进一步构造了 Service 数据结构：</li>
</ol>
<ul>
<li>接收 CommandRequest</li>
<li>根据其类型调用相应的 CommandService 处理</li>
<li>并做合适的事件通知</li>
<li>最后返回 CommandResponse。</li>
</ul>
<blockquote>
<p>但所有这一切都发生在同步的世界：不管数据是怎么获得的，数据已经在那里，我们需要做的就是把一种数据类型转换成另一种数据类型的运算而已。</p>
</blockquote>
<ol start="3">
<li>之后涉足网络的世界。</li>
</ol>
<ul>
<li>为 KV server 构造了自己的 frame：一个包含长度和是否压缩的信息的 4 字节的头，以及实际的 payload；</li>
<li>还设计了一个 FrameCoder 来对 frame 进行封包和拆包，这为接下来构造网络接口打下了坚实的基础。</li>
</ul>
<ol start="4">
<li>
<p>考虑到网络安全，提供了 TLS 的支持。</p>
</li>
<li>
<p>在构建 ProstStream 的时候开始处理异步</p>
</li>
</ol>
<ul>
<li>ProstStream 内部的 stream 需要支持 AsyncRead + AsyncWrite，这可以让 ProstStream 适配包括 TcpStream 和 TlsStream 在内的一切实现了 AsyncRead 和 AsyncWrite 的异步网络接口。</li>
</ul>
<blockquote>
<p>至此，我们打通了:</p>
</blockquote>
<ul>
<li>从远端得到一个命令</li>
<li>历经 TCP、TLS</li>
<li>然后被 FrameCoder 解出来一个 CommandRequest</li>
<li>交由 Service 来处理的过程</li>
<li>把同步世界和异步世界连接起来的，就是 ProstServerStream 这个结构。</li>
</ul>
</div>
</details>
<div id="admonition--这个从收包处理到处理完成后发包的完整流程和系统结构可以看下图" class="admonition abstract">
<div class="admonition-title">
<blockquote>
<p>这个从收包处理到处理完成后发包的完整流程和系统结构，可以看下图：</p>
</blockquote>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition--这个从收包处理到处理完成后发包的完整流程和系统结构可以看下图"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/82da823b4eb16935fdeyy727e3b3262c.jpg" alt="img" /></p>
</div>
</div>
<h2 id="开始做异步重构"><a class="header" href="#开始做异步重构">开始做异步重构</a></h2>
<p>虽然我们很早就已经撰写了不少异步或者和异步有关的代码。但是最能体现 Rust 异步本质的 poll()、poll_read()、poll_next() 这样的处理函数还没有怎么写过，之前测试异步的 read_frame() 写过一个
DummyStream，算是体验了一下底层的异步处理函数的复杂接口。</p>
<details id="admonition-不过在-dummystream-里并没有做任何复杂的动作" class="admonition note">
<summary class="admonition-title">
<p>不过在 DummyStream 里，并没有做任何复杂的动作： </p>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-不过在-dummystream-里并没有做任何复杂的动作"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
struct DummyStream {
    buf: BytesMut,
}

impl AsyncRead for DummyStream {
    fn poll_read(
        self: std::pin::Pin&lt;&amp;mut Self&gt;,
        _cx: &amp;mut std::task::Context&lt;'_&gt;,
        buf: &amp;mut tokio::io::ReadBuf&lt;'_&gt;,
    ) -&gt; std::task::Poll&lt;std::io::Result&lt;()&gt;&gt; {
        // 看看 ReadBuf 需要多大的数据
        let len = buf.capacity();
        // split 出这么大的数据
        let data = self.get_mut().buf.split_to(len);
        // 拷贝给 ReadBuf
        buf.put_slice(&amp;data);
        // 直接完工
        std::task::Poll::Ready(Ok(()))
    }
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>这里对现有的代码做些重构，让核心的 ProstStream 更符合 Rust 的异步 IO 接口逻辑。</p>
</blockquote>
<p>具体要做点什么呢？</p>
<details id="admonition-看之前写的-prostserverstream-的-process-函数比较一下它和-async_prost-库的-asyncprost-的调用逻辑" class="admonition info">
<summary class="admonition-title">
<p>看之前写的 ProstServerStream 的 process() 函数，比较一下它和 async_prost 库的 AsyncProst 的调用逻辑： </p>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-看之前写的-prostserverstream-的-process-函数比较一下它和-async_prost-库的-asyncprost-的调用逻辑"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
// process() 函数的内在逻辑
while let Ok(cmd) = self.recv().await {
    info!(&quot;Got a new command: {:?}&quot;, cmd);
    let res = self.service.execute(cmd);
    self.send(res).await?;
}

// async_prost 库的 AsyncProst 的调用逻辑
while let Some(Ok(cmd)) = stream.next().await {
    info!(&quot;Got a new command: {:?}&quot;, cmd);
    let res = svc.execute(cmd);
    stream.send(res).await.unwrap();
}
</code></pre></pre>
<p>可以看到：</p>
<ul>
<li>由于 AsyncProst 实现了 <a href="https://docs.rs/futures/0.3.17/futures/stream/trait.Stream.html">Stream</a> 和 <a href="https://docs.rs/futures/0.3.17/futures/sink/trait.Sink.html">Sink</a></li>
<li>能更加自然地调用 <a href="https://docs.rs/futures/0.3.17/futures/stream/trait.StreamExt.html">StreamExt trait </a>的 next() 方法和 SinkExt trait 的 send() 方法，来处理数据的收发</li>
<li>而 ProstServerStream 则自己额外实现了函数 recv() 和 send()。</li>
</ul>
<blockquote>
<p>虽然从代码对比的角度，这两段代码几乎一样，但未来的可扩展性，和整个异步生态的融洽性上，AsyncProst 还是更胜一筹。</p>
</blockquote>
</div>
</details>
<p>所以这里就构造一个 ProstStream 结构，让它实现 Stream 和 Sink 这两个 trait，然后让 ProstServerStream 和 ProstClientStream 使用它。</p>
<h2 id="创建-proststream"><a class="header" href="#创建-proststream">创建 ProstStream</a></h2>
<details id="admonition-在开始重构之前先来简单复习一下-stream-trait-和-sink-trait" class="admonition note">
<summary class="admonition-title">
<p>在开始重构之前，先来简单复习一下 Stream trait 和 Sink trait：</p>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-在开始重构之前先来简单复习一下-stream-trait-和-sink-trait"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
// 可以类比 Iterator
pub trait Stream {
    // 从 Stream 中读取到的数据类型
    type Item;

  // 从 stream 里读取下一个数据
    fn poll_next(
    self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}

// 
pub trait Sink&lt;Item&gt; {
    type Error;
    fn poll_ready(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt;;
    fn start_send(self: Pin&lt;&amp;mut Self&gt;, item: Item) -&gt; Result&lt;(), Self::Error&gt;;
    fn poll_flush(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt;;
    fn poll_close(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt;;
}
</code></pre></pre>
</div>
</details>
<details id="admonition--那么-proststream-具体需要包含什么类型呢" class="admonition question">
<summary class="admonition-title">
<blockquote>
<p>那么 ProstStream 具体需要包含什么类型呢？ </p>
</blockquote>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition--那么-proststream-具体需要包含什么类型呢"></a></p>
</summary>
<div>
<ol>
<li>
<p>因为它的主要职责是从底下的 stream 中读取或者发送数据，所以一个支持 AsyncRead 和 AsyncWrite 的泛型参数 S 是必然需要的。</p>
</li>
<li>
<p>另外 Stream trait 和 Sink 都各需要一个 Item 类型，对于我们的系统来说，Item 是 CommandRequest 或者 CommandResponse，但为了灵活性，我们可以用 In 和 Out 这两个泛型参数来表示。</p>
</li>
<li>
<p>当然，在处理 Stream 和 Sink 时还需要 read buffer 和 write buffer。</p>
</li>
</ol>
<p>综上所述，我们的 ProstStream 结构看上去是这样子的：</p>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct ProstStream&lt;S, In, Out&gt; {
    // innner stream
    stream: S,
    // 写缓存
    wbuf: BytesMut,
    // 读缓存
    rbuf: BytesMut,
}
</code></pre></pre>
</div>
</details>
<details id="admonition-然而rust-不允许数据结构有超出需要的泛型参数怎么办" class="admonition question">
<summary class="admonition-title">
<p>然而，Rust 不允许数据结构有超出需要的泛型参数。怎么办？</p>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-然而rust-不允许数据结构有超出需要的泛型参数怎么办"></a></p>
</summary>
<div>
<blockquote>
<p>别急，可以用<a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html"> PhantomData，它是一个零字节大小的占位符</a>，可以让我们的数据结构携带未使用的泛型参数。</p>
</blockquote>
</div>
</details>
<p>好，现在有足够的思路了，我们创建 src/network/stream.rs，添加如下代码（记得在 src/network/mod.rs 添加对 stream.rs 的引用）：</p>
<details id="admonition-这段代码包含了为-proststream-实现-stream-和-sink-的骨架代码" class="admonition note">
<summary class="admonition-title">
<p>这段代码包含了为 ProstStream 实现 Stream 和 Sink 的骨架代码。 </p>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-这段代码包含了为-proststream-实现-stream-和-sink-的骨架代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use bytes::BytesMut;
use futures::{Sink, Stream};
use std::{
    marker::PhantomData,
    pin::Pin,
    task::{Context, Poll},
};
use tokio::io::{AsyncRead, AsyncWrite};

use crate::{FrameCoder, KvError};

/// 处理 KV server prost frame 的 stream
pub struct ProstStream&lt;S, In, Out&gt; where {
    // innner stream
    stream: S,
    // 写缓存
    wbuf: BytesMut,
    // 读缓存
    rbuf: BytesMut,

    // 类型占位符
    _in: PhantomData&lt;In&gt;,
    _out: PhantomData&lt;Out&gt;,
}

impl&lt;S, In, Out&gt; Stream for ProstStream&lt;S, In, Out&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send,
    In: Unpin + Send + FrameCoder,
    Out: Unpin + Send,
{
    /// 当调用 next() 时，得到 Result&lt;In, KvError&gt;
    type Item = Result&lt;In, KvError&gt;;

    fn poll_next(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt; {
        todo!()
    }
}

/// 当调用 send() 时，会把 Out 发出去
impl&lt;S, In, Out&gt; Sink&lt;Out&gt; for ProstStream&lt;S, In, Out&gt;
where
    S: AsyncRead + AsyncWrite + Unpin,
    In: Unpin + Send,
    Out: Unpin + Send + FrameCoder,
{
    /// 如果发送出错，会返回 KvError
    type Error = KvError;

    fn poll_ready(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        todo!()
    }

    fn start_send(self: Pin&lt;&amp;mut Self&gt;, item: Out) -&gt; Result&lt;(), Self::Error&gt; {
        todo!()
    }

    fn poll_flush(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        todo!()
    }

    fn poll_close(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        todo!()
    }
}
</code></pre></pre>
</div>
</details>
<p>接下来我们就一个个处理。</p>
<blockquote>
<p>注意对于 In 和 Out 参数，还为其约束了 FrameCoder，这样，在实现里我们可以使用 decode_frame() 和 encode_frame() 来获取一个 Item 或者 encode 一个 Item。</p>
</blockquote>
<details id="admonition-1-stream-的实现-主要是stream-的-poll_next-方法" class="admonition note">
<summary class="admonition-title">
<ol>
<li>Stream 的实现, 主要是Stream 的 poll_next() 方法。</li>
</ol>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-1-stream-的实现-主要是stream-的-poll_next-方法"></a></p>
</summary>
<div>
<p>poll_next() 可以直接调用之前写好的 read_frame()，然后再用 decode_frame() 来解包：</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn poll_next(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt; {
    // 上一次调用结束后 rbuf 应该为空
    assert!(self.rbuf.len() == 0);

    // 从 rbuf 中分离出 rest（摆脱对 self 的引用）
    let mut rest = self.rbuf.split_off(0);

    // 使用 read_frame 来获取数据
    let fut = read_frame(&amp;mut self.stream, &amp;mut rest);
    ready!(Box::pin(fut).poll_unpin(cx))?;

    // 拿到一个 frame 的数据，把 buffer 合并回去
    self.rbuf.unsplit(rest);

    // 调用 decode_frame 获取解包后的数据
    Poll::Ready(Some(In::decode_frame(&amp;mut self.rbuf)))
}
</code></pre></pre>
<blockquote>
<p>这个不难理解，但中间这段需要稍微解释一下：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
 // 使用 read_frame 来获取数据
let fut = read_frame(&amp;mut self.stream, &amp;mut rest);
ready!(Box::pin(fut).poll_unpin(cx))?;
</code></pre></pre>
<ol>
<li>因为 poll_xxx() 方法已经是 async/await 的底层 API 实现，所以我们在 poll_xxx() 方法中，是不能直接使用异步函数的，需要把它看作一个 future，然后调用 future 的 poll 函数。</li>
<li>因为 future 是一个 trait，所以需要 Box 将其处理成一个在堆上的 trait object，这样就可以调用 <a href="https://docs.rs/futures/0.3.17/futures/future/trait.FutureExt.html#method.poll_unpin">FutureExt 的 poll_unpin() 方法</a>。Box::pin 会生成 Pin<Box>。</li>
<li>至于 ready! 宏，它会在 Pending 时直接 return Pending，而在 Ready 时，返回 Ready 的值：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
macro_rules! ready {
    ($e:expr $(,)?) =&gt; {
        match $e {
            $crate::task::Poll::Ready(t) =&gt; t,
            $crate::task::Poll::Pending =&gt; return $crate::task::Poll::Pending,
        }
    };
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>Stream 我们就实现好了，是不是也没有那么复杂？</p>
</blockquote>
<details id="admonition-2-sink的实现主要是四个方法" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>Sink的实现：主要是四个方法</li>
</ol>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-2-sink的实现主要是四个方法"></a></p>
</summary>
<div>
<p>再写 Sink，看上去要实现好几个方法，其实也不算复杂的四个方法 ：</p>
<ul>
<li>poll_ready</li>
<li>start_send()</li>
<li>poll_flush </li>
<li>poll_close </li>
</ul>
<p>我们再回顾一下：</p>
<ol>
<li><a href="https://docs.rs/futures/0.3.17/futures/prelude/trait.Sink.html#tymethod.poll_ready">poll_ready() </a>是做背压的</li>
</ol>
<p>你可以根据负载来决定要不要返回 Poll::Ready。对于我们的网络层来说，可以先不关心背压，依靠操作系统的 TCP 协议栈提供背压处理即可，所以这里直接返回 Poll::Ready(Ok(()))，也就是说，上层想写数据，可以随时写。</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn poll_ready(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
    Poll::Ready(Ok(()))
}
</code></pre></pre>
<ol start="2">
<li>当 poll_ready() 返回 Ready 后，Sink 就走到<a href="https://docs.rs/futures/0.3.17/futures/prelude/trait.Sink.html#tymethod.start_send"> start_send()</a>。我们在 start_send() 里就把必要的数据准备好。这里把 item 封包成字节流，存入 wbuf 中：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
fn start_send(self: Pin&lt;&amp;mut Self&gt;, item: Out) -&gt; Result&lt;(), Self::Error&gt; {
    let this = self.get_mut();
    item.encode_frame(&amp;mut this.wbuf)?;

    Ok(())
}
</code></pre></pre>
<ol start="3">
<li>然后在 <a href="https://docs.rs/futures/0.3.17/futures/prelude/trait.Sink.html#tymethod.poll_flush">poll_flush()</a> 中，我们开始写数据。这里需要记录当前写到哪里，所以需要在 ProstStream 里加一个字段 written，记录写入了多少字节：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
/// 处理 KV server prost frame 的 stream
pub struct ProstStream&lt;S, In, Out&gt; {
    // innner stream
    stream: S,
    // 写缓存
    wbuf: BytesMut,
    // 写入了多少字节
    written: usize,
    // 读缓存
    rbuf: BytesMut,

    // 类型占位符
    _in: PhantomData&lt;In&gt;,
    _out: PhantomData&lt;Out&gt;,
}
</code></pre></pre>
<p>有了这个 written 字段， 就可以循环写入：</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn poll_flush(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
    let this = self.get_mut();

    // 循环写入 stream 中
    while this.written != this.wbuf.len() {
        let n = ready!(Pin::new(&amp;mut this.stream).poll_write(cx, &amp;this.wbuf[this.written..]))?;
        this.written += n;
    }

    // 清除 wbuf
    this.wbuf.clear();
    this.written = 0;

    // 调用 stream 的 poll_flush 确保写入
    ready!(Pin::new(&amp;mut this.stream).poll_flush(cx)?);
    Poll::Ready(Ok(()))
}
</code></pre></pre>
<ol start="4">
<li>最后是 <a href="https://docs.rs/futures/0.3.17/futures/prelude/trait.Sink.html#tymethod.poll_close">poll_close()</a>，我们只需要调用 stream 的 flush 和 shutdown 方法，确保数据写完并且 stream 关闭：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
fn poll_close(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
    // 调用 stream 的 poll_flush 确保写入
    ready!(self.as_mut().poll_flush(cx))?;

    // 调用 stream 的 poll_shutdown 确保 stream 关闭
    ready!(Pin::new(&amp;mut self.stream).poll_shutdown(cx))?;
    Poll::Ready(Ok(()))
}
</code></pre></pre>
</div>
</details>
<details id="admonition-3-我们的-proststream-目前已经实现了-stream-和-sink为了方便使用再构建一些辅助方法比如-new" class="admonition note">
<summary class="admonition-title">
<ol start="3">
<li>我们的 ProstStream 目前已经实现了 Stream 和 Sink，为了方便使用，再构建一些辅助方法，比如 new()： </li>
</ol>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-3-我们的-proststream-目前已经实现了-stream-和-sink为了方便使用再构建一些辅助方法比如-new"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;S, In, Out&gt; ProstStream&lt;S, In, Out&gt;
where
    S: AsyncRead + AsyncWrite + Send + Unpin,
{
    /// 创建一个 ProstStream
    pub fn new(stream: S) -&gt; Self {
        Self {
            stream,
            written: 0,
            wbuf: BytesMut::new(),
            rbuf: BytesMut::new(),
            _in: PhantomData::default(),
            _out: PhantomData::default(),
        }
    }
}

// 一般来说，如果我们的 Stream 是 Unpin，最好实现一下
impl&lt;S, Req, Res&gt; Unpin for ProstStream&lt;S, Req, Res&gt; where S: Unpin {}
</code></pre></pre>
<hr />
<p>此外，我们还为其实现 Unpin trait，这会给别人在使用你的代码时带来很多方便。</p>
<p>一般来说，为异步操作而创建的数据结构，如果使用了泛型参数，那么只要内部没有自引用数据，就应该实现 Unpin。</p>
</div>
</details>
<h3 id="测试-1"><a class="header" href="#测试-1">测试！</a></h3>
<p>又到了重要的测试环节。我们需要写点测试来确保 ProstStream 能正常工作。因为之前在 src/network/frame.rs 中写了个 DummyStream，实现了 AsyncRead，我们只需要扩展它，让它再实现
AsyncWrite。</p>
<details id="admonition-1-为了让它可以被复用我们将其从-framers-中移出来放在-srcnetworkmodrs-中并修改成下面的样子记得在-framers-的测试里-use-新的-dummystream" class="admonition note">
<summary class="admonition-title">
<ol>
<li>为了让它可以被复用，我们将其从 frame.rs 中移出来，放在 src/network/mod.rs 中，并修改成下面的样子（记得在 frame.rs 的测试里 use 新的 DummyStream）： </li>
</ol>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-1-为了让它可以被复用我们将其从-framers-中移出来放在-srcnetworkmodrs-中并修改成下面的样子记得在-framers-的测试里-use-新的-dummystream"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
pub mod utils {
    use bytes::{BufMut, BytesMut};
    use std::task::Poll;
    use tokio::io::{AsyncRead, AsyncWrite};

    pub struct DummyStream {
        pub buf: BytesMut,
    }

    impl AsyncRead for DummyStream {
        fn poll_read(
            self: std::pin::Pin&lt;&amp;mut Self&gt;,
            _cx: &amp;mut std::task::Context&lt;'_&gt;,
            buf: &amp;mut tokio::io::ReadBuf&lt;'_&gt;,
        ) -&gt; Poll&lt;std::io::Result&lt;()&gt;&gt; {
            let len = buf.capacity();
            let data = self.get_mut().buf.split_to(len);
            buf.put_slice(&amp;data);
            Poll::Ready(Ok(()))
        }
    }

    impl AsyncWrite for DummyStream {
        fn poll_write(
            self: std::pin::Pin&lt;&amp;mut Self&gt;,
            _cx: &amp;mut std::task::Context&lt;'_&gt;,
            buf: &amp;[u8],
        ) -&gt; Poll&lt;Result&lt;usize, std::io::Error&gt;&gt; {
            self.get_mut().buf.put_slice(buf);
            Poll::Ready(Ok(buf.len()))
        }

        fn poll_flush(
            self: std::pin::Pin&lt;&amp;mut Self&gt;,
            _cx: &amp;mut std::task::Context&lt;'_&gt;,
        ) -&gt; Poll&lt;Result&lt;(), std::io::Error&gt;&gt; {
            Poll::Ready(Ok(()))
        }

        fn poll_shutdown(
            self: std::pin::Pin&lt;&amp;mut Self&gt;,
            _cx: &amp;mut std::task::Context&lt;'_&gt;,
        ) -&gt; Poll&lt;Result&lt;(), std::io::Error&gt;&gt; {
            Poll::Ready(Ok(()))
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-2-好这样我们就可以在-srcnetworkstreamrs-下写个测试了" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>好，这样我们就可以在 src/network/stream.rs 下写个测试了： </li>
</ol>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-2-好这样我们就可以在-srcnetworkstreamrs-下写个测试了"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
mod tests {
    use super::*;
    use crate::{utils::DummyStream, CommandRequest};
    use anyhow::Result;
    use futures::prelude::*;

    #[tokio::test]
    async fn prost_stream_should_work() -&gt; Result&lt;()&gt; {
        let buf = BytesMut::new();
        let stream = DummyStream { buf };
        let mut stream = ProstStream::&lt;_, CommandRequest, CommandRequest&gt;::new(stream);
        let cmd = CommandRequest::new_hdel(&quot;t1&quot;, &quot;k1&quot;);
        stream.send(cmd.clone()).await?;
        if let Some(Ok(s)) = stream.next().await {
            assert_eq!(s, cmd);
        } else {
            assert!(false);
        }
        Ok(())
    }
}
</code></pre></pre>
</div>
</details>
<ol start="3">
<li>运行 cargo test ，一切测试通过！（如果你编译错误，可能缺少 use 的问题，可以自行修改，或者参考 GitHub 上的完整代码）。</li>
</ol>
<h2 id="使用-proststream"><a class="header" href="#使用-proststream">使用 ProstStream</a></h2>
<details id="admonition-接下来我们可以让-prostserverstream-和-prostclientstream-使用新定义的-proststream-了你可以参考下面的对比看看二者的区别" class="admonition note">
<summary class="admonition-title">
<p>接下来，我们可以让 ProstServerStream 和 ProstClientStream 使用新定义的 ProstStream 了，你可以参考下面的对比，看看二者的区别：</p>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-接下来我们可以让-prostserverstream-和-prostclientstream-使用新定义的-proststream-了你可以参考下面的对比看看二者的区别"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
// 旧的接口
// pub struct ProstServerStream&lt;S&gt; {
//     inner: S,
//     service: Service,
// }

pub struct ProstServerStream&lt;S&gt; {
    inner: ProstStream&lt;S, CommandRequest, CommandResponse&gt;,
    service: Service,
}

// 旧的接口
// pub struct ProstClientStream&lt;S&gt; {
//     inner: S,
// }

pub struct ProstClientStream&lt;S&gt; {
    inner: ProstStream&lt;S, CommandResponse, CommandRequest&gt;,
}
</code></pre></pre>
<blockquote>
<p>然后删除 send() / recv() 函数，并修改 process() / execute() 函数使其使用 next() 方法和 send() 方法。主要的改动如下：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
/// 处理服务器端的某个 accept 下来的 socket 的读写
pub struct ProstServerStream&lt;S&gt; {
    inner: ProstStream&lt;S, CommandRequest, CommandResponse&gt;,
    service: Service,
}

/// 处理客户端 socket 的读写
pub struct ProstClientStream&lt;S&gt; {
    inner: ProstStream&lt;S, CommandResponse, CommandRequest&gt;,
}

impl&lt;S&gt; ProstServerStream&lt;S&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send,
{
    pub fn new(stream: S, service: Service) -&gt; Self {
        Self {
            inner: ProstStream::new(stream),
            service,
        }
    }

    pub async fn process(mut self) -&gt; Result&lt;(), KvError&gt; {
        let stream = &amp;mut self.inner;
        while let Some(Ok(cmd)) = stream.next().await {
            info!(&quot;Got a new command: {:?}&quot;, cmd);
            let res = self.service.execute(cmd);
            stream.send(res).await.unwrap();
        }

        Ok(())
    }
}

impl&lt;S&gt; ProstClientStream&lt;S&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send,
{
    pub fn new(stream: S) -&gt; Self {
        Self {
            inner: ProstStream::new(stream),
        }
    }

    pub async fn execute(&amp;mut self, cmd: CommandRequest) -&gt; Result&lt;CommandResponse, KvError&gt; {
        let stream = &amp;mut self.inner;
        stream.send(cmd).await?;

        match stream.next().await {
            Some(v) =&gt; v,
            None =&gt; Err(KvError::Internal(&quot;Didn't get any response&quot;.into())),
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-测试" class="admonition success">
<summary class="admonition-title">
<p>测试</p>
<p><a class="admonition-anchor-link" href="kv6_async_refactor.html#admonition-测试"></a></p>
</summary>
<div>
<p>再次运行 cargo test ，所有的测试应该都能通过。同样如果有编译错误，可能是缺少了引用。</p>
<p>我们也可以打开一个命令行窗口，运行：</p>
<pre><code class="language-shell">RUST_LOG=info cargo run --bin kvs --quiet
</code></pre>
<p>然后在另一个命令行窗口，运行：</p>
<pre><code class="language-shell">RUST_LOG=info cargo run --bin kvc --quiet
</code></pre>
<p>此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常！</p>
</div>
</details>
<blockquote>
<p>我们重构了 ProstServerStream 和 ProstClientStream 的代码，使其内部使用更符合 futures 库里 Stream / Sink trait
的用法，整体代码改动不小，但是内部实现的变更并不影响系统的其它部分！这简直太棒了！</p>
</blockquote>
<h2 id="异步处理回顾单元测试的重要性"><a class="header" href="#异步处理回顾单元测试的重要性">异步处理回顾：单元测试的重要性</a></h2>
<p>在实际开发中，进行重构来改善既有代码的质量是必不可少的。之前在开发 KV server 的过程中，我们在不断地进行一些小的重构。</p>
<p>本节我们做了个稍微大一些的重构，为已有的代码提供更加符合异步 IO 接口的功能。</p>
<blockquote>
<p>从对外使用的角度来说，它并没有提供或者满足任何额外的需求，但是从代码结构和质量的角度，它使得我们的 ProstStream 可以更方便和更直观地被其它接口调用，也更容易跟整个 Rust 的现有生态结合起来。</p>
</blockquote>
<p>你可能会好奇，为什么可以这么自然地进行代码重构？这是因为我们有足够的单元测试覆盖来打底。</p>
<p>就像生物的进化一样，好的代码是在良性的重构中不断演进出来的，而良性的重构，是在优秀的单元测试的监管下，使代码朝着正确方向迈出的步伐。在这里，单元测试扮演着生物进化中自然环境的角色，把重构过程中的错误一一扼杀。</p>
<h2 id="思考题-1"><a class="header" href="#思考题-1">思考题</a></h2>
<p>为什么在创建 ProstStream 时，要在数据结构中放 wbuf / rbuf 和 written 字段？为什么不能用局部变量？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="七如何做大的重构"><a class="header" href="#七如何做大的重构">七、如何做大的重构？</a></h1>
<!--ts-->
<ul>
<li><a href="kv7_big_refactor.html#%E4%B8%83%E5%A6%82%E4%BD%95%E5%81%9A%E5%A4%A7%E7%9A%84%E9%87%8D%E6%9E%84">七、如何做大的重构？</a>
<ul>
<li><a href="kv7_big_refactor.html#%E7%8E%B0%E6%9C%89%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90">现有架构分析</a></li>
<li><a href="kv7_big_refactor.html#%E8%A6%81%E6%94%AF%E6%8C%81-pubsub%E7%8E%B0%E6%9C%89%E6%9E%B6%E6%9E%84%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%BE%88%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98">要支持 Pub/Sub，现有架构有两个很大的问题。</a></li>
<li><a href="kv7_big_refactor.html#%E4%BD%BF%E7%94%A8-yamux-%E5%81%9A%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">使用 yamux 做多路复用</a></li>
<li><a href="kv7_big_refactor.html#%E6%94%AF%E6%8C%81-pubsub">支持 pub/sub</a>
<ul>
<li><a href="kv7_big_refactor.html#pubsub-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1">Pub/Sub 如何设计？</a></li>
<li><a href="kv7_big_refactor.html#pubsub-%E7%9A%84%E5%AE%9E%E7%8E%B0">Pub/Sub 的实现</a></li>
<li><a href="kv7_big_refactor.html#%E5%9C%A8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E4%B8%AD%E5%BC%95%E5%85%A5-pubsub">在处理流程中引入 Pub/Sub</a></li>
<li><a href="kv7_big_refactor.html#%E7%BB%A7%E7%BB%AD%E9%87%8D%E6%9E%84%E5%BC%A5%E8%A1%A5%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98">继续重构：弥补设计上的小问题</a></li>
<li><a href="kv7_big_refactor.html#%E8%AE%A9%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%83%BD%E6%9B%B4%E5%A5%BD%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%96%B0%E7%9A%84%E6%8E%A5%E5%8F%A3">让客户端能更好地使用新的接口</a></li>
</ul>
</li>
<li><a href="kv7_big_refactor.html#%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BB%94%E7%BB%86%E9%98%85%E8%AF%BB%E8%BF%99%E4%B8%80%E8%8A%82%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A5%BD%E5%A5%BD%E5%93%81%E5%91%B3%E8%BF%99%E4%BA%9B%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E8%AE%A1">你可以仔细阅读这一节中的代码，好好品味这些接口的设计。</a></li>
<li><a href="kv7_big_refactor.html#%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E8%80%83%E8%99%91">一些相关考虑</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:31 UTC 2022 -->
<!--te-->
<h2 id="现有架构分析"><a class="header" href="#现有架构分析">现有架构分析</a></h2>
<details id="admonition-先简单回顾一下-redis-对-pubsub-的支持" class="admonition info">
<summary class="admonition-title">
<p>先简单回顾一下 Redis 对 Pub/Sub 的支持 </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-先简单回顾一下-redis-对-pubsub-的支持"></a></p>
</summary>
<div>
<ol>
<li>客户端可以随时发起 SUBSCRIBE、PUBLISH 和 UNSUBSCRIBE。</li>
<li>如果客户端 A 和 B SUBSCRIBE 了一个叫 lobby 的主题，客户端 C 往 lobby 里发了 “hello”，A 和 B 都将立即收到这个信息。</li>
<li>使用起来是这个样子的：</li>
</ol>
<pre><code class="language-shell">A: SUBSCRIBE &quot;lobby&quot;
A: SUBSCRIBE &quot;王者荣耀&quot;
B: SUBSCRIBE &quot;lobby&quot;
C: PUBLISH &quot;lobby&quot; &quot;hello&quot;
// A/B 都收到 &quot;hello&quot;
B: UNSUBSCRIBE &quot;lobby&quot;
B: SUBSCRIBE &quot;王者荣耀&quot;
D: PUBLISH &quot;lobby&quot; &quot;goodbye&quot;
// 只有 A 收到 &quot;goodbye&quot;
C: PUBLISH &quot;王者荣耀&quot; &quot;good game&quot;
// A/B 都收到 &quot;good game&quot;
</code></pre>
</div>
</details>
<details id="admonition--带着这个需求我们重新审视目前的架构" class="admonition abstract">
<summary class="admonition-title">
<blockquote>
<p>带着这个需求，我们重新审视目前的架构：</p>
</blockquote>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition--带着这个需求我们重新审视目前的架构"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/82da823b4eb16935fdeyy727e3b3262c-20221005230003663.jpg" alt="img" /></p>
</div>
</details>
<h2 id="要支持-pubsub现有架构有两个很大的问题"><a class="header" href="#要支持-pubsub现有架构有两个很大的问题">要支持 Pub/Sub，现有架构有两个很大的问题。</a></h2>
<details id="admonition-1-commandservice是同步处理" class="admonition info">
<summary class="admonition-title">
<ol>
<li>CommandService是同步处理 </li>
</ol>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-1-commandservice是同步处理"></a></p>
</summary>
<div>
<p>首先，CommandService 是一个同步的处理，来一个命令，立刻就能计算出一个值返回。但现在来一个 SUBSCRIBE 命令，它期待的不是一个值，而是未来可能产生的若干个值。而 Stream 代表未来可能产生的一系列值，所以这里需要返回一个异步的 Stream。</p>
<p>因此，这里有两个思路：</p>
<ol>
<li>要么需要牺牲 CommandService 这个 trait 来适应新的需求</li>
<li>要么构建一个新的、和 CommandService trait 并列的 trait，来处理和 Pub/Sub 有关的命令。</li>
</ol>
</div>
</details>
<details id="admonition-其次如果直接在-tcptls-之上构建-pubsub-的支持我们需要在-request-和-response-之间建立流的概念为什么呢" class="admonition info">
<summary class="admonition-title">
<p>其次，如果直接在 TCP/TLS 之上构建 Pub/Sub 的支持，我们需要在 Request 和 Response 之间建立“流”的概念，为什么呢？ </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-其次如果直接在-tcptls-之上构建-pubsub-的支持我们需要在-request-和-response-之间建立流的概念为什么呢"></a></p>
</summary>
<div>
<p>之前我们的协议运行模式是同步的，一来一回：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/7byy9cdb2c3651e4cd77bdda89a52968.jpg" alt="img" /></p>
<p>但是，如果继续采用这样的方式，就会有应用层的 <a href="https://en.wikipedia.org/wiki/Head-of-line_blocking">head of line blocking（队头阻塞）问题</a>：</p>
<ul>
<li>
<p>一个 SUBSCRIBE 命令，因为其返回结果不知道什么时候才结束，会阻塞后续的所有命令。</p>
</li>
<li>
<p>所以，我们需要在一个连接里，划分出很多彼此独立的“流”，让它们的收发不受影响：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/67659457626d12eba6e26b37ayy08edb.jpg" alt="img" /></p>
</div>
</details>
<details id="admonition-流式处理的的典型协议使用了多路复用的http2有两个方案选择" class="admonition tip">
<summary class="admonition-title">
<p>流式处理的的典型协议使用了多路复用的HTTP/2，有两个方案选择 </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-流式处理的的典型协议使用了多路复用的http2有两个方案选择"></a></p>
</summary>
<div>
<p>这种流式处理的典型协议是使用了多路复用（multiplex）的 HTTP/2。所以：</p>
<ol>
<li>
<p>一种方案是我们可以把 KV server 构建在使用 HTTP/2 的 gRPC 上。不过，HTTP 是个太过庞杂的协议，对于 KV server 这种性能非常重要的服务来说，不必要的额外开销太多，所以它不太适合。</p>
</li>
<li>
<p>另一种方式是使用 <a href="https://github.com/hashicorp/yamux/blob/master/spec.md">Yamux 协议</a>，它是一个简单的、和 HTTP/2 内部多路复用机制非常类似的协议。如果使用它，整个协议的交互看上去是这个样子的：</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/31f3efcd510ff6a3yy0caf32dbfd8667.jpg" alt="img" /></p>
<blockquote>
<p>Yamux 适合不希望引入 HTTP 的繁文缛节（大量的头信息），在 TCP 层做多路复用的场景，这里就用它来支持我们所要实现的 Pub/Sub。</p>
</blockquote>
</div>
</details>
<h2 id="使用-yamux-做多路复用"><a class="header" href="#使用-yamux-做多路复用">使用 yamux 做多路复用</a></h2>
<p>Rust 下有lip2p出品的 <a href="https://github.com/libp2p/rust-yamux">rust-yamux</a> 这个库，来支持 yamux。</p>
<details id="admonition-除此之外我们还需要-tokio-util它提供了-tokio-下的-trait-和-futures-下的-trait-的兼容能力" class="admonition note">
<summary class="admonition-title">
<p>除此之外，我们还需要 tokio-util，它提供了 tokio 下的 trait 和 futures 下的 trait 的兼容能力。 </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-除此之外我们还需要-tokio-util它提供了-tokio-下的-trait-和-futures-下的-trait-的兼容能力"></a></p>
</summary>
<div>
<ol>
<li>在 Cargo.toml 中引入它们：</li>
</ol>
<pre><code class="language-toml">
[dependencies]
...
tokio-util = { version = &quot;0.6&quot;, features = [&quot;compat&quot;]} # tokio 和 futures 的兼容性库
...
yamux = &quot;0.9&quot; # yamux 多路复用支持
...
</code></pre>
<ol start="2">
<li>然后创建 src/network/multiplex.rs（记得在 mod.rs 里引用），添入如下代码：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use futures::{future, Future, TryStreamExt};
use std::marker::PhantomData;
use tokio::io::{AsyncRead, AsyncWrite};
use tokio_util::compat::{Compat, FuturesAsyncReadCompatExt, TokioAsyncReadCompatExt};
use yamux::{Config, Connection, ConnectionError, Control, Mode, WindowUpdateMode};

/// Yamux 控制结构
pub struct YamuxCtrl&lt;S&gt; {
    /// yamux control，用于创建新的 stream
    ctrl: Control,
    _conn: PhantomData&lt;S&gt;,
}

impl&lt;S&gt; YamuxCtrl&lt;S&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send + 'static,
{
    /// 创建 yamux 客户端
    pub fn new_client(stream: S, config: Option&lt;Config&gt;) -&gt; Self {
        Self::new(stream, config, true, |_stream| future::ready(Ok(())))
    }

    /// 创建 yamux 服务端，服务端我们需要具体处理 stream
    pub fn new_server&lt;F, Fut&gt;(stream: S, config: Option&lt;Config&gt;, f: F) -&gt; Self
    where
        F: FnMut(yamux::Stream) -&gt; Fut,
        F: Send + 'static,
        Fut: Future&lt;Output = Result&lt;(), ConnectionError&gt;&gt; + Send + 'static,
    {
        Self::new(stream, config, false, f)
    }

    // 创建 YamuxCtrl
    fn new&lt;F, Fut&gt;(stream: S, config: Option&lt;Config&gt;, is_client: bool, f: F) -&gt; Self
    where
        F: FnMut(yamux::Stream) -&gt; Fut,
        F: Send + 'static,
        Fut: Future&lt;Output = Result&lt;(), ConnectionError&gt;&gt; + Send + 'static,
    {
        let mode = if is_client {
            Mode::Client
        } else {
            Mode::Server
        };

        // 创建 config
        let mut config = config.unwrap_or_default();
        config.set_window_update_mode(WindowUpdateMode::OnRead);

        // 创建 config，yamux::Stream 使用的是 futures 的 trait 所以需要 compat() 到 tokio 的 trait
        let conn = Connection::new(stream.compat(), config, mode);

        // 创建 yamux ctrl
        let ctrl = conn.control();

        // pull 所有 stream 下的数据
        tokio::spawn(yamux::into_stream(conn).try_for_each_concurrent(None, f));

        Self {
            ctrl,
            _conn: PhantomData::default(),
        }
    }

    /// 打开一个新的 stream
    pub async fn open_stream(&amp;mut self) -&gt; Result&lt;Compat&lt;yamux::Stream&gt;, ConnectionError&gt; {
        let stream = self.ctrl.open_stream().await?;
        Ok(stream.compat())
    }
}
</code></pre></pre>
<p>这段代码提供了 Yamux 的基本处理。如果有些地方你看不明白，比如 WindowUpdateMode，yamux::into_stream() 等，很正常，需要看看 <a href="https://github.com/libp2p/rust-yamux">yamux crate 的文档和例子</a>(由于这个库没有发布，所以只能clone本地运行cargo doc查看)。</p>
</div>
</details>
<details id="admonition--这里有一个复杂的接口我们稍微解释一下" class="admonition example">
<summary class="admonition-title">
<blockquote>
<p>这里有一个复杂的接口，我们稍微解释一下：</p>
</blockquote>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition--这里有一个复杂的接口我们稍微解释一下"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn new_server&lt;F, Fut&gt;(stream: S, config: Option&lt;Config&gt;, f: F) -&gt; Self
where
    F: FnMut(yamux::Stream) -&gt; Fut,
    F: Send + 'static,
    Fut: Future&lt;Output = Result&lt;(), ConnectionError&gt;&gt; + Send + 'static,
{
    Self::new(stream, config, false, f)
}
</code></pre></pre>
<p>它的意思是:</p>
<ul>
<li>参数 f 是一个 FnMut 闭包</li>
<li>接受一个 yamux::Stream 参数</li>
<li>返回 Future</li>
</ul>
<p>这样的结构我们之前见过，之所以接口这么复杂，是因为 Rust 还没有把 async 闭包稳定下来。所以，如果要想写一个 async || {}，这是最佳的方式。</p>
</div>
</details>
<details id="admonition-测试通过" class="admonition success">
<summary class="admonition-title">
<p>测试通过 </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-测试通过"></a></p>
</summary>
<div>
<p>还是写一段测试测一下（篇幅关系，完整的代码就不放了，你可以到 GitHub repo 下对照 diff_yamux 看修改）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[tokio::test]
async fn yamux_ctrl_client_server_should_work() -&gt; Result&lt;()&gt; {
    // 创建使用了 TLS 的 yamux server
    let acceptor = tls_acceptor(false)?;
    let addr = start_yamux_server(&quot;127.0.0.1:0&quot;, acceptor, MemTable::new()).await?;

    let connector = tls_connector(false)?;
    let stream = TcpStream::connect(addr).await?;
    let stream = connector.connect(stream).await?;
    // 创建使用了 TLS 的 yamux client
    let mut ctrl = YamuxCtrl::new_client(stream, None);

    // 从 client ctrl 中打开一个新的 yamux stream
    let stream = ctrl.open_stream().await?;
    // 封装成 ProstClientStream
    let mut client = ProstClientStream::new(stream);

    let cmd = CommandRequest::new_hset(&quot;t1&quot;, &quot;k1&quot;, &quot;v1&quot;.into());
    client.execute(cmd).await.unwrap();

    let cmd = CommandRequest::new_hget(&quot;t1&quot;, &quot;k1&quot;);
    let res = client.execute(cmd).await.unwrap();
    assert_res_ok(res, &amp;[&quot;v1&quot;.into()], &amp;[]);

    Ok(())
}
</code></pre></pre>
<p>可以看到:</p>
<ul>
<li>经过简单的封装，yamux 就很自然地融入到我们现有的架构中</li>
<li>因为 open_stream() 得到的是符合 tokio AsyncRead / AsyncWrite 的 stream，所以它可以直接配合 ProstClientStream 使用。</li>
<li>也就是说，我们网络层又改动了一下，但后面逻辑依然不用变。</li>
</ul>
<p>运行 cargo test ，所有测试都能通过。</p>
</div>
</details>
<h2 id="支持-pubsub"><a class="header" href="#支持-pubsub">支持 pub/sub</a></h2>
<p>好，现在网络层已经支持了 yamux，为多路复用打下了基础。我们来看 pub/sub 具体怎么实现。</p>
<details id="admonition-首先修改-abiproto加入新的几个命令" class="admonition note">
<summary class="admonition-title">
<p>首先修改 abi.proto，加入新的几个命令： </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-首先修改-abiproto加入新的几个命令"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
// 来自客户端的命令请求
message CommandRequest {
  oneof request_data {
    ...
    Subscribe subscribe = 10;
    Unsubscribe unsubscribe = 11;
    Publish publish = 12;
  }
}

// subscribe 到某个主题，任何发布到这个主题的数据都会被收到
// 成功后，第一个返回的 CommandResponse，我们返回一个唯一的 subscription id
message Subscribe { string topic = 1; }

// 取消对某个主题的订阅
message Unsubscribe {
  string topic = 1;
  uint32 id = 2;
}

// 发布数据到某个主题
message Publish {
  string topic = 1;
  repeated Value data = 2;
}
</code></pre></pre>
</div>
</details>
<p>命令的响应我们不用改变。当客户端 Subscribe 时，返回的 stream 里的第一个值包含订阅 ID，这是一个全局唯一的 ID，这样，客户端后续可以用 Unsubscribe 取消。</p>
<h3 id="pubsub-如何设计"><a class="header" href="#pubsub-如何设计">Pub/Sub 如何设计？</a></h3>
<details id="admonition-那么pubsub-该如何实现呢" class="admonition question">
<summary class="admonition-title">
<p>那么，Pub/Sub 该如何实现呢？ </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-那么pubsub-该如何实现呢"></a></p>
</summary>
<div>
<p>我们可以用两张表：</p>
<ul>
<li>一张 Topic Table，存放主题和对应的订阅列表；</li>
<li>一张 Subscription Table，存放订阅 ID 和 channel 的发送端。</li>
</ul>
<ol>
<li>当 SUBSCRIBE 时，我们获取一个订阅 ID，插入到 Topic Table</li>
<li>然后再创建一个 MPSC channel，把 channel 的发送端和订阅 ID 存入 subscription table。</li>
</ol>
<p>这样：</p>
<ul>
<li>当有人 PUBLISH 时，可以从 Topic table 中找到对应的订阅 ID 的列表</li>
<li>然后循环从 subscription table 中找到对应的 Sender，往里面写入数据。</li>
<li>此时，channel 的 Receiver 端会得到数据，这个数据会被 yamux stream poll 到，然后发给客户端。</li>
</ul>
</div>
</details>
<div id="admonition-整个流程如下图所示" class="admonition abstract">
<div class="admonition-title">
<p>整个流程如下图所示： </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-整个流程如下图所示"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/7ce3046af823dbbdaa7b47d12d04ce30.jpg" alt="img" /></p>
</div>
</div>
<details id="admonition-有了这个基本设计我们可以着手接口和数据结构的构建了" class="admonition note">
<summary class="admonition-title">
<p>有了这个基本设计，我们可以着手接口和数据结构的构建了：</p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-有了这个基本设计我们可以着手接口和数据结构的构建了"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
/// 下一个 subscription id
static NEXT_ID: AtomicU32 = AtomicU32::new(1);

/// 获取下一个 subscription id
fn get_next_subscription_id() -&gt; u32 {
    NEXT_ID.fetch_add(1, Ordering::Relaxed)
}

pub trait Topic: Send + Sync + 'static {
    /// 订阅某个主题
    fn subscribe(self, name: String) -&gt; mpsc::Receiver&lt;Arc&lt;CommandResponse&gt;&gt;;
    /// 取消对主题的订阅
    fn unsubscribe(self, name: String, id: u32);
    /// 往主题里发布一个数据
    fn publish(self, name: String, value: Arc&lt;CommandResponse&gt;);
}

/// 用于主题发布和订阅的数据结构
#[derive(Default)]
pub struct Broadcaster {
    /// 所有的主题列表
    topics: DashMap&lt;String, DashSet&lt;u32&gt;&gt;,
    /// 所有的订阅列表
    subscriptions: DashMap&lt;u32, mpsc::Sender&lt;Arc&lt;CommandResponse&gt;&gt;&gt;,
}
</code></pre></pre>
<blockquote>
<p>这里，subscription_id 我们用一个 AtomicU32 来表述。</p>
</blockquote>
<ul>
<li>对于这样一个全局唯一的 ID，很多同学喜欢用 UUID4 来表述。</li>
<li>注意使用 UUID 的话，存储时一定不要存它的字符串表现形式，太浪费内存且每次都有额外的堆分配，应该用它 u128 的表现形式。</li>
<li>不过即便 u128，也比 u32 浪费很多空间</li>
</ul>
<p>假设某个主题 M 下有一万个订阅，要往这个 M 里发送一条消息，就意味着整个 DashSet<u32> 的一次拷贝，乘上一万，u32 的话做 40k 内存的拷贝，而 u128 要做 160k 内存的拷贝。这个性能上的差距就很明显了。</p>
<ul>
<li>另外，我们把 CommandResponse 封装进了一个 Arc。</li>
</ul>
<p>如果一条消息要发送给一万个客户端，那么我们不希望这条消息被复制后，再被发送，而是直接发送同一份数据。</p>
</div>
</details>
<blockquote>
<p>这里对 Pub/Sub 的接口，构建了一个 Topic trait。虽然目前我们只有 Broadcaster 会实现 Topic trait，但未来也许会换不同的实现方式，所以，抽象出 Topic trait 很有意义。</p>
</blockquote>
<h3 id="pubsub-的实现"><a class="header" href="#pubsub-的实现">Pub/Sub 的实现</a></h3>
<details id="admonition-创建-srcservicetopicrs记得在-modrs-里引用并添入" class="admonition note">
<summary class="admonition-title">
<p>创建 src/service/topic.rs（记得在 mod.rs 里引用），并添入：</p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-创建-srcservicetopicrs记得在-modrs-里引用并添入"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use dashmap::{DashMap, DashSet};
use std::sync::{
    atomic::{AtomicU32, Ordering},
    Arc,
};
use tokio::sync::mpsc;
use tracing::{debug, info, warn};

use crate::{CommandResponse, Value};

/// topic 里最大存放的数据
const BROADCAST_CAPACITY: usize = 128;

/// 下一个 subscription id
static NEXT_ID: AtomicU32 = AtomicU32::new(1);

/// 获取下一个 subscription id
fn get_next_subscription_id() -&gt; u32 {
    NEXT_ID.fetch_add(1, Ordering::Relaxed)
}

pub trait Topic: Send + Sync + 'static {
    /// 订阅某个主题
    fn subscribe(self, name: String) -&gt; mpsc::Receiver&lt;Arc&lt;CommandResponse&gt;&gt;;
    /// 取消对主题的订阅
    fn unsubscribe(self, name: String, id: u32);
    /// 往主题里发布一个数据
    fn publish(self, name: String, value: Arc&lt;CommandResponse&gt;);
}

/// 用于主题发布和订阅的数据结构
#[derive(Default)]
pub struct Broadcaster {
    /// 所有的主题列表
    topics: DashMap&lt;String, DashSet&lt;u32&gt;&gt;,
    /// 所有的订阅列表
    subscriptions: DashMap&lt;u32, mpsc::Sender&lt;Arc&lt;CommandResponse&gt;&gt;&gt;,
}

impl Topic for Arc&lt;Broadcaster&gt; {
    fn subscribe(self, name: String) -&gt; mpsc::Receiver&lt;Arc&lt;CommandResponse&gt;&gt; {
        let id = {
            let entry = self.topics.entry(name).or_default();
            let id = get_next_subscription_id();
            entry.value().insert(id);
            id
        };

        // 生成一个 mpsc channel
        let (tx, rx) = mpsc::channel(BROADCAST_CAPACITY);

        let v: Value = (id as i64).into();

        // 立刻发送 subscription id 到 rx
        let tx1 = tx.clone();
        tokio::spawn(async move {
            if let Err(e) = tx1.send(Arc::new(v.into())).await {
                // TODO: 这个很小概率发生，但目前我们没有善后
                warn!(&quot;Failed to send subscription id: {}. Error: {:?}&quot;, id, e);
            }
        });

        // 把 tx 存入 subscription table
        self.subscriptions.insert(id, tx);
        debug!(&quot;Subscription {} is added&quot;, id);

        // 返回 rx 给网络处理的上下文
        rx
    }

    fn unsubscribe(self, name: String, id: u32) {
        if let Some(v) = self.topics.get_mut(&amp;name) {
            // 在 topics 表里找到 topic 的 subscription id，删除
            v.remove(&amp;id);

            // 如果这个 topic 为空，则也删除 topic
            if v.is_empty() {
                info!(&quot;Topic: {:?} is deleted&quot;, &amp;name);
                drop(v);
                self.topics.remove(&amp;name);
            }
        }

        debug!(&quot;Subscription {} is removed!&quot;, id);
        // 在 subscription 表中同样删除
        self.subscriptions.remove(&amp;id);
    }

    fn publish(self, name: String, value: Arc&lt;CommandResponse&gt;) {
        tokio::spawn(async move {
            match self.topics.get(&amp;name) {
                Some(chan) =&gt; {
                    // 复制整个 topic 下所有的 subscription id
                    // 这里我们每个 id 是 u32，如果一个 topic 下有 10k 订阅，复制的成本
                    // 也就是 40k 堆内存（外加一些控制结构），所以效率不算差
                    // 这也是为什么我们用 NEXT_ID 来控制 subscription id 的生成
                    let chan = chan.value().clone();

                    // 循环发送
                    for id in chan.into_iter() {
                        if let Some(tx) = self.subscriptions.get(&amp;id) {
                            if let Err(e) = tx.send(value.clone()).await {
                                warn!(&quot;Publish to {} failed! error: {:?}&quot;, id, e);
                            }
                        }
                    }
                }
                None =&gt; {}
            }
        });
    }
}
</code></pre></pre>
</div>
</details>
<p>这段代码就是 Pub/Sub 的核心功能了。你可以对照着上面的设计图和代码中的详细注释去理解。</p>
<details id="admonition-我们来写一个测试确保它正常工作" class="admonition success">
<summary class="admonition-title">
<p>我们来写一个测试确保它正常工作： </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-我们来写一个测试确保它正常工作"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
mod tests {
    use std::convert::TryInto;

    use crate::assert_res_ok;

    use super::*;

    #[tokio::test]
    async fn pub_sub_should_work() {
        let b = Arc::new(Broadcaster::default());
        let lobby = &quot;lobby&quot;.to_string();

        // subscribe
        let mut stream1 = b.clone().subscribe(lobby.clone());
        let mut stream2 = b.clone().subscribe(lobby.clone());

        // publish
        let v: Value = &quot;hello&quot;.into();
        b.clone().publish(lobby.clone(), Arc::new(v.clone().into()));

        // subscribers 应该能收到 publish 的数据
        let id1: i64 = stream1.recv().await.unwrap().as_ref().try_into().unwrap();
        let id2: i64 = stream2.recv().await.unwrap().as_ref().try_into().unwrap();

        assert!(id1 != id2);

        let res1 = stream1.recv().await.unwrap();
        let res2 = stream2.recv().await.unwrap();

        assert_eq!(res1, res2);
        assert_res_ok(&amp;res1, &amp;[v.clone()], &amp;[]);

        // 如果 subscriber 取消订阅，则收不到新数据
        b.clone().unsubscribe(lobby.clone(), id1 as _);

        // publish
        let v: Value = &quot;world&quot;.into();
        b.clone().publish(lobby.clone(), Arc::new(v.clone().into()));

        assert!(stream1.recv().await.is_none());
        let res2 = stream2.recv().await.unwrap();
        assert_res_ok(&amp;res2, &amp;[v.clone()], &amp;[]);
    }
}
</code></pre></pre>
</div>
</details>
<p>这个测试需要一系列新的改动，比如 assert_res_ok() 的接口变化了，我们需要在 src/pb/mod.rs 里添加新的 TryFrom 支持等等，详细代码你可以看 repo 里的 diff_topic。</p>
<h3 id="在处理流程中引入-pubsub"><a class="header" href="#在处理流程中引入-pubsub">在处理流程中引入 Pub/Sub</a></h3>
<p>好，再来看它和用户传入的 CommandRequest 如何发生关系。</p>
<details id="admonition-我们之前设计了-commandservice-trait它虽然可以处理其它命令但对-pubsub-相关的几个新命令无法处理因为接口没有任何和-topic-有关的参数" class="admonition note">
<summary class="admonition-title">
<p>我们之前设计了 CommandService trait，它虽然可以处理其它命令，但对 Pub/Sub 相关的几个新命令无法处理，因为接口没有任何和 Topic 有关的参数： </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-我们之前设计了-commandservice-trait它虽然可以处理其它命令但对-pubsub-相关的几个新命令无法处理因为接口没有任何和-topic-有关的参数"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
/// 对 Command 的处理的抽象
pub trait CommandService {
    /// 处理 Command，返回 Response
    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse;
}
</code></pre></pre>
<p>但是如果直接修改这个接口，对已有的代码就非常不友好。所以我们还是对比着创建一个新的 trait：</p>
<pre><pre class="playground"><code class="language-rust  editable">pub type StreamingResponse = Pin&lt;Box&lt;dyn Stream&lt;Item = Arc&lt;CommandResponse&gt;&gt; + Send&gt;&gt;;
pub trait TopicService {
    /// 处理 Command，返回 Response
    fn execute&lt;T&gt;(self, chan: impl Topic) -&gt; StreamingResponse;
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>因为 Stream 是一个 trait，在 trait 的方法里我们无法返回一个 impl Stream，所以用 trait object：Pin&lt;Box&lt;dyn Stream&gt;&gt;。</p>
</blockquote>
<details id="admonition-实现它很简单我们创建-srcservicetopic_servicers记得在-modrs-引用然后添加" class="admonition note">
<summary class="admonition-title">
<p>实现它很简单，我们创建 src/service/topic_service.rs（记得在 mod.rs 引用），然后添加： </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-实现它很简单我们创建-srcservicetopic_servicers记得在-modrs-引用然后添加"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use futures::{stream, Stream};
use std::{pin::Pin, sync::Arc};
use tokio_stream::wrappers::ReceiverStream;

use crate::{CommandResponse, Publish, Subscribe, Topic, Unsubscribe};

pub type StreamingResponse = Pin&lt;Box&lt;dyn Stream&lt;Item = Arc&lt;CommandResponse&gt;&gt; + Send&gt;&gt;;

pub trait TopicService {
    /// 处理 Command，返回 Response
    fn execute&lt;T, S&gt;(self, topic: impl Topic) -&gt; StreamingResponse;
}

impl TopicService for Subscribe {
    fn execute&lt;T, S&gt;(self, topic: impl Topic) -&gt; StreamingResponse {
        let rx = topic.subscribe(self.topic);
        Box::pin(ReceiverStream::new(rx))
    }
}

impl TopicService for Unsubscribe {
    fn execute&lt;T, S&gt;(self, topic: impl Topic) -&gt; StreamingResponse {
        topic.unsubscribe(self.topic, self.id);
        Box::pin(stream::once(async { Arc::new(CommandResponse::ok()) }))
    }
}

impl TopicService for Publish {
    fn execute&lt;T, S&gt;(self, topic: impl Topic) -&gt; StreamingResponse {
        topic.publish(self.topic, Arc::new(self.data.into()));
        Box::pin(stream::once(async { Arc::new(CommandResponse::ok()) }))
    }
}
</code></pre></pre>
</div>
</details>
<ul>
<li>我们使用了 <a href="https://docs.rs/tokio-stream/0.1.7/tokio_stream/">tokio-stream</a> 的 wrapper 把一个 mpsc::Receiver 转换成
ReceiverStream, 这样 Subscribe 的处理就能返回一个 Stream。</li>
<li>对于 Unsubscribe 和 Publish，它们都返回单个值，我们使用 stream::once 将其统一起来。</li>
</ul>
<details id="admonition-同样地要在-srcpbmodrs-里添加一些新的方法比如-commandresponseok它返回一个状态码是-ok-的-response" class="admonition note">
<summary class="admonition-title">
<p>同样地，要在 src/pb/mod.rs 里添加一些新的方法，比如 CommandResponse::ok()，它返回一个状态码是 OK 的 response： </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-同样地要在-srcpbmodrs-里添加一些新的方法比如-commandresponseok它返回一个状态码是-ok-的-response"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl CommandResponse {
    pub fn ok() -&gt; Self {
        let mut result = CommandResponse::default();
        result.status = StatusCode::OK.as_u16() as _;
        result
    }
}
</code></pre></pre>
</div>
</details>
<p>好，接下来看 src/service/mod.rs，我们可以对应着原来的 dispatch 做一个 dispatch_stream。</p>
<details id="admonition-同样地已有的接口应该少动我们平行添加一个新的" class="admonition note">
<summary class="admonition-title">
<p>同样地，已有的接口应该少动，我们平行添加一个新的： </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-同样地已有的接口应该少动我们平行添加一个新的"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
/// 从 Request 中得到 Response，目前处理所有 HGET/HSET/HDEL/HEXIST
pub fn dispatch(cmd: CommandRequest, store: &amp;impl Storage) -&gt; CommandResponse {
    match cmd.request_data {
        Some(RequestData::Hget(param)) =&gt; param.execute(store),
        Some(RequestData::Hgetall(param)) =&gt; param.execute(store),
        Some(RequestData::Hmget(param)) =&gt; param.execute(store),
        Some(RequestData::Hset(param)) =&gt; param.execute(store),
        Some(RequestData::Hmset(param)) =&gt; param.execute(store),
        Some(RequestData::Hdel(param)) =&gt; param.execute(store),
        Some(RequestData::Hmdel(param)) =&gt; param.execute(store),
        Some(RequestData::Hexist(param)) =&gt; param.execute(store),
        Some(RequestData::Hmexist(param)) =&gt; param.execute(store),
        None =&gt; KvError::InvalidCommand(&quot;Request has no data&quot;.into()).into(),
        // 处理不了的返回一个啥都不包括的 Response，这样后续可以用 dispatch_stream 处理
        _ =&gt; CommandResponse::default(),
    }
}

/// 从 Request 中得到 Response，目前处理所有 PUBLISH/SUBSCRIBE/UNSUBSCRIBE
pub fn dispatch_stream(cmd: CommandRequest, topic: impl Topic) -&gt; StreamingResponse {
    match cmd.request_data {
        Some(RequestData::Publish(param)) =&gt; param.execute(topic),
        Some(RequestData::Subscribe(param)) =&gt; param.execute(topic),
        Some(RequestData::Unsubscribe(param)) =&gt; param.execute(topic),
        // 如果走到这里，就是代码逻辑的问题，直接 crash 出来
        _ =&gt; unreachable!(),
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-为了使用这个新的接口service-结构也需要相应改动" class="admonition note">
<summary class="admonition-title">
<p>为了使用这个新的接口，Service 结构也需要相应改动： </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-为了使用这个新的接口service-结构也需要相应改动"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
/// Service 数据结构
pub struct Service&lt;Store = MemTable&gt; {
    inner: Arc&lt;ServiceInner&lt;Store&gt;&gt;,
    broadcaster: Arc&lt;Broadcaster&gt;,
}

impl&lt;Store&gt; Clone for Service&lt;Store&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self {
            inner: Arc::clone(&amp;self.inner),
            broadcaster: Arc::clone(&amp;self.broadcaster),
        }
    }
}

impl&lt;Store: Storage&gt; From&lt;ServiceInner&lt;Store&gt;&gt; for Service&lt;Store&gt; {
    fn from(inner: ServiceInner&lt;Store&gt;) -&gt; Self {
        Self {
            inner: Arc::new(inner),
            broadcaster: Default::default(),
        }
    }
}

impl&lt;Store: Storage&gt; Service&lt;Store&gt; {
    pub fn execute(&amp;self, cmd: CommandRequest) -&gt; StreamingResponse {
        debug!(&quot;Got request: {:?}&quot;, cmd);
        self.inner.on_received.notify(&amp;cmd);
        let mut res = dispatch(cmd, &amp;self.inner.store);

        if res == CommandResponse::default() {
            dispatch_stream(cmd, Arc::clone(&amp;self.broadcaster))
        } else {
            debug!(&quot;Executed response: {:?}&quot;, res);
            self.inner.on_executed.notify(&amp;res);
            self.inner.on_before_send.notify(&amp;mut res);
            if !self.inner.on_before_send.is_empty() {
                debug!(&quot;Modified response: {:?}&quot;, res);
            }

            Box::pin(stream::once(async { Arc::new(res) }))
        }
    }
}
</code></pre></pre>
</div>
</details>
<p>这里，为了处理 Pub/Sub，我们引入了一个破坏性的更新:</p>
<ul>
<li>execute() 方法的返回值变成了 StreamingResponse</li>
<li>这就意味着所有围绕着这个方法的调用，包括测试，都需要相应更新。</li>
<li>这是迫不得已的，不过通过构建和 CommandService / dispatch 平行的 TopicService / dispatch_stream，我们已经让这个破坏性更新尽可能地在比较高层，否则，改动会更大。</li>
</ul>
<p>目前，代码无法编译通过，这是因为如下的代码，res 现在是个 stream，</p>
<details id="admonition-我们需要处理一下" class="admonition note">
<summary class="admonition-title">
<p>我们需要处理一下： </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-我们需要处理一下"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;S&gt; ProstServerStream&lt;S&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send + 'static,
{
    ...

    pub async fn process(mut self) -&gt; Result&lt;(), KvError&gt; {
        let stream = &amp;mut self.inner;
        while let Some(Ok(cmd)) = stream.next().await {
            info!(&quot;Got a new command: {:?}&quot;, cmd);
            let mut res = self.service.execute(cmd);
            while let Some(data) = res.next().await {
                // 目前 data 是 Arc&lt;CommandResponse&gt;，
                // 所以我们 send 最好用 &amp;CommandResponse
                stream.send(&amp;data).await.unwrap();
            }
        }
        // info!(&quot;Client {:?} disconnected&quot;, self.addr);
        Ok(())
    }
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>当然，这样的改动也意味着，原本的函数需要变成 async。</p>
</blockquote>
<p>如果是个 test，需要使用 #[tokio::test]。你可以自己试着把所有相关的代码都改一下。</p>
<div id="admonition-error-rendering-admonishment" class="admonition bug">
<div class="admonition-title">
<p>Error rendering admonishment</p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-error-rendering-admonishment"></a></p>
</div>
<div>
<p>Failed with: TOML parsing error: expected an equals, found a newline at line 1 column 6</p>
<p>Original markdown input:</p>
<pre><code>~~~admonish note title=&quot;当你改到 src/network/mod.rs 里 ProstServerStream 的 process 方法里面的stream.send(data) 时，我们目前的 data 是 Arc&lt;CommandResponse&gt;：
 &quot; collapsible=true
```rust, editable

impl&lt;S&gt; ProstServerStream&lt;S&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send + 'static,
{
    ...

    pub async fn process(mut self) -&gt; Result&lt;(), KvError&gt; {
        let stream = &amp;mut self.inner;
        while let Some(Ok(cmd)) = stream.next().await {
            info!(&quot;Got a new command: {:?}&quot;, cmd);
            let mut res = self.service.execute(cmd);
            while let Some(data) = res.next().await {
                // 目前 data 是 Arc&lt;CommandResponse&gt;，
                // 所以我们 send 最好用 &amp;CommandResponse
                stream.send(&amp;data).await.unwrap();
            }
        }
        // info!(&quot;Client {:?} disconnected&quot;, self.addr);
        Ok(())
    }
}
```
~~~
</code></pre>
</div>
</div>
<p>所以我们还需要稍微改动一下 src/network/stream.rs：</p>
<pre><pre class="playground"><code class="language-rust  editable">
// impl&lt;S, In, Out&gt; Sink&lt;Out&gt; for ProstStream&lt;S, In, Out&gt;
impl&lt;S, In, Out&gt; Sink&lt;&amp;Out&gt; for ProstStream&lt;S, In, Out&gt;
</code></pre></pre>
<p>这会引发一系列的变动，你可以试着自己改一下。</p>
<p>如果你把所有编译错误都改正，cargo test 会全部通过。你也可以看 repo 里的 diff_service，看看所有改动的代码。</p>
<h3 id="继续重构弥补设计上的小问题"><a class="header" href="#继续重构弥补设计上的小问题">继续重构：弥补设计上的小问题</a></h3>
<p>现在看上去大功告成，但你有没有注意，我们在撰写 src/service/topic_service.rs 时，没有写测试。你也许会说：这段代码如此简单，还有必要测试么？</p>
<blockquote>
<p>还是那句话，测试是体验和感受接口完备性的一种手段。测试并不是为了测试实现本身，而是看接口是否好用，是否遗漏了某些产品需求。</p>
</blockquote>
<details id="admonition-测试" class="admonition success">
<summary class="admonition-title">
<p>测试</p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-测试"></a></p>
</summary>
<div>
<p>当开始写测试的时候，我们就会思考：</p>
<ul>
<li>unsubscribe 接口如果遇到不存在的 subscription，要不要返回一个 404？</li>
<li>publish 的时候遇到错误，是不是意味着客户端非正常退出了？</li>
<li>我们要不要把它从 subscription 中移除掉？</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
mod tests {
    use super::*;
    use crate::{assert_res_error, assert_res_ok, dispatch_stream, Broadcaster, CommandRequest};
    use futures::StreamExt;
    use std::{convert::TryInto, time::Duration};
    use tokio::time;

    #[tokio::test]
    async fn dispatch_publish_should_work() {
        let topic = Arc::new(Broadcaster::default());
        let cmd = CommandRequest::new_publish(&quot;lobby&quot;, vec![&quot;hello&quot;.into()]);
        let mut res = dispatch_stream(cmd, topic);
        let data = res.next().await.unwrap();
        assert_res_ok(&amp;data, &amp;[], &amp;[]);
    }

    #[tokio::test]
    async fn dispatch_subscribe_should_work() {
        let topic = Arc::new(Broadcaster::default());
        let cmd = CommandRequest::new_subscribe(&quot;lobby&quot;);
        let mut res = dispatch_stream(cmd, topic);
        let id: i64 = res.next().await.unwrap().as_ref().try_into().unwrap();
        assert!(id &gt; 0);
    }

    #[tokio::test]
    async fn dispatch_subscribe_abnormal_quit_should_be_removed_on_next_publish() {
        let topic = Arc::new(Broadcaster::default());
        let id = {
            let cmd = CommandRequest::new_subscribe(&quot;lobby&quot;);
            let mut res = dispatch_stream(cmd, topic.clone());
            let id: i64 = res.next().await.unwrap().as_ref().try_into().unwrap();
            drop(res);
            id as u32
        };

        // publish 时，这个 subscription 已经失效，所以会被删除
        let cmd = CommandRequest::new_publish(&quot;lobby&quot;, vec![&quot;hello&quot;.into()]);
        dispatch_stream(cmd, topic.clone());
        time::sleep(Duration::from_millis(10)).await;

        // 如果再尝试删除，应该返回 KvError
        let result = topic.unsubscribe(&quot;lobby&quot;.into(), id);
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn dispatch_unsubscribe_should_work() {
        let topic = Arc::new(Broadcaster::default());
        let cmd = CommandRequest::new_subscribe(&quot;lobby&quot;);
        let mut res = dispatch_stream(cmd, topic.clone());
        let id: i64 = res.next().await.unwrap().as_ref().try_into().unwrap();

        let cmd = CommandRequest::new_unsubscribe(&quot;lobby&quot;, id as _);
        let mut res = dispatch_stream(cmd, topic);
        let data = res.next().await.unwrap();

        assert_res_ok(&amp;data, &amp;[], &amp;[]);
    }

    #[tokio::test]
    async fn dispatch_unsubscribe_random_id_should_error() {
        let topic = Arc::new(Broadcaster::default());

        let cmd = CommandRequest::new_unsubscribe(&quot;lobby&quot;, 9527);
        let mut res = dispatch_stream(cmd, topic);
        let data = res.next().await.unwrap();

        assert_res_error(&amp;data, 404, &quot;Not found: subscription 9527&quot;);
    }
}
</code></pre></pre>
<p>在撰写这些测试，并试图使测试通过的过程中，我们又进一步重构了代码。具体的代码变更，你可以参考 repo 里的 diff_refactor。</p>
</div>
</details>
<h3 id="让客户端能更好地使用新的接口"><a class="header" href="#让客户端能更好地使用新的接口">让客户端能更好地使用新的接口</a></h3>
<details id="admonition-目前我们-prostclientstream-还是一个统一的-execute-方法" class="admonition note">
<summary class="admonition-title">
<p>目前，我们 ProstClientStream 还是一个统一的 execute() 方法： </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-目前我们-prostclientstream-还是一个统一的-execute-方法"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;S&gt; ProstClientStream&lt;S&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send,
{
    ...

    pub async fn execute(&amp;mut self, cmd: CommandRequest) -&gt; Result&lt;CommandResponse, KvError&gt; {
        let stream = &amp;mut self.inner;
        stream.send(&amp;cmd).await?;

        match stream.next().await {
            Some(v) =&gt; v,
            None =&gt; Err(KvError::Internal(&quot;Didn't get any response&quot;.into())),
        }
    }
}
</code></pre></pre>
</div>
</details>
<p>它并没有妥善处理 SUBSCRIBE。</p>
<p>为了支持 SUBSCRIBE，我们需要两个接口：</p>
<ul>
<li>execute_unary</li>
<li>execute_streaming。</li>
</ul>
<details id="admonition-在-srcnetworkmodrs-修改这个代码" class="admonition note">
<summary class="admonition-title">
<p>在 src/network/mod.rs 修改这个代码： </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-在-srcnetworkmodrs-修改这个代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;S&gt; ProstClientStream&lt;S&gt;
where
    S: AsyncRead + AsyncWrite + Unpin + Send + 'static,
{
    ...

    pub async fn execute_unary(
        &amp;mut self,
        cmd: &amp;CommandRequest,
    ) -&gt; Result&lt;CommandResponse, KvError&gt; {
        let stream = &amp;mut self.inner;
        stream.send(cmd).await?;

        match stream.next().await {
            Some(v) =&gt; v,
            None =&gt; Err(KvError::Internal(&quot;Didn't get any response&quot;.into())),
        }
    }

    pub async fn execute_streaming(self, cmd: &amp;CommandRequest) -&gt; Result&lt;StreamResult, KvError&gt; {
        let mut stream = self.inner;

        stream.send(cmd).await?;
        stream.close().await?;

        StreamResult::new(stream).await
    }
}
</code></pre></pre>
<p>注意:</p>
<ul>
<li>因为 execute_streaming 里返回 Box:pin(stream)</li>
<li>我们需要对 ProstClientStream 的 S 限制是 ’static，否则编译器会抱怨</li>
<li>这个改动会导致使用 execute() 方法的测试都无法编译，你可以试着修改掉它们。</li>
</ul>
</div>
</details>
<p>此外我们还创建了一个新的文件 src/network/stream_result.rs，用来帮助客户端更好地使用 execute_streaming() 接口。所有改动的具体代码可以看 repo 中的 diff_client。</p>
<details id="admonition-测试-1" class="admonition note">
<summary class="admonition-title">
<p>测试 </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-测试-1"></a></p>
</summary>
<div>
<p>现在，代码一切就绪:</p>
<ol>
<li>打开一个命令行窗口，运行：</li>
</ol>
<pre><code class="language-shell">RUST_LOG=info cargo run --bin kvs --quiet
</code></pre>
<ol start="2">
<li>然后在另一个命令行窗口，运行：</li>
</ol>
<pre><code class="language-shell">RUST_LOG=info cargo run --bin kvc --quiet
</code></pre>
</div>
</details>
<blockquote>
<p>此时，服务器和客户端都收到了彼此的请求和响应，即便混合 HSET/HGET 和 PUBLISH/SUBSCRIBE 命令，一切都依旧处理正常！今天我们做了一个比较大的重构，但比预想中对原有代码的改动要小，这简直太棒了！</p>
</blockquote>
<h2 id="你可以仔细阅读这一节中的代码好好品味这些接口的设计"><a class="header" href="#你可以仔细阅读这一节中的代码好好品味这些接口的设计">你可以仔细阅读这一节中的代码，好好品味这些接口的设计。</a></h2>
<details id="admonition-你可以仔细阅读这一节中的代码好好品味这些接口的设计" class="admonition abstract">
<summary class="admonition-title">
<p>你可以仔细阅读这一节中的代码，好好品味这些接口的设计。</p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-你可以仔细阅读这一节中的代码好好品味这些接口的设计"></a></p>
</summary>
<div>
<p>当一个项目越来越复杂，且新加的功能并不能很好地融入已有的系统时，大的重构是不可避免的。在重构的时候，我们一定要首先要弄清楚现有的流程和架构，然后再思考如何重构，这样对系统的侵入才是最小的。</p>
<p>重构一般会带来对现有测试的破坏，在修复被破坏的测试时，我们要注意不要变动原有测试的逻辑。在做因为新功能添加导致的重构时，如果伴随着大量测试的删除和大量新测试的添加，那么，说明要么原来的测试写得很有问题，要么重构对原有系统的侵入性太强。我们要尽量避免这种事情发生。</p>
<p>在架构和设计都相对不错的情况下，撰写代码的终极目标是对使用者友好的抽象。所谓对使用者友好的抽象，是指让别人调用我们写的接口时，不用想太多，接口本身就是自解释的。</p>
<p>如果你仔细阅读 diff_client，可以看到类似 StreamResult 这样的抽象。它避免了调用者需要了解如何手工从 Stream 中取第一个值作为 subscription_id 这样的实现细节，直接替调用者完成了这个工作，并以一个优雅的 ID 暴露给调用者。</p>
<p>你可以仔细阅读这一节中的代码，好好品味这些接口的设计。它们并非完美，世上没有完美的代码，只有不断完善的代码。如果把一行行代码比作一段段文字，起码它们都需要努力地推敲和不断地迭代。</p>
</div>
</details>
<h2 id="一些相关考虑"><a class="header" href="#一些相关考虑">一些相关考虑</a></h2>
<details id="admonition-思考用gc处理客户端意外终止" class="admonition question">
<summary class="admonition-title">
<p>思考用GC处理客户端意外终止</p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-思考用gc处理客户端意外终止"></a></p>
</summary>
<div>
<p>现在我们的系统对 Pub/Sub 已经有比较完整的支持，但你有没有注意到，有一个潜在的内存泄漏的 bug。如果客户端 A subscribe 了 Topic M，但客户端意外终止，且随后也没有任何人往 Topic M publish 消息。这样，A 的 subscription 就一直放在表中。你能做一个 GC 来处理这种情况么？</p>
<p>Redis 还支持 PSUBSCRIBE，也就是说除了可以 subscribe “chat” 这样固定的 topic，还可以是 “chat.*”，一并订阅所有 “chat”、“chat.rust”、“chat.elixir” 。想想看，如果要支持 PSUBSCRIBE，你该怎么设计 Broadcaster 里的两张表？</p>
</div>
</details>
<details id="admonition-tokio-本身不就是-支持了多路复用吗用-yamux来整合多路复用的意义是什么" class="admonition question">
<summary class="admonition-title">
<p>tokio 本身不就是 支持了多路复用吗？用 yamux来整合多路复用的意义是什么? </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-tokio-本身不就是-支持了多路复用吗用-yamux来整合多路复用的意义是什么"></a></p>
</summary>
<div>
<p>yamux 是一个具体的网络协议，它在 TCP 之上可以运行多个互不干扰的 stream（就像 HTTP/2）；tokio 是一个异步运行时，可以在 N 个线程上跑 M 个 tokio task。我们利用 tokio 的异步能力来承载 Yamux 协议。</p>
</div>
</details>
<details id="admonition-非rust写的客户端可否进行通信" class="admonition note">
<summary class="admonition-title">
<p>非rust写的客户端可否进行通信？ </p>
<p><a class="admonition-anchor-link" href="kv7_big_refactor.html#admonition-非rust写的客户端可否进行通信"></a></p>
</summary>
<div>
<p>yamux 是个协议，比如你可以用 nodejs client, python client 访问。你当然需要使用支持 yamux 协议的库，比如 <a href="https://www.npmjs.com/package/yamux-js">yamux-js</a>。这就跟你要访问 http server，需要符合协议规范的 http client 一样。</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="八配置测试监控cicd"><a class="header" href="#八配置测试监控cicd">八、配置/测试/监控/CI/CD</a></h1>
<!--ts-->
<ul>
<li><a href="kv8_config_ci_cd.html#%E5%85%AB%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7cicd">八、配置/测试/监控/CI/CD</a>
<ul>
<li><a href="kv8_config_ci_cd.html#%E9%85%8D%E7%BD%AE">配置</a></li>
<li><a href="kv8_config_ci_cd.html#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95">集成测试</a></li>
<li><a href="kv8_config_ci_cd.html#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95">性能测试</a></li>
<li><a href="kv8_config_ci_cd.html#%E6%B5%8B%E9%87%8F%E5%92%8C%E7%9B%91%E6%8E%A7">测量和监控</a></li>
<li><a href="kv8_config_ci_cd.html#cicd">CI/CD</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Oct 10 08:45:32 UTC 2022 -->
<!--te-->
<p>虽然这是一个“简单”的 KV server：</p>
<ul>
<li>它没有复杂的性能优化：只用了一句 unsafe；</li>
<li>也没有复杂的生命周期处理：只有零星 ’static 标注；</li>
<li>更没有支持集群的处理。</li>
</ul>
<blockquote>
<p>然而，如果你能够理解到目前为止的代码，甚至能独立写出这样的代码，那么，你已经具备足够的、能在一线大厂开发的实力了，国内我不是特别清楚，但在北美这边，保守一些地说，300k+ USD 的 package 应该可以轻松拿到。</p>
</blockquote>
<p>今天我们就给 KV server 项目收个尾，结合之前梳理的实战中 Rust 项目应该考虑的问题，来聊聊和生产环境有关的一些处理，按开发流程，主要讲五个方面：</p>
<ul>
<li>配置</li>
<li>集成测试</li>
<li>性能测试</li>
<li>测量和监控</li>
<li>CI/CD</li>
</ul>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<ol>
<li>首先在 Cargo.toml 里添加 <a href="https://github.com/serde-rs/serde">serde</a> 和<a href="https://github.com/toml-rs/toml-rs"> toml</a>。我们计划：</li>
</ol>
<ul>
<li>使用 toml 做配置文件</li>
<li>serde 用来处理配置的序列化和反序列化</li>
</ul>
<details id="admonition-cargotoml" class="admonition note">
<summary class="admonition-title">
<p>Cargo.toml</p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-cargotoml"></a></p>
</summary>
<div>
<pre><code class="language-toml">
[dependencies]
...
serde = { version = &quot;1&quot;, features = [&quot;derive&quot;] } # 序列化/反序列化
...
toml = &quot;0.5&quot; # toml 支持
...
</code></pre>
</div>
</details>
<details id="admonition-2-然后来创建一个-srcconfigrs构建-kv-server-的配置" class="admonition note">
<summary class="admonition-title">
<ol start="2">
<li>然后来创建一个 src/config.rs，构建 KV server 的配置：</li>
</ol>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-2-然后来创建一个-srcconfigrs构建-kv-server-的配置"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::KvError;
use serde::{Deserialize, Serialize};
use std::fs;

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ServerConfig {
    pub general: GeneralConfig,
    pub storage: StorageConfig,
    pub tls: ServerTlsConfig,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ClientConfig {
    pub general: GeneralConfig,
    pub tls: ClientTlsConfig,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct GeneralConfig {
    pub addr: String,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[serde(tag = &quot;type&quot;, content = &quot;args&quot;)]
pub enum StorageConfig {
    MemTable,
    SledDb(String),
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ServerTlsConfig {
    pub cert: String,
    pub key: String,
    pub ca: Option&lt;String&gt;,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ClientTlsConfig {
    pub domain: String,
    pub identity: Option&lt;(String, String)&gt;,
    pub ca: Option&lt;String&gt;,
}

impl ServerConfig {
    pub fn load(path: &amp;str) -&gt; Result&lt;Self, KvError&gt; {
        let config = fs::read_to_string(path)?;
        let config: Self = toml::from_str(&amp;config)?;
        Ok(config)
    }
}

impl ClientConfig {
    pub fn load(path: &amp;str) -&gt; Result&lt;Self, KvError&gt; {
        let config = fs::read_to_string(path)?;
        let config: Self = toml::from_str(&amp;config)?;
        Ok(config)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn server_config_should_be_loaded() {
        let result: Result&lt;ServerConfig, toml::de::Error&gt; =
            toml::from_str(include_str!(&quot;../fixtures/server.conf&quot;));
        assert!(result.is_ok());
    }

    #[test]
    fn client_config_should_be_loaded() {
        let result: Result&lt;ClientConfig, toml::de::Error&gt; =
            toml::from_str(include_str!(&quot;../fixtures/client.conf&quot;));
        assert!(result.is_ok());
    }
}
</code></pre></pre>
</div>
</details>
<p>你可以看到:</p>
<ul>
<li>在 Rust 下，有了 serde 的帮助，处理任何已知格式的配置文件，是多么容易的一件事情。</li>
<li>我们只需要定义数据结构，并为数据结构使用 Serialize/Deserialize 派生宏，就可以处理任何支持 serde 的数据结构。</li>
</ul>
<details id="admonition-3-examplesgen_configrs-用来生成toml配置文件" class="admonition info">
<summary class="admonition-title">
<ol start="3">
<li>examples/gen_config.rs, 用来生成toml配置文件</li>
</ol>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-3-examplesgen_configrs-用来生成toml配置文件"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use crate::KvError;
use serde::{Deserialize, Serialize};
use std::fs;

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ServerConfig {
    pub general: GeneralConfig,
    pub storage: StorageConfig,
    pub tls: ServerTlsConfig,
    pub log: LogConfig,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ClientConfig {
    pub general: GeneralConfig,
    pub tls: ClientTlsConfig,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct GeneralConfig {
    pub addr: String,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct LogConfig {
    pub path: String,
    pub rotation: RotationConfig,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub enum RotationConfig {
    Hourly,
    Daily,
    Never,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[serde(tag = &quot;type&quot;, content = &quot;args&quot;)]
pub enum StorageConfig {
    MemTable,
    SledDb(String),
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ServerTlsConfig {
    pub cert: String,
    pub key: String,
    pub ca: Option&lt;String&gt;,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ClientTlsConfig {
    pub domain: String,
    pub identity: Option&lt;(String, String)&gt;,
    pub ca: Option&lt;String&gt;,
}

impl ServerConfig {
    pub fn load(path: &amp;str) -&gt; Result&lt;Self, KvError&gt; {
        let config = fs::read_to_string(path)?;
        let config: Self = toml::from_str(&amp;config)?;
        Ok(config)
    }
}

impl ClientConfig {
    pub fn load(path: &amp;str) -&gt; Result&lt;Self, KvError&gt; {
        let config = fs::read_to_string(path)?;
        let config: Self = toml::from_str(&amp;config)?;
        Ok(config)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn server_config_should_be_loaded() {
        let result: Result&lt;ServerConfig, toml::de::Error&gt; =
            toml::from_str(include_str!(&quot;../fixtures/server.conf&quot;));
        assert!(result.is_ok());
    }

    #[test]
    fn client_config_should_be_loaded() {
        let result: Result&lt;ClientConfig, toml::de::Error&gt; =
            toml::from_str(include_str!(&quot;../fixtures/client.conf&quot;));
        assert!(result.is_ok());
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-下面是生成的服务端的配置" class="admonition note">
<summary class="admonition-title">
<p>下面是生成的服务端的配置： </p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-下面是生成的服务端的配置"></a></p>
</summary>
<div>
<pre><code class="language-toml">
[general]
addr = '127.0.0.1:9527'

[storage]
type = 'SledDb'
args = '/tmp/kv_server'

[tls]
cert = &quot;&quot;&quot;
-----BEGIN CERTIFICATE-----\r
MIIBdzCCASmgAwIBAgIICpy02U2yuPowBQYDK2VwMDMxCzAJBgNVBAYMAkNOMRIw\r
EAYDVQQKDAlBY21lIEluYy4xEDAOBgNVBAMMB0FjbWUgQ0EwHhcNMjEwOTI2MDEy\r
NTU5WhcNMjYwOTI1MDEyNTU5WjA6MQswCQYDVQQGDAJDTjESMBAGA1UECgwJQWNt\r
ZSBJbmMuMRcwFQYDVQQDDA5BY21lIEtWIHNlcnZlcjAqMAUGAytlcAMhAK2Z2AjF\r
A0uiltNuCvl6EVFl6tpaS/wJYB5IdWT2IISdo1QwUjAcBgNVHREEFTATghFrdnNl\r
cnZlci5hY21lLmluYzATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMEBTADAQEA\r
MA8GA1UdDwEB/wQFAwMH4AAwBQYDK2VwA0EASGOmOWFPjbGhXNOmYNCa3lInbgRy\r
iTNtB/5kElnbKkhKhRU7yQ8HTHWWkyU5WGWbOOIXEtYp+5ERUJC+mzP9Bw==\r
-----END CERTIFICATE-----\r
&quot;&quot;&quot;
key = &quot;&quot;&quot;
-----BEGIN PRIVATE KEY-----\r
MFMCAQEwBQYDK2VwBCIEIPMyINaewhXwuTPUufFO2mMt/MvQMHrGDGxgdgfy/kUu\r
oSMDIQCtmdgIxQNLopbTbgr5ehFRZeraWkv8CWAeSHVk9iCEnQ==\r
-----END PRIVATE KEY-----\r
&quot;&quot;&quot;
</code></pre>
</div>
</details>
<p>有了配置文件的支持，就可以在 lib.rs 下写一些辅助函数，让我们创建服务端和客户端更加简单：</p>
<details id="admonition-examplesgen_configrs" class="admonition info">
<summary class="admonition-title">
<p>examples/gen_config.rs</p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-examplesgen_configrs"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">mod config;
mod error;
mod network;
mod pb;
mod service;
mod storage;

pub use config::*;
pub use error::KvError;
pub use network::*;
pub use pb::abi::*;
pub use service::*;
pub use storage::*;

use anyhow::Result;
use tokio::net::{TcpListener, TcpStream};
use tokio_rustls::client;
use tokio_util::compat::FuturesAsyncReadCompatExt;
use tracing::{info, instrument, span};

/// 通过配置创建 KV 服务器
#[instrument(skip_all)]
pub async fn start_server_with_config(config: &amp;ServerConfig) -&gt; Result&lt;()&gt; {
    let acceptor =
        TlsServerAcceptor::new(&amp;config.tls.cert, &amp;config.tls.key, config.tls.ca.as_deref())?;

    let addr = &amp;config.general.addr;
    match &amp;config.storage {
        StorageConfig::MemTable =&gt; start_tls_server(addr, MemTable::new(), acceptor).await?,
        StorageConfig::SledDb(path) =&gt; start_tls_server(addr, SledDb::new(path), acceptor).await?,
    };

    Ok(())
}

/// 通过配置创建 KV 客户端
#[instrument(skip_all)]
pub async fn start_client_with_config(
    config: &amp;ClientConfig,
) -&gt; Result&lt;YamuxCtrl&lt;client::TlsStream&lt;TcpStream&gt;&gt;&gt; {
    let addr = &amp;config.general.addr;
    let tls = &amp;config.tls;

    let identity = tls.identity.as_ref().map(|(c, k)| (c.as_str(), k.as_str()));
    let connector = TlsClientConnector::new(&amp;tls.domain, identity, tls.ca.as_deref())?;
    let stream = TcpStream::connect(addr).await?;
    let stream = connector.connect(stream).await?;

    // 打开一个 stream
    Ok(YamuxCtrl::new_client(stream, None))
}

async fn start_tls_server&lt;Store: Storage&gt;(
    addr: &amp;str,
    store: Store,
    acceptor: TlsServerAcceptor,
) -&gt; Result&lt;()&gt; {
    let service: Service&lt;Store&gt; = ServiceInner::new(store).into();
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Start listening on {}&quot;, addr);
    loop {
        let root = span!(tracing::Level::INFO, &quot;server_process&quot;);
        let _enter = root.enter();
        let tls = acceptor.clone();
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Client {:?} connected&quot;, addr);

        let svc = service.clone();
        tokio::spawn(async move {
            let stream = tls.accept(stream).await.unwrap();
            YamuxCtrl::new_server(stream, None, move |stream| {
                let svc1 = svc.clone();
                async move {
                    let stream = ProstServerStream::new(stream.compat(), svc1.clone());
                    stream.process().await.unwrap();
                    Ok(())
                }
            });
        });
    }
}
</code></pre></pre>
</div>
</details>
<p>有了 start_server_with_config 和 start_client_with_config 这两个辅助函数，我们就可以简化 src/server.rs 和 src/client.rs 了。</p>
<details id="admonition-下面是-srcserverrs-的新代码" class="admonition note">
<summary class="admonition-title">
<p>下面是 src/server.rs 的新代码： </p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-下面是-srcserverrs-的新代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use kv6::{start_server_with_config, ServerConfig};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();
    let config: ServerConfig = toml::from_str(include_str!(&quot;../fixtures/server.conf&quot;))?;

    start_server_with_config(&amp;config).await?;

    Ok(())
}
</code></pre></pre>
</div>
</details>
<details id="admonition-examplesgen_configrs-1" class="admonition info">
<summary class="admonition-title">
<p>examples/gen_config.rs</p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-examplesgen_configrs-1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::env;

use anyhow::Result;
use kv6::{start_server_with_config, RotationConfig, ServerConfig};
use tokio::fs;
use tracing::span;
use tracing_subscriber::{
    fmt::{self, format},
    layer::SubscriberExt,
    prelude::*,
    EnvFilter,
};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let config = match env::var(&quot;KV_SERVER_CONFIG&quot;) {
        Ok(path) =&gt; fs::read_to_string(&amp;path).await?,
        Err(_) =&gt; include_str!(&quot;../fixtures/server.conf&quot;).to_string(),
    };
    let config: ServerConfig = toml::from_str(&amp;config)?;

    let tracer = opentelemetry_jaeger::new_pipeline()
        .with_service_name(&quot;kv-server&quot;)
        .install_simple()?;
    let opentelemetry = tracing_opentelemetry::layer().with_tracer(tracer);

    // 添加
    let log = &amp;config.log;
    let file_appender = match log.rotation {
        RotationConfig::Hourly =&gt; tracing_appender::rolling::hourly(&amp;log.path, &quot;server.log&quot;),
        RotationConfig::Daily =&gt; tracing_appender::rolling::daily(&amp;log.path, &quot;server.log&quot;),
        RotationConfig::Never =&gt; tracing_appender::rolling::never(&amp;log.path, &quot;server.log&quot;),
    };

    let (non_blocking, _guard1) = tracing_appender::non_blocking(file_appender);
    let fmt_layer = fmt::layer()
        .event_format(format().compact())
        .with_writer(non_blocking);

    tracing_subscriber::registry()
        .with(EnvFilter::from_default_env())
        .with(fmt_layer)
        .with(opentelemetry)
        .init();

    let root = span!(tracing::Level::INFO, &quot;app_start&quot;, work_units = 2);
    let _enter = root.enter();

    start_server_with_config(&amp;config).await?;

    Ok(())
}
</code></pre></pre>
</div>
</details>
<p>可以看到，整个代码简洁了很多。在这个重构的过程中，还有一些其它改动，你可以看 GitHub repo 下 45 讲的 diff_config。</p>
<h2 id="集成测试"><a class="header" href="#集成测试">集成测试</a></h2>
<p>之前我们写了很多单元测试，但还没有写过一行集成测试。今天就来写一个简单的集成测试，确保客户端和服务器完整的交互工作正常。</p>
<p>之前提到在 Rust 里，集成测试放在 tests 目录下，每个测试编成单独的二进制。</p>
<ol>
<li>所以首先，我们创建和 src 平行的 tests 目录。</li>
<li>然后再创建 tests/server.rs，填入以下代码：</li>
</ol>
<details id="admonition-examplesgen_configrs-2" class="admonition info">
<summary class="admonition-title">
<p>examples/gen_config.rs</p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-examplesgen_configrs-2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use anyhow::Result;
use kv6::{
    start_client_with_config, start_server_with_config, ClientConfig, CommandRequest, ServerConfig,
    StorageConfig,
};
use std::time::Duration;
use tokio::time;

#[tokio::test]
async fn yamux_server_client_full_tests() -&gt; Result&lt;()&gt; {
    let addr = &quot;127.0.0.1:10086&quot;;

    let mut config: ServerConfig = toml::from_str(include_str!(&quot;../fixtures/server.conf&quot;))?;
    config.general.addr = addr.into();
    config.storage = StorageConfig::MemTable;

    // 启动服务器
    tokio::spawn(async move {
        start_server_with_config(&amp;config).await.unwrap();
    });

    time::sleep(Duration::from_millis(10)).await;
    let mut config: ClientConfig = toml::from_str(include_str!(&quot;../fixtures/client.conf&quot;))?;
    config.general.addr = addr.into();

    let mut ctrl = start_client_with_config(&amp;config).await.unwrap();
    let mut stream = ctrl.open_stream().await?;

    // 生成一个 HSET 命令
    let cmd = CommandRequest::new_hset(&quot;table1&quot;, &quot;hello&quot;, &quot;world&quot;.to_string().into());
    stream.execute_unary(&amp;cmd).await?;

    // 生成一个 HGET 命令
    let cmd = CommandRequest::new_hget(&quot;table1&quot;, &quot;hello&quot;);
    let data = stream.execute_unary(&amp;cmd).await?;

    assert_eq!(data.status, 200);
    assert_eq!(data.values, &amp;[&quot;world&quot;.into()]);

    Ok(())
}
</code></pre></pre>
<blockquote>
<p>可以看到，集成测试的写法和单元测试其实很类似，只不过我们不需要再使用 #[cfg(test)] 来做条件编译。</p>
</blockquote>
<pre><code class="language-admonish note title=&quot;如果你的集成测试比较复杂，需要比较多的辅助代码，那么你还可以:&quot; collapsible=true">1. 在 tests 下 cargo new 出一个项目
2. 然后在那个项目里撰写辅助代码和测试代码
3. 如果你对此感兴趣，可以看[ tonic 的集成测试](https://github.com/hyperium/tonic/tree/master/tests)。
4. 不过注意了,集成测试和你的 crate 用同样的条件编译，所以在集成测试里，无法使用单元测试中构建的辅助代码。

&lt;/div&gt;
&lt;/details&gt;

## 性能测试

在之前不断完善 KV server 的过程中，你一定会好奇：我们的 KV server 性能究竟如何呢？那来写一个关于 Pub/Sub 的性能测试吧。

基本的想法是我们连上 100 个 subscriber 作为背景，然后看 publisher publish 的速度。

因为 BROADCAST_CAPACITY 有限，是 128，当 publisher 速度太快，而导致 server 不能及时往 subscriber 发送时，server 接收 client 数据的速度就会降下来，无法接收新的
client，整体的 publish 的速度也会降下来，所以这个测试能够了解 server 处理 publish 的速度。


&lt;details id=&quot;admonition-为了确认这一点我们在-start_tls_server-函数中在-process-之前再加个-100ms-的延时人为减缓系统的处理速度&quot; class=&quot;admonition note&quot;&gt;
&lt;summary class=&quot;admonition-title&quot;&gt;

为了确认这一点，我们在 start_tls_server() 函数中，在 process() 之前，再加个 100ms 的延时，人为减缓系统的处理速度：

&lt;a class=&quot;admonition-anchor-link&quot; href=&quot;#admonition-为了确认这一点我们在-start_tls_server-函数中在-process-之前再加个-100ms-的延时人为减缓系统的处理速度&quot;&gt;&lt;/a&gt;
&lt;/summary&gt;
&lt;div&gt;

```rust, editable

async move {
    let stream = ProstServerStream::new(stream.compat(), svc1.clone());
    // 延迟 100ms 处理
    time::sleep(Duration::from_millis(100)).await;
    stream.process().await.unwrap();
    Ok(())
}
```

&lt;/div&gt;
&lt;/details&gt;

好，现在可以写性能测试了。


&lt;details id=&quot;admonition-在-rust-下我们可以用-criterion-库httpsgithubcombheislercriterionrs它可以处理基本的性能测试并生成漂亮的报告&quot; class=&quot;admonition note&quot;&gt;
&lt;summary class=&quot;admonition-title&quot;&gt;

在 Rust 下，我们可以用 [criterion 库](https://github.com/bheisler/criterion.rs)。它可以处理基本的性能测试，并生成漂亮的报告 

&lt;a class=&quot;admonition-anchor-link&quot; href=&quot;#admonition-在-rust-下我们可以用-criterion-库httpsgithubcombheislercriterionrs它可以处理基本的性能测试并生成漂亮的报告&quot;&gt;&lt;/a&gt;
&lt;/summary&gt;
&lt;div&gt;

所以在 Cargo.toml 中加入：

```toml

[dev-dependencies]
...
criterion = { version = &quot;0.3&quot;, features = [&quot;async_futures&quot;, &quot;async_tokio&quot;, &quot;html_reports&quot;] } # benchmark
...
rand = &quot;0.8&quot; # 随机数处理
...

[[bench]]
name = &quot;pubsub&quot;
harness = false
```

&gt; 最后这个 bench section，描述了性能测试的名字，它对应 benches 目录下的同名文件。

我们创建和 src 平级的 benches，然后再创建 benches/pubsub.rs，添入如下代码：

~~~admonish info title=&quot;examples/gen_config.rs&quot; collapsible=true
```rust, editable
use anyhow::Result;
use criterion::{criterion_group, criterion_main, Criterion};
use futures::StreamExt;
use kv6::{
    start_client_with_config, start_server_with_config, ClientConfig, CommandRequest, ServerConfig,
    StorageConfig, YamuxCtrl,
};
use rand::prelude::SliceRandom;
use std::time::Duration;
use tokio::net::TcpStream;
use tokio::runtime::Builder;
use tokio::time;
use tokio_rustls::client::TlsStream;
use tracing::{info, span};
use tracing_subscriber::{layer::SubscriberExt, prelude::*, EnvFilter};

async fn start_server() -&gt; Result&lt;()&gt; {
    let addr = &quot;127.0.0.1:9999&quot;;
    let mut config: ServerConfig = toml::from_str(include_str!(&quot;../fixtures/server.conf&quot;))?;
    config.general.addr = addr.into();
    config.storage = StorageConfig::MemTable;

    tokio::spawn(async move {
        start_server_with_config(&amp;config).await.unwrap();
    });

    Ok(())
}

async fn connect() -&gt; Result&lt;YamuxCtrl&lt;TlsStream&lt;TcpStream&gt;&gt;&gt; {
    let addr = &quot;127.0.0.1:9999&quot;;
    let mut config: ClientConfig = toml::from_str(include_str!(&quot;../fixtures/client.conf&quot;))?;
    config.general.addr = addr.into();

    Ok(start_client_with_config(&amp;config).await?)
}

async fn start_subscribers(topic: &amp;'static str) -&gt; Result&lt;()&gt; {
    let mut ctrl = connect().await?;
    let stream = ctrl.open_stream().await?;
    info!(&quot;C(subscriber): stream opened&quot;);
    let cmd = CommandRequest::new_subscribe(topic.to_string());
    tokio::spawn(async move {
        let mut stream = stream.execute_streaming(&amp;cmd).await.unwrap();
        while let Some(Ok(data)) = stream.next().await {
            drop(data);
        }
    });

    Ok(())
}

async fn start_publishers(topic: &amp;'static str, values: &amp;'static [&amp;'static str]) -&gt; Result&lt;()&gt; {
    let mut rng = rand::thread_rng();
    let v = values.choose(&amp;mut rng).unwrap();

    let mut ctrl = connect().await.unwrap();
    let mut stream = ctrl.open_stream().await.unwrap();
    info!(&quot;C(publisher): stream opened&quot;);

    let cmd = CommandRequest::new_publish(topic.to_string(), vec![(*v).into()]);
    stream.execute_unary(&amp;cmd).await.unwrap();

    Ok(())
}

fn pubsub(c: &amp;mut Criterion) {
    let tracer = opentelemetry_jaeger::new_pipeline()
        .with_service_name(&quot;kv-bench&quot;)
        .install_simple()
        .unwrap();
    let opentelemetry = tracing_opentelemetry::layer().with_tracer(tracer);

    tracing_subscriber::registry()
        .with(EnvFilter::from_default_env())
        .with(opentelemetry)
        .init();

    let root = span!(tracing::Level::INFO, &quot;app_start&quot;, work_units = 2);
    let _enter = root.enter();
    // 创建 Tokio runtime
    let runtime = Builder::new_multi_thread()
        .worker_threads(4)
        .thread_name(&quot;pubsub&quot;)
        .enable_all()
        .build()
        .unwrap();

    let base_str = include_str!(&quot;../fixtures/server.conf&quot;); // 891 bytes

    let values: &amp;'static [&amp;'static str] = Box::leak(
        vec![
            &amp;base_str[..64],
            &amp;base_str[..128],
            &amp;base_str[..256],
            &amp;base_str[..512],
        ]
        .into_boxed_slice(),
    );
    let topic = &quot;lobby&quot;;

    // 运行服务器和 100 个 subscriber，为测试准备
    runtime.block_on(async {
        eprint!(&quot;preparing server and subscribers&quot;);
        start_server().await.unwrap();
        time::sleep(Duration::from_millis(50)).await;
        for _ in 0..1000 {
            start_subscribers(topic).await.unwrap();
            eprint!(&quot;.&quot;);
        }
        eprintln!(&quot;Done!&quot;);
    });

    // 进行 benchmark
    c.bench_function(&quot;publishing&quot;, move |b| {
        b.to_async(&amp;runtime)
            .iter(|| async { start_publishers(topic, values).await })
    });
}

criterion_group! {
    name = benches;
    config = Criterion::default().sample_size(10);
    targets = pubsub
}
criterion_main!(benches);
```

&lt;/div&gt;
&lt;/details&gt;

大部分的代码都很好理解，就是创建服务器和客户端，为测试做准备。

说一下这里面核心的 benchmark 代码：

```rust, editable

c.bench_function(&quot;publishing&quot;, move |b| {
    b.to_async(&amp;runtime)
        .iter(|| async { start_publishers(topic, values).await })
});
```

对于要测试的代码，我们可以封装成一个函数进行测试。

- 这里因为要做 async 函数的测试，需要使用 runtime。
- 普通的函数不需要调用 to_async。对于更多有关 criterion 的用法，可以参考它的文档。

</code></pre>
<p>````admonish success title=&quot;运行 <code>cargo bench</code> 后，会见到如下打印（如果你的代码无法通过，可以参考 repo 里的 diff_benchmark，我顺便做了一点小重构）： &quot; collapsible=true</p>
<pre><code class="language-shell">
preparing server and subscribers....................................................................................................Done!
publishing              time:   [419.73 ms 426.84 ms 434.20 ms]                     
                        change: [-1.6712% +1.0499% +3.6586%] (p = 0.48 &gt; 0.05)
                        No change in performance detected.
</code></pre>
<p>可以看到，单个 publish 的处理速度要 426ms，好慢！我们把之前在 start_tls_server() 里加的延迟去掉，再次测试：</p>
<pre><code class="language-shell">
preparing server and subscribers....................................................................................................Done!
publishing              time:   [318.61 ms 324.48 ms 329.81 ms]                     
                        change: [-25.854% -23.980% -22.144%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
</code></pre>
<pre><code>
 &gt; 
 &gt; 嗯，这下 324ms，正好是减去刚才加的 100ms。可是这个速度依旧不合理，凭直觉我们感觉一下这个速度，是 Python 这样的语言还正常，如果是 Rust 也太慢了吧？

## 测量和监控

 &gt; 
 &gt; 工业界有句名言：如果你无法测量，那你就无法改进（If you can’t measure it, you can’t improve it）。

现在知道了 KV server 性能有问题，但并不知道问题出在哪里。我们需要使用合适的测量方式。

目前，比较好的端对端的性能监控和测量工具是 jaeger，我们可以在 KV server/client 侧收集监控信息，发送给 jaeger 来查看在服务器和客户端的整个处理流程中，时间都花费到哪里去了。

之前我们在 KV server 里使用的日志工具是
tracing，不过日志只是它的诸多功能之一，它还能做[ instrument](https://docs.rs/tracing/0.1.28/tracing/attr.instrument.html)
，然后配合 [opentelemetry 库](https://github.com/open-telemetry/opentelemetry-rust)，我们就可以把 instrument 的结果发送给 jaeger 了。

&lt;details id=&quot;admonition-1-加入jaeger&quot; class=&quot;admonition note&quot;&gt;
&lt;summary class=&quot;admonition-title&quot;&gt;

1. 加入jaeger 

&lt;a class=&quot;admonition-anchor-link&quot; href=&quot;#admonition-1-加入jaeger&quot;&gt;&lt;/a&gt;

&lt;/summary&gt;
&lt;div&gt;

好，在 Cargo.toml 里添加新的依赖：

````toml

[dependencies]
...
opentelemetry-jaeger = &quot;0.15&quot; # opentelemetry jaeger 支持
...
tracing-appender = &quot;0.1&quot; # 文件日志
tracing-opentelemetry = &quot;0.15&quot; # opentelemetry 支持
tracing-subscriber = { version = &quot;0.2&quot;, features = [&quot;json&quot;, &quot;chrono&quot;] } # 日志处理
</code></pre>
<p>有了这些依赖后，在 benches/pubsub.rs 里，我们可以在初始化 tracing_subscriber 时，使用 jaeger 和 opentelemetry tracer：</p>
<pre><pre class="playground"><code class="language-rust  editable">
fn pubsub(c: &amp;mut Criterion) {
    let tracer = opentelemetry_jaeger::new_pipeline()
        .with_service_name(&quot;kv-bench&quot;)
        .install_simple()
        .unwrap();
    let opentelemetry = tracing_opentelemetry::layer().with_tracer(tracer);

    tracing_subscriber::registry()
        .with(EnvFilter::from_default_env())
        .with(opentelemetry)
        .init();

    let root = span!(tracing::Level::INFO, &quot;app_start&quot;, work_units = 2);
    let _enter = root.enter();
    // 创建 Tokio runtime
    ...
}
</code></pre></pre>
<p>设置好 tracing 后，就在系统的主流程上添加相应的 instrument：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/f1680244d5c7901ec26181c01bfea8a1.jpg" alt="img" /></p>
<h2 id="新添加的代码你可以看-repo-中的-diff_telemetry"><a class="header" href="#新添加的代码你可以看-repo-中的-diff_telemetry">新添加的代码你可以看 repo 中的 diff_telemetry。</a></h2>
<p>注意 instrument 可以用不同的名称:</p>
<blockquote>
<p>比如，对于 TlsConnector::new() 函数，可以用 #[instrument(name = “tls_connector_new”)]，这样它的名字辨识度高一些。</p>
</blockquote>
</div>
</details>
<details id="admonition-2-运行jaeger" class="admonition success">
<summary class="admonition-title">
<ol start="2">
<li>运行jaeger </li>
</ol>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-2-运行jaeger"></a></p>
</summary>
<div>
<p>为主流程中的函数添加完 instrument 后，你需要先打开一个窗口，运行 jaeger（需要 docker）：</p>
<pre><code class="language-shell">docker run -d -p6831:6831/udp -p6832:6832/udp -p16686:16686 -p14268:14268 jaegertracing/all-in-one:latest
</code></pre>
<p>然后带着 RUST_LOG=info 运行 benchmark：</p>
<pre><code class="language-shell">RUST_LOG=info cargo bench
</code></pre>
<pre><code class="language-shell">
preparing server and subscribers....................................................................................................Done!
publishing              time:   [1.7464 ms 1.9556 ms 2.2343 ms]                       
Found 2 outliers among 10 measurements (20.00%)
  1 (10.00%) high mild
  1 (10.00%) high severe
</code></pre>
</div>
</details>
<p>并没有做任何事情，似乎只是换了个系统，性能就提升了很多，这给我们一个 tip：也许问题出在 OS X 和 Linux 系统相关的部分。</p>
<p>不管怎样，已经发送了不少数据给 jaeger，我们到 jaeger 上看看问题出在哪里。</p>
<details id="admonition-第一次检查" class="admonition bug">
<summary class="admonition-title">
<p>第一次检查</p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-第一次检查"></a></p>
</summary>
<div>
<ul>
<li>打开 http://localhost:16686/</li>
<li>service 选 kv-bench</li>
<li>Operation 选 app_start</li>
<li>点击 “Find Traces”</li>
<li>我们可以看到捕获的 trace。因为运行了两次 benchmark，所以有两个 app_start 的查询结果：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/ecd9b1d06debe7fb3fe507befd803877.png" alt="img" /></p>
<p>可以看到，每次 start_client_with_config 都要花 1.6-2.5ms，其中有差不多一小半时间花在了 TlsClientConnector::new() 上：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/fe574ccac09ce5434027fce2afebaeb6.png" alt="img" /></p>
</div>
</details>
<details id="admonition-第一次修改" class="admonition info">
<summary class="admonition-title">
<p>第一次修改 </p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-第一次修改"></a></p>
</summary>
<div>
<p>如果说 TlsClientConnector::connect() 花不少时间还情有可原，因为这是整个 TLS 协议的握手过程，涉及到网络调用、包的加解密等。</p>
<p>但 TlsClientConnector::new() 就是加载一些证书、创建 TlsConnector 这个数据结构而已，为何这么慢？</p>
<p>仔细阅读 TlsClientConnector::new() 的代码，你可以对照注释看：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[instrument(name = &quot;tls_connector_new&quot;, skip_all)]
pub fn new(
    domain: impl Into&lt;String&gt; + std::fmt::Debug,
    identity: Option&lt;(&amp;str, &amp;str)&gt;,
    server_ca: Option&lt;&amp;str&gt;,
) -&gt; Result&lt;Self, KvError&gt; {
    let mut config = ClientConfig::new();

    // 如果有客户端证书，加载之
    if let Some((cert, key)) = identity {
        let certs = load_certs(cert)?;
        let key = load_key(key)?;
        config.set_single_client_cert(certs, key)?;
    }

    // 加载本地信任的根证书链
    config.root_store = match rustls_native_certs::load_native_certs() {
        Ok(store) | Err((Some(store), _)) =&gt; store,
        Err((None, error)) =&gt; return Err(error.into()),
    };

    // 如果有签署服务器的 CA 证书，则加载它，这样服务器证书不在根证书链
    // 但是这个 CA 证书能验证它，也可以
    if let Some(cert) = server_ca {
        let mut buf = Cursor::new(cert);
        config.root_store.add_pem_file(&amp;mut buf).unwrap();
    }

    Ok(Self {
        config: Arc::new(config),
        domain: Arc::new(domain.into()),
    })
}
</code></pre></pre>
<p>可以发现，它的代码唯一可能影响性能的就是加载本地信任的根证书链的部分。这个代码会和操作系统交互，获取信任的根证书链。也许，这就是影响性能的原因之一？</p>
<p>那我们将其简单重构一下。因为根证书链，只有在客户端没有提供用于验证服务器证书的 CA 证书时，才需要，所以可以在没有 CA 证书时，才加载本地的根证书链：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[instrument(name = &quot;tls_connector_new&quot;, skip_all)]
pub fn new(
    domain: impl Into&lt;String&gt; + std::fmt::Debug,
    identity: Option&lt;(&amp;str, &amp;str)&gt;,
    server_ca: Option&lt;&amp;str&gt;,
) -&gt; Result&lt;Self, KvError&gt; {
    let mut config = ClientConfig::new();

    // 如果有客户端证书，加载之
    if let Some((cert, key)) = identity {
        let certs = load_certs(cert)?;
        let key = load_key(key)?;
        config.set_single_client_cert(certs, key)?;
    }

    // 如果有签署服务器的 CA 证书，则加载它，这样服务器证书不在根证书链
    // 但是这个 CA 证书能验证它，也可以
    if let Some(cert) = server_ca {
        let mut buf = Cursor::new(cert);
        config.root_store.add_pem_file(&amp;mut buf).unwrap();
    } else {
        // 加载本地信任的根证书链
        config.root_store = match rustls_native_certs::load_native_certs() {
            Ok(store) | Err((Some(store), _)) =&gt; store,
            Err((None, error)) =&gt; return Err(error.into()),
        };
    }

    Ok(Self {
        config: Arc::new(config),
        domain: Arc::new(domain.into()),
    })
}
</code></pre></pre>
<p>完成这个修改后，我们再运行 RUST_LOG=info cargo bench，现在的性能达到了 1.64ms，相比之前的 1.95ms，提升了 16%。</p>
</div>
</details>
<details id="admonition-第二次检查" class="admonition bug">
<summary class="admonition-title">
<p>第二次检查 </p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-第二次检查"></a></p>
</summary>
<div>
<p>打开 jaeger，看最新的 app_start 结果，发现 TlsClientConnector::new() 所花时间降到了 ~12us 左右。嗯，虽然没有抓到服务器本身的 bug，但客户端的 bug 倒是解决了一个。</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/3cfde740dbe0d4a897e2d4c3684b530b.png" alt="img" /></p>
<p>至于服务器，如果我们看 Service::execute 的主流程，执行速度在 40-60us，问题不大：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/7be6139668c82fb8b79fb66f3ed06d31.png" alt="img" /></p>
<p>再看服务器的主流程 server_process：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/076402ac25b507295d022b980378e363.png" alt="img" /></p>
<p>这是我们在 start_tls_server() 里额外添加的 tracing span：</p>
<pre><pre class="playground"><code class="language-rust  editable">
loop {
    let root = span!(tracing::Level::INFO, &quot;server_process&quot;);
    let _enter = root.enter();
    ...
}
</code></pre></pre>
<p>把右上角的 trace timeline 改成 trace graph，然后点右侧的 time：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/1499657924a241e43c9d1be467793041.png" alt="img" /></p>
<p>可以看到，主要的服务器时间都花在了 TLS accept 上，所以，目前服务器没有太多值得优化的地方。</p>
<p>由于 tracing 本身也占用不少 CPU，所以我们直接 cargo bench 看看目前的结果：</p>
<pre><code class="language-shell">preparing server and subscribers....................................................................................................Done!
publishing              time:   [1.3986 ms 1.4140 ms 1.4474 ms]                       
                        change: [-26.647% -19.977% -10.798%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 2 outliers among 10 measurements (20.00%)
  2 (20.00%) high severe
</code></pre>
<p>不加 RUST_LOG=info 后，整体性能到了 1.4ms。这是我在 Ubuntu 虚拟机下的结果。</p>
<p>我们再回到 OS X 下测试，看看 TlsClientConnector::new() 的修改，对 OS X 是否有效：</p>
<pre><code class="language-shell">preparing server and subscribers....................................................................................................Done!
publishing              time:   [1.4086 ms 1.4229 ms 1.4315 ms]                       
                        change: [-99.570% -99.563% -99.554%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
</code></pre>
<p>嗯，在我的 OS X 下，现在整体性能也到了 1.4ms 的水平。这也意味着，在有 100 个 subscribers 的情况下，我们的 KV server 每秒钟可以处理 714k publish 请求；而在 1000 个 subscribers 的情况下，性能在 11.1ms 的水平，也就是每秒可以处理 90k publish 请求：</p>
<pre><code class="language-shell">
publishing              time:   [11.007 ms 11.095 ms 11.253 ms]                      
                        change: [-96.618% -96.556% -96.486%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
</code></pre>
<p>你也许会觉得目前 publish 的 value 太小，那换一些更加贴近实际的字符串大小：</p>
<pre><code class="language-shell">
// let values = &amp;[&quot;Hello&quot;, &quot;Tyr&quot;, &quot;Goodbye&quot;, &quot;World&quot;];
let base_str = include_str!(&quot;../fixtures/server.conf&quot;); // 891 bytes

let values: &amp;'static [&amp;'static str] = Box::leak(
    vec![
        &amp;base_str[..64],
        &amp;base_str[..128],
        &amp;base_str[..256],
        &amp;base_str[..512],
    ]
    .into_boxed_slice(),
);
</code></pre>
<p>测试结果差不太多：</p>
<pre><code class="language-shell">
publishing              time:   [10.917 ms 11.098 ms 11.428 ms]                      
                        change: [-0.4822% +2.3311% +4.9631%] (p = 0.12 &gt; 0.05)
                        No change in performance detected.
</code></pre>
</div>
</details>
<details id="admonition-criterion-还会生成漂亮的-report" class="admonition info">
<summary class="admonition-title">
<p>criterion 还会生成漂亮的 report </p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-criterion-还会生成漂亮的-report"></a></p>
</summary>
<div>
<p>你可以用浏览器打开 ./target/criterion/publishing/report/index.html 查看（名字是 publishing ，因为 benchmark ID 是 publishing）：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/d3cebd8e3c164171febbe34e43916885.png" alt="img" /></p>
</div>
</details>
<details id="admonition-好处理完性能相关的问题我们来为-server-添加日志和性能监测的支持" class="admonition note">
<summary class="admonition-title">
<p>好，处理完性能相关的问题，我们来为 server 添加日志和性能监测的支持： </p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-好处理完性能相关的问题我们来为-server-添加日志和性能监测的支持"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::env;

use anyhow::Result;
use kv6::{start_server_with_config, RotationConfig, ServerConfig};
use tokio::fs;
use tracing::span;
use tracing_subscriber::{
    fmt::{self, format},
    layer::SubscriberExt,
    prelude::*,
    EnvFilter,
};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // 如果有环境变量，使用环境变量中的 config
    let config = match env::var(&quot;KV_SERVER_CONFIG&quot;) {
        Ok(path) =&gt; fs::read_to_string(&amp;path).await?,
        Err(_) =&gt; include_str!(&quot;../fixtures/server.conf&quot;).to_string(),
    };
    let config: ServerConfig = toml::from_str(&amp;config)?;

    let tracer = opentelemetry_jaeger::new_pipeline()
        .with_service_name(&quot;kv-server&quot;)
        .install_simple()?;
    let opentelemetry = tracing_opentelemetry::layer().with_tracer(tracer);

    // 添加
    let log = &amp;config.log;
    let file_appender = match log.rotation {
        RotationConfig::Hourly =&gt; tracing_appender::rolling::hourly(&amp;log.path, &quot;server.log&quot;),
        RotationConfig::Daily =&gt; tracing_appender::rolling::daily(&amp;log.path, &quot;server.log&quot;),
        RotationConfig::Never =&gt; tracing_appender::rolling::never(&amp;log.path, &quot;server.log&quot;),
    };

    let (non_blocking, _guard1) = tracing_appender::non_blocking(file_appender);
    let fmt_layer = fmt::layer()
        .event_format(format().compact())
        .with_writer(non_blocking);

    tracing_subscriber::registry()
        .with(EnvFilter::from_default_env())
        .with(fmt_layer)
        .with(opentelemetry)
        .init();

    let root = span!(tracing::Level::INFO, &quot;app_start&quot;, work_units = 2);
    let _enter = root.enter();

    start_server_with_config(&amp;config).await?;

    Ok(())
}
</code></pre></pre>
<p>为了让日志能在配置文件中配置，需要更新一下 src/config.rs：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ServerConfig {
    pub general: GeneralConfig,
    pub storage: StorageConfig,
    pub tls: ServerTlsConfig,
    pub log: LogConfig,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct LogConfig {
    pub path: String,
    pub rotation: RotationConfig,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub enum RotationConfig {
    Hourly,
    Daily,
    Never,
}
</code></pre></pre>
<p>你还需要更新 examples/gen_config.rs。相关的改变可以看 repo 下的 diff_logging。</p>
</div>
</details>
<h2 id="cicd"><a class="header" href="#cicd">CI/CD</a></h2>
<p>为了讲述方便，我把 CI/CD 放在最后，但 CI/CD 应该是在一开始的时候就妥善设置的。</p>
<details id="admonition-使用github-action实现ci" class="admonition note">
<summary class="admonition-title">
<p>使用github action实现CI</p>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition-使用github-action实现ci"></a></p>
</summary>
<div>
<p>先说 CI 吧, repo tyrchen/geektime-rust 在一开始就设置了 github action，每次 commit 都会运行：</p>
<ul>
<li>
<p>代码格式检查：cargo fmt</p>
</li>
<li>
<p>依赖 license 检查：cargo deny</p>
</li>
<li>
<p>linting：cargo check 和 cargo clippy</p>
</li>
<li>
<p>单元测试和集成测试：cargo test</p>
</li>
<li>
<p>生成文档：cargo doc</p>
</li>
</ul>
<blockquote>
<p>github action 配置如下，供你参考：</p>
</blockquote>
<pre><code class="language-yaml">
name: build

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

jobs:
  build-rust:
    strategy:
      matrix:
        platform: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - name: Cache cargo registry
        uses: actions/cache@v1
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry
      - name: Cache cargo index
        uses: actions/cache@v1
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index
      - name: Cache cargo build
        uses: actions/cache@v1
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target
      - name: Install stable
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
      - name: Check code format
        run: cargo fmt -- --check
      - name: Check the package for errors
        run: cargo check --all
      - name: Lint rust sources
        run: cargo clippy --all-targets --all-features --tests --benches -- -D warnings
      - name: Run tests
        run: cargo test --all-features -- --test-threads=1 --nocapture
      - name: Generate docs
        run: cargo doc --all-features --no-deps
      - name: Deploy docs to gh-page
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./target/doc
</code></pre>
<p>除此之外，我们还可以在每次 push tag 时做 release：</p>
<pre><code class="language-yaml">
name: release

on:
  push:
    tags:
      - &quot;v*&quot; # Push events to matching v*, i.e. v1.0, v20.15.10

jobs:
  build:
    name: Upload Release Asset
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
    steps:
      - name: Cache cargo registry
        uses: actions/cache@v1
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry
      - name: Cache cargo index
        uses: actions/cache@v1
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index
      - name: Cache cargo build
        uses: actions/cache@v1
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          token: ${{ secrets.GH_TOKEN }}
          submodules: recursive
      - name: Build project
        run: |
          make build-release
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false
      - name: Upload asset
        id: upload-kv-asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./target/release/kvs
          asset_name: kvs
          asset_content_type: application/octet-stream
      - name: Set env
        run: echo &quot;RELEASE_VERSION=${GITHUB_REF#refs/*/}&quot; &gt;&gt; $GITHUB_ENV
      - name: Deploy docs to gh-page
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./target/doc/simple_kv
          destination_dir: ${{ env.RELEASE_VERSION }}
</code></pre>
<p>这样，每次 push tag 时，都可以打包出来 Linux 的 kvs 版本：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/1c61b7f58dd176bd25a565577d75af19.png" alt="img" /></p>
<p>如果你不希望直接使用编译出来的二进制，也可以打包成 docker，在 Kubernetes 下使用。</p>
</div>
</details>
<details id="admonition--在做-ci-的过程中我们也可以触发-cd比如" class="admonition info">
<summary class="admonition-title">
<blockquote>
<p>在做 CI 的过程中，我们也可以触发 CD，比如： </p>
</blockquote>
<p><a class="admonition-anchor-link" href="kv8_config_ci_cd.html#admonition--在做-ci-的过程中我们也可以触发-cd比如"></a></p>
</summary>
<div>
<ul>
<li>
<p>PR merge 到 master，在 build 完成后，触发 dev 服务器的部署，团队内部可以尝试；</p>
</li>
<li>
<p>如果 release tag 包含 alpha，在 build 完成后，触发 staging 服务器的部署，公司内部可以使用；</p>
</li>
<li>
<p>如果 release tag 包含 beta，在 build 完成后，触发 beta 服务器的部署，beta 用户可以使用；</p>
</li>
<li>
<p>正式的 release tag 会触发生产环境的滚动升级，升级覆盖到的用户可以使用。</p>
</li>
</ul>
</div>
</details>
<p>一般来说，每家企业都有自己的 CI/CD 的工具链，这里为了展示方便，我们演示了如何使用 github action 对 Rust 代码做 CI，你可以按照自己的需要来处理。</p>
<p>在刚才的 action 代码中，还编译并上传了文档，所以我们可以通过 github pages 很方便地访问文档：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/885d092273f8cacda1a65867a2489ea7.png" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构建自己的类axum异步web框架"><a class="header" href="#构建自己的类axum异步web框架">构建自己的类axum异步Web框架</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checklist"><a class="header" href="#checklist">Checklist</a></h1>

            </main>

            <!--            <script src="https://utteranc.es/client.js"-->
            <!--                    repo="RustMagazine/rust_magazine_2022"-->
            <!--                    issue-term="title"-->
            <!--                    theme="github-light"-->
            <!--                    crossorigin="anonymous"-->
            <!--                    async></script>-->

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->


                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">

    </nav>

</div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/mermaid/mermaid.min.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid-init.js"></script>
    <script type="text/javascript" src="assets/smart-anchor.js"></script>
    <script type="text/javascript" src="assets/pagetoc/sidebar.js"></script>

        <script type="text/javascript">
            window.addEventListener('load', function () {
                MathJax.Hub.Register.StartupHook('End', function () {
                    window.setTimeout(window.print, 100);
                });
            });
        </script>
</body>
</html>
