<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Anatomy In First Rust Programming Class 🦀</title>
        <meta name="robots" content="noindex"/>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust编程第一课的代码为例进行基础代码分析">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="md-favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/pagetoc/pagetoc_style.css">
        <link rel="stylesheet" href="assets/css/mdbook-admonish.css">

        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="anatomy_logic.html"><strong aria-hidden="true">1.</strong> 源码阅读逻辑</a></li><li class="chapter-item expanded "><a href="intro_gdb_lldb.html"><strong aria-hidden="true">2.</strong> gdb/lldb调试或查看内存结构</a></li><li class="chapter-item expanded "><a href="get_hands_dirty.html"><strong aria-hidden="true">3.</strong> get hands dirty</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="httpie.html"><strong aria-hidden="true">3.1.</strong> httpie</a></li><li class="chapter-item expanded "><a href="rgrep.html"><strong aria-hidden="true">3.2.</strong> rgrep</a></li><li class="chapter-item expanded "><a href="thumbor.html"><strong aria-hidden="true">3.3.</strong> thumbor</a></li><li class="chapter-item expanded "><a href="queryer.html"><strong aria-hidden="true">3.4.</strong> queryer</a></li></ol></li><li class="chapter-item expanded "><a href="rust_cores.html"><strong aria-hidden="true">4.</strong> Rust核心深入</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_stack_heap_ownership_lifetime_memory.html"><strong aria-hidden="true">4.1.</strong> I. 从栈堆、所有权、生命周期开始内存管理</a></li><li class="chapter-item expanded "><a href="2_type_system.html"><strong aria-hidden="true">4.2.</strong> II. 类型系统</a></li><li class="chapter-item expanded "><a href="3_data_structure.html"><strong aria-hidden="true">4.3.</strong> III. 数据结构</a></li><li class="chapter-item expanded "><a href="4_macros.html"><strong aria-hidden="true">4.4.</strong> IV. 宏编程</a></li><li class="chapter-item expanded "><a href="5_concurrency_async.html"><strong aria-hidden="true">4.5.</strong> V. 并发与异步</a></li><li class="chapter-item expanded "><a href="6_unsafe_ffi.html"><strong aria-hidden="true">4.6.</strong> VI. 混合编程</a></li></ol></li><li class="chapter-item expanded "><a href="kv_server_design.html"><strong aria-hidden="true">5.</strong> kv server设计与实现</a></li><li class="chapter-item expanded "><a href="custom_axum_async_web_framework.html"><strong aria-hidden="true">6.</strong> 构建自己的类axum异步Web框架</a></li><li class="chapter-item expanded affix "><a href="checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Anatomy In First Rust Programming Class 🦀</h1>
            <h4 class="menu-bar"><a href="https://kuanhsiaokuo.github.io/think-tool-kit/">保持批判，有所取舍，知行合一, 方见真我</a> -- 练武不练功
                到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/geektime-tyr-rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="源码解析逻辑"><a class="header" href="#源码解析逻辑">源码解析逻辑</a></h1>
<!--ts-->
<ul>
<li><a href="anatomy_logic.html#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E9%80%BB%E8%BE%91">源码解析逻辑</a>
<ul>
<li><a href="anatomy_logic.html#%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3">项目文档</a>
<ul>
<li><a href="anatomy_logic.html#%E6%9D%A5%E6%BA%90">来源</a></li>
<li><a href="anatomy_logic.html#cargo-doc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8">cargo doc命令使用</a>
<ul>
<li><a href="anatomy_logic.html#--open">–open</a></li>
<li><a href="anatomy_logic.html#--no-deps">–no-deps</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB">使用区别</a></li>
<li><a href="anatomy_logic.html#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82">使用细节</a>
<ul>
<li><a href="anatomy_logic.html#crates">Crates</a></li>
<li><a href="anatomy_logic.html#crate%E5%8C%85%E5%90%AB%E6%88%90%E5%91%98">crate包含成员</a></li>
<li><a href="anatomy_logic.html#re-exports">Re-exports</a></li>
<li><a href="anatomy_logic.html#modules">Modules</a></li>
<li><a href="anatomy_logic.html#macros">Macros</a></li>
<li><a href="anatomy_logic.html#derive-macros">Derive Macros</a></li>
<li><a href="anatomy_logic.html#attribute-macros">Attribute Macros</a></li>
<li><a href="anatomy_logic.html#structs">Structs</a>
<ul>
<li><a href="anatomy_logic.html#definition">Definition</a></li>
<li><a href="anatomy_logic.html#associated-types">Associated Types</a></li>
<li><a href="anatomy_logic.html#implementations">Implementations</a></li>
<li><a href="anatomy_logic.html#trait-implementations">Trait Implementations</a></li>
<li><a href="anatomy_logic.html#auto-trait-implementations">Auto Trait Implementations</a></li>
<li><a href="anatomy_logic.html#blanket-implementations">Blanket Implementations</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#enums">Enums</a>
<ul>
<li><a href="anatomy_logic.html#definition-1">Definition</a></li>
<li><a href="anatomy_logic.html#variants">Variants</a></li>
<li><a href="anatomy_logic.html#trait-implementations-1">Trait Implementations</a></li>
<li><a href="anatomy_logic.html#auto-trait-implementations-1">Auto Trait Implementations</a></li>
<li><a href="anatomy_logic.html#blanket-implementations-1">Blanket Implementations</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#constants">Constants</a></li>
<li><a href="anatomy_logic.html#traits">Traits</a>
<ul>
<li><a href="anatomy_logic.html#definition-2">Definition</a></li>
<li><a href="anatomy_logic.html#required-methods">Required methods</a></li>
<li><a href="anatomy_logic.html#implementations-on-foreign-types">Implementations on Foreign Types</a></li>
<li><a href="anatomy_logic.html#implementors">Implementors</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#functions">Functions</a>
<ul>
<li><a href="anatomy_logic.html#definition-3">Definition</a></li>
</ul>
</li>
<li><a href="anatomy_logic.html#type-definitions">Type Definitions</a>
<ul>
<li><a href="anatomy_logic.html#definition-4">Definition</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Oct  4 07:24:33 UTC 2022 -->
<!--te-->
<h2 id="项目文档"><a class="header" href="#项目文档">项目文档</a></h2>
<h3 id="来源"><a class="header" href="#来源">来源</a></h3>
<ol>
<li>第三方crate可以在<a href="https://docs.rs/">官方文档</a>上面搜索</li>
<li>本地crate可以使用命令<code>cargo doc --open</code>.</li>
</ol>
<h3 id="cargo-doc命令使用"><a class="header" href="#cargo-doc命令使用">cargo doc命令使用</a></h3>
<blockquote>
<p><a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html">更多内容</a></p>
</blockquote>
<h4 id="open"><a class="header" href="#open">–open</a></h4>
<p>自动生成文档并在浏览器打开</p>
<h4 id="no-deps"><a class="header" href="#no-deps">–no-deps</a></h4>
<p>默认情况下会把项目依赖的包文档也生成，这也是文档左侧Crates的来源之一。
这个参数可以屏蔽掉依赖的crates</p>
<h3 id="使用区别"><a class="header" href="#使用区别">使用区别</a></h3>
<ol>
<li>二者内容没有区别，官方文档也是执行命令生成文档。</li>
<li>官方文档还可以提供很多细节，比如git分支地址</li>
</ol>
<h3 id="使用细节"><a class="header" href="#使用细节">使用细节</a></h3>
<blockquote>
<p>这里按照文档的层级进行递进说明</p>
</blockquote>
<h4 id="crates"><a class="header" href="#crates">Crates</a></h4>
<p>所有文档的首页都会有这一项，列出项目包含的crate</p>
<h4 id="crate包含成员"><a class="header" href="#crate包含成员">crate包含成员</a></h4>
<blockquote>
<p>点击Crates下的某个crate，右侧页面就会显示当前crate包含的元素， 主要有下列内容</p>
</blockquote>
<ul>
<li>Re-exports</li>
<li>Modules</li>
<li>Macros</li>
<li>Derive Macros</li>
<li>Attribute Macros</li>
<li>Structs</li>
<li>Enums</li>
<li>Constants</li>
<li>Traits</li>
<li>Functions</li>
<li>Type Definitions</li>
</ul>
<h4 id="re-exports"><a class="header" href="#re-exports">Re-exports</a></h4>
<blockquote>
<p>futures_util</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use reader::DecompressorCustomIo;
<span class="boring">}
</span></code></pre></pre>
<h4 id="modules"><a class="header" href="#modules">Modules</a></h4>
<p>其实就是mod，点击之后将会列出某个mod里面的成员</p>
<h4 id="macros"><a class="header" href="#macros">Macros</a></h4>
<h4 id="derive-macros"><a class="header" href="#derive-macros">Derive Macros</a></h4>
<blockquote>
<p>darling_macro、clap_derive</p>
</blockquote>
<h4 id="attribute-macros"><a class="header" href="#attribute-macros">Attribute Macros</a></h4>
<blockquote>
<p>tokio_macros、futures_macro</p>
</blockquote>
<h4 id="structs"><a class="header" href="#structs">Structs</a></h4>
<h5 id="definition"><a class="header" href="#definition">Definition</a></h5>
<h5 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h5>
<h5 id="implementations"><a class="header" href="#implementations">Implementations</a></h5>
<h5 id="trait-implementations"><a class="header" href="#trait-implementations">Trait Implementations</a></h5>
<h5 id="auto-trait-implementations"><a class="header" href="#auto-trait-implementations">Auto Trait Implementations</a></h5>
<h5 id="blanket-implementations"><a class="header" href="#blanket-implementations">Blanket Implementations</a></h5>
<h4 id="enums"><a class="header" href="#enums">Enums</a></h4>
<h5 id="definition-1"><a class="header" href="#definition-1">Definition</a></h5>
<h5 id="variants"><a class="header" href="#variants">Variants</a></h5>
<h5 id="trait-implementations-1"><a class="header" href="#trait-implementations-1">Trait Implementations</a></h5>
<h5 id="auto-trait-implementations-1"><a class="header" href="#auto-trait-implementations-1">Auto Trait Implementations</a></h5>
<h5 id="blanket-implementations-1"><a class="header" href="#blanket-implementations-1">Blanket Implementations</a></h5>
<h4 id="constants"><a class="header" href="#constants">Constants</a></h4>
<h4 id="traits"><a class="header" href="#traits">Traits</a></h4>
<h5 id="definition-2"><a class="header" href="#definition-2">Definition</a></h5>
<h5 id="required-methods"><a class="header" href="#required-methods">Required methods</a></h5>
<h5 id="implementations-on-foreign-types"><a class="header" href="#implementations-on-foreign-types">Implementations on Foreign Types</a></h5>
<h5 id="implementors"><a class="header" href="#implementors">Implementors</a></h5>
<h4 id="functions"><a class="header" href="#functions">Functions</a></h4>
<h5 id="definition-3"><a class="header" href="#definition-3">Definition</a></h5>
<h4 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h4>
<h5 id="definition-4"><a class="header" href="#definition-4">Definition</a></h5>
<blockquote>
<p>html2md</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type BoxedError = Box&lt;dyn Error + Send + Sync&gt;;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gdblldb调试或查看内存结构"><a class="header" href="#gdblldb调试或查看内存结构">gdb/lldb调试或查看内存结构</a></h1>
<!--ts-->
<ul>
<li><a href="intro_gdb_lldb.html#gdblldb%E8%B0%83%E8%AF%95%E6%88%96%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">gdb/lldb调试或查看内存结构</a>
<ul>
<li><a href="intro_gdb_lldb.html#%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86">资料整理</a>
<ul>
<li><a href="intro_gdb_lldb.html#%E5%AE%98%E6%96%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84cheat-sheet">官方数据结构cheat sheet</a></li>
</ul>
</li>
<li><a href="intro_gdb_lldb.html#%E6%9F%A5%E7%9C%8Bhashmap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">查看hashmap内存结构</a>
<ul>
<li><a href="intro_gdb_lldb.html#bin%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%BF%90%E8%A1%8C">bin配置与运行</a></li>
<li><a href="intro_gdb_lldb.html#%E7%9B%AE%E6%A0%87%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81">目标调试代码</a></li>
<li><a href="intro_gdb_lldb.html#%E4%BD%BF%E7%94%A8gdblldb%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">使用gdb/lldb进行调试查看内存结构</a>
<ul>
<li><a href="intro_gdb_lldb.html#gdb-%E4%B8%BB%E8%A6%81%E6%98%AFlinux%E7%B3%BB%E7%BB%9F">gdb: 主要是linux系统</a></li>
<li><a href="intro_gdb_lldb.html#lldb-%E4%B8%BB%E8%A6%81osx%E7%B3%BB%E7%BB%9F">lldb: 主要OSX系统</a></li>
<li><a href="intro_gdb_lldb.html#idea">IDEA</a></li>
<li><a href="intro_gdb_lldb.html#gdb%E4%B8%8Elldb%E5%91%BD%E4%BB%A4%E5%AF%B9%E7%85%A7">gdb与lldb命令对照</a></li>
<li><a href="intro_gdb_lldb.html#%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95">开始调试</a></li>
<li><a href="intro_gdb_lldb.html#breakpoint-%E6%B7%BB%E5%8A%A0%E6%96%AD%E7%82%B9">b(reakpoint): 添加断点</a></li>
<li><a href="intro_gdb_lldb.html#run%E8%BF%90%E8%A1%8C%E5%88%B0%E6%96%AD%E7%82%B9">r(un):运行到断点</a></li>
<li><a href="intro_gdb_lldb.html#continue%E7%BB%A7%E7%BB%AD%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C">c(ontinue):继续单步执行</a></li>
<li><a href="intro_gdb_lldb.html#x-%E6%89%93%E5%8D%B0%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80">x: 打印内存地址</a></li>
<li><a href="intro_gdb_lldb.html#continue-%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%E5%88%B0%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%96%AD%E7%82%B9">c(ontinue): 继续执行到下一个断点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="intro_gdb_lldb.html#%E6%9F%A5%E7%9C%8B%E9%97%AD%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84">查看闭包的结构</a>
<ul>
<li><a href="intro_gdb_lldb.html#%E4%BB%A3%E7%A0%81">代码</a></li>
<li><a href="intro_gdb_lldb.html#%E8%BF%90%E8%A1%8C%E8%BF%9B%E5%85%A5lldb">运行进入lldb</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Oct  4 07:24:34 UTC 2022 -->
<!--te-->
<h2 id="资料整理"><a class="header" href="#资料整理">资料整理</a></h2>
<h3 id="官方数据结构cheat-sheet"><a class="header" href="#官方数据结构cheat-sheet">官方数据结构cheat sheet</a></h3>
<ul>
<li><a href="https://cheats.rs/#data-layout">Rust Language Cheat Sheet</a></li>
</ul>
<h2 id="查看hashmap内存结构"><a class="header" href="#查看hashmap内存结构">查看hashmap内存结构</a></h2>
<h3 id="bin配置与运行"><a class="header" href="#bin配置与运行">bin配置与运行</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html?highlight=bin#binaries">Cargo Targets - The Cargo Book</a></li>
</ul>
<pre><code class="language-toml">[package]
name = &quot;hashtable&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[[bin]]
name = &quot;hashmap1&quot;
path = &quot;src/hashmap1.rs&quot;

[[bin]]
name = &quot;hashmap2&quot;
path = &quot;src/hashmap2.rs&quot;

[[bin]]
name = &quot;hash&quot;
path = &quot;src/hash.rs&quot;

[[bin]]
name = &quot;siphasher&quot;
path = &quot;src/siphasher.rs&quot;
doc = false

[[bin]]
name = &quot;hashmap3&quot;
path = &quot;src/hashmap3.rs&quot;

[[bin]]
name = &quot;btreemap1&quot;
path = &quot;src/btreemap1.rs&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<blockquote>
<p>如果要单独运行指定bin文件：</p>
</blockquote>
<pre><code class="language-shell">cargo run --bin hashmap2
</code></pre>
<h3 id="目标调试代码"><a class="header" href="#目标调试代码">目标调试代码</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use std::collections::HashMap;

fn main() {
    let map = HashMap::new();
    let mut map = explain(&quot;empty&quot;, map);

    map.insert('a', 1);
    let mut map = explain(&quot;added 1&quot;, map);
    map.insert('b', 2);
    map.insert('c', 3);

    let mut map = explain(&quot;added 3&quot;, map);

    map.insert('d', 4);

    let mut map = explain(&quot;added 4&quot;, map);

    map.remove(&amp;'a');

    explain(&quot;final&quot;, map);
}

// HashMap 结构有两个 u64 的 RandomState，然后是四个 usize，
// 分别是 bucket_mask, ctrl, growth_left 和 items
// 我们 transmute 打印之后，再 transmute 回去
fn explain&lt;K, V&gt;(name: &amp;str, map: HashMap&lt;K, V&gt;) -&gt; HashMap&lt;K, V&gt; {
    let arr: [usize; 6] = unsafe { std::mem::transmute(map) };
    println!(
        &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
        name, arr[2], arr[3], arr[4], arr[5]
    );
    unsafe { std::mem::transmute(arr) }
}
</code></pre></pre>
<h3 id="使用gdblldb进行调试查看内存结构"><a class="header" href="#使用gdblldb进行调试查看内存结构">使用gdb/lldb进行调试查看内存结构</a></h3>
<h4 id="gdb-主要是linux系统"><a class="header" href="#gdb-主要是linux系统">gdb: 主要是linux系统</a></h4>
<h4 id="lldb-主要osx系统"><a class="header" href="#lldb-主要osx系统">lldb: 主要OSX系统</a></h4>
<h4 id="idea"><a class="header" href="#idea">IDEA</a></h4>
<blockquote>
<p>自带的调试界面同时包含lldb更好的界面功能。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/CleanShot%202022-09-18%20at%2021.24.12%402x.png" alt="CleanShot 2022-09-18 at 21.24.12@2x" /></p>
<h4 id="gdb与lldb命令对照"><a class="header" href="#gdb与lldb命令对照">gdb与lldb命令对照</a></h4>
<ul>
<li><a href="https://lldb.llvm.org/use/map.html">GDB to LLDB command map — The LLDB Debugger</a></li>
</ul>
<h4 id="开始调试"><a class="header" href="#开始调试">开始调试</a></h4>
<pre><code class="language-shell">rust-lldb target/debug/hashmap2                                                                                                                  ─╯
(lldb) command script import &quot;/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_lookup.py&quot;
(lldb) command source -s 0 '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'
Executing commands in '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'.
(lldb) type synthetic add -l lldb_lookup.synthetic_lookup -x &quot;.*&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)String$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?str$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?\\[.+\\]$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::ffi::([a-z_]+::)+)OsString$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Vec&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)VecDeque&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Rc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Arc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Cell&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Ref&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefMut&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefCell&lt;.+&gt;$&quot; --category Rust
(lldb) type category enable Rust
(lldb) target create &quot;target/debug/hashmap2&quot;
Current executable set to '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/hashmap2' (x86_64).
(lldb)
</code></pre>
<h4 id="breakpoint-添加断点"><a class="header" href="#breakpoint-添加断点">b(reakpoint): 添加断点</a></h4>
<blockquote>
<p>在32行打断点，方便看std::mem::transmute(arr)</p>
</blockquote>
<pre><code class="language-shell">(lldb) b hashmap2.rs:32
Breakpoint 1: where = hashmap2`hashmap2::explain::h4091c852f38a0de4 + 406 at hashmap2.rs:32:34, address = 0x0000000100008d16
</code></pre>
<h4 id="run运行到断点"><a class="header" href="#run运行到断点">r(un):运行到断点</a></h4>
<pre><code class="language-shell">(lldb) r
Process 69337 launched: '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/hashmap2' (x86_64)
empty: bucket_mask 0x0, ctrl 0x100043d20, growth_left: 0, items: 0
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;empty&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 最初的状态，哈希表为空
empty: bucket_mask 0x0, ctrl 0x100043d20, growth_left: 0, items: 0
</code></pre>
<h4 id="continue继续单步执行"><a class="header" href="#continue继续单步执行">c(ontinue):继续单步执行</a></h4>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
added 1: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 2, items: 1
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;added 1&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 插入了一个元素后，bucket 有 4 个（0x3+1），堆地址起始位置 0x600001700160 - 4*8(0x20)
added 1: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 2, items: 1
</code></pre>
<h4 id="x-打印内存地址"><a class="header" href="#x-打印内存地址">x: 打印内存地址</a></h4>
<ul>
<li><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/examine-memory.html">打印内存的值 | 100个gdb小技巧</a></li>
</ul>
<pre><code class="language-shell"># 以12进制打印从内存地址开始的值
(lldb) x/12x 0x600001700160
0x600001700160: 0xffff6dff 0xffffffff 0xffffffff 0xffffffff
0x600001700170: 0xffff6dff 0x00000000 0x00000000 0x00000000
0x600001700180: 0x20ec913f 0x00007ff8 0x4e5ef01e 0x00000000
</code></pre>
<h4 id="continue-继续执行到下一个断点"><a class="header" href="#continue-继续执行到下一个断点">c(ontinue): 继续执行到下一个断点</a></h4>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
added 3: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 0, items: 3
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;added 3&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># # 插入了三个元素后，哈希表没有剩余空间，堆地址起始位置不变 0x600001700160 - 4*8(0x20)
added 3: bucket_mask 0x3, ctrl 0x600001700160, growth_left: 0, items: 3
</code></pre>
<pre><code class="language-shell">(lldb) x/12x 0x600001700160
0x600001700160: 0x16ff6d66 0xffffffff 0xffffffff 0xffffffff
0x600001700170: 0x16ff6d66 0x00000000 0x00000000 0x00000000
0x600001700180: 0x20ec913f 0x00007ff8 0x4e5ef01e 0x00000000
</code></pre>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
added 4: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 3, items: 4
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;added 4&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 插入第四个元素后，哈希表扩容，堆地址起始位置变为 0x600002604040 - 8*8(0x40)
added 4: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 3, items: 4
</code></pre>
<pre><code class="language-shell">(lldb) x/12x 0x600002604040
0x600002604040: 0x16446d66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x16446d66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
(lldb) x/20x 0x600002604040
0x600002604040: 0x16446d66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x16446d66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604070: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604080: 0x00000000 0x00000000 0x00000000 0x00000000
</code></pre>
<pre><code class="language-shell">(lldb) c
Process 69337 resuming
final: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 4, items: 3
Process 69337 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100008d16 hashmap2`hashmap2::explain::h4091c852f38a0de4(name=&quot;final&quot;, map=&lt;unavailable&gt;) at hashmap2.rs:32:34
   29           &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,
   30           name, arr[2], arr[3], arr[4], arr[5]
   31       );
-&gt; 32       unsafe { std::mem::transmute(arr) }
   33   }
Target 0: (hashmap2) stopped.
</code></pre>
<pre><code class="language-shell"># 删除 a 后，剩余 4 个位置。注意 ctrl bit 的变化，以及 0x61 0x1 并没有被清除
final: bucket_mask 0x7, ctrl 0x600002604040, growth_left: 4, items: 3
</code></pre>
<pre><code class="language-shell">(lldb) x/12x 0x600002604040
0x600002604040: 0x1644ff66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x1644ff66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
(lldb) x/20x 0x600002604040
0x600002604040: 0x1644ff66 0xffffffff 0xffffffff 0xffffffff
0x600002604050: 0x1644ff66 0xffffffff 0x00000000 0x00000000
0x600002604060: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604070: 0x00000000 0x00000000 0x00000000 0x00000000
0x600002604080: 0x00000000 0x00000000 0x00000000 0x00000000
</code></pre>
<h2 id="查看闭包的结构"><a class="header" href="#查看闭包的结构">查看闭包的结构</a></h2>
<h3 id="代码"><a class="header" href="#代码">代码</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use std::{collections::HashMap, mem::size_of_val};
fn main() {
    // 长度为 0
    let c1 = || println!(&quot;hello world!&quot;);
    // 和参数无关，长度也为 0
    let c2 = |i: i32| println!(&quot;hello: {}&quot;, i);
    let name = String::from(&quot;tyr&quot;);
    let name1 = name.clone();
    let mut table = HashMap::new();
    table.insert(&quot;hello&quot;, &quot;world&quot;);
    // 如果捕获一个引用，长度为 8
    let c3 = || println!(&quot;hello: {}&quot;, name);
    // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
    let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
    let name2 = name.clone();
    // 和局部变量无关，捕获了一个 String name2，closure 长度 24
    let c5 = move || {
        let x = 1;
        let name3 = String::from(&quot;lindsey&quot;);
        println!(&quot;hello: {}, {:?}, {:?}&quot;, x, name2, name3);
    };

    println!(
        &quot;c1: {}, c2: {}, c3: {}, c4: {}, c5: {}, main: {}&quot;,
        size_of_val(&amp;c1),
        size_of_val(&amp;c2),
        size_of_val(&amp;c3),
        size_of_val(&amp;c4),
        size_of_val(&amp;c5),
        size_of_val(&amp;main),
    )
}
</code></pre></pre>
<h3 id="运行进入lldb"><a class="header" href="#运行进入lldb">运行进入lldb</a></h3>
<pre><code class="language-shell"># 自动去examples目录找对应名字的代码文件
cargo run --example closure_size
</code></pre>
<pre><code class="language-shell">rust-lldb ../target/debug/examples/closure_size                                                                                                  ─╯
(lldb) command script import &quot;/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_lookup.py&quot;
(lldb) command source -s 0 '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'
Executing commands in '/Users/kuanhsiaokuo/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/etc/lldb_commands'.
(lldb) type synthetic add -l lldb_lookup.synthetic_lookup -x &quot;.*&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)String$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?str$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^&amp;(mut )?\\[.+\\]$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::ffi::([a-z_]+::)+)OsString$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Vec&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)VecDeque&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)BTreeMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashMap&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(std::collections::([a-z_]+::)+)HashSet&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Rc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(alloc::([a-z_]+::)+)Arc&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Cell&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)Ref&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefMut&lt;.+&gt;$&quot; --category Rust
(lldb) type summary add -F lldb_lookup.summary_lookup  -e -x -h &quot;^(core::([a-z_]+::)+)RefCell&lt;.+&gt;$&quot; --category Rust
(lldb) type category enable Rust
(lldb) target create &quot;../target/debug/examples/closure_size&quot;
Current executable set to '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/closure_size' (x86_64).
(lldb)
</code></pre>
<pre><code class="language-shell">(lldb) b closure_size.rs:14
Breakpoint 1: where = closure_size`closure_size::main::h679d75437a0cd078 + 199 at closure_size.rs:14:14, address = 0x00000001000056b7
</code></pre>
<pre><code class="language-shell">(lldb) r
Process 95084 launched: '/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/closure_size' (x86_64)
Process 95084 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x00000001000056b7 closure_size`closure_size::main::h679d75437a0cd078 at closure_size.rs:14:14
   11       // 如果捕获一个引用，长度为 8
   12       let c3 = || println!(&quot;hello: {}&quot;, name);
   13       // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
-&gt; 14       let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
   15       let name2 = name.clone();
   16       // 和局部变量无关，捕获了一个 String name2，closure 长度 24
   17       let c5 = move || {
Target 0: (closure_size) stopped.
</code></pre>
<pre><code class="language-shell">(lldb) frame variable
(closure_size::main::{closure_env#0}) c1 =
(closure_size::main::{closure_env#1}) c2 =
(alloc::string::String) name = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(alloc::string::String) name1 = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(std::collections::hash::map::HashMap&lt;&amp;str, &amp;str, std::collections::hash::map::RandomState&gt;) table = size=1 {
  [0] = {
    0 = &quot;hello&quot; {
      data_ptr = 0x0000000100043daf &quot;helloworld, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
    1 = &quot;world&quot; {
      data_ptr = 0x0000000100043db4 &quot;world, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
  }
}
(lldb) fr v
(closure_size::main::{closure_env#0}) c1 =
(closure_size::main::{closure_env#1}) c2 =
(alloc::string::String) name = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(alloc::string::String) name1 = &quot;tyr&quot; {
  vec = size=3 {
    [0] = 't'
    [1] = 'y'
    [2] = 'r'
  }
}
(std::collections::hash::map::HashMap&lt;&amp;str, &amp;str, std::collections::hash::map::RandomState&gt;) table = size=1 {
  [0] = {
    0 = &quot;hello&quot; {
      data_ptr = 0x0000000100043daf &quot;helloworld, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
    1 = &quot;world&quot; {
      data_ptr = 0x0000000100043db4 &quot;world, c2: , c3: , c4: , c5: \n&quot;
      length = 5
    }
  }
}
</code></pre>
<pre><code class="language-shell">(lldb) x/gx c1
error: memory read failed for 0x0
(lldb) x/gx &amp;c1
0x7ff7bfefed20: 0x0000000100266000
(lldb) x/gx &amp;c2
0x7ff7bfefed28: 0x00006000017041c0
(lldb) x/gx &amp;c3
0x7ff7bfefed90: 0x00007ff7bfefed30
(lldb) x/gx 0x00007ff7bfefed30
0x7ff7bfefed30: 0x0000600000008010
(lldb) x/3c  0x0000600000008010
error: reading memory as characters of size 8 is not supported
(lldb) x/gx  0x0000600000008010
0x600000008010: 0x0000000000727974
</code></pre>
<ul>
<li>g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</li>
<li>可以看出：c1是</li>
</ul>
<pre><code class="language-shell">(lldb) n
Process 95084 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
    frame #0: 0x0000000100005744 closure_size`closure_size::main::h679d75437a0cd078 at closure_size.rs:15:17
   12       let c3 = || println!(&quot;hello: {}&quot;, name);
   13       // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
   14       let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
-&gt; 15       let name2 = name.clone();
   16       // 和局部变量无关，捕获了一个 String name2，closure 长度 24
   17       let c5 = move || {
   18           let x = 1;
Target 0: (closure_size) stopped.
(lldb) x/9gx c4
error: memory read failed for 0x0
(lldb) x/9gx &amp;c4
0x7ff7bfefed98: 0x0000600000008020 0x0000000000000003
0x7ff7bfefeda8: 0x0000000000000003 0x3e49f3270a1a0fb0
0x7ff7bfefedb8: 0x79dd9a78e6c327e7 0x0000000000000003
0x7ff7bfefedc8: 0x0000600003304080 0x0000000000000002
0x7ff7bfefedd8: 0x0000000000000001
(lldb) x/3c 0x0000600000008020
error: reading memory as characters of size 8 is not supported
(lldb) x/gx 0x0000600000008020
0x600000008020: 0x0000000000727974
(lldb) x/18gx 0x0000600000008020 - 0x80
error: memory read takes a start address expression with an optional end address expression.
warning: Expressions should be quoted if they contain spaces or other special characters.
(lldb) x/18gx '0x0000600000008020 - 0x80'
0x600000007fa0: 0x0000000000000000 0x0000000000000000
0x600000007fb0: 0x0000000000000000 0x0000000000000000
0x600000007fc0: 0x0000000000000000 0x0000000000000000
0x600000007fd0: 0x0000000000000000 0x0000000000000000
0x600000007fe0: 0x0000000000000000 0x0000000000000000
0x600000007ff0: 0x0000000000000000 0x0000000000000000
0x600000008000: 0x000000006e69616d 0x0000000000000000
0x600000008010: 0x0000000000727974 0x0000000000000000
0x600000008020: 0x0000000000727974 0x0000000000000000
</code></pre>
<ul>
<li>0x: C语言里的0x0和0x1分别表示十六进制的数的0和1。</li>
</ul>
<p>C语言、C++、Shell、Python、Java语言及其他相近的语言使用字首“0x”，例如“0x5A3”。开头的“0”令解析器更易辨认数，而“x”则代表十六进制（就如“O”代表八进制）。在“0x”中的“x”可以大写或小写。对于字符量C语言中则以x+两位十六进制数的方式表示，如xFF。</p>
<p>因此，0x0中“0x”表示的是十六进制数，0是十六进制数值0，0x,1中“0x”表示的是十六进制数，1是十六进制数值1</p>
<ul>
<li>C语言中的相关数值表示法：</li>
</ul>
<p>1、在C语言里，整数有三种表示形式：十进制，八进制，十六进制。其中以数字0开头，由0~7组成的数是八进制。以0X或0x开头，由0~9，A~F或a~f 组成是十六进制。除表示正负的符号外，以1~9开头，由0~9组成是十进制。</p>
<p>2、十进制：除表示正负的符号外，以1~9开头，由0~9组成。如，128，+234，-278。</p>
<p>3、八进制：以0开头，由0~7组成的数。如，0126,050000.</p>
<p>4、十六进制：以0X或0x开头，由0~9，A~F或a~f 组成。如，0x12A,0x5a000。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-hands-dirty"><a class="header" href="#get-hands-dirty">get hands dirty</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="httpie源码剖析"><a class="header" href="#httpie源码剖析">httpie源码剖析</a></h1>
<!--ts-->
<ul>
<li><a href="httpie.html#httpie%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90">httpie源码剖析</a>
<ul>
<li><a href="httpie.html#example%E7%9A%84%E4%BD%BF%E7%94%A8">example的使用</a>
<ul>
<li><a href="httpie.html#cargotoml">Cargo.toml</a></li>
</ul>
</li>
<li><a href="httpie.html#step1%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90">Step1：指令解析</a>
<ul>
<li><a href="httpie.html#clapparser">clap::Parser</a></li>
</ul>
</li>
<li><a href="httpie.html#step2%E6%B7%BB%E5%8A%A0%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E4%B8%8E%E9%94%AE%E5%80%BC%E5%AF%B9%E6%94%B9%E9%80%A0">Step2：添加参数验证与键值对改造</a>
<ul>
<li><a href="httpie.html#%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81">参数验证</a></li>
<li><a href="httpie.html#%E9%94%AE%E5%80%BC%E5%AF%B9%E6%94%B9%E9%80%A0">键值对改造</a></li>
</ul>
</li>
<li><a href="httpie.html#step3%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%94%B9%E9%80%A0">Step3：异步请求改造</a></li>
<li><a href="httpie.html#step4-%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E6%89%93%E5%8D%B0">Step4: 语法高亮打印</a></li>
<li><a href="httpie.html#step5-%E6%B7%BB%E5%8A%A0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">Step5: 添加单元测试</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Oct  4 07:24:33 UTC 2022 -->
<!--te-->
<h2 id="example的使用"><a class="header" href="#example的使用">example的使用</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html?highlight=%5B%5Bexample%5D%5D#examples">Cargo Targets &gt;&gt; Examples - The Cargo Book</a></li>
</ul>
<h3 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h3>
<pre><code class="language-toml">[package]
name = &quot;httpie&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[[example]]
name = &quot;cli&quot;

[[example]]
name = &quot;cli_verify&quot;

[[example]]
name = &quot;cli_get&quot;

[dependencies]
anyhow = &quot;1&quot; # 错误处理
clap = { version = &quot;3&quot;, features = [&quot;derive&quot;] } # 命令行解析
colored = &quot;2&quot; # 命令终端多彩显示
jsonxf = &quot;1.1&quot; # JSON pretty print 格式化
mime = &quot;0.3&quot; # 处理 mime 类型
# reqwest 默认使用 openssl，有些 linux 用户如果没有安装好 openssl 会无法编译，这里我改成了使用 rustls
reqwest = { version = &quot;0.11&quot;, default-features = false, features = [&quot;json&quot;, &quot;rustls-tls&quot;] } # HTTP 客户端
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] } # 异步处理库
syntect = &quot;4&quot;
</code></pre>
<pre><code class="language-toml">[[example]]
name = &quot;cli&quot;

[[example]]
name = &quot;cli_verify&quot;

[[example]]
name = &quot;cli_get&quot;
</code></pre>
<div id="admonition-example使用" class="admonition tip">
<div class="admonition-title">
<p>example使用</p>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-example使用"></a></p>
</div>
<div>
<ol>
<li>示例代码放在根目录的examples文件夹，与src同级</li>
</ol>
<pre><code class="language-shell">tree -L 2                                                                                                       ─╯
.
├── Cargo.toml
├── examples
│   ├── cli.rs
│   ├── cli_get.rs
│   └── cli_verify.rs
└── src
    └── main.rs

2 directories, 5 files
</code></pre>
<ol start="2">
<li>执行指令</li>
</ol>
<pre><code class="language-shell">cargo run --example &lt;example-name-in-cargo&gt;
cargo run --example cli
cargo run --example cli_get
cargo run --example cli_verify
</code></pre>
<ol start="3">
<li>使用示例</li>
</ol>
<pre><code class="language-shell">cargo run --example cli                                                                                                                                                                                                                ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli`
httpie 1.0
Tyr Chen &lt;tyr@chen.com&gt;
A naive httpie implementation with Rust, can you imagine how easy it is?

USAGE:
    cli &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    get     feed get with an url and we will retrieve the response for you
    help    Print this message or the help of the given subcommand(s)
    post    feed post with an url and optional key=value pairs. We will post the data as JSON,
                and retrieve the response for you
</code></pre>
<ul>
<li>Run a binary or example of the local package</li>
<li>SUBCOMMANDS来自代码中的注释</li>
</ul>
</div>
</div>
<h2 id="step1指令解析"><a class="header" href="#step1指令解析">Step1：指令解析</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">use clap::Parser;

// 定义 httpie 的 CLI 的主入口，它包含若干个子命令
// 下面 /// 的注释是文档，clap 会将其作为 CLI 的帮助

/// A naive httpie implementation with Rust, can you imagine how easy it is?
#[derive(Parser, Debug)]
#[clap(version = &quot;1.0&quot;, author = &quot;Tyr Chen &lt;tyr@chen.com&gt;&quot;)]
struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

// 子命令分别对应不同的 HTTP 方法，目前只支持 get / post
#[derive(Parser, Debug)]
enum SubCommand {
    Get(Get),
    Post(Post),
    // 我们暂且不支持其它 HTTP 方法
}

// get 子命令

/// feed get with an url and we will retrieve the response for you
#[derive(Parser, Debug)]
struct Get {
    /// HTTP 请求的 URL
    url: String,
}

// post 子命令。需要输入一个 url，和若干个可选的 key=value，用于提供 json body

/// feed post with an url and optional key=value pairs. We will post the data
/// as JSON, and retrieve the response for you
#[derive(Parser, Debug)]
struct Post {
    /// HTTP 请求的 URL
    url: String,
    /// HTTP 请求的 body
    body: Vec&lt;String&gt;,
}

fn main() {
    let opts: Opts = Opts::parse();
    let opt_subcmd: SubCommand = opts.subcmd;
    // println!(&quot;{:?}&quot;, opts);
    println!(&quot;{:?}&quot;, opt_subcmd);
    // println!(&quot;{:?}&quot;, opts.subcmd);
    // 这里就可以看出，结构体的内在元素使用&quot;.&quot;来获取
    // println!(&quot;{:?}&quot;, opts::subcmd);
}
</code></pre></pre>
<h3 id="clapparser"><a class="header" href="#clapparser">clap::Parser</a></h3>
<div id="admonition-clapparser" class="admonition info">
<div class="admonition-title">
<p>clap::Parser</p>
<p><a class="admonition-anchor-link" href="httpie.html#admonition-clapparser"></a></p>
</div>
<div>
<ul>
<li><a href="https://github.com/clap-rs/clap">clap-rs/clap: A full featured, fast Command Line Argument Parser for Rust</a></li>
<li><a href="https://docs.rs/clap/latest/clap/">clap - Rust</a></li>
<li><a href="https://docs.rs/clap/latest/clap/parser/index.html">clap::parser - Rust</a></li>
</ul>
</div>
</div>
<ol>
<li>clap的parser派生宏会自动实现parse方法来接收指令参数</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

// 子命令分别对应不同的 HTTP 方法，目前只支持 get / post
#[derive(Parser, Debug)]
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let opts: Opts = Opts::parse();
    let opt_subcmd: SubCommand = opts.subcmd;
    // println!(&quot;{:?}&quot;, opts);
</code></pre></pre>
<ol start="2">
<li>运行效果</li>
</ol>
<pre><code class="language-shell">cargo run --example cli get http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                                ─╯
   Compiling httpie v0.1.0 (/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/04_httpie)
    Finished dev [unoptimized + debuginfo] target(s) in 2.31s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli get 'http://jsonplaceholder.typicode.com/posts/2'`
Opts { subcmd: Get(Get { url: &quot;http://jsonplaceholder.typicode.com/posts/2&quot; }) }
</code></pre>
<pre><code class="language-shell">cargo run --example cli post http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                               ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli post 'http://jsonplaceholder.typicode.com/posts/2'`
Opts { subcmd: Post(Post { url: &quot;http://jsonplaceholder.typicode.com/posts/2&quot;, body: [] }) }
</code></pre>
<pre><code class="language-shell">cargo run --example cli delete http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                             ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli delete 'http://jsonplaceholder.typicode.com/posts/2'`
error: Found argument 'delete' which wasn't expected, or isn't valid in this context

USAGE:
    cli &lt;SUBCOMMAND&gt;

For more information try --help

</code></pre>
<ul>
<li>opts的获取：自动以空格分隔，根据<subcommand>模式匹配，之后的参数依次赋值给<subcommand> struct里面的元素</li>
</ul>
<h2 id="step2添加参数验证与键值对改造"><a class="header" href="#step2添加参数验证与键值对改造">Step2：添加参数验证与键值对改造</a></h2>
<h3 id="参数验证"><a class="header" href="#参数验证">参数验证</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// feed get with an url and we will retrieve the response for you
#[derive(Parser, Debug)]
struct Get {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
}

// post 子命令。需要输入一个 url，和若干个可选的 key=value，用于提供 json body

/// feed post with an url and optional key=value pairs. We will post the data
/// as JSON, and retrieve the response for you
#[derive(Parser, Debug)]
struct Post {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
    /// HTTP 请求的 body
    #[clap(parse(try_from_str=parse_kv_pair))]
    body: Vec&lt;KvPair&gt;,
}
</code></pre></pre>
<ol>
<li>clap 允许你为每个解析出来的值添加自定义的解析函数，我们这里定义了parse_url和parse_kv_pair检查一下。</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">/// 因为我们为 KvPair 实现了 FromStr，这里可以直接 s.parse() 得到 KvPair
fn parse_kv_pair(s: &amp;str) -&gt; Result&lt;KvPair&gt; {
    s.parse()
}
fn parse_url(s: &amp;str) -&gt; Result&lt;String&gt; {
    // 这里我们仅仅检查一下 URL 是否合法
    let _url: Url = s.parse()?;

    Ok(s.into())
}
</code></pre></pre>
<ol>
<li>clap 允许你为每个解析出来的值添加自定义的解析函数，我们这里定义了个parse_url检查一下。</li>
</ol>
<h3 id="键值对改造"><a class="header" href="#键值对改造">键值对改造</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// 命令行中的 key=value 可以通过 parse_kv_pair 解析成 KvPair 结构
#[allow(dead_code)]
#[derive(Debug)]
struct KvPair {
    k: String,
    v: String,
}

/// 当我们实现 FromStr trait 后，可以用 str.parse() 方法将字符串解析成 KvPair
impl FromStr for KvPair {
    type Err = anyhow::Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        // 使用 = 进行 split，这会得到一个迭代器
        let mut split = s.split('=');
        let err = || anyhow!(format!(&quot;Failed to parse {}&quot;, s));
        Ok(Self {
            // 从迭代器中取第一个结果作为 key，迭代器返回 Some(T)/None
            // 我们将其转换成 Ok(T)/Err(E)，然后用 ? 处理错误
            k: (split.next().ok_or_else(err)?).to_string(),
            // 从迭代器中取第二个结果作为 value
            v: (split.next().ok_or_else(err)?).to_string(),
        })
    }
}
</code></pre></pre>
<h2 id="step3异步请求改造"><a class="header" href="#step3异步请求改造">Step3：异步请求改造</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let opts: Opts = Opts::parse();
    // 生成一个
    let client = Client::new();
    match opts.subcmd {
        SubCommand::Get(ref args) =&gt; get(client, args).await?,
        SubCommand::Post(ref args) =&gt; post(client, args).await?,
    };

    Ok(())
}

async fn get(client: Client, args: &amp;Get) -&gt; Result&lt;()&gt; {
    let resp = client.get(&amp;args.url).send().await?;
    println!(&quot;{:?}&quot;, resp.text().await?);
    Ok(())
}

async fn post(client: Client, args: &amp;Post) -&gt; Result&lt;()&gt; {
    let mut body = HashMap::new();
    for pair in args.body.iter() {
        body.insert(&amp;pair.k, &amp;pair.v);
    }
    let resp = client.post(&amp;args.url).json(&amp;body).send().await?;
    println!(&quot;{:?}&quot;, resp.text().await?);
    Ok(())
}
</code></pre></pre>
<h2 id="step4-语法高亮打印"><a class="header" href="#step4-语法高亮打印">Step4: 语法高亮打印</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">// 打印服务器版本号 + 状态码
fn print_status(resp: &amp;Response) {
    let status = format!(&quot;{:?} {}&quot;, resp.version(), resp.status()).blue();
    println!(&quot;{}\n&quot;, status);
}

// 打印服务器返回的 HTTP header
fn print_headers(resp: &amp;Response) {
    for (name, value) in resp.headers() {
        println!(&quot;{}: {:?}&quot;, name.to_string().green(), value);
    }

    println!();
}

/// 打印服务器返回的 HTTP body
fn print_body(m: Option&lt;Mime&gt;, body: &amp;str) {
    match m {
        // 对于 &quot;application/json&quot; 我们 pretty print
        Some(v) if v == mime::APPLICATION_JSON =&gt; print_syntect(body, &quot;json&quot;),
        Some(v) if v == mime::TEXT_HTML =&gt; print_syntect(body, &quot;html&quot;),

        // 其它 mime type，我们就直接输出
        _ =&gt; println!(&quot;{}&quot;, body),
    }
}

/// 打印整个响应
async fn print_resp(resp: Response) -&gt; Result&lt;()&gt; {
    print_status(&amp;resp);
    print_headers(&amp;resp);
    let mime = get_content_type(&amp;resp);
    let body = resp.text().await?;
    print_body(mime, &amp;body);
    Ok(())
}

/// 将服务器返回的 content-type 解析成 Mime 类型
fn get_content_type(resp: &amp;Response) -&gt; Option&lt;Mime&gt; {
    resp.headers()
        .get(header::CONTENT_TYPE)
        .map(|v| v.to_str().unwrap().parse().unwrap())
}

fn print_syntect(s: &amp;str, ext: &amp;str) {
    // Load these once at the start of your program
    let ps = SyntaxSet::load_defaults_newlines();
    let ts = ThemeSet::load_defaults();
    let syntax = ps.find_syntax_by_extension(ext).unwrap();
    let mut h = HighlightLines::new(syntax, &amp;ts.themes[&quot;base16-ocean.dark&quot;]);
    for line in LinesWithEndings::from(s) {
        let ranges: Vec&lt;(Style, &amp;str)&gt; = h.highlight(line, &amp;ps);
        let escaped = as_24_bit_terminal_escaped(&amp;ranges[..], true);
        print!(&quot;{}&quot;, escaped);
    }
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">/// 程序的入口函数，因为在 http 请求时我们使用了异步处理，所以这里引入 tokio
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let opts: Opts = Opts::parse();
    let mut headers = header::HeaderMap::new();
    // 为我们的 http 客户端添加一些缺省的 HTTP 头
    headers.insert(&quot;X-POWERED-BY&quot;, &quot;Rust&quot;.parse()?);
    headers.insert(header::USER_AGENT, &quot;Rust Httpie&quot;.parse()?);
    let client = Client::builder()
        .default_headers(headers)
        .build()?;
    let result = match opts.subcmd {
        SubCommand::Get(ref args) =&gt; get(client, args).await?,
        SubCommand::Post(ref args) =&gt; post(client, args).await?,
    };

    Ok(result)
}
</code></pre></pre>
<h2 id="step5-添加单元测试"><a class="header" href="#step5-添加单元测试">Step5: 添加单元测试</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">// 仅在 cargo test 时才编译
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_url_works() {
        assert!(parse_url(&quot;abc&quot;).is_err());
        assert!(parse_url(&quot;http://abc.xyz&quot;).is_ok());
        assert!(parse_url(&quot;https://httpbin.org/post&quot;).is_ok());
    }

    #[test]
    fn parse_kv_pair_works() {
        assert!(parse_kv_pair(&quot;a&quot;).is_err());
        assert_eq!(
            parse_kv_pair(&quot;a=1&quot;).unwrap(),
            KvPair {
                k: &quot;a&quot;.into(),
                v: &quot;1&quot;.into(),
            }
        );

        assert_eq!(
            parse_kv_pair(&quot;b=&quot;).unwrap(),
            KvPair {
                k: &quot;b&quot;.into(),
                v: &quot;&quot;.into(),
            }
        );
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rgrep"><a class="header" href="#rgrep">rgrep</a></h1>
<!--ts-->
<ul>
<li><a href="rgrep.html#rgrep">rgrep</a>
<ul>
<li><a href="rgrep.html#cargotoml">Cargo.toml</a></li>
<li><a href="rgrep.html#srcerrorrs-thiserror%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2">src/error.rs: thiserror会自动转换</a></li>
<li><a href="rgrep.html#srclibrs%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">src/lib.rs：定义结构体+实现方法+单元测试</a>
<ul>
<li><a href="rgrep.html#mod%E5%BC%95%E5%85%A5%E4%B8%8E%E4%BD%BF%E7%94%A8">mod引入与使用</a></li>
<li><a href="rgrep.html#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93">定义结构体</a>
<ul>
<li><a href="rgrep.html#%E4%B8%93%E9%97%A8%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B">专门简化复杂类型</a></li>
<li><a href="rgrep.html#%E4%B8%93%E9%97%A8%E7%9A%84%E7%BB%93%E5%90%88%E7%89%88%E6%9C%ACgrep%E7%BB%93%E6%9E%84%E4%BD%93">专门的结合版本grep结构体</a></li>
</ul>
</li>
<li><a href="rgrep.html#%E7%BB%99%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">给结构体实现方法</a></li>
<li><a href="rgrep.html#%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5-default_strategy">默认策略: default_strategy</a></li>
<li><a href="rgrep.html#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA">格式化输出</a></li>
<li><a href="rgrep.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li>
</ul>
</li>
<li><a href="rgrep.html#srcmainrs">src/main.rs</a>
<ul>
<li><a href="rgrep.html#%E5%BC%95%E5%85%A5librs%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9">引入lib.rs中的内容</a></li>
<li><a href="rgrep.html#%E4%B8%BB%E5%87%BD%E6%95%B0main">主函数：main()</a></li>
</ul>
</li>
<li><a href="rgrep.html#%E4%BD%BF%E7%94%A8">使用</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Oct  4 07:24:34 UTC 2022 -->
<!--te-->
<h2 id="cargotoml-1"><a class="header" href="#cargotoml-1">Cargo.toml</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">[package]
name = &quot;rgrep&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

<span class="boring">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</span>
[dependencies]
anyhow = &quot;1&quot;
clap = { version = &quot;3&quot;, features = [&quot;derive&quot;] }
colored = &quot;2&quot;
glob = &quot;0.3&quot;
itertools = &quot;0.10&quot;
rayon = &quot;1&quot;
regex = &quot;1&quot;
thiserror = &quot;1&quot;
</code></pre></pre>
<h2 id="srcerrorrs-thiserror会自动转换"><a class="header" href="#srcerrorrs-thiserror会自动转换">src/error.rs: thiserror会自动转换</a></h2>
<blockquote>
<p>它们都是需要进行转换的错误。thiserror 能够通过宏帮我们完成错误类型的转换。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">use thiserror::Error;

#[derive(Error, Debug)]
pub enum GrepError {
    #[error(&quot;Glob pattern error&quot;)]
    GlobPatternError(#[from] glob::PatternError),
    #[error(&quot;Regex pattern error&quot;)]
    RegexPatternError(#[from] regex::Error),
    #[error(&quot;I/O error&quot;)]
    IoError(#[from] std::io::Error),
}
</code></pre></pre>
<h2 id="srclibrs定义结构体实现方法单元测试"><a class="header" href="#srclibrs定义结构体实现方法单元测试">src/lib.rs：定义结构体+实现方法+单元测试</a></h2>
<h3 id="mod引入与使用"><a class="header" href="#mod引入与使用">mod引入与使用</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">mod error;
pub use error::GrepError;
</code></pre></pre>
<h3 id="定义结构体"><a class="header" href="#定义结构体">定义结构体</a></h3>
<h4 id="专门简化复杂类型"><a class="header" href="#专门简化复杂类型">专门简化复杂类型</a></h4>
<blockquote>
<p>这里其实就是传入一个指定结构的函数对象</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">/// 定义类型，这样，在使用时可以简化复杂类型的书写
pub type StrategyFn = fn(&amp;Path, &amp;mut dyn BufRead, &amp;Regex, &amp;mut dyn Write) -&gt; Result&lt;(), GrepError&gt;;
</code></pre></pre>
<h4 id="专门的结合版本grep结构体"><a class="header" href="#专门的结合版本grep结构体">专门的结合版本grep结构体</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 简化版本的 grep，支持正则表达式和文件通配符
#[derive(Parser, Debug)]
#[clap(version = &quot;1.0&quot;, author = &quot;Tyr Chen &lt;tyr@chen.com&gt;&quot;)]
pub struct GrepConfig {
    /// 用于查找的正则表达式
    pattern: String,
    /// 文件通配符
    glob: String,
}
</code></pre></pre>
<h3 id="给结构体实现方法"><a class="header" href="#给结构体实现方法">给结构体实现方法</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">impl GrepConfig {
    /// 使用缺省策略来查找匹配
    pub fn match_with_default_strategy(&amp;self) -&gt; Result&lt;(), GrepError&gt; {
        self.match_with(default_strategy)
    }

    /// 使用某个策略函数来查找匹配
    pub fn match_with(&amp;self, strategy: StrategyFn) -&gt; Result&lt;(), GrepError&gt; {
        let regex = Regex::new(&amp;self.pattern)?;
        // 生成所有符合通配符的文件列表
        let files: Vec&lt;_&gt; = glob::glob(&amp;self.glob)?.collect();
        // 并行处理所有文件
        files.into_par_iter().for_each(|v| {
            if let Ok(filename) = v {
                if let Ok(file) = File::open(&amp;filename) {
                    let mut reader = BufReader::new(file);
                    let mut stdout = io::stdout();

                    if let Err(e) = strategy(filename.as_path(), &amp;mut reader, &amp;regex, &amp;mut stdout) {
                        println!(&quot;Internal error: {:?}&quot;, e);
                    }
                }
            }
        });
        Ok(())
    }
}
</code></pre></pre>
<blockquote>
<p>主要实现两种解析策略：</p>
</blockquote>
<ol>
<li>默认策略：match_with_default_strategy, 使用default_strategy</li>
<li>指定策略：match_with, 使用传入的strategy: StrategyFn</li>
</ol>
<h3 id="默认策略-default_strategy"><a class="header" href="#默认策略-default_strategy">默认策略: default_strategy</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// 缺省策略，从头到尾串行查找，最后输出到 writer
pub fn default_strategy(
    path: &amp;Path,
    reader: &amp;mut dyn BufRead,
    pattern: &amp;Regex,
    writer: &amp;mut dyn Write,
) -&gt; Result&lt;(), GrepError&gt; {
    let matches: String = reader
        .lines()
        .enumerate()
        .map(|(lineno, line)| {
            line.ok()
                .map(|line| {
                    pattern
                        .find(&amp;line)
                        .map(|m| format_line(&amp;line, lineno + 1, m.range()))
                })
                .flatten()
        })
        .filter_map(|v| v.ok_or(()).ok())
        .join(&quot;\n&quot;);

    if !matches.is_empty() {
        writer.write_all(path.display().to_string().green().as_bytes())?;
        writer.write_all(b&quot;\n&quot;)?;
        writer.write_all(matches.as_bytes())?;
        writer.write_all(b&quot;\n&quot;)?;
    }

    Ok(())
}
</code></pre></pre>
<h3 id="格式化输出"><a class="header" href="#格式化输出">格式化输出</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// 格式化输出匹配的行，包含行号，列号和带有高亮的第一个匹配项
pub fn format_line(line: &amp;str, lineno: usize, range: Range&lt;usize&gt;) -&gt; String {
    let Range { start, end } = range;
    let prefix = &amp;line[..start];
    format!(
        &quot;{0: &gt;6}:{1: &lt;3} {2}{3}{4}&quot;,
        lineno.to_string().blue(),
        // 找到匹配项的起始位置，注意对汉字等非 ascii 字符，我们不能使用 prefix.len()
        // 这是一个 O(n) 的操作，会拖累效率，这里只是为了演示的效果
        (prefix.chars().count() + 1).to_string().cyan(),
        prefix,
        &amp;line[start..end].red(),
        &amp;line[end..]
    )
}
</code></pre></pre>
<h3 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn format_line_should_work() {
        let result = format_line(&quot;Hello, Tyr~&quot;, 1000, 7..10);
        let expected = format!(
            &quot;{0: &gt;6}:{1: &lt;3} Hello, {2}~&quot;,
            &quot;1000&quot;.blue(),
            &quot;8&quot;.cyan(),
            &quot;Tyr&quot;.red()
        );
        assert_eq!(result, expected);
    }

    #[test]
    fn default_strategy_should_work() {
        let path = Path::new(&quot;src/main.rs&quot;);
        let input = b&quot;hello world!\nhey Tyr!&quot;;
        let mut reader = BufReader::new(&amp;input[..]);
        let pattern = Regex::new(r&quot;he\w+&quot;).unwrap();
        let mut writer = Vec::new();
        default_strategy(path, &amp;mut reader, &amp;pattern, &amp;mut writer).unwrap();
        let result = String::from_utf8(writer).unwrap();
        let expected = [
            String::from(&quot;src/main.rs&quot;),
            format_line(&quot;hello world!&quot;, 1, 0..5),
            format_line(&quot;hey Tyr!\n&quot;, 2, 0..3),
        ];

        assert_eq!(result, expected.join(&quot;\n&quot;));
    }
}
</code></pre></pre>
<h2 id="srcmainrs"><a class="header" href="#srcmainrs">src/main.rs</a></h2>
<h3 id="引入librs中的内容"><a class="header" href="#引入librs中的内容">引入lib.rs中的内容</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use itertools::Itertools;
</code></pre></pre>
<h3 id="主函数main"><a class="header" href="#主函数main">主函数：main()</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use regex::Regex;
use std::{
    fs::File,
    io::{self, BufRead, BufReader, Write},
    ops::Range,
    path::Path,
};
</code></pre></pre>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<pre><code class="language-shell">cargo run --quiet -- &quot;Re[^\\s]+&quot; &quot;src/*.rs&quot;                                                                                                                                                                                            ─╯
src/main.rs
     1:13  use anyhow::Result;
     5:14  fn main() -&gt; Result&lt;()&gt; {
src/error.rs
     7:14      #[error(&quot;Regex pattern error&quot;)]
     8:5       RegexPatternError(#[from] regex::Error),
src/lib.rs
     5:12  use regex::Regex;
     8:19      io::{self, BufRead, BufReader, Write},
    17:45  pub type StrategyFn = fn(&amp;Path, &amp;mut dyn BufRead, &amp;Regex, &amp;mut dyn Write) -&gt; Result&lt;(), GrepError&gt;;
    31:50      pub fn match_with_default_strategy(&amp;self) -&gt; Result&lt;(), GrepError&gt; {
    36:55      pub fn match_with(&amp;self, strategy: StrategyFn) -&gt; Result&lt;(), GrepError&gt; {
    37:21          let regex = Regex::new(&amp;self.pattern)?;
    44:41                      let mut reader = BufReader::new(file);
    60:25      reader: &amp;mut dyn BufRead,
    61:15      pattern: &amp;Regex,
    63:6   ) -&gt; Result&lt;(), GrepError&gt; {
   126:29          let mut reader = BufReader::new(&amp;input[..]);
   127:23          let pattern = Regex::new(r&quot;he\w+&quot;).unwrap();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thumbor图片服务"><a class="header" href="#thumbor图片服务">thumbor图片服务</a></h1>
<!--ts-->
<!--te-->
<h2 id="abiproto"><a class="header" href="#abiproto">abi.proto</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">syntax = &quot;proto3&quot;;

package abi;

// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
message ImageSpec { repeated Spec specs = 1; }

// 处理图片改变大小
message Resize {
  uint32 width = 1;
  uint32 height = 2;

  enum ResizeType {
    NORMAL = 0;
    SEAM_CARVE = 1;
  }

  ResizeType rtype = 3;

  enum SampleFilter {
    UNDEFINED = 0;
    NEAREST = 1;
    TRIANGLE = 2;
    CATMULL_ROM = 3;
    GAUSSIAN = 4;
    LANCZOS3 = 5;
  }

  SampleFilter filter = 4;
}

// 处理图片截取
message Crop {
  uint32 x1 = 1;
  uint32 y1 = 2;
  uint32 x2 = 3;
  uint32 y2 = 4;
}

// 处理水平翻转
message Fliph {}
// 处理垂直翻转
message Flipv {}
// 处理对比度
message Contrast { float contrast = 1; }
// 处理滤镜
message Filter {
  enum Filter {
    UNSPECIFIED = 0;
    OCEANIC = 1;
    ISLANDS = 2;
    MARINE = 3;
    // more: https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html
  }
  Filter filter = 1;
}

// 处理水印
message Watermark {
  uint32 x = 1;
  uint32 y = 2;
}

// 一个 spec 可以包含上述的处理方式之一
message Spec {
  oneof data {
    Resize resize = 1;
    Crop crop = 2;
    Flipv flipv = 3;
    Fliph fliph = 4;
    Contrast contrast = 5;
    Filter filter = 6;
    Watermark watermark = 7;
  }
}
</code></pre></pre>
<h2 id="buildrs"><a class="header" href="#buildrs">build.rs</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">use std::process::Command;

fn main() {
    // 在编译时可选择检查环境变量。
    let build_enabled = option_env!(&quot;BUILD_PROTO&quot;)
        .map(|v| v == &quot;1&quot;)
        .unwrap_or(false);
    // 如果没有找到环境变量的对应值，就直接return，不再进行后续编译
    if !build_enabled {
        println!(&quot;=== Skipped compiling protos ===&quot;);
        return;
    }
    // 使用 prost_build 把 abi.proto 编译到 src/pb 目录下
    prost_build::Config::new()
        .out_dir(&quot;src/pb&quot;)
        .compile_protos(&amp;[&quot;abi.proto&quot;], &amp;[&quot;.&quot;])
        .unwrap();
    Command::new(&quot;cargo&quot;)
        .args(&amp;[&quot;fmt&quot;, &quot;--&quot;, &quot;src/*.rs&quot;])
        .status()
        .expect(&quot;cargo fmt failed&quot;);
}
</code></pre></pre>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.option_env.html">option_env in std - Rust</a></li>
</ul>
<blockquote>
<p>在编译时可选择检查环境变量。</p>
</blockquote>
<h2 id="关于rust的模块"><a class="header" href="#关于rust的模块">关于rust的模块</a></h2>
<blockquote>
<p>可以参考这篇：<a href="https://zhuanlan.zhihu.com/p/443926839">Rust 模块系统理解 - 知乎</a></p>
</blockquote>
<div id="admonition-mod全认识" class="admonition tip">
<div class="admonition-title">
<p>mod全认识</p>
<p><a class="admonition-anchor-link" href="thumbor.html#admonition-mod全认识"></a></p>
</div>
<div>
<ol>
<li>mod(mod.rs或mod关键字)将代码分为多个逻辑模块，并管理这些模块的可见性（public / private）。</li>
<li>模块是项（item）的集合，项可以是：函数，结构体，trait，impl块，甚至其它模块。</li>
<li>一个目录下的所有代码，可以通过 mod.rs 声明</li>
<li>Rust模块有三种形式:
<ul>
<li>mod.rs: 一个目录下的所有代码，可以通过 mod.rs 声明</li>
<li>文件/目录即模块：编译器的机制决定，除了mod.rs外，每一个文件和目录都是一个模块。不允许只分拆文件，但是不声明mod，我们通常使用pub use，在父空间直接调用子空间的函数。</li>
<li>mod关键字: 在文件内部分拆模块</li>
</ul>
</li>
<li>Rust编译器只接受一个源文件，输出一个crate</li>
<li>每一个crate都有一个匿名的根命名空间，命名空间可以无限嵌套</li>
<li>“mod mod-name { … }“ 将大括号中的代码置于命名空间mod-name之下</li>
<li>“use mod-name1::mod-name2;“ 可以打开命名空间，减少无休止的::操作符</li>
<li>“mod mod-name;“ 可以指导编译器将多个文件组装成一个文件</li>
<li>“pub use mod-nam1::mod-name2::item-name;“
语句可以将mod-name2下的item-name提升到这条语句所在的空间，item-name通常是函数或者结构体。Rust社区通常用这个方法来缩短库API的命名空间深度
编译器规定use语句一定要在mod语句之前</li>
</ol>
</div>
</div>
<h2 id="mod文件定义与实现分离"><a class="header" href="#mod文件定义与实现分离">mod文件定义与实现分离</a></h2>
<p>在rust中，一般会在模块的mod.rs文件中对供外部使用的项进行实现, 项可以是：函数，结构体，trait，impl块，甚至其它模块.
这样有个好处，高内聚，可以在代码增长时，将变动局限在服务提供者内部，对外提供的api不变，不会造成破坏性更新。</p>
<h2 id="pb模块-处理protobuf"><a class="header" href="#pb模块-处理protobuf">pb模块: 处理protobuf</a></h2>
<h3 id="pbmodrs声明模块"><a class="header" href="#pbmodrs声明模块">pb/mod.rs声明模块</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">mod abi; // 声明 abi.rs
pub use abi::*;
</code></pre></pre>
<h3 id="pbabirs里面还有子模块"><a class="header" href="#pbabirs里面还有子模块">pb/abi.rs里面还有子模块</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// Nested message and enum types in `Spec`.
pub mod spec {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = &quot;1&quot;)]
        Resize(super::Resize),
        #[prost(message, tag = &quot;2&quot;)]
        Crop(super::Crop),
        #[prost(message, tag = &quot;3&quot;)]
        Flipv(super::Flipv),
        #[prost(message, tag = &quot;4&quot;)]
        Fliph(super::Fliph),
        #[prost(message, tag = &quot;5&quot;)]
        Contrast(super::Contrast),
        #[prost(message, tag = &quot;6&quot;)]
        Filter(super::Filter),
        #[prost(message, tag = &quot;7&quot;)]
        Watermark(super::Watermark),
    }
}
</code></pre></pre>
<h3 id="pbabirs另外定义了specdata里面的各个元素结构体嵌套模块mod"><a class="header" href="#pbabirs另外定义了specdata里面的各个元素结构体嵌套模块mod">pb/abi.rs另外定义了spec::Data里面的各个元素结构体/嵌套模块mod</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSpec {
    #[prost(message, repeated, tag = &quot;1&quot;)]
    pub specs: ::prost::alloc::vec::Vec&lt;Spec&gt;,
}
/// 处理图片改变大小
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resize {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub width: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub height: u32,
    #[prost(enumeration = &quot;resize::ResizeType&quot;, tag = &quot;3&quot;)]
    pub rtype: i32,
    #[prost(enumeration = &quot;resize::SampleFilter&quot;, tag = &quot;4&quot;)]
    pub filter: i32,
}
/// Nested message and enum types in `Resize`.
pub mod resize {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResizeType {
        Normal = 0,
        SeamCarve = 1,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SampleFilter {
        Undefined = 0,
        Nearest = 1,
        Triangle = 2,
        CatmullRom = 3,
        Gaussian = 4,
        Lanczos3 = 5,
    }
}
/// 处理图片截取
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Crop {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub x1: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub y1: u32,
    #[prost(uint32, tag = &quot;3&quot;)]
    pub x2: u32,
    #[prost(uint32, tag = &quot;4&quot;)]
    pub y2: u32,
}
/// 处理水平翻转
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fliph {}
/// 处理垂直翻转
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Flipv {}
/// 处理对比度
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contrast {
    #[prost(float, tag = &quot;1&quot;)]
    pub contrast: f32,
}
/// 处理滤镜
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filter {
    #[prost(enumeration = &quot;filter::Filter&quot;, tag = &quot;1&quot;)]
    pub filter: i32,
}
/// Nested message and enum types in `Filter`.
pub mod filter {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Filter {
        Unspecified = 0,
        Oceanic = 1,
        Islands = 2,
        /// more: &lt;https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html&gt;
        Marine = 3,
    }
}
/// 处理水印
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Watermark {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub x: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub y: u32,
}
</code></pre></pre>
<h3 id="pbabirs有个特殊结构体"><a class="header" href="#pbabirs有个特殊结构体">pb/abi.rs有个特殊结构体</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 spec 可以包含上述的处理方式之一
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    #[prost(oneof = &quot;spec::Data&quot;, tags = &quot;1, 2, 3, 4, 5, 6, 7&quot;)]
    pub data: ::core::option::Option&lt;spec::Data&gt;,
}
</code></pre></pre>
<h3 id="imagespec"><a class="header" href="#imagespec">ImageSpec</a></h3>
<h4 id="定义有序数组"><a class="header" href="#定义有序数组">定义：有序数组</a></h4>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSpec {
    #[prost(message, repeated, tag = &quot;1&quot;)]
    pub specs: ::prost::alloc::vec::Vec&lt;Spec&gt;,
}
</code></pre></pre>
<h4 id="实现new方法fromtryfrom实现类型转化"><a class="header" href="#实现new方法fromtryfrom实现类型转化">实现：new方法、From&amp;TryFrom实现类型转化</a></h4>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">impl ImageSpec {
    pub fn new(specs: Vec&lt;Spec&gt;) -&gt; Self {
        Self { specs }
    }
}

// 让 ImageSpec 可以生成一个字符串
impl From&lt;&amp;ImageSpec&gt; for String {
    fn from(image_spec: &amp;ImageSpec) -&gt; Self {
        let data = image_spec.encode_to_vec();
        encode_config(data, URL_SAFE_NO_PAD)
    }
}

// 让 ImageSpec 可以通过一个字符串创建。比如 s.parse().unwrap()
impl TryFrom&lt;&amp;str&gt; for ImageSpec {
    type Error = anyhow::Error;

    fn try_from(value: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {
        let data = decode_config(value, URL_SAFE_NO_PAD)?;
        Ok(ImageSpec::decode(&amp;data[..])?)
    }
}
</code></pre></pre>
<h3 id="filter"><a class="header" href="#filter">Filter</a></h3>
<h4 id="定义枚举体mod"><a class="header" href="#定义枚举体mod">定义：枚举体mod</a></h4>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// Nested message and enum types in `Filter`.
pub mod filter {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Filter {
        Unspecified = 0,
        Oceanic = 1,
        Islands = 2,
        /// more: &lt;https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html&gt;
        Marine = 3,
    }
}
</code></pre></pre>
<h4 id="实现双引号的使用模式匹配"><a class="header" href="#实现双引号的使用模式匹配">实现：双引号的使用、模式匹配</a></h4>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">// 辅助函数，photon_rs 相应的方法里需要字符串
impl filter::Filter {
    pub fn to_str(self) -&gt; Option&lt;&amp;'static str&gt; {
        match self {
            filter::Filter::Unspecified =&gt; None,
            filter::Filter::Oceanic =&gt; Some(&quot;oceanic&quot;),
            filter::Filter::Islands =&gt; Some(&quot;islands&quot;),
            filter::Filter::Marine =&gt; Some(&quot;marine&quot;),
        }
    }
}
</code></pre></pre>
<h3 id="samplefilter"><a class="header" href="#samplefilter">SampleFilter</a></h3>
<h4 id="定义枚举体mod-1"><a class="header" href="#定义枚举体mod-1">定义：枚举体mod</a></h4>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// Nested message and enum types in `Resize`.
pub mod resize {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResizeType {
        Normal = 0,
        SeamCarve = 1,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SampleFilter {
        Undefined = 0,
        Nearest = 1,
        Triangle = 2,
        CatmullRom = 3,
        Gaussian = 4,
        Lanczos3 = 5,
    }
}
</code></pre></pre>
<h3 id="实现mod使用双引号from转为不同结果"><a class="header" href="#实现mod使用双引号from转为不同结果">实现：mod使用双引号、From转为不同结果</a></h3>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">impl From&lt;resize::SampleFilter&gt; for SamplingFilter {
    fn from(v: resize::SampleFilter) -&gt; Self {
        match v {
            resize::SampleFilter::Undefined =&gt; SamplingFilter::Nearest,
            resize::SampleFilter::Nearest =&gt; SamplingFilter::Nearest,
            resize::SampleFilter::Triangle =&gt; SamplingFilter::Triangle,
            resize::SampleFilter::CatmullRom =&gt; SamplingFilter::CatmullRom,
            resize::SampleFilter::Gaussian =&gt; SamplingFilter::Gaussian,
            resize::SampleFilter::Lanczos3 =&gt; SamplingFilter::Lanczos3,
        }
    }
}
</code></pre></pre>
<h3 id="spec"><a class="header" href="#spec">Spec</a></h3>
<h4 id="定义结构体-1"><a class="header" href="#定义结构体-1">定义：结构体</a></h4>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">/// 一个 spec 可以包含上述的处理方式之一
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    #[prost(oneof = &quot;spec::Data&quot;, tags = &quot;1, 2, 3, 4, 5, 6, 7&quot;)]
    pub data: ::core::option::Option&lt;spec::Data&gt;,
}
</code></pre></pre>
<h4 id="实现类似面向对象中添加类方法self"><a class="header" href="#实现类似面向对象中添加类方法self">实现：类似面向对象中添加类方法Self</a></h4>
<blockquote>
<p>注意区别Self和self的使用：
<a href="https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self">rust - What’s the difference between self and Self? - Stack Overflow</a></p>
</blockquote>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">// 提供一些辅助函数，让创建一个 spec 的过程简单一些
impl Spec {
    pub fn new_resize_seam_carve(width: u32, height: u32) -&gt; Self {
        Self {
            data: Some(spec::Data::Resize(Resize {
                width,
                height,
                rtype: resize::ResizeType::SeamCarve as i32,
                filter: resize::SampleFilter::Undefined as i32,
            })),
        }
    }

    pub fn new_resize(width: u32, height: u32, filter: resize::SampleFilter) -&gt; Self {
        Self {
            data: Some(spec::Data::Resize(Resize {
                width,
                height,
                rtype: resize::ResizeType::Normal as i32,
                filter: filter as i32,
            })),
        }
    }

    pub fn new_filter(filter: filter::Filter) -&gt; Self {
        Self {
            data: Some(spec::Data::Filter(Filter {
                filter: filter as i32,
            })),
        }
    }

    pub fn new_watermark(x: u32, y: u32) -&gt; Self {
        Self {
            data: Some(spec::Data::Watermark(Watermark { x, y })),
        }
    }
}
</code></pre></pre>
<h3 id="单元测试-1"><a class="header" href="#单元测试-1">单元测试</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {
    use super::*;
    use std::borrow::Borrow;

    #[test]
    fn encoded_spec_could_be_decoded() {
        let spec1 = Spec::new_resize(600, 600, resize::SampleFilter::CatmullRom);
        let spec2 = Spec::new_filter(filter::Filter::Marine);
        let image_spec = ImageSpec::new(vec![spec1, spec2]);
        let s: String = image_spec.borrow().into();
        assert_eq!(image_spec, s.as_str().try_into().unwrap());
    }
}
</code></pre></pre>
<h2 id="engine模块-处理图片"><a class="header" href="#engine模块-处理图片">engine模块: 处理图片</a></h2>
<h3 id="modrs-定义统一的引擎trait"><a class="header" href="#modrs-定义统一的引擎trait">mod.rs: 定义统一的引擎trait</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">// Engine trait：未来可以添加更多的 engine，主流程只需要替换 engine
pub trait Engine {
    // 对 engine 按照 specs 进行一系列有序的处理
    fn apply(&amp;mut self, specs: &amp;[Spec]);
    // 从 engine 中生成目标图片，注意这里用的是 self，而非 self 的引用
    fn generate(self, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt;;
}

// SpecTransform：未来如果添加更多的 spec，只需要实现它即可
pub trait SpecTransform&lt;T&gt; {
    // 对图片使用 op 做 transform
    fn transform(&amp;mut self, op: T);
}
</code></pre></pre>
<h3 id="photonrs--静态变量加载"><a class="header" href="#photonrs--静态变量加载">photon.rs &gt; 静态变量加载</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">lazy_static! {
    // 预先把水印文件加载为静态变量
    static ref WATERMARK: PhotonImage = {
        let data = include_bytes!(&quot;../../rust-logo.png&quot;);
        let watermark = open_image_from_bytes(data).unwrap();
        transform::resize(&amp;watermark, 64, 64, transform::SamplingFilter::Nearest)
    };
}
</code></pre></pre>
<h3 id="photonrs--具体引擎photon的定义与转化tryfrom"><a class="header" href="#photonrs--具体引擎photon的定义与转化tryfrom">photon.rs &gt; 具体引擎Photon的定义与转化TryFrom</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">pub struct Photon(PhotonImage);

// 从 Bytes 转换成 Photon 结构
impl TryFrom&lt;Bytes&gt; for Photon {
    type Error = anyhow::Error;

    fn try_from(data: Bytes) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(Self(open_image_from_bytes(&amp;data)?))
    }
}
</code></pre></pre>
<h3 id="photonrs--具体引擎photon的trait实现"><a class="header" href="#photonrs--具体引擎photon的trait实现">photon.rs &gt; 具体引擎Photon的trait实现</a></h3>
<h4 id="engine-trait"><a class="header" href="#engine-trait">Engine Trait</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">impl Engine for Photon {
    fn apply(&amp;mut self, specs: &amp;[Spec]) {
        for spec in specs.iter() {
            match spec.data {
                Some(spec::Data::Crop(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Contrast(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Filter(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Fliph(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Flipv(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Resize(ref v)) =&gt; self.transform(v),
                Some(spec::Data::Watermark(ref v)) =&gt; self.transform(v),
                // 对于目前不认识的 spec，不做任何处理
                _ =&gt; {}
            }
        }
    }
</code></pre></pre>
<h4 id="spectransform-trait"><a class="header" href="#spectransform-trait">SpecTransform Trait</a></h4>
<h5 id="格式语义化"><a class="header" href="#格式语义化">格式语义化</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SpecTransform(&amp;OpreationName) for SpecificEngine {
    fn transform(&amp;mut self, _op: &amp;OperationName) {
        transform::OperationMethod(&amp;mut self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">impl SpecTransform&lt;&amp;Crop&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Crop) {
        let img = transform::crop(&amp;mut self.0, op.x1, op.y1, op.x2, op.y2);
        self.0 = img;
    }
}

impl SpecTransform&lt;&amp;Contrast&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Contrast) {
        effects::adjust_contrast(&amp;mut self.0, op.contrast);
    }
}

impl SpecTransform&lt;&amp;Flipv&gt; for Photon {
    fn transform(&amp;mut self, _op: &amp;Flipv) {
        transform::flipv(&amp;mut self.0)
    }
}

impl SpecTransform&lt;&amp;Fliph&gt; for Photon {
    fn transform(&amp;mut self, _op: &amp;Fliph) {
        transform::fliph(&amp;mut self.0)
    }
}

impl SpecTransform&lt;&amp;Filter&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Filter) {
        match filter::Filter::from_i32(op.filter) {
            Some(filter::Filter::Unspecified) =&gt; {}
            Some(f) =&gt; filters::filter(&amp;mut self.0, f.to_str().unwrap()),
            _ =&gt; {}
        }
    }
}

impl SpecTransform&lt;&amp;Resize&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Resize) {
        let img = match resize::ResizeType::from_i32(op.rtype).unwrap() {
            resize::ResizeType::Normal =&gt; transform::resize(
                &amp;self.0,
                op.width,
                op.height,
                resize::SampleFilter::from_i32(op.filter).unwrap().into(),
            ),
            resize::ResizeType::SeamCarve =&gt; transform::seam_carve(&amp;self.0, op.width, op.height),
        };
        self.0 = img;
    }
}

impl SpecTransform&lt;&amp;Watermark&gt; for Photon {
    fn transform(&amp;mut self, op: &amp;Watermark) {
        multiple::watermark(&amp;mut self.0, &amp;WATERMARK, op.x, op.y);
    }
}
</code></pre></pre>
<h3 id="photonrs--在内存中对图片转换格式的方法"><a class="header" href="#photonrs--在内存中对图片转换格式的方法">photon.rs &gt; 在内存中对图片转换格式的方法</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">fn image_to_buf(img: PhotonImage, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt; {
    let raw_pixels = img.get_raw_pixels();
    let width = img.get_width();
    let height = img.get_height();

    let img_buffer = ImageBuffer::from_vec(width, height, raw_pixels).unwrap();
    let dynimage = DynamicImage::ImageRgba8(img_buffer);

    let mut buffer = Vec::with_capacity(32768);
    dynimage.write_to(&amp;mut buffer, format).unwrap();
    buffer
}
</code></pre></pre>
<h2 id="mainrs"><a class="header" href="#mainrs">main.rs</a></h2>
<h3 id="先引入mod再use"><a class="header" href="#先引入mod再use">先引入mod，再use</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">// 参数使用 serde 做 Deserialize，axum 会自动识别并解析
#[derive(Deserialize)]
struct Params {
    spec: String,
    url: String,
}
</code></pre></pre>
<h3 id="图片资源用到lru策略缓存type定义"><a class="header" href="#图片资源用到lru策略缓存type定义">图片资源用到Lru策略缓存type定义</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">type Cache = Arc&lt;Mutex&lt;LruCache&lt;u64, Bytes&gt;&gt;&gt;;
</code></pre></pre>
<h3 id="主流程main函数"><a class="header" href="#主流程main函数">主流程main函数</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">#[tokio::main]
async fn main() {
    // 初始化 tracing
    tracing_subscriber::fmt::init();
    let cache: Cache = Arc::new(Mutex::new(LruCache::new(1024)));
    // 构建路由
    let app = Router::new()
        // `GET /` 会执行
        .route(&quot;/image/:spec/:url&quot;, get(generate))
        .layer(
            ServiceBuilder::new()
                .load_shed()
                .concurrency_limit(1024)
                .timeout(Duration::from_secs(10))
                .layer(TraceLayer::new_for_http())
                .layer(AddExtensionLayer::new(cache))
                .layer(CompressionLayer::new())
                .into_inner(),
        );

    // 运行 web 服务器
    let addr = &quot;127.0.0.1:3000&quot;.parse().unwrap();
    print_test_url(&quot;https://images.pexels.com/photos/1562477/pexels-photo-1562477.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=3&amp;h=750&amp;w=1260&quot;);
    info!(&quot;Listening on {}&quot;, addr);
    axum::Server::bind(&amp;addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
</code></pre></pre>
<h4 id="建造者模式"><a class="header" href="#建造者模式">建造者模式</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">            ServiceBuilder::new()
                .load_shed()
                .concurrency_limit(1024)
                .timeout(Duration::from_secs(10))
                .layer(TraceLayer::new_for_http())
                .layer(AddExtensionLayer::new(cache))
                .layer(CompressionLayer::new())
                .into_inner(),
</code></pre></pre>
<h4 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">    // 运行 web 服务器
    let addr = &quot;127.0.0.1:3000&quot;.parse().unwrap();
</code></pre></pre>
<h5 id="数字与字符串"><a class="header" href="#数字与字符串">数字与字符串</a></h5>
<p>||i32|u32|f64|String*|
|--|---|---|---|-------|
|i32|\|x as u32|x as f64|x.to_string()|
|u32|x as i32|\|x as f64|x.to_string()|
|f64|x as i32|x as u32|\|x.to_string()|
|String*|x.parse().unwrap()|x.parse().unwrap()|x.parse().unwrap()|\|</p>
<h5 id="string-与--str"><a class="header" href="#string-与--str">String 与 &amp; str</a></h5>
<p>|\|String|&amp;str|
|-|------|----|
|String|\|&amp;*x|
|&amp;str|x.to_string()|\|</p>
<h5 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h5>
<p>|\|Vec&lt;T&gt;|&amp;[T]|Box&lt;[T]&gt;|
|-|------|----|--------|
|Vec&lt;T&gt;|\|&amp;x[…]|x.into_boxed_slice()|
|&amp;[T]|x.to_vec()|\|Box::new(*x)|
|Box&lt;[T]&gt;|x.to_vec()|&amp;*x|\|</p>
<h3 id="路由绑定的处理函数handler"><a class="header" href="#路由绑定的处理函数handler">路由绑定的处理函数handler</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">// basic handler that responds with a static string
async fn generate(
    Path(Params { spec, url }): Path&lt;Params&gt;,
    Extension(cache): Extension&lt;Cache&gt;,
) -&gt; Result&lt;(HeaderMap, Vec&lt;u8&gt;), StatusCode&gt; {
    let spec: ImageSpec = spec
        .as_str()
        .try_into()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    let url: &amp;str = &amp;percent_decode_str(&amp;url).decode_utf8_lossy();
    let data = retrieve_image(url, cache)
        .await
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    // 使用 image engine 处理
    let mut engine: Photon = data
        .try_into()
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    engine.apply(&amp;spec.specs);
    // TODO: 这里目前类型写死了，应该使用 content negotiation
    let image = engine.generate(ImageOutputFormat::Jpeg(85));

    info!(&quot;Finished processing: image size {}&quot;, image.len());
    let mut headers = HeaderMap::new();

    headers.insert(&quot;content-type&quot;, HeaderValue::from_static(&quot;image/jpeg&quot;));
    Ok((headers, image))
}
</code></pre></pre>
<h3 id="处理函数用到的图片获取方法"><a class="header" href="#处理函数用到的图片获取方法">处理函数用到的图片获取方法</a></h3>
<blockquote>
<p>对于图片的网络请求，我们先把 URL 做个哈希，在 LRU 缓存中查找，找不到才用 reqwest 发送请求。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">#[instrument(level = &quot;info&quot;, skip(cache))]
async fn retrieve_image(url: &amp;str, cache: Cache) -&gt; Result&lt;Bytes&gt; {
    let mut hasher = DefaultHasher::new();
    url.hash(&amp;mut hasher);
    let key = hasher.finish();

    let g = &amp;mut cache.lock().await;
    let data = match g.get(&amp;key) {
        Some(v) =&gt; {
            info!(&quot;Match cache {}&quot;, key);
            v.to_owned()
        }
        None =&gt; {
            info!(&quot;Retrieve url&quot;);
            let resp = reqwest::get(url).await?;
            let data = resp.bytes().await?;
            g.put(key, data.clone());
            data
        }
    };

    Ok(data)
}
</code></pre></pre>
<h3 id="一个用于调试的辅助函数"><a class="header" href="#一个用于调试的辅助函数">一个用于调试的辅助函数</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">// 调试辅助函数
fn print_test_url(url: &amp;str) {
    use std::borrow::Borrow;
    let spec1 = Spec::new_resize(500, 800, resize::SampleFilter::CatmullRom);
    let spec2 = Spec::new_watermark(20, 20);
    let spec3 = Spec::new_filter(filter::Filter::Marine);
    let image_spec = ImageSpec::new(vec![spec1, spec2, spec3]);
    let s: String = image_spec.borrow().into();
    let test_image = percent_encode(url.as_bytes(), NON_ALPHANUMERIC).to_string();
    println!(&quot;test url: http://localhost:3000/image/{}/{}&quot;, s, test_image);
}
</code></pre></pre>
<h2 id="运行与日志"><a class="header" href="#运行与日志">运行与日志</a></h2>
<blockquote>
<p>将RUST_LOG级别设置为info</p>
</blockquote>
<pre><code class="language-shell">cargo build --release
RUST_LOG=info target/release/thumbor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql查询工具"><a class="header" href="#sql查询工具">SQL查询工具</a></h1>
<!--ts-->
<ul>
<li><a href="queryer.html#sql%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7">SQL查询工具</a>
<ul>
<li><a href="queryer.html#workspace-%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%B8%85%E5%8D%95virtual-manifest%E6%96%B9%E5%BC%8F">workspace: 这里使用虚拟清单(virtual manifest)方式</a>
<ul>
<li><a href="queryer.html#workspace%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">workspace使用方式</a></li>
</ul>
</li>
<li><a href="queryer.html#queryer-package">queryer package</a>
<ul>
<li><a href="queryer.html#cargotoml">cargo.toml</a></li>
<li><a href="queryer.html#%E4%B8%A4%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">两个使用示例</a>
<ul>
<li><a href="queryer.html#dialectrssql%E8%A7%A3%E6%9E%90">dialect.rs:SQL解析</a></li>
<li><a href="queryer.html#covidrs-ast%E8%BD%AC%E6%8D%A2">covid.rs: AST转换</a></li>
</ul>
</li>
<li><a href="queryer.html#srcconvertrs">src/convert.rs</a>
<ul>
<li><a href="queryer.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89sql%E4%B8%8E%E5%AF%B9%E5%BA%94%E9%83%A8%E5%88%86%E7%BB%93%E6%9E%84%E4%BD%93-%E6%B3%A8%E6%84%8F%E9%99%90%E4%BA%8E%E5%AD%A4%E5%84%BF%E5%8E%9F%E5%88%99%E7%9A%84%E5%86%8D%E5%8C%85%E8%A3%85">结构体定义:sql与对应部分结构体, 注意限于孤儿原则的再包装</a></li>
<li><a href="queryer.html#sql%E7%9A%84%E8%BD%AC%E6%8D%A2">sql的转换</a></li>
<li><a href="queryer.html#%E5%AF%B9%E5%BA%94%E9%83%A8%E5%88%86%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%BD%AC%E6%8D%A2">对应部分结构体的转换</a></li>
<li><a href="queryer.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li>
</ul>
</li>
<li><a href="queryer.html#srcdialectrs">src/dialect.rs</a>
<ul>
<li><a href="queryer.html#%E5%AE%9A%E4%B9%89%E6%96%B9%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93">定义方言结构体</a></li>
<li><a href="queryer.html#%E7%BB%99%E6%96%B9%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0trait">给方言结构体实现trait</a></li>
<li><a href="queryer.html#%E6%B7%BB%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E5%87%BD%E6%95%B0">添加测试用函数</a></li>
<li><a href="queryer.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-1">单元测试</a></li>
</ul>
</li>
<li><a href="queryer.html#srcloaderrs">src/loader.rs</a>
<ul>
<li><a href="queryer.html#%E5%AE%9A%E4%B9%89loader%E4%B8%8Ecsvloader">定义Loader与CsvLoader</a></li>
<li><a href="queryer.html#%E5%AE%9A%E4%B9%89trait%E5%B9%B6%E7%BB%99csvloader%E5%AE%9E%E7%8E%B0">定义trait并给CsvLoader实现</a></li>
<li><a href="queryer.html#todo-%E7%BB%99csvloader%E6%B7%BB%E5%8A%A0%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B">todo: 给CsvLoader添加内容检测</a></li>
</ul>
</li>
<li><a href="queryer.html#srcfetcherrs">src/fetcher.rs</a>
<ul>
<li><a href="queryer.html#%E5%AE%9A%E4%B9%89urlfetcher%E4%B8%8Efilefetcher">定义UrlFetcher与FileFetcher</a></li>
<li><a href="queryer.html#%E5%AE%9A%E4%B9%89trait%E5%B9%B6%E7%BB%99fetcher%E4%B8%8Efilefetcher%E5%AE%9E%E7%8E%B0">定义trait并给Fetcher与FileFetcher实现</a></li>
<li><a href="queryer.html#%E6%9C%80%E5%90%8E%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95">最后定义一个获取数据的方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="queryer.html#queryer-js-package-%E4%BD%BF%E7%94%A8neon">queryer-js package: 使用neon</a>
<ul>
<li><a href="queryer.html#cargotoml-1">Cargo.toml</a></li>
<li><a href="queryer.html#build-in-packagejson">build in package.json</a></li>
<li><a href="queryer.html#srclibrs">src/lib.rs</a></li>
</ul>
</li>
<li><a href="queryer.html#queryer-py-package-%E4%BD%BF%E7%94%A8pyo3">queryer-py package: 使用pyo3</a>
<ul>
<li><a href="queryer.html#cargotoml-2">Cargo.toml</a></li>
<li><a href="queryer.html#buildrs">build.rs</a></li>
<li><a href="queryer.html#srclibrs-1">src/lib.rs</a></li>
</ul>
</li>
<li><a href="queryer.html#data-viewer-package-%E4%BD%BF%E7%94%A8tauri">data-viewer package: 使用tauri</a>
<ul>
<li><a href="queryer.html#cargotoml-3">Cargo.toml</a></li>
<li><a href="queryer.html#buildrs-1">build.rs</a></li>
<li><a href="queryer.html#mainrs">main.rs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Oct  4 07:24:34 UTC 2022 -->
<!--te-->
<h2 id="workspace-这里使用虚拟清单virtual-manifest方式"><a class="header" href="#workspace-这里使用虚拟清单virtual-manifest方式">workspace: 这里使用虚拟清单(virtual manifest)方式</a></h2>
<blockquote>
<p><a href="https://course.rs/cargo/reference/workspaces.html">工作空间 Workspace - Rust语言圣经(Rust Course)</a></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">[workspace]

members = [
  &quot;queryer&quot;,
  &quot;queryer-js&quot;,
  &quot;queryer-py&quot;,
  &quot;data-viewer/src-tauri&quot;
]
</code></pre></pre>
<div id="admonition-虚拟清单" class="admonition info">
<div class="admonition-title">
<p>虚拟清单</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-虚拟清单"></a></p>
</div>
<div>
<p>若一个 Cargo.toml 有 [workspace] 但是没有 [package] 部分，则它是虚拟清单类型的工作空间。</p>
<p>对于没有主 package 的场景或你希望将所有的 package 组织在单独的目录中时，这种方式就非常适合。</p>
</div>
</div>
<div id="admonition-workspace关键点" class="admonition tip">
<div class="admonition-title">
<p>workspace关键点</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-workspace关键点"></a></p>
</div>
<div>
<ul>
<li>所有的 package 共享同一个 Cargo.lock 文件，该文件位于工作空间的根目录中</li>
<li>所有的 package 共享同一个输出目录，该目录默认的名称是 target ，位于工作空间根目录下</li>
<li>只有工作空间根目录的 Cargo.toml 才能包含 [patch], [replace] 和 [profile.*]，而成员的 Cargo.toml 中的相应部分将被自动忽略</li>
</ul>
</div>
</div>
<h3 id="workspace使用方式"><a class="header" href="#workspace使用方式">workspace使用方式</a></h3>
<pre><code class="language-shell">cargo run -p &lt;member package&gt;
cargo build -p queryer
</code></pre>
<div id="admonition-使用说明" class="admonition info">
<div class="admonition-title">
<p>使用说明</p>
<p><a class="admonition-anchor-link" href="queryer.html#admonition-使用说明"></a></p>
</div>
<div>
<ol>
<li>
<p>在工作空间中，package 相关的 Cargo 命令(例如 cargo build )可以使用 -p 、 –package 或 –workspace 命令行参数来指定想要操作的 package。</p>
</li>
<li>
<p>若没有指定任何参数，则 Cargo 将使用当前工作目录的中的 package 。若工作目录是虚拟清单类型的工作空间，则该命令将作用在所有成员上(就好像是使用了 –workspace 命令行参数)。而 default-members 可以在命令行参数没有被提供时，手动指定操作的成员</p>
</li>
</ol>
</div>
</div>
<h2 id="queryer-package"><a class="header" href="#queryer-package">queryer package</a></h2>
<h3 id="cargotoml-2"><a class="header" href="#cargotoml-2">cargo.toml</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">{{#include ../geektime_rust_codes/06_queryer/queryer/cargo.toml}}
</code></pre></pre>
<h3 id="两个使用示例"><a class="header" href="#两个使用示例">两个使用示例</a></h3>
<h4 id="dialectrssql解析"><a class="header" href="#dialectrssql解析">dialect.rs:SQL解析</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">use sqlparser::{dialect::GenericDialect, parser::Parser};

fn main() {
    tracing_subscriber::fmt::init();

    let sql = &quot;SELECT a a1, b, 123, myfunc(b), * \
    FROM data_source \
    WHERE a &gt; b AND b &lt; 100 AND c BETWEEN 10 AND 20 \
    ORDER BY a DESC, b \
    LIMIT 50 OFFSET 10&quot;;

    let ast = Parser::parse_sql(&amp;GenericDialect::default(), sql);
    println!(&quot;{:#?}&quot;, ast);
}
</code></pre></pre>
<h4 id="covidrs-ast转换"><a class="header" href="#covidrs-ast转换">covid.rs: AST转换</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">use anyhow::Result;
use queryer::query;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();

    let url = &quot;https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv&quot;;

    // 使用 sql 从 URL 里获取数据
    let sql = format!(
        &quot;SELECT location name, total_cases, new_cases, total_deaths, new_deaths \
        FROM {} where new_deaths &gt;= 500 ORDER BY new_cases DESC&quot;,
        url
    );
    let df1 = query(sql).await?;
    println!(&quot;{:?}&quot;, df1);

    Ok(())
}
</code></pre></pre>
<h3 id="srcconvertrs"><a class="header" href="#srcconvertrs">src/convert.rs</a></h3>
<h4 id="结构体定义sql与对应部分结构体-注意限于孤儿原则的再包装"><a class="header" href="#结构体定义sql与对应部分结构体-注意限于孤儿原则的再包装">结构体定义:sql与对应部分结构体, 注意限于孤儿原则的再包装</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 解析出来的 SQL
pub struct Sql&lt;'a&gt; {
    pub(crate) selection: Vec&lt;Expr&gt;,
    pub(crate) condition: Option&lt;Expr&gt;,
    pub(crate) source: &amp;'a str,
    pub(crate) order_by: Vec&lt;(String, bool)&gt;,
    pub(crate) offset: Option&lt;i64&gt;,
    pub(crate) limit: Option&lt;usize&gt;,
}

// 因为 Rust trait 的孤儿规则，我们如果要想对已有的类型实现已有的 trait，
// 需要简单包装一下

pub struct Expression(pub(crate) Box&lt;SqlExpr&gt;);
pub struct Operation(pub(crate) SqlBinaryOperator);
pub struct Projection&lt;'a&gt;(pub(crate) &amp;'a SelectItem);
pub struct Source&lt;'a&gt;(pub(crate) &amp;'a [TableWithJoins]);
pub struct Order&lt;'a&gt;(pub(crate) &amp;'a OrderByExpr);
pub struct Offset&lt;'a&gt;(pub(crate) &amp;'a SqlOffset);
pub struct Limit&lt;'a&gt;(pub(crate) &amp;'a SqlExpr);
pub struct Value(pub(crate) SqlValue);
</code></pre></pre>
<h4 id="sql的转换"><a class="header" href="#sql的转换">sql的转换</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 把 SqlParser 解析出来的 Statement 转换成我们需要的结构
impl&lt;'a&gt; TryFrom&lt;&amp;'a Statement&gt; for Sql&lt;'a&gt; {
    type Error = anyhow::Error;

    fn try_from(sql: &amp;'a Statement) -&gt; Result&lt;Self, Self::Error&gt; {
        match sql {
            // 目前我们只关心 query (select ... from ... where ...)
            Statement::Query(q) =&gt; {
                let offset = q.offset.as_ref();
                let limit = q.limit.as_ref();
                let orders = &amp;q.order_by;
                let Select {
                    from: table_with_joins,
                    selection: where_clause,
                    projection,

                    group_by: _,
                    ..
                } = match &amp;q.body {
                    SetExpr::Select(statement) =&gt; statement.as_ref(),
                    _ =&gt; return Err(anyhow!(&quot;We only support Select Query at the moment&quot;)),
                };

                let source = Source(table_with_joins).try_into()?;

                let condition = match where_clause {
                    Some(expr) =&gt; Some(Expression(Box::new(expr.to_owned())).try_into()?),
                    None =&gt; None,
                };

                let mut selection = Vec::with_capacity(8);
                for p in projection {
                    let expr = Projection(p).try_into()?;
                    selection.push(expr);
                }

                let mut order_by = Vec::new();
                for expr in orders {
                    order_by.push(Order(expr).try_into()?);
                }

                let offset = offset.map(|v| Offset(v).into());
                let limit = limit.map(|v| Limit(v).into());

                Ok(Sql {
                    selection,
                    condition,
                    source,
                    order_by,
                    offset,
                    limit,
                })
            }
            _ =&gt; Err(anyhow!(&quot;We only support Query at the moment&quot;)),
        }
    }
}
</code></pre></pre>
<h4 id="对应部分结构体的转换"><a class="header" href="#对应部分结构体的转换">对应部分结构体的转换</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 把 SqlParser 的 Expr 转换成 DataFrame 的 Expr
impl TryFrom&lt;Expression&gt; for Expr {
    type Error = anyhow::Error;

    fn try_from(expr: Expression) -&gt; Result&lt;Self, Self::Error&gt; {
        match *expr.0 {
            SqlExpr::BinaryOp { left, op, right } =&gt; Ok(Expr::BinaryExpr {
                left: Box::new(Expression(left).try_into()?),
                op: Operation(op).try_into()?,
                right: Box::new(Expression(right).try_into()?),
            }),
            SqlExpr::Wildcard =&gt; Ok(Self::Wildcard),
            SqlExpr::IsNull(expr) =&gt; Ok(Self::IsNull(Box::new(Expression(expr).try_into()?))),
            SqlExpr::IsNotNull(expr) =&gt; Ok(Self::IsNotNull(Box::new(Expression(expr).try_into()?))),
            SqlExpr::Identifier(id) =&gt; Ok(Self::Column(Arc::new(id.value))),
            SqlExpr::Value(v) =&gt; Ok(Self::Literal(Value(v).try_into()?)),
            v =&gt; Err(anyhow!(&quot;expr {:#?} is not supported&quot;, v)),
        }
    }
}

/// 把 SqlParser 的 BinaryOperator 转换成 DataFrame 的 Operator
impl TryFrom&lt;Operation&gt; for Operator {
    type Error = anyhow::Error;

    fn try_from(op: Operation) -&gt; Result&lt;Self, Self::Error&gt; {
        match op.0 {
            SqlBinaryOperator::Plus =&gt; Ok(Self::Plus),
            SqlBinaryOperator::Minus =&gt; Ok(Self::Minus),
            SqlBinaryOperator::Multiply =&gt; Ok(Self::Multiply),
            SqlBinaryOperator::Divide =&gt; Ok(Self::Divide),
            SqlBinaryOperator::Modulo =&gt; Ok(Self::Modulus),
            SqlBinaryOperator::Gt =&gt; Ok(Self::Gt),
            SqlBinaryOperator::Lt =&gt; Ok(Self::Lt),
            SqlBinaryOperator::GtEq =&gt; Ok(Self::GtEq),
            SqlBinaryOperator::LtEq =&gt; Ok(Self::LtEq),
            SqlBinaryOperator::Eq =&gt; Ok(Self::Eq),
            SqlBinaryOperator::NotEq =&gt; Ok(Self::NotEq),
            SqlBinaryOperator::And =&gt; Ok(Self::And),
            SqlBinaryOperator::Or =&gt; Ok(Self::Or),
            v =&gt; Err(anyhow!(&quot;Operator {} is not supported&quot;, v)),
        }
    }
}

/// 把 SqlParser 的 SelectItem 转换成 DataFrame 的 Expr
impl&lt;'a&gt; TryFrom&lt;Projection&lt;'a&gt;&gt; for Expr {
    type Error = anyhow::Error;

    fn try_from(p: Projection&lt;'a&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        match p.0 {
            SelectItem::UnnamedExpr(SqlExpr::Identifier(id)) =&gt; Ok(col(&amp;id.to_string())),
            SelectItem::ExprWithAlias {
                expr: SqlExpr::Identifier(id),
                alias,
            } =&gt; Ok(Expr::Alias(
                Box::new(Expr::Column(Arc::new(id.to_string()))),
                Arc::new(alias.to_string()),
            )),
            SelectItem::QualifiedWildcard(v) =&gt; Ok(col(&amp;v.to_string())),
            SelectItem::Wildcard =&gt; Ok(col(&quot;*&quot;)),
            item =&gt; Err(anyhow!(&quot;projection {} not supported&quot;, item)),
        }
    }
}

impl&lt;'a&gt; TryFrom&lt;Source&lt;'a&gt;&gt; for &amp;'a str {
    type Error = anyhow::Error;

    fn try_from(source: Source&lt;'a&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        if source.0.len() != 1 {
            return Err(anyhow!(&quot;We only support single data source at the moment&quot;));
        }

        let table = &amp;source.0[0];
        if !table.joins.is_empty() {
            return Err(anyhow!(&quot;We do not support joint data source at the moment&quot;));
        }

        match &amp;table.relation {
            TableFactor::Table { name, .. } =&gt; Ok(&amp;name.0.first().unwrap().value),
            _ =&gt; Err(anyhow!(&quot;We only support table&quot;)),
        }
    }
}

/// 把 SqlParser 的 order by expr 转换成 (列名, 排序方法)
impl&lt;'a&gt; TryFrom&lt;Order&lt;'a&gt;&gt; for (String, bool) {
    type Error = anyhow::Error;

    fn try_from(o: Order) -&gt; Result&lt;Self, Self::Error&gt; {
        let name = match &amp;o.0.expr {
            SqlExpr::Identifier(id) =&gt; id.to_string(),
            expr =&gt; {
                return Err(anyhow!(
                    &quot;We only support identifier for order by, got {}&quot;,
                    expr
                ))
            }
        };

        Ok((name, !o.0.asc.unwrap_or(true)))
    }
}

/// 把 SqlParser 的 offset expr 转换成 i64
impl&lt;'a&gt; From&lt;Offset&lt;'a&gt;&gt; for i64 {
    fn from(offset: Offset) -&gt; Self {
        match offset.0 {
            SqlOffset {
                value: SqlExpr::Value(SqlValue::Number(v, _b)),
                ..
            } =&gt; v.parse().unwrap_or(0),
            _ =&gt; 0,
        }
    }
}

/// 把 SqlParser 的 Limit expr 转换成 usize
impl&lt;'a&gt; From&lt;Limit&lt;'a&gt;&gt; for usize {
    fn from(l: Limit&lt;'a&gt;) -&gt; Self {
        match l.0 {
            SqlExpr::Value(SqlValue::Number(v, _b)) =&gt; v.parse().unwrap_or(usize::MAX),
            _ =&gt; usize::MAX,
        }
    }
}

/// 把 SqlParser 的 value 转换成 DataFrame 支持的 LiteralValue
impl TryFrom&lt;Value&gt; for LiteralValue {
    type Error = anyhow::Error;
    fn try_from(v: Value) -&gt; Result&lt;Self, Self::Error&gt; {
        match v.0 {
            SqlValue::Number(v, _) =&gt; Ok(LiteralValue::Float64(v.parse().unwrap())),
            SqlValue::Boolean(v) =&gt; Ok(LiteralValue::Boolean(v)),
            SqlValue::Null =&gt; Ok(LiteralValue::Null),
            v =&gt; Err(anyhow!(&quot;Value {} is not supported&quot;, v)),
        }
    }
}
</code></pre></pre>
<h4 id="单元测试-2"><a class="header" href="#单元测试-2">单元测试</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {
    use super::*;
    use crate::TyrDialect;
    use sqlparser::parser::Parser;

    #[test]
    fn parse_sql_works() {
        let url = &quot;http://abc.xyz/abc?a=1&amp;b=2&quot;;
        let sql = format!(
            &quot;select a, b, c from {} where a=1 order by c desc limit 5 offset 10&quot;,
            url
        );
        let statement = &amp;Parser::parse_sql(&amp;TyrDialect::default(), sql.as_ref()).unwrap()[0];
        let sql: Sql = statement.try_into().unwrap();
        assert_eq!(sql.source, url);
        assert_eq!(sql.limit, Some(5));
        assert_eq!(sql.offset, Some(10));
        assert_eq!(sql.order_by, vec![(&quot;c&quot;.into(), true)]);
        assert_eq!(sql.selection, vec![col(&quot;a&quot;), col(&quot;b&quot;), col(&quot;c&quot;)]);
    }
}
</code></pre></pre>
<h3 id="srcdialectrs"><a class="header" href="#srcdialectrs">src/dialect.rs</a></h3>
<h4 id="定义方言结构体"><a class="header" href="#定义方言结构体">定义方言结构体</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">#[derive(Debug, Default)]
pub struct TyrDialect;
</code></pre></pre>
<h4 id="给方言结构体实现trait"><a class="header" href="#给方言结构体实现trait">给方言结构体实现trait</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// 创建自己的 sql 方言。TyrDialect 支持 identifier 可以是简单的 url
impl Dialect for TyrDialect {
    fn is_identifier_start(&amp;self, ch: char) -&gt; bool {
        ('a'..='z').contains(&amp;ch) || ('A'..='Z').contains(&amp;ch) || ch == '_'
    }

    // identifier 可以有 ':', '/', '?', '&amp;', '='
    fn is_identifier_part(&amp;self, ch: char) -&gt; bool {
        ('a'..='z').contains(&amp;ch)
            || ('A'..='Z').contains(&amp;ch)
            || ('0'..='9').contains(&amp;ch)
            || [':', '/', '?', '&amp;', '=', '-', '_', '.'].contains(&amp;ch)
    }
}
</code></pre></pre>
<h4 id="添加测试用函数"><a class="header" href="#添加测试用函数">添加测试用函数</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 测试辅助函数
pub fn example_sql() -&gt; String {
    let url = &quot;https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv&quot;;

    let sql = format!(
        &quot;SELECT location name, total_cases, new_cases, total_deaths, new_deaths \
        FROM {} where new_deaths &gt;= 500 ORDER BY new_cases DESC LIMIT 6 OFFSET 5&quot;,
        url
    );

    sql
}
</code></pre></pre>
<h4 id="单元测试-3"><a class="header" href="#单元测试-3">单元测试</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">#[cfg(test)]
mod tests {
    use super::*;
    use sqlparser::parser::Parser;

    #[test]
    fn it_works() {
        assert!(Parser::parse_sql(&amp;TyrDialect::default(), &amp;example_sql()).is_ok());
    }
}
</code></pre></pre>
<h3 id="srcloaderrs"><a class="header" href="#srcloaderrs">src/loader.rs</a></h3>
<h4 id="定义loader与csvloader"><a class="header" href="#定义loader与csvloader">定义Loader与CsvLoader</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">#[derive(Debug)]
#[non_exhaustive]
pub enum Loader {
    Csv(CsvLoader),
}

#[derive(Default, Debug)]
pub struct CsvLoader(pub(crate) String);
</code></pre></pre>
<h4 id="定义trait并给csvloader实现"><a class="header" href="#定义trait并给csvloader实现">定义trait并给CsvLoader实现</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">
    let sql = format!(
        &quot;SELECT location name, total_cases, new_cases, total_deaths, new_deaths \
        FROM {} where new_deaths &gt;= 500 ORDER BY new_cases DESC LIMIT 6 OFFSET 5&quot;,
        url
    );

    sql
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlparser::parser::Parser;

</code></pre></pre>
<h4 id="todo-给csvloader添加内容检测"><a class="header" href="#todo-给csvloader添加内容检测">todo: 给CsvLoader添加内容检测</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">    fn it_works() {
        assert!(Parser::parse_sql(&amp;TyrDialect::default(), &amp;example_sql()).is_ok());
    }
}
</code></pre></pre>
<h3 id="srcfetcherrs"><a class="header" href="#srcfetcherrs">src/fetcher.rs</a></h3>
<h4 id="定义urlfetcher与filefetcher"><a class="header" href="#定义urlfetcher与filefetcher">定义UrlFetcher与FileFetcher</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">struct UrlFetcher&lt;'a&gt;(pub(crate) &amp;'a str);

struct FileFetcher&lt;'a&gt;(pub(crate) &amp;'a str);
</code></pre></pre>
<h4 id="定义trait并给fetcher与filefetcher实现"><a class="header" href="#定义trait并给fetcher与filefetcher实现">定义trait并给Fetcher与FileFetcher实现</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// Rust 的 async trait 还没有稳定，可以用 async_trait 宏
#[async_trait]
pub trait Fetch {
    type Error;
    async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt;;
}

#[async_trait]
impl&lt;'a&gt; Fetch for UrlFetcher&lt;'a&gt; {
    type Error = anyhow::Error;

    async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt; {
        Ok(reqwest::get(self.0).await?.text().await?)
    }
}

#[async_trait]
impl&lt;'a&gt; Fetch for FileFetcher&lt;'a&gt; {
    type Error = anyhow::Error;

    async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt; {
        Ok(fs::read_to_string(&amp;self.0[7..]).await?)
    }
}
</code></pre></pre>
<h4 id="最后定义一个获取数据的方法"><a class="header" href="#最后定义一个获取数据的方法">最后定义一个获取数据的方法</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 从文件源或者 http 源中获取数据，返回字符串
pub async fn retrieve_data(source: impl AsRef&lt;str&gt;) -&gt; Result&lt;String&gt; {
    let name = source.as_ref();
    match &amp;name[..4] {
        // 包括 http / https
        &quot;http&quot; =&gt; UrlFetcher(name).fetch().await,
        // 处理 file://&lt;filename&gt;
        &quot;file&quot; =&gt; FileFetcher(name).fetch().await,
        _ =&gt; Err(anyhow!(&quot;We only support http/https/file at the moment&quot;)),
    }
}
</code></pre></pre>
<h2 id="queryer-js-package-使用neon"><a class="header" href="#queryer-js-package-使用neon">queryer-js package: 使用neon</a></h2>
<h3 id="cargotoml-3"><a class="header" href="#cargotoml-3">Cargo.toml</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">[package]
name = &quot;queryer-js&quot;
version = &quot;0.1.0&quot;
license = &quot;ISC&quot;
edition = &quot;2021&quot;
exclude = [&quot;index.node&quot;]

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
anyhow = &quot;1&quot;
queryer = { path = &quot;../queryer&quot; }
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }

[dependencies.neon]
version = &quot;0.9&quot;
default-features = false
features = [&quot;napi-6&quot;]
</code></pre></pre>
<h3 id="build-in-packagejson"><a class="header" href="#build-in-packagejson">build in package.json</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">{
  &quot;name&quot;: &quot;queryer-js&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.node&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;cargo-cp-artifact -nc index.node -- cargo build --message-format=json-render-diagnostics&quot;,
    &quot;build-debug&quot;: &quot;npm run build --&quot;,
    &quot;build-release&quot;: &quot;npm run build -- --release&quot;,
    &quot;install&quot;: &quot;npm run build-release&quot;,
    &quot;test&quot;: &quot;cargo test&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;cargo-cp-artifact&quot;: &quot;^0.1&quot;
  }
}
</code></pre></pre>
<h3 id="srclibrs"><a class="header" href="#srclibrs">src/lib.rs</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use neon::prelude::*;

pub fn example_sql(mut cx: FunctionContext) -&gt; JsResult&lt;JsString&gt; {
    Ok(cx.string(queryer::example_sql()))
}

fn query(mut cx: FunctionContext) -&gt; JsResult&lt;JsString&gt; {
    let sql = cx.argument::&lt;JsString&gt;(0)?.value(&amp;mut cx);
    let output = match cx.argument::&lt;JsString&gt;(1) {
        Ok(v) =&gt; v.value(&amp;mut cx),
        Err(_) =&gt; &quot;csv&quot;.to_string(),
    };
    let rt = tokio::runtime::Runtime::new().unwrap();
    let data = rt.block_on(async { queryer::query(sql).await.unwrap() });

    match output.as_str() {
        &quot;csv&quot; =&gt; Ok(cx.string(data.to_csv().unwrap())),
        v =&gt; cx.throw_type_error(format!(&quot;Output type {} not supported&quot;, v)),
    }
}

#[neon::main]
fn main(mut cx: ModuleContext) -&gt; NeonResult&lt;()&gt; {
    cx.export_function(&quot;example_sql&quot;, example_sql)?;
    cx.export_function(&quot;query&quot;, query)?;
    Ok(())
}
</code></pre></pre>
<h2 id="queryer-py-package-使用pyo3"><a class="header" href="#queryer-py-package-使用pyo3">queryer-py package: 使用pyo3</a></h2>
<blockquote>
<p>python调用查询包</p>
</blockquote>
<h3 id="cargotoml-4"><a class="header" href="#cargotoml-4">Cargo.toml</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">[package]
name = &quot;queryer_py&quot; # Python 模块需要用下划线
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;


[lib]
crate-type = [&quot;cdylib&quot;] # 使用 cdylib 类型

[dependencies]
queryer = { path = &quot;../queryer&quot; } # 引入 queryer
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }

[dependencies.pyo3]
version = &quot;0.14&quot;
features = [&quot;extension-module&quot;]

[build-dependencies]
pyo3-build-config = &quot;0.14&quot;
</code></pre></pre>
<h3 id="buildrs-1"><a class="header" href="#buildrs-1">build.rs</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    pyo3_build_config::add_extension_module_link_args();
}
</code></pre></pre>
<h3 id="srclibrs-1"><a class="header" href="#srclibrs-1">src/lib.rs</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">#![allow(clippy::needless_option_as_deref)]
use pyo3::{exceptions, prelude::*};

#[pyfunction]
pub fn example_sql() -&gt; PyResult&lt;String&gt; {
    Ok(queryer::example_sql())
}

#[pyfunction]
pub fn query(sql: &amp;str, output: Option&lt;&amp;str&gt;) -&gt; PyResult&lt;String&gt; {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let data = rt.block_on(async { queryer::query(sql).await.unwrap() });
    match output {
        Some(&quot;csv&quot;) | None =&gt; Ok(data.to_csv().unwrap()),
        Some(v) =&gt; Err(exceptions::PyTypeError::new_err(format!(
            &quot;Output type {} not supported&quot;,
            v
        ))),
    }
}

#[pymodule]
fn queryer_py(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(query, m)?)?;
    m.add_function(wrap_pyfunction!(example_sql, m)?)?;
    Ok(())
}
</code></pre></pre>
<h2 id="data-viewer-package-使用tauri"><a class="header" href="#data-viewer-package-使用tauri">data-viewer package: 使用tauri</a></h2>
<h3 id="cargotoml-5"><a class="header" href="#cargotoml-5">Cargo.toml</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">[package]
name = &quot;app&quot;
version = &quot;0.1.0&quot;
description = &quot;A Tauri App&quot;
authors = [&quot;you&quot;]
license = &quot;&quot;
repository = &quot;&quot;
default-run = &quot;app&quot;
edition = &quot;2021&quot;
build = &quot;src/build.rs&quot;

<span class="boring">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</span>
[build-dependencies]
tauri-build = { version = &quot;1.0.0-beta.4&quot; }

[dependencies]
anyhow = &quot;1&quot;
serde_json = &quot;1&quot;
queryer = { path = &quot;../../queryer&quot; }
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
tauri = { version = &quot;1.0.0-beta.8&quot;, features = [&quot;api-all&quot;] }

[features]
default = [ &quot;custom-protocol&quot; ]
custom-protocol = [ &quot;tauri/custom-protocol&quot; ]
</code></pre></pre>
<h3 id="buildrs-2"><a class="header" href="#buildrs-2">build.rs</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
  tauri_build::build()
}
</code></pre></pre>
<h3 id="mainrs-1"><a class="header" href="#mainrs-1">main.rs</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">#![cfg_attr(
  all(not(debug_assertions), target_os = &quot;windows&quot;),
  windows_subsystem = &quot;windows&quot;
)]

#[tauri::command]
fn example_sql() -&gt; String {
  queryer::example_sql()
}

#[tauri::command]
async fn query(sql: String) -&gt; Result&lt;String, String&gt; {
  let data = queryer::query(&amp;sql).await.map_err(|err| err.to_string())?;
  Ok(data.to_csv().map_err(|err| err.to_string())?)
}

fn main() {
  tauri::Builder::default()
    .invoke_handler(tauri::generate_handler![example_sql, query])
    .run(tauri::generate_context!())
    .expect(&quot;error while running tauri application&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust核心深入"><a class="header" href="#rust核心深入">Rust核心深入</a></h1>
<h2 id="资料推荐"><a class="header" href="#资料推荐">资料推荐</a></h2>
<ul>
<li><a href="https://tyrchen.github.io/rust-training/rust-training-all-in-one-cn.html#1">陈天培训slides</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i-从栈堆所有权生命周期开始内存管理"><a class="header" href="#i-从栈堆所有权生命周期开始内存管理">I. 从栈堆、所有权、生命周期开始内存管理</a></h1>
<!--ts-->
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#i-%E4%BB%8E%E6%A0%88%E5%A0%86%E6%89%80%E6%9C%89%E6%9D%83%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BC%80%E5%A7%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">I. 从栈堆、所有权、生命周期开始内存管理</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%86%85%E5%AD%98">内存</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%9B%BE">字符串内存使用图</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E6%A0%88">栈</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E6%A0%88%E5%B8%A7%E7%A4%BA%E6%84%8F%E5%9B%BE">栈帧示意图</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E8%80%83%E8%99%91%E6%A0%88%E6%BA%A2%E5%87%BA">考虑栈溢出</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%A0%86">堆</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E4%BD%BF%E7%94%A8%E5%A0%86%E5%BC%95%E7%94%A8%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">使用堆引用共享数据</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E8%80%83%E8%99%91%E5%A0%86%E6%BA%A2%E5%87%BA">考虑堆溢出</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E7%BC%96%E7%A8%8B%E5%9B%9B%E5%A4%A7%E7%B1%BB%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">编程四大类基本概念</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#1-%E6%95%B0%E6%8D%AE">1. 数据</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%80%BC%E5%92%8C%E7%B1%BB%E5%9E%8B">值和类型</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8">指针和引用</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#2-%E4%BB%A3%E7%A0%81">2. 代码</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%87%BD%E6%95%B0---%E6%96%B9%E6%B3%95---%E9%97%AD%E5%8C%85">函数 -&gt; 方法 -&gt; 闭包</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E9%97%AD%E5%8C%85%E7%A4%BA%E6%84%8F%E5%9B%BE">闭包示意图</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%99%9A%E8%A1%A8">接口与虚表</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#3-%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F">3. 运行方式</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C">并发与并行</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5">同步和异步</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#4-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F">4. 编程范式</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B">泛型编程</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#rust%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%A7%88">Rust内存管理概览</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83-%E5%8D%95%E4%B8%80%E5%85%B1%E4%BA%AB">一、所有权: 单一/共享</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%8D%95%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83%E6%8E%8C%E6%8E%A7%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83">单一所有权：掌控生杀大权</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E4%BB%8E%E5%A4%9A%E5%BC%95%E7%94%A8%E5%BC%80%E5%A7%8B">从多引用开始</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#rust%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">Rust如何解决</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E6%96%B9%E6%A1%88%E4%B8%80%E5%8D%95%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83">方案一、单一所有权</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E6%96%B9%E6%A1%88%E4%BA%8Ccopy">方案二、Copy</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%8D%95%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86">单一所有权规则整理</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%8D%95%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83%E5%80%9F%E7%94%A8">单一所有权借用</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E4%B8%A4%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%E4%BC%A0%E5%80%BC%E4%BC%A0%E5%9D%80">两种传参方式：传值/传址</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%8F%AA%E8%AF%BB%E5%80%9F%E7%94%A8%E5%BC%95%E7%94%A8">只读借用/引用</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%80%9F%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E7%BA%A6%E6%9D%9F">借用的生命周期与约束</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%8F%AF%E5%8F%98%E5%80%9F%E7%94%A8%E5%BC%95%E7%94%A8">可变借用/引用</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3%E5%8D%95%E4%B8%80%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99">第一性原理理解单一所有权规则</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">共享内存-多个所有者：引用计数</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#rc%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-%E5%8F%AA%E8%AF%BB%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">Rc使用说明: 只读引用计数</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#rc%E4%BD%BF%E7%94%A8boxleak">Rc使用Box::leak()</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E4%BD%BF%E7%94%A8rc%E5%AE%9E%E7%8E%B0dag">使用Rc实现DAG</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#refcell-%E6%8F%90%E4%BE%9B%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">RefCell: 提供内部可变性，可变引用计数</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%A4%96%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B8%8E%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7">外部可变性与内部可变性</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#refcell%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">RefCell简单使用</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E4%BD%BF%E7%94%A8refcell%E5%AE%9E%E7%8E%B0%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%89%88%E6%9C%ACdag">使用RefCell实现可修改版本DAG</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%88%E6%9C%AC%E8%AE%A1%E6%95%B0%E5%99%A8arcrcmutexrwlockrefcell">线程安全版本计数器：Arc(Rc)、Mutex/RwLock(RefCell)</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E4%BA%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">二、生命周期</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%8A%A8%E6%80%81%E8%BF%98%E6%98%AF%E9%9D%99%E6%80%81">动态还是静态？</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">如何识别生命周期</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E4%B8%A4%E4%B8%AA%E5%B0%8F%E4%BE%8B%E5%AD%90">两个小例子</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E9%9C%80%E8%A6%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E7%9A%84%E6%83%85%E5%86%B5">需要生命周期标注的情况</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B6%E5%AE%9E%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8">编译器其实会自动进行生命周期标注</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E7%BB%83%E4%B9%A0">生命周期标注练习</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E7%9A%84%E7%9B%AE%E7%9A%84">生命周期标注的目的</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E4%B8%89%E8%9E%8D%E4%BC%9A%E8%B4%AF%E9%80%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1">三、融会贯通，从创建到消亡</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%88%9B%E5%BB%BA">创建</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%A0%86%E5%86%85%E5%AD%98%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%8F%91%E5%B1%95%E5%8F%B2">堆内存生命周期管理发展史</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#structenumvecstring%E5%88%9B%E5%BB%BA%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">struct/enum/vec/String创建时的内存布局</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#struct">struct</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#enum">enum</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#vec%E5%92%8Cstring">vec和String</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">引用类型的内存布局</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E6%9B%B4%E5%A4%9A%E5%8F%AF%E8%A7%81cheatsrs">更多可见cheats.rs</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E4%BD%BF%E7%94%A8">使用</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#copy%E5%92%8Cmove">copy和move</a></li>
</ul>
</li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#%E9%94%80%E6%AF%81">销毁</a>
<ul>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#drop%E9%87%8A%E6%94%BE%E5%A0%86%E5%86%85%E5%AD%98">drop释放堆内存</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#raii%E9%87%8A%E6%94%BE%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90">RAII释放其他资源</a></li>
<li><a href="1_stack_heap_ownership_lifetime_memory.html#rust%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%9F%A5%E8%B0%83%E7%94%A8drop">Rust在编译时、运行时检查调用drop</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Oct  4 07:24:32 UTC 2022 -->
<!--te-->
<h1 id="内存"><a class="header" href="#内存">内存</a></h1>
<h2 id="字符串内存使用图"><a class="header" href="#字符串内存使用图">字符串内存使用图</a></h2>
<details id="admonition-字符串内存使用图" class="admonition info">
<summary class="admonition-title">
<p>字符串内存使用图</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-字符串内存使用图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/01%EF%BD%9C%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%BC%E6%94%BE%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%94%BE%E6%A0%88%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98.jpg" alt="字符串内存使用图" /></p>
</div>
</details>
<h2 id="栈"><a class="header" href="#栈">栈</a></h2>
<h3 id="栈帧示意图"><a class="header" href="#栈帧示意图">栈帧示意图</a></h3>
<details id="admonition-栈帧示意图" class="admonition info">
<summary class="admonition-title">
<p>栈帧示意图</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-栈帧示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/01%EF%BD%9C%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%BC%E6%94%BE%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%94%BE%E6%A0%88%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98-4444135.jpg" alt="栈帧示意图" /></p>
</div>
</details>
<h3 id="考虑栈溢出"><a class="header" href="#考虑栈溢出">考虑栈溢出</a></h3>
<h2 id="堆"><a class="header" href="#堆">堆</a></h2>
<h3 id="使用堆引用共享数据"><a class="header" href="#使用堆引用共享数据">使用堆引用共享数据</a></h3>
<details id="admonition-使用堆引用共享内存数据" class="admonition info">
<summary class="admonition-title">
<p>使用堆引用共享内存数据</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-使用堆引用共享内存数据"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/01%EF%BD%9C%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%BC%E6%94%BE%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%94%BE%E6%A0%88%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98-4444274.jpg" alt="使用堆引用共享数据" /></p>
</div>
</details>
<h3 id="考虑堆溢出"><a class="header" href="#考虑堆溢出">考虑堆溢出</a></h3>
<details id="admonition-堆问题示意图" class="admonition info">
<summary class="admonition-title">
<p>堆问题示意图</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-堆问题示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/01%EF%BD%9C%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%BC%E6%94%BE%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%94%BE%E6%A0%88%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98.png" alt="堆问题" /></p>
</div>
</details>
<h1 id="编程四大类基本概念"><a class="header" href="#编程四大类基本概念">编程四大类基本概念</a></h1>
<h2 id="1-数据"><a class="header" href="#1-数据">1. 数据</a></h2>
<h3 id="值和类型"><a class="header" href="#值和类型">值和类型</a></h3>
<h3 id="指针和引用"><a class="header" href="#指针和引用">指针和引用</a></h3>
<h2 id="2-代码"><a class="header" href="#2-代码">2. 代码</a></h2>
<h3 id="函数---方法---闭包"><a class="header" href="#函数---方法---闭包">函数 -&gt; 方法 -&gt; 闭包</a></h3>
<h4 id="闭包示意图"><a class="header" href="#闭包示意图">闭包示意图</a></h4>
<details id="admonition-闭包与自由变量" class="admonition info">
<summary class="admonition-title">
<p>闭包与自由变量</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-闭包与自由变量"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/02%EF%BD%9C%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%BA%9B%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpg" alt="闭包与自由变量" /></p>
</div>
</details>
<h3 id="接口与虚表"><a class="header" href="#接口与虚表">接口与虚表</a></h3>
<details id="admonition-虚表示意图" class="admonition info">
<summary class="admonition-title">
<p>虚表示意图</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-虚表示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/02%EF%BD%9C%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%BA%9B%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4444557.jpg" alt="虚表" /></p>
</div>
</details>
<h2 id="3-运行方式"><a class="header" href="#3-运行方式">3. 运行方式</a></h2>
<h3 id="并发与并行"><a class="header" href="#并发与并行">并发与并行</a></h3>
<details id="admonition-并发与并行对比" class="admonition info">
<summary class="admonition-title">
<p>并发与并行对比</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-并发与并行对比"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/02%EF%BD%9C%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%BA%9B%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4444672.jpg" alt="并发与并行" /></p>
</div>
</details>
<h3 id="同步和异步"><a class="header" href="#同步和异步">同步和异步</a></h3>
<h2 id="4-编程范式"><a class="header" href="#4-编程范式">4. 编程范式</a></h2>
<h3 id="泛型编程"><a class="header" href="#泛型编程">泛型编程</a></h3>
<details id="admonition-泛型编程更抽象更通用" class="admonition info">
<summary class="admonition-title">
<p>泛型编程更抽象，更通用</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-泛型编程更抽象更通用"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/02%EF%BD%9C%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%BA%9B%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4444741.jpg" alt="泛型编程更抽象，更通用" /></p>
</div>
</details>
<h3 id="函数式编程"><a class="header" href="#函数式编程">函数式编程</a></h3>
<h3 id="面向对象编程"><a class="header" href="#面向对象编程">面向对象编程</a></h3>
<h1 id="rust内存管理概览"><a class="header" href="#rust内存管理概览">Rust内存管理概览</a></h1>
<h2 id="一所有权-单一共享"><a class="header" href="#一所有权-单一共享">一、所有权: 单一/共享</a></h2>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4606985.jpg" alt="单一/共享所有权对比" /></p>
<h2 id="单一所有权掌控生杀大权"><a class="header" href="#单一所有权掌控生杀大权">单一所有权：掌控生杀大权</a></h2>
<h3 id="从多引用开始"><a class="header" href="#从多引用开始">从多引用开始</a></h3>
<details id="admonition-多重堆引用问题" class="admonition info">
<summary class="admonition-title">
<p>多重堆引用问题</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-多重堆引用问题"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/07%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%81%E6%89%8B%E4%B8%8A%EF%BC%9F-4446989.jpg" alt="多重堆引用的问题" /></p>
</div>
</details>
<h3 id="rust如何解决"><a class="header" href="#rust如何解决">Rust如何解决</a></h3>
<h4 id="方案一单一所有权"><a class="header" href="#方案一单一所有权">方案一、单一所有权</a></h4>
<details id="admonition-单一所有权解决多重引用问题" class="admonition info">
<summary class="admonition-title">
<p>单一所有权解决多重引用问题</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-单一所有权解决多重引用问题"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/07%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%81%E6%89%8B%E4%B8%8A%EF%BC%9F-4446891.jpg" alt="rust所有权规则解决多重引用问题" /></p>
</div>
</details>
<h4 id="方案二copy"><a class="header" href="#方案二copy">方案二、Copy</a></h4>
<details id="admonition-使用copy解决多重引用问题" class="admonition info">
<summary class="admonition-title">
<p>使用Copy解决多重引用问题</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-使用copy解决多重引用问题"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/07%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%81%E6%89%8B%E4%B8%8A%EF%BC%9F-4447051.jpg" alt="Copy解决" /></p>
</div>
</details>
<h3 id="单一所有权规则整理"><a class="header" href="#单一所有权规则整理">单一所有权规则整理</a></h3>
<details id="admonition-单一所有权规则整理" class="admonition info">
<summary class="admonition-title">
<p>单一所有权规则整理</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-单一所有权规则整理"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/07%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E7%94%9F%E6%9D%80%E5%A4%A7%E6%9D%83%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%81%E6%89%8B%E4%B8%8A%EF%BC%9F-4447111.jpg" alt="所有权规则整理" /></p>
</div>
</details>
<h3 id="单一所有权借用"><a class="header" href="#单一所有权借用">单一所有权借用</a></h3>
<h4 id="两种传参方式传值传址"><a class="header" href="#两种传参方式传值传址">两种传参方式：传值/传址</a></h4>
<details id="admonition-传值-or-传址" class="admonition info">
<summary class="admonition-title">
<p>传值 or 传址</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-传值-or-传址"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/08%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F.jpg" alt="传值/传址" /></p>
</div>
</details>
<h4 id="只读借用引用"><a class="header" href="#只读借用引用">只读借用/引用</a></h4>
<details id="admonition-只读借用引用" class="admonition info">
<summary class="admonition-title">
<p>只读借用/引用</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-只读借用引用"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/08%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F-4447323.jpg" alt="只读" /></p>
</div>
</details>
<h4 id="借用的生命周期与约束"><a class="header" href="#借用的生命周期与约束">借用的生命周期与约束</a></h4>
<details id="admonition-三段生命周期分析" class="admonition info">
<summary class="admonition-title">
<p>三段生命周期分析</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-三段生命周期分析"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/08%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F-4447702.jpg" alt="三段生命周期分析" /></p>
</div>
</details>
<h4 id="可变借用引用"><a class="header" href="#可变借用引用">可变借用/引用</a></h4>
<blockquote>
<p>同一个上下文中多个可变引用是不安全的，那如果同时有一个可变引用和若干个只读引 用就可以</p>
</blockquote>
<h4 id="第一性原理理解单一所有权规则"><a class="header" href="#第一性原理理解单一所有权规则">第一性原理理解单一所有权规则</a></h4>
<details id="admonition-第一性原理理解所有权模型单一所有权共享所有权" class="admonition info">
<summary class="admonition-title">
<p>第一性原理理解所有权模型：单一所有权/共享所有权</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-第一性原理理解所有权模型单一所有权共享所有权"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/08%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E5%80%BC%E7%9A%84%E5%80%9F%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F-4447883.jpg" alt="第一性原理" /></p>
</div>
</details>
<h2 id="共享内存-多个所有者引用计数"><a class="header" href="#共享内存-多个所有者引用计数">共享内存-多个所有者：引用计数</a></h2>
<details id="admonition-单一所有权与多个所有者是否有冲突" class="admonition info">
<summary class="admonition-title">
<p>单一所有权与多个所有者是否有冲突？</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-单一所有权与多个所有者是否有冲突"></a></p>
</summary>
<div>
<ol>
<li>静态检查：单一所有权是rust的编译期默认检查内容</li>
<li>动态检查：多个所有者主要是用于共享内存，这是专门提供Rc/Arc、Box::leak()、RefCell/Mutex/RwLock等工具。</li>
</ol>
<hr />
<blockquote>
<p>这里其实可以看出rust如何使用’二八法则’解决问题：</p>
</blockquote>
<ul>
<li>对于常用场景，用编译期静态检查来默认解决</li>
<li>对于特别场景，用专门的语法显式表达出来，提供运行期动态检查来专门解决</li>
</ul>
</div>
</details>
<h3 id="rc使用说明-只读引用计数"><a class="header" href="#rc使用说明-只读引用计数">Rc使用说明: 只读引用计数</a></h3>
<details id="admonition-对一个-rc-结构进行-clone不会将其内部的数据复制只会增加引用计数" class="admonition info">
<summary class="admonition-title">
<p>对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-对一个-rc-结构进行-clone不会将其内部的数据复制只会增加引用计数"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::rc::Rc;
fn main() {
    let a = Rc::new(1);
    let b = a.clone();
    let c = a.clone();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-上方代码rc引用计数示意图共享堆内存" class="admonition info">
<summary class="admonition-title">
<p>上方代码Rc引用计数示意图：共享堆内存</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-上方代码rc引用计数示意图共享堆内存"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4604653.jpg" alt="引用计数示意图" /></p>
</div>
</details>
<details id="admonition-clone源码" class="admonition info">
<summary class="admonition-title">
<p>clone源码</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-clone源码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn clone(&amp;self) -&gt; Rc&lt;T&gt; {
    // 增加引用计数
    self.inner().inc_strong();
    // 通过 self.ptr 生成一个新的 Rc 结构
    Self::from_inner(self.ptr)
}
</code></pre></pre>
</div>
</details>
<h4 id="rc使用boxleak"><a class="header" href="#rc使用boxleak">Rc使用Box::leak()</a></h4>
<details id="admonition-使用boxleak创建不受栈内存控制堆堆内存示意图" class="admonition info">
<summary class="admonition-title">
<p>使用Box::leak()创建不受栈内存控制堆堆内存示意图</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-使用boxleak创建不受栈内存控制堆堆内存示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4605420.jpg" alt="使用Box::leak()创建不受栈内存控制堆堆内存示意图" /></p>
</div>
</details>
<details id="admonition-有了-boxleak我们就可以跳出-rust-编译器的静态检查" class="admonition info">
<summary class="admonition-title">
<p>有了 Box::leak()，我们就可以跳出 Rust 编译器的静态检查</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-有了-boxleak我们就可以跳出-rust-编译器的静态检查"></a></p>
</summary>
<div>
<p>保证 Rc 指向的堆内存，有最大的生命周期，然后我们再通过引用计数，在合适的时机，结束这段内存的生命周期。如果你对此感兴趣，可以看 <a href="https://doc.rust-lang.org/src/alloc/rc.rs.html#342-350">Rc::new() 的源码</a>。</p>
</div>
</details>
<h4 id="使用rc实现dag"><a class="header" href="#使用rc实现dag">使用Rc实现DAG</a></h4>
<details id="admonition-dag数据结构示意图" class="admonition info">
<summary class="admonition-title">
<p>DAG数据结构示意图</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-dag数据结构示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4607216.jpg" alt="DAG数据结构" /></p>
</div>
</details>
<details id="admonition-不可修改版本" class="admonition info">
<summary class="admonition-title">
<p>不可修改版本</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-不可修改版本"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::rc::Rc;

#[allow(dead_code)]
#[derive(Debug)]
struct Node {
    id: usize,
    downstream: Option&lt;Rc&lt;Node&gt;&gt;,
}

impl Node {
    pub fn new(id: usize) -&gt; Self {
        Self {
            id,
            downstream: None,
        }
    }

    pub fn update_downstream(&amp;mut self, downstream: Rc&lt;Node&gt;) {
        self.downstream = Some(downstream);
    }

    pub fn get_downstream(&amp;self) -&gt; Option&lt;Rc&lt;Node&gt;&gt; {
        self.downstream.as_ref().cloned()
    }
}

fn main() {
    let mut node1 = Node::new(1);
    let mut node2 = Node::new(2);
    let mut node3 = Node::new(3);
    let node4 = Node::new(4);
    node3.update_downstream(Rc::new(node4));

    node1.update_downstream(Rc::new(node3));
    node2.update_downstream(node1.get_downstream().unwrap());
    println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);

    // 无法编译通过: cannot borrow as mutable
    // let node5 = Node::new(5);
    // let node3 = node1.get_downstream().unwrap();
    // node3.update_downstream(Rc::new(node5));

    // println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);
}
</code></pre></pre>
<ul>
<li>new()：建立一个新的 Node。</li>
<li>update_downstream()：设置 Node 的 downstream。</li>
<li>get_downstream()：clone 一份 Node 里的 downstream。</li>
</ul>
</div>
</details>
<h3 id="refcell-提供内部可变性可变引用计数"><a class="header" href="#refcell-提供内部可变性可变引用计数">RefCell: 提供内部可变性，可变引用计数</a></h3>
<h4 id="外部可变性与内部可变性"><a class="header" href="#外部可变性与内部可变性">外部可变性与内部可变性</a></h4>
<details id="admonition-外部可变性与内部可变性对比图" class="admonition info">
<summary class="admonition-title">
<p>外部可变性与内部可变性对比图</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-外部可变性与内部可变性对比图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4606188-4606221.jpg" alt="外部可变性与内部可变性" /></p>
</div>
</details>
<h4 id="refcell简单使用"><a class="header" href="#refcell简单使用">RefCell简单使用</a></h4>
<details id="admonition-获得-refcell-内部数据的可变借用" class="admonition info">
<summary class="admonition-title">
<p>获得 RefCell 内部数据的可变借用</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-获得-refcell-内部数据的可变借用"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::cell::RefCell;

fn main() {
    let data = RefCell::new(1);
    {
        // 获得 RefCell 内部数据的可变借用
        let mut v = data.borrow_mut();
        *v += 1;
    }
    println!(&quot;data: {:?}&quot;, data.borrow());
}
</code></pre></pre>
</div>
</details>
<h4 id="使用refcell实现可修改版本dag"><a class="header" href="#使用refcell实现可修改版本dag">使用RefCell实现可修改版本DAG</a></h4>
<details id="admonition-不可修改版本-1" class="admonition info">
<summary class="admonition-title">
<p>不可修改版本</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-不可修改版本-1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::cell::RefCell;
use std::rc::Rc;

#[allow(dead_code)]
#[derive(Debug)]
struct Node {
    id: usize,
    // 使用 Rc&lt;RefCell&lt;T&gt;&gt; 让节点可以被修改
    downstream: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

impl Node {
    pub fn new(id: usize) -&gt; Self {
        Self {
            id,
            downstream: None,
        }
    }

    pub fn update_downstream(&amp;mut self, downstream: Rc&lt;RefCell&lt;Node&gt;&gt;) {
        self.downstream = Some(downstream);
    }

    pub fn get_downstream(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt; {
        self.downstream.as_ref().cloned()
    }
}

fn main() {
    let mut node1 = Node::new(1);
    let mut node2 = Node::new(2);
    let mut node3 = Node::new(3);
    let node4 = Node::new(4);

    node3.update_downstream(Rc::new(RefCell::new(node4)));
    node1.update_downstream(Rc::new(RefCell::new(node3)));
    node2.update_downstream(node1.get_downstream().unwrap());
    println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);

    let node5 = Node::new(5);
    let node3 = node1.get_downstream().unwrap();
    // 获得可变引用，来修改 downstream
    node3.borrow_mut().downstream = Some(Rc::new(RefCell::new(node5)));

    println!(&quot;node1: {:?}, node2: {:?}&quot;, node1, node2);
}
</code></pre></pre>
<ol>
<li>首先数据结构的 downstream 需要 Rc 内部嵌套一个 RefCell</li>
<li>这样，就可以利用 RefCell 的内部可变性，来获得数据的可变借用</li>
<li>同时 Rc 还允许值有多个所有者。</li>
</ol>
</div>
</details>
<details id="admonition-refcell内部可变性示意图" class="admonition info">
<summary class="admonition-title">
<p>RefCell内部可变性示意图</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-refcell内部可变性示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/09%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%89%80%E6%9C%89%E8%80%85%E4%B9%88%EF%BC%9F-4606429.jpg" alt="使用RefCell实现可修改版本DAG" /></p>
</div>
</details>
<h3 id="线程安全版本计数器arcrcmutexrwlockrefcell"><a class="header" href="#线程安全版本计数器arcrcmutexrwlockrefcell">线程安全版本计数器：Arc(Rc)、Mutex/RwLock(RefCell)</a></h3>
<details id="admonition-rust实现两套不同的引用计数数据结构" class="admonition info">
<summary class="admonition-title">
<p>Rust实现两套不同的引用计数数据结构</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-rust实现两套不同的引用计数数据结构"></a></p>
</summary>
<div>
<blockquote>
<p>Arc 内部的引用计数使用了 <a href="https://doc.rust-lang.org/src/alloc/sync.rs.html#303-312">Atomic Usize</a> ，而非普通的 usize。
从名称上也可以感觉出来，Atomic Usize 是 usize 的原子类型，它使用了 CPU 的特殊指令，来保证多线程下的安全。
如果你对原子类型感兴趣，可以看 <a href="https://doc.rust-lang.org/std/sync/atomic/index.html">std::sync::atomic</a> 的文档。</p>
</blockquote>
<p>Rust 实现两套不同的引用计数数据结构，完全是为了性能考虑，从这里我们也可以感受到 Rust 对性能的极致渴求:</p>
<ul>
<li>如果不用跨线程访问，可以用效率非常高的 Rc； 如果要跨线程访问，那么必须用 Arc。</li>
<li>同样的，RefCell 也不是线程安全的，如果我们要在多线程中，使用内部可变性，Rust 提供了 Mutex 和 RwLock。</li>
</ul>
</div>
</details>
<details id="admonition-mutexrwlock其实是并发的两个方案" class="admonition info">
<summary class="admonition-title">
<p>Mutex/RwLock其实是并发的两个方案</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-mutexrwlock其实是并发的两个方案"></a></p>
</summary>
<div>
<p>这两个数据结构你应该都不陌生:</p>
<ol>
<li>Mutex 是互斥量，获得互斥量的线程对数据独占访问.</li>
<li>RwLock 是读写锁，获得写锁的线程对数据独占访问，但当没有写锁的时候，允许有多个读锁。 </li>
<li>读写锁的规则和 Rust 的借用规则非常类似，我们可以类比着学。</li>
<li>Mutex 和 RwLock 都用在多线程环境下，对共享数据访问的保护上。</li>
<li>前面构建的 DAG 如果要用在多线程环境下，需要把 Rc&gt; 替换为 Arc&gt; 或者 Arc&gt;。</li>
</ol>
</div>
</details>
<h2 id="二生命周期"><a class="header" href="#二生命周期">二、生命周期</a></h2>
<h3 id="动态还是静态"><a class="header" href="#动态还是静态">动态还是静态？</a></h3>
<details id="admonition-动态静态生命周期定义与表示方式" class="admonition info">
<summary class="admonition-title">
<p>动态/静态生命周期定义与表示方式</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-动态静态生命周期定义与表示方式"></a></p>
</summary>
<div>
<ol>
<li>静态生命周期: ’static str</li>
</ol>
<ul>
<li>如果一个值的生命周期贯穿整个进程的生命周期，那么我们就称这种生命周期为静态生命周期。</li>
<li>当值拥有静态生命周期，其引用也具有静态生命周期。</li>
<li>我们在表述这种引用的时候，可以用 ’static 来表示。比如： &amp;’static str 代表这是一个具有静态生命周期的字符串引用。</li>
<li>一般来说，全局变量、静态变量、字符串字面量（string literal (字面) ）等，都拥有静态生命周期。</li>
<li>堆内存，如果使用了 Box::leak 后，也具有静态生命周期。</li>
</ul>
<ol start="2">
<li>动态生命周期: ’a 、’b 或者 ’hello 这样的小写字符或者字符串来表述</li>
</ol>
<ul>
<li>如果一个值是在某个作用域中定义的，也就是说它被创建在栈上或者堆上，那么其生命周期是动态的。</li>
<li>当这个值的作用域结束时，值的生命周期也随之结束。</li>
<li>对于动态生命周期，我们约定用 ’a 、’b 或者 ’hello 这样的小写字符或者字符串来表述。 </li>
<li>’ 后面具体是什么名字不重要，它代表某一段动态的生命周期</li>
<li>其中， &amp;’a str 和 &amp;’b str 表示这两个字符串引用的生命周期可能不一致。</li>
</ul>
</div>
</details>
<details id="admonition-动静态生命周期示意图" class="admonition info">
<summary class="admonition-title">
<p>动静态生命周期示意图</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-动静态生命周期示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/10%EF%BD%9C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%BD%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%80%BC%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%B4%BB%E5%A4%9A%E4%B9%85%EF%BC%9F.jpg" alt="动静态生命周期示意图" /></p>
<ol>
<li>分配在堆和栈上的内存有其各自的作用域，它们的生命周期是动态的。</li>
<li>全局变量、静态变量、字符串字面量、代码等内容，在编译时，会被编译到可执行文件中的 BSS/Data/RoData/Text 段，然后在加载时，装入内存。</li>
<li>因而，它们的生命周期和进程的生命周期一致，所以是静态的。</li>
<li>所以，函数指针的生命周期也是静态的，因为函数在 Text 段中，只要进程活着，其内存一直存在。</li>
</ol>
</div>
</details>
<h3 id="如何识别生命周期"><a class="header" href="#如何识别生命周期">如何识别生命周期</a></h3>
<h4 id="两个小例子"><a class="header" href="#两个小例子">两个小例子</a></h4>
<details id="admonition-两个小例子" class="admonition info">
<summary class="admonition-title">
<p>两个小例子</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-两个小例子"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/10%EF%BD%9C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%BD%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%80%BC%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%B4%BB%E5%A4%9A%E4%B9%85%EF%BC%9F-4607802.jpg" alt="识别生命周期的两个小例子" /></p>
<ol>
<li>x 引用了在内层作用域中创建出来的变量 y。由于，变量从开始定义到其作用域结束的这段时间，是它的生命周期，所以 x 的生命周期 ’a 大于 y 的生命周期 ’b，当 x 引用 y 时，编译器报错。</li>
</ol>
<hr />
<ol start="2">
<li>y 和 x 处在同一个作用域下， x 引用了 y，我们可以看到 x 的生命周期 ’a 和 y 的生命周期 ’b 几乎同时结束，或者说 ’a 小于等于 ’b，所以，x 引用 y 是可行的。</li>
</ol>
</div>
</details>
<h4 id="需要生命周期标注的情况"><a class="header" href="#需要生命周期标注的情况">需要生命周期标注的情况</a></h4>
<details id="admonition-missing-lifetime-specifier" class="admonition info">
<summary class="admonition-title">
<p>missing lifetime specifier</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-missing-lifetime-specifier"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let s1 = String::from(&quot;Lindsey&quot;);
    let s2 = String::from(&quot;Rosie&quot;);

    let result = max(&amp;s1, &amp;s2);

    println!(&quot;bigger one: {}&quot;, result);

    let result = get_max(s1);
    println!(&quot;bigger one: {}&quot;, result);
}

fn get_max(s1: &amp;str) -&gt; &amp;str {
    // 字符串字面量的生命周期是静态的，而 s1 是动态的，它们的生命周期显然不一致
    max(s1, &quot;Cynthia&quot;)
}

// 这段代码无法编译通过
fn max(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {
    if s1 &gt; s2 {
        s1
    } else {
        s2
    }
}
</code></pre></pre>
<ol>
<li>编译器在编译 max() 函数时，无法判断 s1、s2 和返回值的生命周期。</li>
<li>函数本身携带的信息，就是编译器在编译时使用的全部信息。</li>
<li>这里函数本身提供的信息就告诉编译期，生命周期不一致</li>
</ol>
</div>
</details>
<details id="admonition-添加生命周期标注即可编译通过" class="admonition info">
<summary class="admonition-title">
<p>添加生命周期标注即可编译通过</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-添加生命周期标注即可编译通过"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let s1 = String::from(&quot;Lindsey&quot;);
    let s2 = String::from(&quot;Rosie&quot;);

    let result = max(&amp;s1, &amp;s2);

    println!(&quot;bigger one: {}&quot;, result);

    let result = get_max(&amp;s1);
    println!(&quot;bigger one: {}&quot;, result);
}

fn get_max(s1: &amp;str) -&gt; &amp;str {
    max(s1, &quot;Cynthia&quot;)
}

fn max&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {
    if s1 &gt; s2 {
        s1
    } else {
        s2
    }
}
</code></pre></pre>
</div>
</details>
<h4 id="编译器其实会自动进行生命周期标注"><a class="header" href="#编译器其实会自动进行生命周期标注">编译器其实会自动进行生命周期标注</a></h4>
<blockquote>
<p>编译器希望尽可能减轻开发者的负担，其实所有使用了引用的函数，都需要生命周期的标注，只不过编译器会自动做这件事，省却了开发者的麻烦</p>
</blockquote>
<details id="admonition-编译器自动进行生命周期标注" class="admonition info">
<summary class="admonition-title">
<p>编译器自动进行生命周期标注</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-编译器自动进行生命周期标注"></a></p>
</summary>
<div>
<ol>
<li>无标注版本</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let s1 = &quot;Hello world&quot;;

    println!(&quot;first word of s1: {}&quot;, first(s1));
}

// 如果你用 clippy，多余的 lifetime 会提醒你不需要
// fn first&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
fn first(s: &amp;str) -&gt; &amp;str {
    let trimmed = s.trim();
    match trimmed.find(' ') {
        None =&gt; &quot;&quot;,
        Some(pos) =&gt; &amp;trimmed[..pos],
    }
}
</code></pre></pre>
<hr />
<ol start="2">
<li>自动标注</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let s1 = &quot;Lindsey&quot;;
    let s2 = String::from(&quot;Rosie&quot;);

    let result = max(s1, &amp;s2);

    println!(&quot;bigger one: {}&quot;, result);
}

fn max&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {
    if s1 &gt; s2 {
        s1
    } else {
        s2
    }
}
</code></pre></pre>
<blockquote>
<p>返回值如何标注？是 ’a 还是’b 呢？这里的冲突，编译器无能为力。</p>
</blockquote>
</div>
</details>
<details id="admonition-自动标注规则" class="admonition info">
<summary class="admonition-title">
<p>自动标注规则</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-自动标注规则"></a></p>
</summary>
<div>
<ol>
<li>所有引用类型的参数都有独立的生命周期 ’a 、’b 等。</li>
<li>如果只有一个引用型输入，它的生命周期会赋给所有输出。</li>
<li>如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出。</li>
</ol>
</div>
</details>
<h4 id="生命周期标注练习"><a class="header" href="#生命周期标注练习">生命周期标注练习</a></h4>
<details id="admonition-标注练习题" class="admonition info">
<summary class="admonition-title">
<p>标注练习题</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-标注练习题"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn strtok(s: &amp;mut &amp;str, delimiter: char) -&gt; &amp;str {
    if let Some(i) = s.find(delimiter) {
        let prefix = &amp;s[..i];
        // 由于 delimiter 可以是 utf8，所以我们需要获得其 utf8 长度，
        // 直接使用 len 返回的是字节长度，会有问题
        let suffix = &amp;s[(i + delimiter.len_utf8())..];
        *s = suffix;
        prefix
    } else { // 如果没找到，返回整个字符串，把原字符串指针 s 指向空串
        let prefix = *s;
        *s = &quot;&quot;;
        prefix
    }
}

fn main() {
    let s = &quot;hello world&quot;.to_owned();
    let mut s1 = s.as_str();
    let hello = strtok(&amp;mut s1, ' ');
    println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);
}
</code></pre></pre>
<ol>
<li>按照编译器的规则， &amp;mut &amp;str 添加生命周期后变成 &amp;’b mut &amp;’a str</li>
<li>这将导致返回的 ’&amp;str 无法选择一个合适的生命周期。</li>
</ol>
</div>
</details>
<details id="admonition-标注练习题参考" class="admonition info">
<summary class="admonition-title">
<p>标注练习题参考</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-标注练习题参考"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">pub fn strtok&lt;'a&gt;(s: &amp;mut &amp;'a str, delimiter: char) -&gt; &amp;'a str {
    if let Some(i) = s.find(delimiter) {
        let prefix = &amp;s[..i];
        let suffix = &amp;s[(i + delimiter.len_utf8())..];
        *s = suffix;
        prefix
    } else {
        let prefix = *s;
        *s = &quot;&quot;;
        prefix
    }
}

fn main() {
    let s = &quot;hello world&quot;.to_owned();
    let mut s1 = s.as_str();
    let hello = strtok(&amp;mut s1, ' ');
    println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);
}
</code></pre></pre>
<hr />
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/10%EF%BD%9C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%BD%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%80%BC%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%B4%BB%E5%A4%9A%E4%B9%85%EF%BC%9F-4609161.jpg" alt="标注练习示意图" /></p>
</div>
</details>
<h4 id="生命周期标注的目的"><a class="header" href="#生命周期标注的目的">生命周期标注的目的</a></h4>
<details id="admonition-生命周期标注的目的是在参数和返回值之间建立联系或者约束" class="admonition info">
<summary class="admonition-title">
<p>生命周期标注的目的是，在参数和返回值之间建立联系或者约束</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-生命周期标注的目的是在参数和返回值之间建立联系或者约束"></a></p>
</summary>
<div>
<p>生命周期标注的目的是，在参数和返回值之间建立联系或者约束:</p>
<ol>
<li>调用函数时，传入的参数的生命周期需要大于等于标注的生命周期。</li>
<li>当每个函数都添加好生命周期标注后，编译器，就可以从函数调用的上下文中分析出，在传参时，引用的生命周期，是否和函数签名中要求的生命周期匹配。</li>
<li>如果不匹配，就违背了“引用的生命周期不能超出值的生命周期”，编译器就会报错。</li>
</ol>
</div>
</details>
<h2 id="三融会贯通从创建到消亡"><a class="header" href="#三融会贯通从创建到消亡">三、融会贯通，从创建到消亡</a></h2>
<h2 id="创建"><a class="header" href="#创建">创建</a></h2>
<h3 id="堆内存生命周期管理发展史"><a class="header" href="#堆内存生命周期管理发展史">堆内存生命周期管理发展史</a></h3>
<details id="admonition-堆内存生命周期管理发展史" class="admonition info">
<summary class="admonition-title">
<p>堆内存生命周期管理发展史</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-堆内存生命周期管理发展史"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.jpg" alt="堆内存生命周期管理发展史" /></p>
</div>
</details>
<details id="admonition-堆内存管理需求动态大小-or-生命周期" class="admonition info">
<summary class="admonition-title">
<p>堆内存管理需求：动态大小 or 生命周期</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-堆内存管理需求动态大小-or-生命周期"></a></p>
</summary>
<div>
<p>Rust 的创造者们，重新审视了堆内存的生命周期，发现:</p>
<ul>
<li>大部分堆内存的需求在于动态大小</li>
<li>小部分需求是更长的生命周期。</li>
</ul>
<blockquote>
<p>所以它默认将堆内存的生命周期和使用它的栈内存的生命周期绑在一起，并留了个小口子 leaked 机制，让堆内存在需要的时候，可以有超出帧存活期的生命周期。</p>
</blockquote>
<hr />
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4639705.jpg" alt="Rust与其他编程语言堆内存管理对比" /></p>
</div>
</details>
<h3 id="structenumvecstring创建时的内存布局"><a class="header" href="#structenumvecstring创建时的内存布局">struct/enum/vec/String创建时的内存布局</a></h3>
<h4 id="struct"><a class="header" href="#struct">struct</a></h4>
<details id="admonition-内存布局优化示意图" class="admonition info">
<summary class="admonition-title">
<p>内存布局优化示意图</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-内存布局优化示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4639867.jpg" alt="内存布局优化示意图" /></p>
</div>
</details>
<details id="admonition-c语言手动优化内存布局" class="admonition info">
<summary class="admonition-title">
<p>c语言手动优化内存布局</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-c语言手动优化内存布局"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4639905.jpg" alt="c语言手动优化内存布局" /></p>
</div>
</details>
<details id="admonition-c语言手动优化内存布局与rust自动优化内存布局对比" class="admonition info">
<summary class="admonition-title">
<p>c语言手动优化内存布局与rust自动优化内存布局对比</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-c语言手动优化内存布局与rust自动优化内存布局对比"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4639936.jpg" alt="c语言手动优化内存布局与rust自动优化内存布局对比" /></p>
</div>
</details>
<details id="admonition-代码对比rust和clang的内存布局优化" class="admonition info">
<summary class="admonition-title">
<p>代码对比rust和clang的内存布局优化</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-代码对比rust和clang的内存布局优化"></a></p>
</summary>
<div>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct S1 {
    u_int8_t a;
    u_int16_t b;
    u_int8_t c;
};

struct S2 {
    u_int8_t a;
    u_int8_t c;
    u_int16_t b;
};

void main() {
    printf(&quot;size of S1: %d, S2: %d&quot;, sizeof(struct S1), sizeof(struct S2));
}
</code></pre>
<hr />
<pre><pre class="playground"><code class="language-rust  editable">use std::mem::{align_of, size_of};

#[allow(dead_code)]
struct S1 {
    a: u8,
    b: u16,
    c: u8,
}

#[allow(dead_code)]
struct S2 {
    a: u8,
    c: u8,
    b: u16,
}

fn main() {
    println!(&quot;sizeof S1: {}, S2: {}&quot;, size_of::&lt;S1&gt;(), size_of::&lt;S2&gt;());
    println!(&quot;alignof S1: {}, S2: {}&quot;, align_of::&lt;S1&gt;(), align_of::&lt;S2&gt;());
}
</code></pre></pre>
</div>
</details>
<h4 id="enum"><a class="header" href="#enum">enum</a></h4>
<details id="admonition-enumoptionresult内存布局对比" class="admonition info">
<summary class="admonition-title">
<p>enum/Option<T>/Result&lt;T,E&gt;内存布局对比</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-enumoptionresult内存布局对比"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4640218.jpg" alt="enum/Option&lt;T&gt;/Result&lt;T,E&gt;内存布局对比" /></p>
</div>
</details>
<details id="admonition-rust-编译器会对-enum-做一些额外的优化让某些常用结构的内存布局更紧凑" class="admonition info">
<summary class="admonition-title">
<p>Rust 编译器会对 enum 做一些额外的优化，让某些常用结构的内存布局更紧凑。</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-rust-编译器会对-enum-做一些额外的优化让某些常用结构的内存布局更紧凑"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::collections::HashMap;
use std::mem::size_of;

#[allow(dead_code)]
enum E {
    A(f64),
    B(HashMap&lt;String, String&gt;),
    C(Result&lt;Vec&lt;u8&gt;, String&gt;),
}

macro_rules! show_size {
    (header) =&gt; {
        println!(
            &quot;{:&lt;24} {:&gt;4}    {}    {}&quot;,
            &quot;Type&quot;, &quot;T&quot;, &quot;Option&lt;T&gt;&quot;, &quot;Result&lt;T, io::Error&gt;&quot;
        );
        println!(&quot;{}&quot;, &quot;-&quot;.repeat(64));
    };
    ($t:ty) =&gt; {
        println!(
            &quot;{:&lt;24} {:4} {:8} {:12}&quot;,
            stringify!($t),
            size_of::&lt;$t&gt;(),
            size_of::&lt;Option&lt;$t&gt;&gt;(),
            size_of::&lt;Result&lt;$t, std::io::Error&gt;&gt;(),
        )
    };
}

fn main() {
    show_size!(header);
    show_size!(u8);
    show_size!(f64);
    show_size!(&amp;u8);
    show_size!(Box&lt;u8&gt;);
    show_size!(&amp;[u8]);

    show_size!(String);
    show_size!(Vec&lt;u8&gt;);
    show_size!(HashMap&lt;String, String&gt;);
    show_size!(E);
}
</code></pre></pre>
<hr />
<blockquote>
<p>你会发现，Option 配合带有引用类型的数据结构，比如 &amp;u8、Box、Vec、HashMap ，没有额外占用空间，这就很有意思了</p>
</blockquote>
<pre><code class="language-shell">
Type                        T    Option&lt;T&gt;    Result&lt;T, io::Error&gt;
----------------------------------------------------------------
u8                          1        2           24
f64                         8       16           24
&amp;u8                         8        8           24
Box&lt;u8&gt;                     8        8           24
&amp;[u8]                      16       16           24
String                     24       24           32
Vec&lt;u8&gt;                    24       24           32
HashMap&lt;String, String&gt;    48       48           56
E                          56       56           64
</code></pre>
<hr />
<p>Rust 是这么处理的:</p>
<ol>
<li>我们知道，引用类型的第一个域是个指针，而指针是不可能等于 0 的，</li>
<li>但是我们可以复用这个指针：当其为 0 时，表示 None，否则是 Some，减少了内存占用，这是个非常巧妙的优化</li>
</ol>
</div>
</details>
<h4 id="vec和string"><a class="header" href="#vec和string">vec<T>和String</a></h4>
<details id="admonition-string其实就是vec" class="admonition info">
<summary class="admonition-title">
<p>String其实就是Vec<u8></p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-string其实就是vec"></a></p>
</summary>
<div>
<p>String 和 Vec 占用相同的大小，都是 24 个字节。其实，如果你打开 String 结构的<a href="https://doc.rust-lang.org/src/alloc/string.rs.html#279-281">源码</a>，可以看到，它内部就是一个 Vec</p>
</div>
</details>
<details id="admonition-vec-结构是-3-个-word-的胖指针" class="admonition info">
<summary class="admonition-title">
<p>Vec 结构是 3 个 word 的胖指针</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-vec-结构是-3-个-word-的胖指针"></a></p>
</summary>
<div>
<h2 id=""><a class="header" href="#"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4640654.jpg" alt="vec就是一个胖指针" /></a></h2>
<p>包含：</p>
<ol>
<li>一个指向堆内存的指针 pointer</li>
<li>分配的堆内存的容量 capacity</li>
<li>以及数据在堆内存的长度 length</li>
</ol>
</div>
</details>
<h4 id="引用类型的内存布局"><a class="header" href="#引用类型的内存布局">引用类型的内存布局</a></h4>
<details id="admonition-引用类型的内存布局" class="admonition info">
<summary class="admonition-title">
<p>引用类型的内存布局</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-引用类型的内存布局"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.png" alt="引用类型的内存布局" /></p>
</div>
</details>
<h3 id="更多可见cheatsrs"><a class="header" href="#更多可见cheatsrs">更多可见cheats.rs</a></h3>
<ul>
<li><a href="https://cheats.rs/#data-layout">Rust Language Cheat Sheet</a></li>
</ul>
<h2 id="使用-1"><a class="header" href="#使用-1">使用</a></h2>
<h3 id="copy和move"><a class="header" href="#copy和move">copy和move</a></h3>
<details id="admonition-copy和move的内部实现都只是浅层按位做内存复制" class="admonition info">
<summary class="admonition-title">
<p>copy和move的内部实现都只是浅层按位做内存复制</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-copy和move的内部实现都只是浅层按位做内存复制"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4640936.jpg" alt="copy和move的内部实现都只是浅层按位做内存复制" /></p>
</div>
</details>
<h2 id="销毁"><a class="header" href="#销毁">销毁</a></h2>
<h3 id="drop释放堆内存"><a class="header" href="#drop释放堆内存">drop释放堆内存</a></h3>
<details id="admonition-当一个值被释放其实就是调用它的drop方法" class="admonition info">
<summary class="admonition-title">
<p>当一个值被释放，其实就是调用它的drop方法</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-当一个值被释放其实就是调用它的drop方法"></a></p>
</summary>
<div>
<h2 id="-1"><a class="header" href="#-1"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4641072.jpg" alt="当一个值被释放，其实就是调用它的drop方法" /></a></h2>
<ol>
<li>变量 greeting 是一个字符串，在退出作用域时，其 drop() 函数被自动调用</li>
<li>释放堆上包含 “hello world” 的内存</li>
<li>然后再释放栈上的内存</li>
</ol>
</div>
</details>
<details id="admonition-复杂结构递归调用drop" class="admonition info">
<summary class="admonition-title">
<p>复杂结构递归调用drop</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-复杂结构递归调用drop"></a></p>
</summary>
<div>
<h2 id="-2"><a class="header" href="#-2"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4641173.jpg" alt="复杂结构递归调用drop" /></a></h2>
<blockquote>
<p>如果要释放的值是一个复杂的数据结构，比如一个结构体，那么:</p>
</blockquote>
<ol>
<li>这个结构体在调用 drop() 时，会依次调用每一个域的 drop() 函数</li>
<li>如果域又是一个复杂的结构或者集合类型，就会递归下去</li>
<li>直到每一个域都释放干净。</li>
</ol>
<hr />
<ul>
<li>student 变量是一个结构体，有 name、age、scores。</li>
<li>其中 name 是 String，scores 是 HashMap，它们本身需要额外 drop()。</li>
<li>又因为 HashMap 的 key 是 String，所以还需要进一步调用这些 key 的 drop()。</li>
</ul>
<blockquote>
<p>整个释放顺序从内到外是：先释放 HashMap 下的 key，然后释放 HashMap 堆上的表结构，最后释放栈上的内存</p>
</blockquote>
</div>
</details>
<h3 id="raii释放其他资源"><a class="header" href="#raii释放其他资源">RAII释放其他资源</a></h3>
<details id="admonition-rust基于raii释放文件资源" class="admonition info">
<summary class="admonition-title">
<p>Rust基于RAII释放文件资源</p>
<p><a class="admonition-anchor-link" href="1_stack_heap_ownership_lifetime_memory.html#admonition-rust基于raii释放文件资源"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::fs::File;
use std::io::prelude::*;
fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut file = File::create(&quot;foo.txt&quot;)?;
    file.write_all(b&quot;Hello, world!&quot;)?;
    Ok(())
}
</code></pre></pre>
</div>
</details>
<h3 id="rust在编译时运行时检查调用drop"><a class="header" href="#rust在编译时运行时检查调用drop">Rust在编译时、运行时检查调用drop</a></h3>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/11%EF%BD%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%EF%BC%8C%E5%80%BC%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-4641604.jpg" alt="Rust在编译时、运行时检查调用drop" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ii-类型系统"><a class="header" href="#ii-类型系统">II. 类型系统</a></h1>
<!--ts-->
<ul>
<li><a href="2_type_system.html#ii-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">II. 类型系统</a>
<ul>
<li><a href="2_type_system.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB%E5%9B%BE">类型系统分类图</a>
<ul>
<li><a href="2_type_system.html#%E4%B8%89%E4%B8%AA%E6%A0%87%E5%87%86">三个标准</a></li>
<li><a href="2_type_system.html#rust%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9">Rust类型系统特点</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">类型分类</a>
<ul>
<li><a href="2_type_system.html#%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B">原生类型</a></li>
<li><a href="2_type_system.html#%E7%BB%84%E5%90%88%E7%B1%BB%E5%9E%8B">组合类型</a></li>
<li><a href="2_type_system.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E5%90%88%E7%B1%BB%E5%9E%8B">自定义组合类型</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E5%B0%8F%E4%BE%8B%E5%AD%90">小例子</a>
<ul>
<li><a href="2_type_system.html#%E5%B8%B8%E9%87%8F">常量</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">类型推导</a></li>
<li><a href="2_type_system.html#turbofish">Turbofish</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E6%B3%9B%E5%9E%8B">泛型</a>
<ul>
<li><a href="2_type_system.html#%E6%B3%9B%E5%9E%8B%E5%B0%B1%E5%83%8F%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">泛型就像定义函数</a></li>
<li><a href="2_type_system.html#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a></li>
<li><a href="2_type_system.html#%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">泛型数据结构</a>
<ul>
<li><a href="2_type_system.html#%E9%80%90%E6%AD%A5%E7%BA%A6%E6%9D%9F%E6%8A%8A%E5%86%B3%E7%AD%96%E4%BA%A4%E7%BB%99%E4%BD%BF%E7%94%A8%E8%80%85">逐步约束：把决策交给使用者</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0">泛型参数</a>
<ul>
<li><a href="2_type_system.html#%E5%8F%82%E6%95%B0%E5%A4%9A%E6%80%81">参数多态</a></li>
<li><a href="2_type_system.html#%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">三种使用场景</a>
<ul>
<li><a href="2_type_system.html#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A">延迟绑定</a></li>
<li><a href="2_type_system.html#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A-1">延迟绑定</a></li>
<li><a href="2_type_system.html#%E5%A4%9A%E4%B8%AA%E5%AE%9E%E7%8E%B0">多个实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="2_type_system.html#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0">泛型函数</a>
<ul>
<li><a href="2_type_system.html#%E5%8D%95%E6%80%81%E5%8C%96">单态化</a>
<ul>
<li><a href="2_type_system.html#%E4%BC%98%E5%8A%A3">优劣</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E6%90%BA%E5%B8%A6%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0">返回值携带泛型参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="2_type_system.html#trait">Trait</a>
<ul>
<li><a href="2_type_system.html#%E5%9F%BA%E6%9C%AC%E7%BB%83%E4%B9%A0">基本练习</a>
<ul>
<li><a href="2_type_system.html#self%E5%92%8Cself">Self和self</a></li>
<li><a href="2_type_system.html#%E9%80%92%E8%BF%9B%E7%BB%83%E4%B9%A0trait%E4%BD%BF%E7%94%A8">递进练习trait使用</a>
<ul>
<li><a href="2_type_system.html#%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89trait">基础定义trait</a></li>
<li><a href="2_type_system.html#%E6%B7%BB%E5%8A%A0%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F">添加泛型参数作为泛型约束</a></li>
<li><a href="2_type_system.html#%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E6%B7%BB%E5%8A%A0resultt-e">使用关联类型+添加Result&lt;T, E&gt;</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F-%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E7%9A%84trait">泛型约束: 支持泛型的trait</a>
<ul>
<li><a href="2_type_system.html#%E6%80%9D%E8%80%83%E9%A2%98">思考题</a></li>
<li><a href="2_type_system.html#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">关联类型</a></li>
<li><a href="2_type_system.html#%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B">支持泛型</a></li>
<li><a href="2_type_system.html#%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF">支持继承</a></li>
<li><a href="2_type_system.html#%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1-or-%E7%89%B9%E8%AE%BE%E5%A4%9A%E6%80%81">接口抽象 or 特设多态</a></li>
</ul>
</li>
<li><a href="2_type_system.html#trait-object">Trait Object</a>
<ul>
<li><a href="2_type_system.html#%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%A4%9A%E6%80%81-%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE">子类型多态: 动态分派</a></li>
<li><a href="2_type_system.html#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86ptrvtable">实现机理：ptr+vtable</a></li>
<li><a href="2_type_system.html#%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8">对象安全</a></li>
<li><a href="2_type_system.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a>
<ul>
<li><a href="2_type_system.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8">在函数中使用</a></li>
<li><a href="2_type_system.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%AD%E4%BD%BF%E7%94%A8">在函数返回值中使用</a>
<ul>
<li><a href="2_type_system.html#%E5%9C%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E4%BD%BF%E7%94%A8">在数据结构中使用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="2_type_system.html#%E5%AD%A4%E5%84%BF%E8%A7%84%E5%88%99">孤儿规则</a></li>
<li><a href="2_type_system.html#%E5%B8%B8%E7%94%A8trait">常用trait</a>
<ul>
<li><a href="2_type_system.html#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3">内存相关</a>
<ul>
<li><a href="2_type_system.html#copy">Copy</a></li>
<li><a href="2_type_system.html#drop">Drop</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E6%A0%87%E7%AD%BEtrait">标签trait</a>
<ul>
<li><a href="2_type_system.html#sized">Sized</a></li>
<li><a href="2_type_system.html#sendsync">Send/Sync</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a>
<ul>
<li><a href="2_type_system.html#frominto-%E5%80%BC%E5%88%B0%E5%80%BC">From/Into: 值到值</a></li>
<li><a href="2_type_system.html#tryfromtryinto-%E5%80%BC%E5%88%B0%E5%80%BC%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF">TryFrom/TryInto: 值到值，可能出现错误</a></li>
<li><a href="2_type_system.html#asrefasmut-%E5%BC%95%E7%94%A8%E5%88%B0%E5%BC%95%E7%94%A8">AsRef/AsMut: 引用到引用</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9B%B8%E5%85%B3-derefderefmut">操作符相关: Deref/DerefMut</a></li>
<li><a href="2_type_system.html#%E5%85%B6%E4%BB%96debugdisplaydefault">其他：Debug/Display/Default</a></li>
</ul>
</li>
<li><a href="2_type_system.html#%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84">设计架构</a>
<ul>
<li><a href="2_type_system.html#%E9%A1%BA%E6%89%8B%E8%87%AA%E7%84%B6">顺手自然</a></li>
<li><a href="2_type_system.html#%E6%A1%A5%E6%8E%A5">桥接</a></li>
<li><a href="2_type_system.html#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC">控制反转</a></li>
<li><a href="2_type_system.html#solid%E5%8E%9F%E5%88%99">SOLID原则</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Oct  4 07:24:32 UTC 2022 -->
<!--te-->
<h2 id="类型系统分类图"><a class="header" href="#类型系统分类图">类型系统分类图</a></h2>
<div id="admonition-类型系统分类图" class="admonition info">
<div class="admonition-title">
<p>类型系统分类图</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-类型系统分类图"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F.jpg" alt="类型系统分类图" /></p>
</div>
</div>
<h3 id="三个标准"><a class="header" href="#三个标准">三个标准</a></h3>
<ol>
<li>隐式转换</li>
<li>检查时机</li>
<li>多态支持</li>
</ol>
<h3 id="rust类型系统特点"><a class="header" href="#rust类型系统特点">Rust类型系统特点</a></h3>
<div id="admonition-rust的类型系统有什么特点" class="admonition info">
<div class="admonition-title">
<p>Rust的类型系统有什么特点？</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-rust的类型系统有什么特点"></a></p>
</div>
<div>
<h2 id="-3"><a class="header" href="#-3"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F-4257735.jpg" alt="Rust的类型系统有什么特点？" /></a></h2>
<p>强类型 + 静态类型 + 显式类型</p>
</div>
</div>
<h2 id="类型分类"><a class="header" href="#类型分类">类型分类</a></h2>
<h3 id="原生类型"><a class="header" href="#原生类型">原生类型</a></h3>
<details id="admonition-rust原声类型" class="admonition info">
<summary class="admonition-title">
<p>Rust原声类型</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-rust原声类型"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F-4257523.jpg" alt="Rust原生类型" /></p>
</div>
</details>
<h3 id="组合类型"><a class="header" href="#组合类型">组合类型</a></h3>
<details id="admonition-rust组合类型" class="admonition info">
<summary class="admonition-title">
<p>Rust组合类型</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-rust组合类型"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F-4257587.jpg" alt="Rust组合类型" /></p>
</div>
</details>
<h3 id="自定义组合类型"><a class="header" href="#自定义组合类型">自定义组合类型</a></h3>
<h2 id="小例子"><a class="header" href="#小例子">小例子</a></h2>
<h3 id="常量"><a class="header" href="#常量">常量</a></h3>
<details id="admonition-常量定义使用" class="admonition info">
<summary class="admonition-title">
<p>常量定义使用</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-常量定义使用"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">const PI: f64 = std::f64::consts::PI;
static E: f32 = std::f32::consts::E;

fn main() {
    const V: u32 = 10;
    static V1: &amp;str = &quot;hello&quot;;
    println!(&quot;PI: {}, E: {}, V {}, V1: {}&quot;, PI, E, V, V1);
}
</code></pre></pre>
</div>
</details>
<h2 id="类型推导"><a class="header" href="#类型推导">类型推导</a></h2>
<details id="admonition-rust编译器可以从上下文自动推导类型" class="admonition info">
<summary class="admonition-title">
<p>Rust编译器可以从上下文自动推导类型</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-rust编译器可以从上下文自动推导类型"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::collections::BTreeMap;

fn main() {
    let mut map = BTreeMap::new();
    // 没有这一行就缺少自动推导信息
    // map.insert(&quot;hello&quot;, &quot;world&quot;);
    println!(&quot;map: {:?}&quot;, map);
}
</code></pre></pre>
<hr />
<p>把第 5 行这个作用域内的 insert 语句注释去掉，Rust 编译器就会报错：“cannot infer type for type parameter K”。</p>
</div>
</details>
<details id="admonition-rust编译器不能获取足够上下文信息时就需要明确类型" class="admonition info">
<summary class="admonition-title">
<p>Rust编译器不能获取足够上下文信息时，就需要明确类型</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-rust编译器不能获取足够上下文信息时就需要明确类型"></a></p>
</summary>
<div>
<ol>
<li>无法自动推导collect返回什么类型</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let even_numbers = numbers
        .into_iter()
        .filter(|n| n % 2 == 0)
        .collect();

    println!(&quot;{:?}&quot;, even_numbers);
}
</code></pre></pre>
<hr />
<ol start="2">
<li>给even_numbers添加类型声明即可</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let even_numbers: Vec&lt;_&gt; = numbers
        .into_iter()
        .filter(|n| n % 2 == 0)
        .collect();

    println!(&quot;{:?}&quot;, even_numbers);
}
</code></pre></pre>
<blockquote>
<p>这里编译器只是无法推断出集合类型，但集合类型内部元素的类型，还是可以根据上下文得出，所以我们可以简写成 Vec&lt;_&gt;</p>
</blockquote>
<ol start="3">
<li>也可以让 collect 返回一个明确的类型</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let even_numbers = numbers
        .into_iter()
        .filter(|n| n % 2 == 0)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;{:?}&quot;, even_numbers);
}
</code></pre></pre>
<hr />
<blockquote>
<p>这里在泛型函数后使用 :: 来强制使用类型 T，这种写法被称为 turbofish</p>
</blockquote>
</div>
</details>
<h2 id="turbofish"><a class="header" href="#turbofish">Turbofish</a></h2>
<details id="admonition-一个对-ip-地址和端口转换的例子" class="admonition info">
<summary class="admonition-title">
<p>一个对 IP 地址和端口转换的例子</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-一个对-ip-地址和端口转换的例子"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::net::SocketAddr;

fn main() {
    let addr = &quot;127.0.0.1:8080&quot;.parse::&lt;SocketAddr&gt;().unwrap();
    println!(&quot;addr: {:?}, port: {:?}&quot;, addr.ip(), addr.port());
}
</code></pre></pre>
</div>
</details>
<details id="admonition-如果类型在上下文无法被推导出来又没有-turbofish-的写法我们就不得不先给一个局部变量赋值时声明类型然后再返回这样代码就变得冗余" class="admonition info">
<summary class="admonition-title">
<p>如果类型在上下文无法被推导出来，又没有 turbofish 的写法，我们就不得不先给一个局部变量赋值时声明类型，然后再返回，这样代码就变得冗余</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-如果类型在上下文无法被推导出来又没有-turbofish-的写法我们就不得不先给一个局部变量赋值时声明类型然后再返回这样代码就变得冗余"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match data {
    Some(s) =&gt; v.parse::&lt;User&gt;()?,
    _ =&gt; return Err(...),
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<h2 id="泛型就像定义函数"><a class="header" href="#泛型就像定义函数">泛型就像定义函数</a></h2>
<ol>
<li>函数，是把重复代码中的参数抽取出来，使其更加通用，调用函数的时候，根据参数的不同，我们得到不同的结果；</li>
<li>而泛型，是把重复数据结构中的参数抽取出来，在使用泛型类型时，根据不同的参数，我们会得到不同的具体类型。</li>
</ol>
<details id="admonition-泛型结构vec例子" class="admonition info">
<summary class="admonition-title">
<p>泛型结构Vec<T>例子</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-泛型结构vec例子"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub struct Vec&lt;T, A: Allocator = Global&gt; {
    buf: RawVec&lt;T, A&gt;,
    len: usize,
}

pub struct RawVec&lt;T, A: Allocator = Global&gt; {
    ptr: Unique&lt;T&gt;,
    cap: usize,
    alloc: A,
}
</code></pre></pre>
<hr />
<p>Vec有两个参数:</p>
<ol>
<li>一个是 T，是列表里的每个数据的类型</li>
<li>另一个是 A，它有进一步的限制 A: Allocator </li>
</ol>
<blockquote>
<p>也就是说 A 需要满足 Allocator trait。
A 这个参数有默认值 Global，它是 Rust 默认的全局分配器</p>
</blockquote>
<ol start="3">
<li>这也是为什么 Vec 虽然有两个参数，使用时都只需要用 T。</li>
</ol>
</div>
</details>
<details id="admonition-枚举类型cow例子" class="admonition info">
<summary class="admonition-title">
<p>枚举类型Cow<T>例子</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-枚举类型cow例子"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub enum Cow&lt;'a, B: ?Sized + 'a&gt; where B: ToOwned,
{
    // 借用的数据
    Borrowed(&amp;'a B),
    // 拥有的数据
    Owned(&lt;B as ToOwned&gt;::Owned),
}
</code></pre></pre>
<p>这里对 B 的三个约束分别是：</p>
<ol>
<li>生命周期 ’a</li>
<li>长度可变 ?Sized</li>
<li>符合 ToOwned trait</li>
</ol>
</div>
</details>
<details id="admonition-cow" class="admonition info">
<summary class="admonition-title">
<p>Cow</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-cow"></a></p>
</summary>
<div>
<p>Cow（Clone-on-Write）是 Rust 中一个很有意思且很重要的数据结构。它就像 Option 一样，在返回数据的时候，提供了一种可能：要么返回一个借用的数据（只读），要么返回一个拥有所有权的数据（可写）。</p>
</div>
</details>
<details id="admonition-sized代表可变大小" class="admonition info">
<summary class="admonition-title">
<p>?Sized代表可变大小</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-sized代表可变大小"></a></p>
</summary>
<div>
<p>?Sized 是一种特殊的约束写法，? 代表可以放松问号之后的约束。由于 Rust 默认的泛型参数都需要是 Sized，也就是固定大小的类型，所以这里 ?Sized 代表用可变大小的类型。</p>
</div>
</details>
<details id="admonition-toowned" class="admonition info">
<summary class="admonition-title">
<p>ToOwned</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-toowned"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html">ToOwned</a> 是一个 trait，它可以把借用的数据克隆出一个拥有所有权的数据。</p>
</div>
</details>
<details id="admonition-owned" class="admonition info">
<summary class="admonition-title">
<p><B as ToOwned>::Owned</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-owned"></a></p>
</summary>
<div>
<h2 id="它对-b-做了一个强制类型转换转成-toowned-trait然后访问-toowned-trait-内部的-owned-类型"><a class="header" href="#它对-b-做了一个强制类型转换转成-toowned-trait然后访问-toowned-trait-内部的-owned-类型">它对 B 做了一个强制类型转换，转成 ToOwned trait，然后访问 ToOwned trait 内部的 Owned 类型</a></h2>
<p>因为在 Rust 里，子类型可以强制转换成父类型，B 可以用 ToOwned 约束，所以它是 ToOwned trait 的子类型，因而 B 可以安全地强制转换成 ToOwned。这里 B as ToOwned 是成立的。</p>
</div>
</details>
<h2 id="实现方式"><a class="header" href="#实现方式">实现方式</a></h2>
<details id="admonition-不同语言实现泛型的方式" class="admonition info">
<summary class="admonition-title">
<p>不同语言实现泛型的方式</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-不同语言实现泛型的方式"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/12%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ARust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F.png" alt="不同语言实现泛型的方式" /></p>
</div>
</details>
<h2 id="泛型数据结构"><a class="header" href="#泛型数据结构">泛型数据结构</a></h2>
<h3 id="逐步约束把决策交给使用者"><a class="header" href="#逐步约束把决策交给使用者">逐步约束：把决策交给使用者</a></h3>
<details id="admonition-在不同的实现下逐步添加约束" class="admonition info">
<summary class="admonition-title">
<p>在不同的实现下逐步添加约束</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-在不同的实现下逐步添加约束"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::fs::File;
use std::io::{BufReader, Read, Result};

struct MyReader&lt;R&gt; {
    reader: R,
    buf: String,
}

impl&lt;R&gt; MyReader&lt;R&gt; {
    pub fn new(reader: R) -&gt; Self {
        Self {
            reader,
            buf: String::with_capacity(1024),
        }
    }
}

impl&lt;R&gt; MyReader&lt;R&gt;
where
    R: Read,
{
    pub fn process(&amp;mut self) -&gt; Result&lt;usize&gt; {
        self.reader.read_to_string(&amp;mut self.buf)
    }
}

fn main() {
    let f = File::open(&quot;/etc/hosts&quot;).unwrap();
    let mut reader = MyReader::new(BufReader::new(f));

    let size = reader.process().unwrap();
    println!(&quot;total size read: {}&quot;, size);
}
</code></pre></pre>
</div>
</details>
<h2 id="泛型参数"><a class="header" href="#泛型参数">泛型参数</a></h2>
<h3 id="参数多态"><a class="header" href="#参数多态">参数多态</a></h3>
<h3 id="三种使用场景"><a class="header" href="#三种使用场景">三种使用场景</a></h3>
<h4 id="延迟绑定"><a class="header" href="#延迟绑定">延迟绑定</a></h4>
<h4 id="延迟绑定-1"><a class="header" href="#延迟绑定-1">延迟绑定</a></h4>
<h4 id="多个实现"><a class="header" href="#多个实现">多个实现</a></h4>
<h2 id="泛型函数"><a class="header" href="#泛型函数">泛型函数</a></h2>
<h3 id="单态化"><a class="header" href="#单态化">单态化</a></h3>
<details id="admonition-编译时展开泛型参数单态化" class="admonition info">
<summary class="admonition-title">
<p>编译时展开泛型参数单态化</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-编译时展开泛型参数单态化"></a></p>
</summary>
<div>
<blockquote>
<p>对于泛型函数，Rust 会进行单态化（Monomorphization）处理，也就是在编译时，把所有用到的泛型函数的泛型参数展开，生成若干个函数。
所以，下方的 id() 编译后会得到 一个处理后的多个版本</p>
</blockquote>
<hr />
<pre><pre class="playground"><code class="language-rust  editable">fn id&lt;T&gt;(x: T) -&gt; T {
    x
}

fn main() {
    let int = id(42);
    let string = id(&quot;Tyr&quot;);
    println!(&quot;{}, {}&quot;, int, string);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-单态化的优劣" class="admonition info">
<summary class="admonition-title">
<p>单态化的优劣</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-单态化的优劣"></a></p>
</summary>
<div>
<ol>
<li>单态化的好处是:</li>
</ol>
<ul>
<li>泛型函数的调用是静态分派（static dispatch） 在编译时就一一对应</li>
<li>既保有多态的灵活性，又没有任何效率的损失，和普通函数调用一样高效。</li>
</ul>
<ol start="2">
<li>坏处：编译慢、文件大、丢失泛型信息。这反过来又是动态分派的好处</li>
</ol>
<ul>
<li>但是对比刚才编译会展开的代码也能很清楚看出来，单态化有很明显的坏处</li>
<li>就是编译速度很慢，一个泛型函数，编译器需要找到所有用到的不同类型，一个个编译</li>
<li>所以 Rust 编译代码的速度总被人吐槽，这和单态化脱不开干系（另一个重要因素是宏）。</li>
<li>同时，这样编出来的二进制会比较大，因为泛型函数的二进制代码实际存在 N 份。</li>
<li>还有一个可能你不怎么注意的问题：因为单态化，代码以二进制分发会损失泛型的信息。</li>
<li>如果我写了一个库，提供了如上的 id() 函数，使用这个库的开发者如果拿到的是二进制</li>
<li>那么这个二进制中必须带有原始的泛型函数，才能正确调用。但单态化之后，原本的泛型信息就被丢弃了。</li>
</ul>
</div>
</details>
<h4 id="优劣"><a class="header" href="#优劣">优劣</a></h4>
<h3 id="返回值携带泛型参数"><a class="header" href="#返回值携带泛型参数">返回值携带泛型参数</a></h3>
<h1 id="trait"><a class="header" href="#trait">Trait</a></h1>
<div id="admonition-trait概览图" class="admonition info">
<div class="admonition-title">
<p>trait概览图</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-trait概览图"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/13%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F.jpg" alt="trait概览图" /></p>
</div>
</div>
<h2 id="基本练习"><a class="header" href="#基本练习">基本练习</a></h2>
<h3 id="self和self"><a class="header" href="#self和self">Self和self</a></h3>
<details id="admonition-self和self区别使用-self其实就是静态方法" class="admonition info">
<summary class="admonition-title">
<p>Self和self区别使用, Self其实就是静态方法</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-self和self区别使用-self其实就是静态方法"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::fmt;
use std::io::Write;

struct BufBuilder {
    buf: Vec&lt;u8&gt;,
}

impl BufBuilder {
    pub fn new() -&gt; Self {
        Self {
            buf: Vec::with_capacity(1024),
        }
    }
}

impl fmt::Debug for BufBuilder {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, String::from_utf8_lossy(self.buf.as_ref()))
    }
}

impl Write for BufBuilder {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; std::io::Result&lt;usize&gt; {
        self.buf.extend_from_slice(buf);
        Ok(buf.len())
    }

    fn flush(&amp;mut self) -&gt; std::io::Result&lt;()&gt; {
        Ok(())
    }
}

fn main() {
    let mut buf = BufBuilder::new();
    buf.write_all(b&quot;Hello world!&quot;).unwrap();
    println!(&quot;{:?}&quot;, buf);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-self-self-实例来自于类型" class="admonition info">
<summary class="admonition-title">
<p>self: Self, 实例来自于类型</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-self-self-实例来自于类型"></a></p>
</summary>
<div>
<ol>
<li>Self 代表当前的类型，比如 File 类型实现了 Write，那么实现过程中使用到的 Self 就指代 File。</li>
<li>self 在用作方法的第一个参数时，实际上是 self: Self 的简写，所以 &amp;self 是 self: &amp;Self, 而 &amp;mut self 是 self: &amp;mut Self。</li>
</ol>
</div>
</details>
<h3 id="递进练习trait使用"><a class="header" href="#递进练习trait使用">递进练习trait使用</a></h3>
<h4 id="基础定义trait"><a class="header" href="#基础定义trait">基础定义trait</a></h4>
<details id="admonition-定义parse-trait并实现使用" class="admonition info">
<summary class="admonition-title">
<p>定义Parse trait并实现使用</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-定义parse-trait并实现使用"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use regex::Regex;
pub trait Parse {
    fn parse(s: &amp;str) -&gt; Self;
}

impl Parse for u8 {
    fn parse(s: &amp;str) -&gt; Self {
        let re: Regex = Regex::new(r&quot;^[0-9]+&quot;).unwrap();
        if let Some(captures) = re.captures(s) {
            captures
                .get(0)
                .map_or(0, |s| s.as_str().parse().unwrap_or(0))
        } else {
            0
        }
    }
}

#[test]
fn parse_should_work() {
    assert_eq!(u8::parse(&quot;123abcd&quot;), 123);
    assert_eq!(u8::parse(&quot;1234abcd&quot;), 0);
    assert_eq!(u8::parse(&quot;abcd&quot;), 0);
}

fn main() {
    println!(&quot;result: {}&quot;, u8::parse(&quot;255 hello world&quot;));
}
</code></pre></pre>
</div>
</details>
<h4 id="添加泛型参数作为泛型约束"><a class="header" href="#添加泛型参数作为泛型约束">添加泛型参数作为泛型约束</a></h4>
<details id="admonition-impl-parse-for-t" class="admonition info">
<summary class="admonition-title">
<p>impl<T> Parse for T</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-impl-parse-for-t"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::str::FromStr;

use regex::Regex;
pub trait Parse {
    fn parse(s: &amp;str) -&gt; Self;
}

impl&lt;T&gt; Parse for T
where
    T: FromStr + Default,
{
    fn parse(s: &amp;str) -&gt; Self {
        let re: Regex = Regex::new(r&quot;^[0-9]+(\.[0-9]+)?&quot;).unwrap();
        let d = || Default::default();
        if let Some(captures) = re.captures(s) {
            captures
                .get(0)
                .map_or(d(), |s| s.as_str().parse().unwrap_or_else(|_| d()))
        } else {
            d()
        }
    }
}

#[test]
fn parse_should_work() {
    assert_eq!(u32::parse(&quot;123abcd&quot;), 123);
    assert_eq!(u32::parse(&quot;123.45abcd&quot;), 0);
    assert_eq!(f64::parse(&quot;123.45abcd&quot;).to_string(), &quot;123.45&quot;);
    assert_eq!(f64::parse(&quot;abcd&quot;).to_string(), &quot;0&quot;);
}

fn main() {
    println!(&quot;result: {}&quot;, u8::parse(&quot;255 hello world&quot;));
}
</code></pre></pre>
</div>
</details>
<h4 id="使用关联类型添加resultt-e"><a class="header" href="#使用关联类型添加resultt-e">使用关联类型+添加Result&lt;T, E&gt;</a></h4>
<details id="admonition-关联类型自定义error" class="admonition info">
<summary class="admonition-title">
<p>关联类型自定义Error</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-关联类型自定义error"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::str::FromStr;

use regex::Regex;
pub trait Parse {
    type Error;
    fn parse(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt;
    where
        Self: Sized;
}

impl&lt;T&gt; Parse for T
where
    T: FromStr + Default,
{
    // 定义关联类型 Error 为 String
    type Error = String;
    fn parse(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {
        let re: Regex = Regex::new(r&quot;^[0-9]+(\.[0-9]+)?&quot;).unwrap();
        if let Some(captures) = re.captures(s) {
            // 当出错时我们返回 Err(String)
            captures
                .get(0)
                .map_or(Err(&quot;failed to capture&quot;.to_string()), |s| {
                    s.as_str()
                        .parse()
                        .map_err(|_err| &quot;failed to parse captured string&quot;.to_string())
                })
        } else {
            Err(&quot;failed to parse string&quot;.to_string())
        }
    }
}

#[test]
fn parse_should_work() {
    assert_eq!(u32::parse(&quot;123abcd&quot;), Ok(123));
    assert_eq!(
        u32::parse(&quot;123.45abcd&quot;),
        Err(&quot;failed to parse captured string&quot;.into())
    );
    assert_eq!(f64::parse(&quot;123.45abcd&quot;), Ok(123.45));
    assert!(f64::parse(&quot;abcd&quot;).is_err());
}

fn main() {
    println!(&quot;result: {:?}&quot;, u8::parse(&quot;255 hello world&quot;));
}
</code></pre></pre>
</div>
</details>
<h3 id="泛型约束-支持泛型的trait"><a class="header" href="#泛型约束-支持泛型的trait">泛型约束: 支持泛型的trait</a></h3>
<h4 id="思考题"><a class="header" href="#思考题">思考题</a></h4>
<details id="admonition-泛型参数impl报错" class="admonition info">
<summary class="admonition-title">
<p>泛型参数impl报错</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-泛型参数impl报错"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::io::{BufWriter, Write};
use std::net::TcpStream;

#[derive(Debug)]
struct MyWriter&lt;W&gt; {
    writer: W,
}

impl&lt;W: Write&gt; MyWriter&lt;W&gt; {
    pub fn new(addr: &amp;str) -&gt; Self {
        let stream = TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap();
        Self {
            writer: BufWriter::new(stream),
        }
    }

    pub fn write(&amp;mut self, buf: &amp;str) -&gt; std::io::Result&lt;()&gt; {
        self.writer.write_all(buf.as_bytes())
    }
}

fn main() {
    let writer = MyWriter::new(&quot;127.0.0.1:8080&quot;);
    writer.write(&quot;hello world!&quot;);
}
</code></pre></pre>
</div>
</details>
<div id="admonition-分析编译报错原因" class="admonition tip">
<div class="admonition-title">
<p>分析编译报错原因</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-分析编译报错原因"></a></p>
</div>
<div>
<p>主要原因是，实现 new 方法时，对泛型的约束要求要满足 W: Write，而 new 的声明返回值是 Self，也就是说 self.wirter 必须是 W: Write 类型(泛型)，但实际返回值是一个确定的类型 BufWriter<TcpStream>，这不满足要求。</p>
</div>
</div>
<h4 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h4>
<div id="admonition-解决方案梳理" class="admonition info">
<div class="admonition-title">
<p>解决方案梳理</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-解决方案梳理"></a></p>
</div>
<div>
<ol>
<li>修改 new 方法的返回值</li>
<li>对确定的类型 MyWriter&lt;BufWriter<TcpStream>&gt;实现 new 方法</li>
<li>修改 new 方法的实现，使用依赖注入</li>
</ol>
</div>
</div>
<details id="admonition-1-修改new方法返回值" class="admonition info">
<summary class="admonition-title">
<ol>
<li>修改new方法返回值</li>
</ol>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-1-修改new方法返回值"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::io::{BufWriter, Write};
use std::net::TcpStream;

#[derive(Debug)]
struct MyWriter&lt;W&gt; {
    writer: W,
}

impl&lt;W: Write&gt; MyWriter&lt;W&gt; {
    pub fn new(writer: W) -&gt; Self {
        Self { writer }
    }

    pub fn write(&amp;mut self, buf: &amp;str) -&gt; std::io::Result&lt;()&gt; {
        self.writer.write_all(buf.as_bytes())
    }
}

fn main() {
    let stream = TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap();

    let mut writer = MyWriter::new(BufWriter::new(stream));
    writer.write(&quot;hello world!&quot;).unwrap();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-2-针对实现new方法" class="admonition info">
<summary class="admonition-title">
<ol start="2">
<li>针对实现new方法</li>
</ol>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-2-针对实现new方法"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl MyWriter&lt;BufWriter&lt;TcpStream&gt;&gt; {
    pub fn new(addr: &amp;str) -&gt; Self {
        let stream = TcpStream::connect(addr).unwrap();
        Self {
            writer: BufWriter::new(stream),
        }
    }
}

fn main() {
    let mut writer = MyWriter::new(&quot;127.0.0.1:8080&quot;);
    writer.write(&quot;hello world!&quot;);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-3-使用依赖注入修改new方法实现" class="admonition info">
<summary class="admonition-title">
<ol start="3">
<li>使用依赖注入修改new方法实现</li>
</ol>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-3-使用依赖注入修改new方法实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;W: Write&gt; MyWriter&lt;W&gt; {
    pub fn new(writer: W) -&gt; Self {
        Self {
            writer,
        }
    }
}

fn main() {
    let stream = TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap();
    let mut writer = MyWriter::new(BufWriter::new(stream));
    writer.write(&quot;hello world!&quot;);
}
</code></pre></pre>
</div>
</details>
<h3 id="关联类型"><a class="header" href="#关联类型">关联类型</a></h3>
<h3 id="支持泛型"><a class="header" href="#支持泛型">支持泛型</a></h3>
<details id="admonition-版本一支持数字相加" class="admonition info">
<summary class="admonition-title">
<p>版本一：支持数字相加</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-版本一支持数字相加"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::ops::Add;

#[derive(Debug)]
struct Complex {
    real: f64,
    imagine: f64,
}

impl Complex {
    pub fn new(real: f64, imagine: f64) -&gt; Self {
        Self { real, imagine }
    }
}

// 对 Complex 类型的实现
impl Add for Complex {
    type Output = Self;

    // 注意 add 第一个参数是 self，会移动所有权
    fn add(self, rhs: Self) -&gt; Self::Output {
        let real = self.real + rhs.real;
        let imagine = self.imagine + rhs.imagine;
        Self::new(real, imagine)
    }
}


fn main() {
    let c1 = Complex::new(1.0, 1f64);
    let c2 = Complex::new(2 as f64, 3.0);
    println!(&quot;{:?}&quot;, c1 + c2);
    // c1, c2 已经被移动，所以下面这句无法编译
    // println!(&quot;{:?}&quot;, c1 + c2);
}
</code></pre></pre>
</div>
</details>
<h3 id="支持继承"><a class="header" href="#支持继承">支持继承</a></h3>
<details id="admonition-trait-ba" class="admonition info">
<summary class="admonition-title">
<p>trait B:A</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-trait-ba"></a></p>
</summary>
<div>
<p>在 Rust 中，一个 trait 可以“继承”另一个 trait 的关联类型和关联函数。比如 trait B: A ，是说任何类型 T，如果实现了 trait B，它也必须实现 trait A，换句话说，trait B 在定义时可以使用 trait A 中的关联类型和方法。</p>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T: ?Sized&gt; StreamExt for T where T: Stream {}
</code></pre></pre>
<hr />
<p>如果你实现了 Stream trait，就可以直接使用 StreamExt 里的方法了</p>
</div>
</details>
<h3 id="接口抽象-or-特设多态"><a class="header" href="#接口抽象-or-特设多态">接口抽象 or 特设多态</a></h3>
<details id="admonition-对不同类型统一实现-trait将各种接口定义场景考虑进去" class="admonition info">
<summary class="admonition-title">
<p>对不同类型统一实现: trait将各种接口定义场景考虑进去</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-对不同类型统一实现-trait将各种接口定义场景考虑进去"></a></p>
</summary>
<div>
<p>trait 作为对不同数据结构中相同行为的一种抽象。</p>
<ol>
<li>除了基本 trait 之外，当行为和具体的数据关联时，比如字符串解析时定义的 Parse trait，我们引入了带有关联类型的 trait，把和行为有关的数据类型的定义，进一步延迟到 trait 实现的时候。</li>
<li>对于同一个类型的同一个 trait 行为，可以有不同的实现，比如我们之前大量使用的 From，此时可以用泛型 trait。可以说 Rust 的 trait 就像一把瑞士军刀，把需要定义接口的各种场景都考虑进去了。</li>
</ol>
</div>
</details>
<details id="admonition-对不同类型的不同实现-特设多态" class="admonition info">
<summary class="admonition-title">
<p>对不同类型的不同实现: 特设多态</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-对不同类型的不同实现-特设多态"></a></p>
</summary>
<div>
<p>特设多态是同一种行为的不同实现。所以其实，通过定义 trait 以及为不同的类型实现这个 trait，我们就已经实现了特设多态。</p>
<ol>
<li>Add trait 就是一个典型的特设多态，同样是加法操作，根据操作数据的不同进行不同的处理。</li>
<li>Service trait 是一个不那么明显的特设多态，同样是 Web 请求，对于不同的 URL，我们使用不同的代码去处理。</li>
</ol>
</div>
</details>
<h2 id="trait-object"><a class="header" href="#trait-object">Trait Object</a></h2>
<h3 id="子类型多态-动态分派"><a class="header" href="#子类型多态-动态分派">子类型多态: 动态分派</a></h3>
<details id="admonition-在运行期决定" class="admonition info">
<summary class="admonition-title">
<p>在运行期决定</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-在运行期决定"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">pub trait Formatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool;
}

struct MarkdownFormatter;
impl Formatter for MarkdownFormatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool {
        input.push_str(&quot;\nformatted with Markdown formatter&quot;);
        true
    }
}

struct RustFormatter;
impl Formatter for RustFormatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool {
        input.push_str(&quot;\nformatted with Rust formatter&quot;);
        true
    }
}

struct HtmlFormatter;
impl Formatter for HtmlFormatter {
    fn format(&amp;self, input: &amp;mut String) -&gt; bool {
        input.push_str(&quot;\nformatted with HTML formatter&quot;);
        true
    }
}

pub fn format(input: &amp;mut String, formatters: Vec&lt;&amp;dyn Formatter&gt;) {
    for formatter in formatters {
        formatter.format(input);
    }
}

fn main() {
    let mut text = &quot;Hello world!&quot;.to_string();
    let html: &amp;dyn Formatter = &amp;HtmlFormatter;
    let rust: &amp;dyn Formatter = &amp;RustFormatter;
    let formatters = vec![html, rust];
    format(&amp;mut text, formatters);

    println!(&quot;text: {}&quot;, text);
}
</code></pre></pre>
<hr />
<p>要有一种手段，告诉编译器，此处需要并且仅需要任何实现了 Formatter 接口的数据类型。在 Rust 里，这种类型叫 Trait Object，表现为 &amp;dyn Trait 或者 Box。</p>
<ol>
<li>这里结构体只是声明了一下，并不关注其包含什么字段</li>
</ol>
</div>
</details>
<h3 id="实现机理ptrvtable"><a class="header" href="#实现机理ptrvtable">实现机理：ptr+vtable</a></h3>
<details id="admonition-trait-object的底层逻辑就是胖指针" class="admonition info">
<summary class="admonition-title">
<p>Trait Object的底层逻辑就是胖指针</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-trait-object的底层逻辑就是胖指针"></a></p>
</summary>
<div>
<h2 id="-4"><a class="header" href="#-4"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/13%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F-4258625.jpg" alt="13｜类型系统：如何使用trait来定义接口？" /></a></h2>
<p>HtmlFormatter 的引用赋值给 Formatter 后，会生成一个 Trait Object，在上图中可以看到，Trait Object 的底层逻辑就是胖指针。</p>
<blockquote>
<p>其中，一个指针指向数据本身，另一个则指向虚函数表（vtable）。</p>
</blockquote>
</div>
</details>
<details id="admonition-vtable是一张静态表" class="admonition info">
<summary class="admonition-title">
<p>vtable是一张静态表</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-vtable是一张静态表"></a></p>
</summary>
<div>
<h2 id="-5"><a class="header" href="#-5"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/13%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8trait%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F-4258661.jpg" alt="13｜类型系统：如何使用trait来定义接口？" /></a></h2>
<ol>
<li>vtable 是一张静态的表，Rust 在编译时会为使用了 trait object 的类型的 trait 实现生成一张表，放在可执行文件中（一般在 TEXT 或 RODATA 段）</li>
</ol>
<blockquote>
<p>在这张表里，包含具体类型的一些信息，如 size、aligment 以及一系列函数指针
这个接口支持的所有的方法，比如 format() ；具体类型的 drop trait，当 Trait object 被释放，它用来释放其使用的所有资源。这样，当在运行时执行 formatter.format() 时，formatter 就可以从 vtable 里找到对应的函数指针，执行具体的操作。</p>
</blockquote>
</div>
</details>
<details id="admonition-vtable会为每个类型的每个trait实现一张表" class="admonition info">
<summary class="admonition-title">
<p>vtable会为每个类型的每个trait实现一张表</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-vtable会为每个类型的每个trait实现一张表"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::fmt::{Debug, Display};
use std::mem::transmute;

fn main() {
    let s = String::from(&quot;hello world!&quot;);
    let s1 = String::from(&quot;goodbye world!&quot;);
    // Display / Debug trait object for s
    let w1: &amp;dyn Display = &amp;s;
    let w2: &amp;dyn Debug = &amp;s;

    // Display / Debug trait object for s1
    let w3: &amp;dyn Display = &amp;s1;
    let w4: &amp;dyn Debug = &amp;s1;

    // 强行把 triat object 转换成两个地址 (usize, usize)
    // 这是不安全的，所以是 unsafe
    let (addr1, vtable1): (usize, usize) = unsafe { transmute(w1) };
    let (addr2, vtable2): (usize, usize) = unsafe { transmute(w2) };
    let (addr3, vtable3): (usize, usize) = unsafe { transmute(w3) };
    let (addr4, vtable4): (usize, usize) = unsafe { transmute(w4) };

    // s 和 s1 在栈上的地址，以及 main 在 TEXT 段的地址
    println!(
        &quot;s: {:p}, s1: {:p}, main(): {:p}&quot;,
        &amp;s, &amp;s1, main as *const ()
    );
    // trait object(s / Display) 的 ptr 地址和 vtable 地址
    println!(&quot;addr1: 0x{:x}, vtable1: 0x{:x}&quot;, addr1, vtable1);
    // trait object(s / Debug) 的 ptr 地址和 vtable 地址
    println!(&quot;addr2: 0x{:x}, vtable2: 0x{:x}&quot;, addr2, vtable2);

    // trait object(s1 / Display) 的 ptr 地址和 vtable 地址
    println!(&quot;addr3: 0x{:x}, vtable3: 0x{:x}&quot;, addr3, vtable3);

    // trait object(s1 / Display) 的 ptr 地址和 vtable 地址
    println!(&quot;addr4: 0x{:x}, vtable4: 0x{:x}&quot;, addr4, vtable4);

    // 指向同一个数据的 trait object 其 ptr 地址相同
    assert_eq!(addr1, addr2);
    assert_eq!(addr3, addr4);

    // 指向同一种类型的同一个 trait 的 vtable 地址相同
    // 这里都是 String + Display
    assert_eq!(vtable1, vtable3);
    // 这里都是 String + Debug
    assert_eq!(vtable2, vtable4);
}
</code></pre></pre>
</div>
</details>
<h3 id="对象安全"><a class="header" href="#对象安全">对象安全</a></h3>
<details id="admonition-那什么样的-trait-不是对象安全的呢" class="admonition info">
<summary class="admonition-title">
<p>那什么样的 trait 不是对象安全的呢？</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-那什么样的-trait-不是对象安全的呢"></a></p>
</summary>
<div>
<ol>
<li>如果 trait 所有的方法，返回值是 Self 或者携带泛型参数，那么这个 trait 就不能产生 trait object。</li>
<li>不允许返回 Self，是因为 trait object 在产生时，原来的类型会被抹去，所以 Self 究竟是谁不知道。</li>
<li>比如 Clone trait 只有一个方法 clone()，返回 Self，所以它就不能产生 trait object。</li>
<li>不允许携带泛型参数，是因为 Rust 里带泛型的类型在编译时会做单态化，而 trait object 是运行时的产物，两者不能兼容。</li>
<li>比如 Fromtrait，因为整个 trait 带了泛型，每个方法也自然包含泛型，就不能产生 trait object。如果一个 trait 只有部分方法返回 Self 或者使用了泛型参数，那么这部分方法在 trait object 中不能调用。</li>
</ol>
</div>
</details>
<h3 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h3>
<h4 id="在函数中使用"><a class="header" href="#在函数中使用">在函数中使用</a></h4>
<h4 id="在函数返回值中使用"><a class="header" href="#在函数返回值中使用">在函数返回值中使用</a></h4>
<h5 id="在数据结构中使用"><a class="header" href="#在数据结构中使用">在数据结构中使用</a></h5>
<h2 id="孤儿规则"><a class="header" href="#孤儿规则">孤儿规则</a></h2>
<details id="admonition-定义或实现至少有一个" class="admonition info">
<summary class="admonition-title">
<p>定义或实现，至少有一个</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-定义或实现至少有一个"></a></p>
</summary>
<div>
<p>trait 和实现 trait 的数据类型，至少有一个是在当前 crate 中定义的，也就是说，你不能为第三方的类型实现第三方的 trait，当你尝试这么做时，Rust 编译器会报错。</p>
</div>
</details>
<h2 id="常用trait"><a class="header" href="#常用trait">常用trait</a></h2>
<div id="admonition-常用trait分类整理" class="admonition info">
<div class="admonition-title">
<p>常用trait分类整理</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-常用trait分类整理"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/14%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84trait%EF%BC%9F.jpg" alt="14｜类型系统：有哪些必须掌握的trait？" /></p>
</div>
</div>
<h3 id="内存相关"><a class="header" href="#内存相关">内存相关</a></h3>
<details id="admonition-clone使用示例" class="admonition info">
<summary class="admonition-title">
<p>Clone使用示例</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-clone使用示例"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Clone {
  fn clone(&amp;self) -&gt; Self;

  fn clone_from(&amp;mut self, source: &amp;Self) {
    *self = source.clone()
  }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-clone与clone_from" class="admonition info">
<summary class="admonition-title">
<p>clone()与clone_from()</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-clone与clone_from"></a></p>
</summary>
<div>
<p>Clone trait 有两个方法， clone() 和 clone_from() ，后者有缺省实现，所以平时我们只需要实现 clone() 方法即可。你也许会疑惑，这个 clone_from() 有什么作用呢？因为看起来 a.clone_from(&amp;b) ，和 a = b.clone() 是等价的。其实不是，如果 a 已经存在，在 clone 过程中会分配内存，那么用 a.clone_from(&amp;b) 可以避免内存分配，提高效率。b.clone() 是等价的。其实不是，如果 a 已经存在，在 clone 过程中会分配内存，那么用 a.clone_from(&amp;b) 可以避免内存分配，提高效率。</p>
</div>
</details>
<details id="admonition-clone-trait-可以通过派生宏直接实现这样能简化不少代码" class="admonition info">
<summary class="admonition-title">
<p>Clone trait 可以通过派生宏直接实现，这样能简化不少代码</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-clone-trait-可以通过派生宏直接实现这样能简化不少代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[derive(Clone, Debug)]
struct Developer {
  name: String,
  age: u8,
  lang: Language
}

#[allow(dead_code)]
#[derive(Clone, Debug)]
enum Language {
  Rust,
  TypeScript,
  Elixir,
  Haskell
}

fn main() {
    let dev = Developer {
        name: &quot;Tyr&quot;.to_string(),
        age: 18,
        lang: Language::Rust
    };
    let dev1 = dev.clone();
    println!(&quot;dev: {:?}, addr of dev name: {:p}&quot;, dev, dev.name.as_str());
    println!(&quot;dev1: {:?}, addr of dev1 name: {:p}&quot;, dev1, dev1.name.as_str())
}
</code></pre></pre>
<hr />
<p>如果没有为 Language 实现 Clone 的话，Developer 的派生宏 Clone 将会编译出错。运行这段代码可以看到，对于 name，也就是 String 类型的 Clone，其堆上的内存也被 Clone 了一份，所以 Clone 是深度拷贝，栈内存和堆内存一起拷贝。</p>
</div>
</details>
<details id="admonition-clone-方法的接口是-self" class="admonition info">
<summary class="admonition-title">
<p>clone 方法的接口是 &amp;self</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-clone-方法的接口是-self"></a></p>
</summary>
<div>
<p>值得注意的是，clone 方法的接口是 &amp;self，这在绝大多数场合下都是适用的，我们在 clone 一个数据时只需要有已有数据的只读引用。但对 Rc 这样在 clone() 时维护引用计数的数据结构，clone() 过程中会改变自己，所以要用 Cell 这样提供内部可变性的结构来进行改变，如果你也有类似的需求，可以参考</p>
</div>
</details>
<h4 id="copy"><a class="header" href="#copy">Copy</a></h4>
<details id="admonition-不可变引用实现了-copy而可变引用-mut-t-没有实现-copy" class="admonition info">
<summary class="admonition-title">
<p>不可变引用实现了 Copy，而可变引用 &amp;mut T 没有实现 Copy</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-不可变引用实现了-copy而可变引用-mut-t-没有实现-copy"></a></p>
</summary>
<div>
<p>不可变引用实现了 Copy，而可变引用 &amp;mut T 没有实现 Copy。为什么是这样？因为如果可变引用实现了 Copy trait，那么生成一个可变引用然后把它赋值给另一个变量时，就会违背所有权规则：
同一个作用域下只能有一个可变引用。可见，Rust 标准库在哪些结构可以 Copy、哪些不可以 Copy 上，有着仔细的考量。</p>
</div>
</details>
<h4 id="drop"><a class="header" href="#drop">Drop</a></h4>
<details id="admonition-有两种情况你可能需要手工实现-drop" class="admonition info">
<summary class="admonition-title">
<p>有两种情况你可能需要手工实现 Drop</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-有两种情况你可能需要手工实现-drop"></a></p>
</summary>
<div>
<p>大部分场景无需为数据结构提供 Drop trait，系统默认会依次对数据结构的每个域做 drop。但有两种情况你可能需要手工实现 Drop。</p>
<ol>
<li>第一种是希望在数据结束生命周期的时候做一些事情，比如记日志。</li>
<li>第二种是需要对资源回收的场景。编译器并不知道你额外使用了哪些资源，也就无法帮助你 drop 它们。比如说锁资源的释放，</li>
<li>在 MutexGuard 中实现了 Drop 来释放锁资源：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    #[inline]
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.poison.done(&amp;self.poison);
            self.lock.inner.raw_unlock();
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-copy与drop互斥" class="admonition info">
<summary class="admonition-title">
<p>Copy与Drop互斥</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-copy与drop互斥"></a></p>
</summary>
<div>
<p>需要注意的是，Copy trait 和 Drop trait 是互斥的，两者不能共存，当你尝试为同一种数据类型实现 Copy 时，也实现 Drop，编译器就会报错。</p>
<blockquote>
<p>这其实很好理解：</p>
</blockquote>
<ul>
<li>Copy 是按位做浅拷贝，那么它会默认拷贝的数据没有需要释放的资源；</li>
<li>而 Drop 恰恰是为了释放额外的资源而生的。</li>
</ul>
<hr />
<p>辅助理解，在代码中，强行用 Box::into_raw 获得堆内存的指针，放入 RawBuffer 结构中，这样就接管了这块堆内存的释放。
虽然 RawBuffer 可以实现 Copy trait，但这样一来就无法实现 Drop trait。
如果程序非要这么写，会导致内存泄漏，因为该释放的堆内存没有释放。</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::{fmt, slice};

// 注意这里，我们实现了 Copy，这是因为 *mut u8/usize 都支持 Copy
#[derive(Clone, Copy)]
struct RawBuffer {
    // 裸指针用 *const / *mut 来表述，这和引用的 &amp; 不同
    ptr: *mut u8,
    len: usize,
}

impl From&lt;Vec&lt;u8&gt;&gt; for RawBuffer {
    fn from(vec: Vec&lt;u8&gt;) -&gt; Self {
        let slice = vec.into_boxed_slice();
        Self {
            len: slice.len(),
            // into_raw 之后，Box 就不管这块内存的释放了，RawBuffer 需要处理释放
            ptr: Box::into_raw(slice) as *mut u8,
        }
    }
}

// 如果 RawBuffer 实现了 Drop trait，就可以在所有者退出时释放堆内存
// 然后，Drop trait 会跟 Copy trait 冲突，要么不实现 Copy，要么不实现 Drop
// 如果不实现 Drop，那么就会导致内存泄漏，但它不会对正确性有任何破坏
// 比如不会出现 use after free 这样的问题。
// 你可以试着把下面注释去掉，看看会出什么问题
// impl Drop for RawBuffer {
//     #[inline]
//     fn drop(&amp;mut self) {
//         let data = unsafe { Box::from_raw(slice::from_raw_parts_mut(self.ptr, self.len)) };
//         drop(data)
//     }
// }

impl fmt::Debug for RawBuffer {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        let data = self.as_ref();
        write!(f, &quot;{:p}: {:?}&quot;, self.ptr, data)
    }
}

impl AsRef&lt;[u8]&gt; for RawBuffer {
    fn as_ref(&amp;self) -&gt; &amp;[u8] {
        unsafe { slice::from_raw_parts(self.ptr, self.len) }
    }
}

fn main() {
    let data = vec![1, 2, 3, 4];

    let buf: RawBuffer = data.into();

    // 因为 buf 允许 Copy，所以这里 Copy 了一份
    use_buffer(buf);

    // buf 还能用
    println!(&quot;buf: {:?}&quot;, buf);
}

fn use_buffer(buf: RawBuffer) {
    println!(&quot;buf to die: {:?}&quot;, buf);

    // 这里不用特意 drop，写出来只是为了说明 Copy 出来的 buf 被 Drop 了
    drop(buf)
}
</code></pre></pre>
<hr />
<p>但是这个操作不会破坏 Rust 的正确性保证：即便你 Copy 了 N 份 RawBuffer，由于无法实现 Drop trait，RawBuffer 指向的那同一块堆内存不会释放，所以不会出现 use after free 的内存安全问题</p>
</div>
</details>
<details id="admonition-对于代码安全来说内存泄漏危害大还是-use-after-free-危害大呢" class="admonition info">
<summary class="admonition-title">
<p>对于代码安全来说，内存泄漏危害大？还是 use after free 危害大呢？</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-对于代码安全来说内存泄漏危害大还是-use-after-free-危害大呢"></a></p>
</summary>
<div>
<p>对于代码安全来说，内存泄漏危害大？还是 use after free 危害大呢？</p>
<blockquote>
<p>肯定是后者。</p>
</blockquote>
<ul>
<li>Rust 的底线是内存安全，所以两害相权取其轻。</li>
<li>实际上，任何编程语言都无法保证不发生人为的内存泄漏</li>
<li>比如程序在运行时，开发者疏忽了，对哈希表只添加不删除，就会造成内存泄漏。</li>
<li>但 Rust 会保证即使开发者疏忽了，也不会出现内存安全问题。</li>
</ul>
</div>
</details>
<h3 id="标签trait"><a class="header" href="#标签trait">标签trait</a></h3>
<h4 id="sized"><a class="header" href="#sized">Sized</a></h4>
<details id="admonition-size-data-和处理-data-的函数-process_data" class="admonition info">
<summary class="admonition-title">
<p>Size: Data 和处理 Data 的函数 process_data</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-size-data-和处理-data-的函数-process_data"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
struct Data&lt;T&gt; {
    inner: T,
}

fn process_data&lt;T&gt;(data: Data&lt;T&gt;) {
    todo!();
}
</code></pre></pre>
<p>等价于：</p>
<pre><pre class="playground"><code class="language-rust  editable">
struct Data&lt;T: Sized&gt; {
    inner: T,
}

fn process_data&lt;T: Sized&gt;(data: Data&lt;T&gt;) {
    todo!();
}
</code></pre></pre>
<hr />
<p>大部分时候，我们都希望能自动添加这样的约束，因为这样定义出的泛型结构，在编译期，大小是固定的，可以作为参数传递给函数。如果没有这个约束，T 是大小不固定的类型， process_data 函数会无法编译。</p>
</div>
</details>
<details id="admonition-sized-在少数情况下需要-t-是可变类型的" class="admonition info">
<summary class="admonition-title">
<p>?Sized: 在少数情况下，需要 T 是可变类型的</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-sized-在少数情况下需要-t-是可变类型的"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub enum Cow&lt;'a, B: ?Sized + 'a&gt; where B: ToOwned,
{
    // 借用的数据
    Borrowed(&amp;'a B),
    // 拥有的数据
    Owned(&lt;B as ToOwned&gt;::Owned),
}
</code></pre></pre>
<hr />
<p>这样 B 就可以是 [T] 或者 str 类型，大小都是不固定的。要注意 Borrowed(&amp;’a B) 大小是固定的，因为它内部是对 B 的一个引用，而引用的大小是固定的</p>
</div>
</details>
<h4 id="sendsync"><a class="header" href="#sendsync">Send/Sync</a></h4>
<details id="admonition-这两个-trait-都是-unsafe-auto-trait" class="admonition info">
<summary class="admonition-title">
<p>这两个 trait 都是 unsafe auto trait</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-这两个-trait-都是-unsafe-auto-trait"></a></p>
</summary>
<div>
<p>这两个 trait 都是 unsafe auto trait:</p>
<ul>
<li>auto 意味着编译器会在合适的场合，自动为数据结构添加它们的实现</li>
<li>而 unsafe 代表实现的这个 trait 可能会违背 Rust 的内存安全准则</li>
<li>如果开发者手工实现这两个 trait ，要自己为它们的安全性负责。</li>
</ul>
</div>
</details>
<details id="admonition-sendsync-是-rust-并发安全的基础" class="admonition info">
<summary class="admonition-title">
<p>Send/Sync 是 Rust 并发安全的基础</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-sendsync-是-rust-并发安全的基础"></a></p>
</summary>
<div>
<p>Send/Sync 是 Rust 并发安全的基础：</p>
<ul>
<li>如果一个类型 T 实现了 Send trait，意味着 T 可以安全地从一个线程移动到另一个线程，也就是说所有权可以在线程间移动。</li>
<li>如果一个类型 T 实现了 Sync trait，则意味着 &amp;T 可以安全地在多个线程中共享。一个类型 T 满足 Sync trait，当且仅当 &amp;T 满足 Send trait。</li>
</ul>
</div>
</details>
<details id="admonition-sendsync-在线程安全中的作用" class="admonition info">
<summary class="admonition-title">
<p>Send/Sync 在线程安全中的作用</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-sendsync-在线程安全中的作用"></a></p>
</summary>
<div>
<p>对于 Send/Sync 在线程安全中的作用，可以这么看:</p>
<ol>
<li>如果一个类型 T: Send，那么 T 在某个线程中的独占访问是线程安全的；</li>
<li>如果一个类型 T: Sync，那么 T 在线程间的只读共享是安全的。</li>
</ol>
</div>
</details>
<details id="admonition-绝大多数自定义的数据结构都是满足-send--sync-的标准库中不支持-send--sync-的数据结构主要有" class="admonition info">
<summary class="admonition-title">
<p>绝大多数自定义的数据结构都是满足 Send / Sync 的。标准库中，不支持 Send / Sync 的数据结构主要有</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-绝大多数自定义的数据结构都是满足-send--sync-的标准库中不支持-send--sync-的数据结构主要有"></a></p>
</summary>
<div>
<ol>
<li>裸指针 *const T / *mut T。
它们是不安全的，所以既不是 Send 也不是 Sync。</li>
<li>UnsafeCell 不支持 Sync。
也就是说，任何使用了 Cell 或者 RefCell 的数据结构不支持 Sync。</li>
<li>引用计数 Rc 不支持 Send 也不支持 Sync。所以 Rc 无法跨线程。</li>
</ol>
</div>
</details>
<details id="admonition-尝试跨线程使用-rc--refcell会发生什么" class="admonition info">
<summary class="admonition-title">
<p>尝试跨线程使用 Rc / RefCell，会发生什么</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-尝试跨线程使用-rc--refcell会发生什么"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::{
    cell::RefCell,
    rc::Rc,
    sync::{Arc, Mutex},
    thread,
};

// Rc 既不是 Send，也不是 Sync
#[allow(dead_code, unused_variables)]
fn rc_is_not_send_and_sync() {
    let a = Rc::new(1);
    let b = a.clone();
    let c = a.clone();

    println!(&quot;{:?} {:?} {:?}&quot;, a, b, c);

    // 无法编译通过
    // thread::spawn(move || {
    //     println!(&quot;c= {:?}&quot;, c);
    // });
}

#[allow(dead_code)]
fn refcell_is_send() {
    let a = RefCell::new(1);
    thread::spawn(move || {
        println!(&quot;a= {:?}&quot;, a);
    });
}

// RefCell 现在有多个 Arc 持有它，虽然 Arc 是 Send/Sync，但 RefCell 不是 Sync
#[allow(dead_code, unused_variables)]
fn refcell_is_not_sync() {
    let a = Arc::new(RefCell::new(1));
    let b = a.clone();
    let c = a.clone();

    println!(&quot;{:?} {:?} {:?}&quot;, a, b, c);

    // 无法编译通过
    // thread::spawn(move || {
    //     println!(&quot;c= {:?}&quot;, c);
    // });
}

// Arc&lt;Mutext&lt;T&gt;&gt; 可以多线程共享且修改数据
#[allow(dead_code)]
fn arc_mutext_is_send_sync() {
    let a = Arc::new(Mutex::new(1));
    let b = a.clone();
    let c = a.clone();
    let handle = thread::spawn(move || {
        let mut g = c.lock().unwrap();
        *g += 1;
    });

    {
        let mut g = b.lock().unwrap();
        *g += 1;
    }

    handle.join().unwrap();
    println!(&quot;a= {:?}&quot;, a);
}

// 无法编译通过
// fn mutex_guard_is_not_send() {
//     let mutex = Mutex::new(1);
//     let guard = mutex.lock().unwrap();
//     thread::spawn(|| {
//         println!(&quot;data= {:?}&quot;, guard);
//     });

//     thread::spawn(move || {
//         println!(&quot;data= {:?}&quot;, guard);
//     });
// }

fn main() {}
</code></pre></pre>
</div>
</details>
<details id="admonition-用到的stdthreadspawn" class="admonition info">
<summary class="admonition-title">
<p>用到的std::thread::spawn</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-用到的stdthreadspawn"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; 
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static,
</code></pre></pre>
<hr />
<p>它的参数是一个闭包，这个闭包需要 Send + ’static：</p>
<ol>
<li>’static 意思是闭包捕获的自由变量必须是一个拥有所有权的类型，或者是一个拥有静态生命周期的引用；</li>
<li>Send 意思是，这些被捕获自由变量的所有权可以从一个线程移动到另一个线程。</li>
</ol>
<blockquote>
<p>从这个接口上，可以得出结论：如果在线程间传递 Rc，是无法编译通过的</p>
</blockquote>
</div>
</details>
<details id="admonition-rc不支持send和sync" class="admonition info">
<summary class="admonition-title">
<p>Rc不支持Send和Sync</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-rc不支持send和sync"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
// Rc 既不是 Send，也不是 Sync
fn rc_is_not_send_and_sync() {
    let a = Rc::new(1);
    let b = a.clone();
    let c = a.clone();
    thread::spawn(move || {
        println!(&quot;c= {:?}&quot;, c);
    });
}
</code></pre></pre>
<hr />
<h2 id="-6"><a class="header" href="#-6"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/14%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84trait%EF%BC%9F-4694742.jpg" alt="Rc不支持Send/Sync" /></a></h2>
<p><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-Send">Rc 的实现不支持 Send 和 Sync</a></p>
</div>
</details>
<details id="admonition-refcell-可以在线程间转移所有权么" class="admonition info">
<summary class="admonition-title">
<p>RefCell 可以在线程间转移所有权么？</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-refcell-可以在线程间转移所有权么"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn refcell_is_send() {
    let a = RefCell::new(1);
    thread::spawn(move || {
        println!(&quot;a= {:?}&quot;, a);
    });
}
</code></pre></pre>
<hr />
<blockquote>
<p><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#impl-Send">RefCell 实现了 Send，但没有实现 Sync</a></p>
</blockquote>
</div>
</details>
<details id="admonition-arc支持sendsync" class="admonition info">
<summary class="admonition-title">
<p>Arc支持Send/Sync</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-arc支持sendsync"></a></p>
</summary>
<div>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-Send">Arc支持Send/Sync</a></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
// RefCell 现在有多个 Arc 持有它，虽然 Arc 是 Send/Sync，但 RefCell 不是 Sync
fn refcell_is_not_sync() {
    let a = Arc::new(RefCell::new(1));
    let b = a.clone();
    let c = a.clone();
    thread::spawn(move || {
        println!(&quot;c= {:?}&quot;, c);
    });
}

</code></pre></pre>
<hr />
<p>因为 Arc 内部的数据是共享的，需要支持 Sync 的数据结构，但是 RefCell 不是 Sync，编译失败。</p>
</div>
</details>
<details id="admonition-在多线程情况下我们只能使用支持-sendsync-的-arc-和-mutex-一起构造一个可以在多线程间共享且可以修改的类型" class="admonition info">
<summary class="admonition-title">
<p>在多线程情况下，我们只能使用支持 Send/Sync 的 Arc ，和 Mutex 一起，构造一个可以在多线程间共享且可以修改的类型</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-在多线程情况下我们只能使用支持-sendsync-的-arc-和-mutex-一起构造一个可以在多线程间共享且可以修改的类型"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::{
    sync::{Arc, Mutex},
    thread,
};

// Arc&lt;Mutex&lt;T&gt;&gt; 可以多线程共享且修改数据
fn arc_mutext_is_send_sync() {
    let a = Arc::new(Mutex::new(1));
    let b = a.clone();
    let c = a.clone();
    let handle = thread::spawn(move || {
        let mut g = c.lock().unwrap();
        *g += 1;
    });

    {
        let mut g = b.lock().unwrap();
        *g += 1;
    }

    handle.join().unwrap();
    println!(&quot;a= {:?}&quot;, a);
}

fn main() {
    arc_mutext_is_send_sync();
}
</code></pre></pre>
<hr />
<p>最后一个标记 trait Unpin，是用于自引用类型的，属于Future trait。</p>
</div>
</details>
<h3 id="类型转换-1"><a class="header" href="#类型转换-1">类型转换</a></h3>
<details id="admonition-对比两种转化方式" class="admonition info">
<summary class="admonition-title">
<p>对比两种转化方式</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-对比两种转化方式"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
// 第一种方法，为每一种转换提供一个方法
// 把字符串 s 转换成 Path
let v = s.to_path();
// 把字符串 s 转换成 u64
let v = s.to_u64();

// 第二种方法，为 s 和要转换的类型之间实现一个 Into&lt;T&gt; trait
// v 的类型根据上下文得出
let v = s.into();
// 或者也可以显式地标注 v 的类型
let v: u64 = s.into();
</code></pre></pre>
<hr />
<p>显然，第二种方法要更好，因为它符合软件开发的开闭原则（Open-Close Principle），</p>
<blockquote>
<p>“软件中的对象（类、模块、函数等等）对扩展是开放的，但是对修改是封闭的”。</p>
</blockquote>
<ol>
<li>在第一种方式下，未来每次要添加对新类型的转换，都要重新修改类型 T 的实现</li>
<li>而第二种方式，我们只需要添加一个对于数据转换 trait 的新实现即可。</li>
</ol>
</div>
</details>
<details id="admonition-rust-提供了两套不同的-trait" class="admonition info">
<summary class="admonition-title">
<p>Rust 提供了两套不同的 trait</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-rust-提供了两套不同的-trait"></a></p>
</summary>
<div>
<ol>
<li>值类型到值类型的转换：From / Into / TryFrom / TryInto</li>
<li>引用类型到引用类型的转换：AsRef / AsMut</li>
</ol>
</div>
</details>
<h4 id="frominto-值到值"><a class="header" href="#frominto-值到值">From/Into: 值到值</a></h4>
<details id="admonition-这两种方式是等价的怎么选呢" class="admonition info">
<summary class="admonition-title">
<p>这两种方式是等价的，怎么选呢？</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-这两种方式是等价的怎么选呢"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">let s = String::from(&quot;Hello world!&quot;);
let s: String = &quot;Hello world!&quot;.into();
</code></pre></pre>
<hr />
<p>这两种方式是等价的，怎么选呢？</p>
<ol>
<li>From 可以根据上下文做类型推导，使用场景更多；</li>
<li>而且因为实现了 From 会自动实现 Into，反之不会。</li>
<li>所以需要的时候，不要去实现 Into，只要实现 From 就好了。</li>
</ol>
</div>
</details>
<details id="admonition-from-和-into-还是自反的" class="admonition info">
<summary class="admonition-title">
<p>From 和 Into 还是自反的</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-from-和-into-还是自反的"></a></p>
</summary>
<div>
<p>把类型 T 的值转换成类型 T，会直接返回。这是因为标准库有如下的实现：</p>
<pre><pre class="playground"><code class="language-rust  editable">
// From（以及 Into）是自反的
impl&lt;T&gt; From&lt;T&gt; for T {
    fn from(t: T) -&gt; T {
        t
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-有了-from-和-into很多函数的接口就可以变得灵活" class="admonition info">
<summary class="admonition-title">
<p>有了 From 和 Into，很多函数的接口就可以变得灵活</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-有了-from-和-into很多函数的接口就可以变得灵活"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

fn print(v: impl Into&lt;IpAddr&gt;) {
    println!(&quot;{:?}&quot;, v.into());
}

fn main() {
    let v4: Ipv4Addr = &quot;2.2.2.2&quot;.parse().unwrap();
    let v6: Ipv6Addr = &quot;::1&quot;.parse().unwrap();
    
    // IPAddr 实现了 From&lt;[u8; 4]，转换 IPv4 地址
    print([1, 1, 1, 1]);
    // IPAddr 实现了 From&lt;[u16; 8]，转换 IPv6 地址
    print([0xfe80, 0, 0, 0, 0xaede, 0x48ff, 0xfe00, 0x1122]);
    // IPAddr 实现了 From&lt;Ipv4Addr&gt;
    print(v4);
    // IPAddr 实现了 From&lt;Ipv6Addr&gt;
    print(v6);
}
</code></pre></pre>
<hr />
<p>函数如果接受一个 IpAddr 为参数，我们可以使用 Into 让更多的类型可以被这个函数使用
所以，合理地使用 From / Into，可以让代码变得简洁，符合 Rust 可读性强的风格，更符合开闭原则。</p>
</div>
</details>
<h4 id="tryfromtryinto-值到值可能出现错误"><a class="header" href="#tryfromtryinto-值到值可能出现错误">TryFrom/TryInto: 值到值，可能出现错误</a></h4>
<p>注意，如果你的数据类型在转换过程中有可能出现错误，可以使用 TryFrom 和 TryInto，它们的用法和 From / Into 一样，只是 trait 内多了一个关联类型 Error，且返回的结果是 Result。</p>
<h4 id="asrefasmut-引用到引用"><a class="header" href="#asrefasmut-引用到引用">AsRef/AsMut: 引用到引用</a></h4>
<details id="admonition-asrefasmut定义" class="admonition info">
<summary class="admonition-title">
<p>AsRef/AsMut定义</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-asrefasmut定义"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait AsRef&lt;T&gt; where T: ?Sized {
    fn as_ref(&amp;self) -&gt; &amp;T;
}

pub trait AsMut&lt;T&gt; where T: ?Sized {
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}
</code></pre></pre>
<hr />
<p>在 trait 的定义上，都允许 T 使用大小可变的类型，如 str、[u8] 等。
AsMut 除了使用可变引用生成可变引用外，其它都和 AsRef 一样，所以我们重点看 AsRef</p>
</div>
</details>
<details id="admonition-体验一下-asref-的使用和实现" class="admonition info">
<summary class="admonition-title">
<p>体验一下 AsRef 的使用和实现</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-体验一下-asref-的使用和实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[allow(dead_code)]
enum Language {
    Rust,
    TypeScript,
    Elixir,
    Haskell,
}

impl AsRef&lt;str&gt; for Language {
    fn as_ref(&amp;self) -&gt; &amp;str {
        match self {
            Language::Rust =&gt; &quot;Rust&quot;,
            Language::TypeScript =&gt; &quot;TypeScript&quot;,
            Language::Elixir =&gt; &quot;Elixir&quot;,
            Language::Haskell =&gt; &quot;Haskell&quot;,
        }
    }
}

fn print_ref(v: impl AsRef&lt;str&gt;) {
    println!(&quot;{}&quot;, v.as_ref());
}

fn main() {
    let lang = Language::Rust;
    // &amp;str 实现了 AsRef&lt;str&gt;
    print_ref(&quot;Hello world!&quot;);
    // String 实现了 AsRef&lt;str&gt;
    print_ref(&quot;Hello world!&quot;.to_string());
    // 我们自己定义的 enum 也实现了 AsRef&lt;str&gt;
    print_ref(lang);
}
</code></pre></pre>
<hr />
</div>
</details>
<details id="admonition-vas_refclone" class="admonition info">
<summary class="admonition-title">
<p>v.as_ref().clone()</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-vas_refclone"></a></p>
</summary>
<div>
<p>额外说明一下的是:
如果代码出现 v.as_ref().clone() 这样的语句，也就是说你要对 v 进行引用转换，然后又得到了拥有所有权的值，那么应该实现 From，然后做 v.into()。</p>
</div>
</details>
<h3 id="操作符相关-derefderefmut"><a class="header" href="#操作符相关-derefderefmut">操作符相关: Deref/DerefMut</a></h3>
<details id="admonition-derefderefmut定义及说明" class="admonition info">
<summary class="admonition-title">
<p>Deref/DerefMut定义及说明</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-derefderefmut定义及说明"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Deref {
    // 解引用出来的结果类型
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

pub trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
</code></pre></pre>
<hr />
<p>可以看到，DerefMut “继承”了 Deref，只是它额外提供了一个 deref_mut 方法，用来获取可变的解引用。所以这里重点学习 Deref。</p>
</div>
</details>
<details id="admonition-对于普通的引用解引用很直观" class="admonition info">
<summary class="admonition-title">
<p>对于普通的引用，解引用很直观</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-对于普通的引用解引用很直观"></a></p>
</summary>
<div>
<blockquote>
<p>对于普通的引用，解引用很直观，因为它只有一个指向值的地址，从这个地址可以获取到所需要的值</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
let mut x = 42;
let y = &amp;mut x;
// 解引用，内部调用 DerefMut（其实现就是 *self）
*y += 1;
</code></pre></pre>
</div>
</details>
<details id="admonition-智能指针来说拿什么域来解引用就不那么直观-看看rc如何实现deref" class="admonition info">
<summary class="admonition-title">
<p>智能指针来说，拿什么域来解引用就不那么直观, 看看Rc如何实现Deref</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-智能指针来说拿什么域来解引用就不那么直观-看看rc如何实现deref"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
impl&lt;T: ?Sized&gt; Deref for Rc&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.inner().value
    }
}
</code></pre></pre>
<hr />
<h2 id="可以看到它最终指向了堆上的-rcbox-内部的-value-的地址然后如果对其解引用的话得到了-value-对应的值以下图为例最终打印出-v--1"><a class="header" href="#可以看到它最终指向了堆上的-rcbox-内部的-value-的地址然后如果对其解引用的话得到了-value-对应的值以下图为例最终打印出-v--1">可以看到，它最终指向了堆上的 RcBox 内部的 value 的地址，然后如果对其解引用的话，得到了 value 对应的值。以下图为例，最终打印出 v = 1。</a></h2>
<p>从图中还可以看到，Deref 和 DerefMut 是自动调用的，*b 会被展开为 *(b.deref())。</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/14%EF%BD%9C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84trait%EF%BC%9F-4696029.jpg" alt="RcBox解引用" /></p>
</div>
</details>
<details id="admonition-在-rust-里绝大多数智能指针都实现了-deref我们也可以为自己的数据结构实现-deref" class="admonition info">
<summary class="admonition-title">
<p>在 Rust 里，绝大多数智能指针都实现了 Deref，我们也可以为自己的数据结构实现 Deref</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-在-rust-里绝大多数智能指针都实现了-deref我们也可以为自己的数据结构实现-deref"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::ops::{Deref, DerefMut};

#[derive(Debug)]
struct Buffer&lt;T&gt;(Vec&lt;T&gt;);

impl&lt;T&gt; Buffer&lt;T&gt; {
    pub fn new(v: impl Into&lt;Vec&lt;T&gt;&gt;) -&gt; Self {
        Self(v.into())
    }
}

impl&lt;T&gt; Deref for Buffer&lt;T&gt; {
    type Target = [T];

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl&lt;T&gt; DerefMut for Buffer&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.0
    }
}

fn main() {
    let mut buf = Buffer::new([1, 3, 2, 4]);
    // 因为实现了 Deref 和 DerefMut，这里 buf 可以直接访问 Vec&lt;T&gt; 的方法
    // 下面这句相当于：(&amp;mut buf).deref_mut().sort()，也就是 (&amp;mut buf.0).sort()
    buf.sort();
    println!(&quot;buf: {:?}&quot;, buf);
}
</code></pre></pre>
<hr />
<p>但是在这个例子里，数据结构 Buffer 包裹住了 Vec，但这样一来，原本 Vec 实现了的很多方法，现在使用起来就很不方便，需要用 buf.0 来访问。怎么办？
可以实现 Deref 和 DerefMut，这样在解引用的时候，直接访问到 buf.0，省去了代码的啰嗦和数据结构内部字段的隐藏。</p>
</div>
</details>
<details id="admonition-编译器默认强制做解引用" class="admonition info">
<summary class="admonition-title">
<p>编译器默认强制做解引用</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-编译器默认强制做解引用"></a></p>
</summary>
<div>
<p>在上面代码里，还有一个值得注意的地方：
写 buf.sort() 的时候，并没有做解引用的操作，为什么会相当于访问了 buf.0.sort() 呢？这是因为 sort() 方法第一个参数是 &amp;mut self，此时 Rust 编译器会强制做 Deref/DerefMut 的解引用，所以这相当于 (*(&amp;mut buf)).sort()。</p>
</div>
</details>
<h3 id="其他debugdisplaydefault"><a class="header" href="#其他debugdisplaydefault">其他：Debug/Display/Default</a></h3>
<details id="admonition-debugdisplaydefalut定义" class="admonition info">
<summary class="admonition-title">
<p>Debug/Display/Defalut定义</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-debugdisplaydefalut定义"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
</code></pre></pre>
<hr />
<p>可以看到，Debug 和 Display 两个 trait 的签名一样，都接受一个 &amp;self 和一个 &amp;mut Formatter。那为什么要有两个一样的 trait 呢？</p>
<h2 id="这是因为-debug-是为开发者调试打印数据结构所设计的而-display-是给用户显示数据结构所设计的这也是为什么-debug-trait-的实现可以通过派生宏直接生成而-display-必须手工实现在使用的时候debug-用--来打印display-用--打印"><a class="header" href="#这是因为-debug-是为开发者调试打印数据结构所设计的而-display-是给用户显示数据结构所设计的这也是为什么-debug-trait-的实现可以通过派生宏直接生成而-display-必须手工实现在使用的时候debug-用--来打印display-用--打印">这是因为 Debug 是为开发者调试打印数据结构所设计的，而 Display 是给用户显示数据结构所设计的。这也是为什么 Debug trait 的实现可以通过派生宏直接生成，而 Display 必须手工实现。在使用的时候，Debug 用 {:?} 来打印，Display 用 {} 打印。</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">
pub trait Default {
    fn default() -&gt; Self;
}
---
Default trait 用于为类型提供缺省值。它也可以通过 derive 宏 #[derive(Default)] 来生成实现，前提是类型中的每个字段都实现了 Default trait。在初始化一个数据结构时，我们可以部分初始化，然后剩余的部分使用 Default::default()。
</code></pre></pre>
</div>
</details>
<details id="admonition-debugdisplaydefault统一使用例子" class="admonition info">
<summary class="admonition-title">
<p>Debug/Display/Default统一使用例子</p>
<p><a class="admonition-anchor-link" href="2_type_system.html#admonition-debugdisplaydefault统一使用例子"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::fmt;
// struct 可以 derive Default，但我们需要所有字段都实现了 Default
#[derive(Clone, Debug, Default)]
struct Developer {
    name: String,
    age: u8,
    lang: Language,
}

// enum 不能 derive Default
#[allow(dead_code)]
#[derive(Clone, Debug)]
enum Language {
    Rust,
    TypeScript,
    Elixir,
    Haskell,
}

// 手工实现 Default
impl Default for Language {
    fn default() -&gt; Self {
        Language::Rust
    }
}

impl Developer {
    pub fn new(name: &amp;str) -&gt; Self {
        // 用 ..Default::default() 为剩余字段使用缺省值
        Self {
            name: name.to_owned(),
            ..Default::default()
        }
    }
}

impl fmt::Display for Developer {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            &quot;{}({} years old): {:?} developer&quot;,
            self.name, self.age, self.lang
        )
    }
}

fn main() {
    // 使用 T::default()
    let dev1 = Developer::default();
    // 使用 Default::default()，但此时类型无法通过上下文推断，需要提供类型
    let dev2: Developer = Default::default();
    // 使用 T::new
    let dev3 = Developer::new(&quot;Tyr&quot;);
    println!(&quot;dev1: {}\\ndev2: {}\\ndev3: {:?}&quot;, dev1, dev2, dev3);
}
</code></pre></pre>
</div>
</details>
<h2 id="设计架构"><a class="header" href="#设计架构">设计架构</a></h2>
<h3 id="顺手自然"><a class="header" href="#顺手自然">顺手自然</a></h3>
<h3 id="桥接"><a class="header" href="#桥接">桥接</a></h3>
<h3 id="控制反转"><a class="header" href="#控制反转">控制反转</a></h3>
<h3 id="solid原则"><a class="header" href="#solid原则">SOLID原则</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iii-数据结构"><a class="header" href="#iii-数据结构">III. 数据结构</a></h1>
<!--ts-->
<ul>
<li><a href="3_data_structure.html#iii-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">III. 数据结构</a>
<ul>
<li><a href="3_data_structure.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BF%AB%E9%80%9F%E4%B8%80%E8%A7%88">数据结构快速一览</a></li>
<li><a href="3_data_structure.html#%E5%88%86%E7%B1%BB%E5%9B%BE">分类图</a></li>
</ul>
</li>
<li><a href="3_data_structure.html#%E4%B8%80%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">一、智能指针</a>
<ul>
<li><a href="3_data_structure.html#%E6%8C%87%E9%92%88%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8">指针还是引用</a></li>
<li><a href="3_data_structure.html#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8D%E4%BB%85%E6%98%AF%E6%8C%87%E9%92%88">智能指针不仅是指针</a></li>
<li><a href="3_data_structure.html#box-%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98">Box: 在堆上分配内存</a>
<ul>
<li><a href="3_data_structure.html#%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8">实现内存分配器</a></li>
<li><a href="3_data_structure.html#%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E9%87%8A%E6%94%BE">内存如何释放</a></li>
</ul>
</li>
<li><a href="3_data_structure.html#cowa-b-%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D">Cow&lt;’a, B&gt;： 写时拷贝</a>
<ul>
<li><a href="3_data_structure.html#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="3_data_structure.html#%E4%B8%A4%E4%B8%AAtraittoownedborrowed">两个trait：ToOwned、Borrowed</a></li>
<li><a href="3_data_structure.html#toowned">ToOwned</a></li>
<li><a href="3_data_structure.html#%E5%8C%B9%E9%85%8D%E5%88%86%E5%8F%91">匹配分发</a></li>
<li><a href="3_data_structure.html#cow%E5%9C%A8%E9%9C%80%E8%A6%81%E6%97%B6%E6%89%8D%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%8B%B7%E8%B4%9D">Cow在需要时才进行内存分配拷贝</a></li>
</ul>
</li>
<li><a href="3_data_structure.html#mutexguard-%E6%95%B0%E6%8D%AE%E5%8A%A0%E9%94%81">MutexGuard： 数据加锁</a>
<ul>
<li><a href="3_data_structure.html#mutexguard%E4%B8%8Estringboxcowa-b%E7%9A%84%E5%AF%B9%E6%AF%94">MutexGuard与String、Box、Cow&lt;’a, B&gt;的对比</a></li>
<li><a href="3_data_structure.html#%E4%BD%BF%E7%94%A8mutexlock%E8%8E%B7%E5%8F%96">使用Mutex::lock获取</a></li>
<li><a href="3_data_structure.html#%E5%AE%9A%E4%B9%89%E4%B8%8Ederefdrop-trait%E5%AE%9E%E7%8E%B0">定义与Deref、Drop trait实现</a></li>
<li><a href="3_data_structure.html#%E4%BD%BF%E7%94%A8mutex_mutexguard%E7%9A%84%E4%BE%8B%E5%AD%90">使用Mutex_MutexGuard的例子</a></li>
</ul>
</li>
<li><a href="3_data_structure.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">自定义智能指针</a></li>
</ul>
</li>
<li><a href="3_data_structure.html#%E4%BA%8C%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8">二、集合容器</a>
<ul>
<li><a href="3_data_structure.html#%E5%AF%B9%E5%AE%B9%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%B9%89">对容器进行定义</a></li>
<li><a href="3_data_structure.html#%E5%AF%B9%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%B9%89">对集合容器进行定义</a></li>
<li><a href="3_data_structure.html#%E5%88%87%E7%89%87">切片</a>
<ul>
<li><a href="3_data_structure.html#array-vs-vector">array vs vector</a></li>
<li>[Vec 和 &amp;[T]](#vec-和-t)</li>
<li><a href="3_data_structure.html#%E8%A7%A3%E5%BC%95%E7%94%A8">解引用</a></li>
<li><a href="3_data_structure.html#%E5%88%87%E7%89%87%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator">切片和迭代器 Iterator</a></li>
<li><a href="3_data_structure.html#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%88%87%E7%89%87str">特殊的切片：&amp;str</a></li>
<li>[Box&lt;[T]&gt;](#boxt)</li>
<li><a href="3_data_structure.html#%E5%B8%B8%E7%94%A8%E5%88%87%E7%89%87%E5%AF%B9%E6%AF%94%E5%9B%BE">常用切片对比图</a></li>
</ul>
</li>
<li><a href="3_data_structure.html#%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>
<ul>
<li><a href="3_data_structure.html#hashmap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">HashMap数据结构</a></li>
<li><a href="3_data_structure.html#hashmap%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">HashMap基本使用方法</a></li>
<li><a href="3_data_structure.html#hashmap%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">HashMap内存布局</a></li>
<li><a href="3_data_structure.html#ctrl%E8%A1%A8">ctrl表</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="3_data_structure.html#%E4%B8%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">三、错误处理</a>
<ul>
<li><a href="3_data_structure.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%BB%E6%B5%81%E6%96%B9%E6%B3%95">错误处理主流方法</a></li>
<li><a href="3_data_structure.html#rust%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF">Rust如何处理错误</a></li>
</ul>
</li>
<li><a href="3_data_structure.html#%E5%9B%9B%E9%97%AD%E5%8C%85%E7%BB%93%E6%9E%84">四、闭包结构</a>
<ul>
<li><a href="3_data_structure.html#%E9%97%AD%E5%8C%85%E5%AE%9A%E4%B9%89">闭包定义</a></li>
<li><a href="3_data_structure.html#%E9%97%AD%E5%8C%85%E6%9C%AC%E8%B4%A8">闭包本质</a></li>
<li><a href="3_data_structure.html#%E9%97%AD%E5%8C%85%E8%AE%BE%E8%AE%A1">闭包设计</a></li>
<li><a href="3_data_structure.html#rust%E9%97%AD%E5%8C%85%E7%B1%BB%E5%9E%8B">Rust闭包类型</a></li>
<li><a href="3_data_structure.html#%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">闭包使用场景</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Oct  4 07:24:32 UTC 2022 -->
<!--te-->
<h2 id="数据结构快速一览"><a class="header" href="#数据结构快速一览">数据结构快速一览</a></h2>
<div id="admonition-数据结构快速一览" class="admonition tip">
<div class="admonition-title">
<p>数据结构快速一览</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-数据结构快速一览"></a></p>
</div>
<div>
<blockquote>
<p>用40分钟的时间，总结了Rust的主要数据结构的内 存布局。它能厘清“数据是如何在堆和栈上存储“的思路，在这里也推荐给你。
<a href="https://www.youtube.com/watch?v=rDoqT-a6UFg">Visualizing memory layout of Rust’s data types - YouTube</a></p>
</blockquote>
</div>
</div>
<h2 id="分类图"><a class="header" href="#分类图">分类图</a></h2>
<blockquote>
<p>数据结构可以看作对于类型系统的进一步整理，结构化。这其实是进一步抽象，从类型中提取出日常常用的工具并分类。</p>
</blockquote>
<div id="admonition-从系统容器原生三个纬度分类" class="admonition info">
<div class="admonition-title">
<p>从系统/容器/原生三个纬度分类</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-从系统容器原生三个纬度分类"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F.jpg" alt="" /></p>
</div>
</div>
<h1 id="一智能指针"><a class="header" href="#一智能指针">一、智能指针</a></h1>
<h2 id="指针还是引用"><a class="header" href="#指针还是引用">指针还是引用</a></h2>
<details id="admonition-引用是特殊的指针" class="admonition info">
<summary class="admonition-title">
<p>引用是特殊的指针</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-引用是特殊的指针"></a></p>
</summary>
<div>
<ol>
<li>指针是一个持有内存地址的值，可以通过解引用来访问它指向的内存地址，理论上可以解引用到任意数据类型；</li>
<li>引用是一个特殊 的指针，它的解引用访问是受限的，只能解引用到它引用数据的类型，不能用作它用。</li>
</ol>
</div>
</details>
<h2 id="智能指针不仅是指针"><a class="header" href="#智能指针不仅是指针">智能指针不仅是指针</a></h2>
<details id="admonition-智能指针指针额外处理能力" class="admonition info">
<summary class="admonition-title">
<p>智能指针=指针+额外处理能力</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-智能指针指针额外处理能力"></a></p>
</summary>
<div>
<ol>
<li>在指针和引用的基础上，Rust 偷师 C++，提供了智能指针。</li>
<li>智能指针是一个表现行为很 像指针的数据结构，但除了指向数据的指针外，它还有元数据以提供额外的处理能力。</li>
</ol>
</div>
</details>
<details id="admonition-智能指针胖指针所有权" class="admonition info">
<summary class="admonition-title">
<p>智能指针=胖指针+所有权</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-智能指针胖指针所有权"></a></p>
</summary>
<div>
<ol>
<li>智能指针一定是一个胖指针，但胖指针不一定是一个 智能指针。</li>
<li>比如 &amp;str 就只是一个胖指针，它有指向堆内存字符串的指针，同时还有关于字 符串长度的元数据。</li>
</ol>
<h2 id="-7"><a class="header" href="#-7"><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/15%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F.jpg" alt="" /></a></h2>
<ol>
<li>String 除了多一个 capacity 字段，似乎也没有什么特殊。</li>
<li>但 String 对 堆上的值有所有权，而 &amp;str 是没有所有权的</li>
<li>这是 Rust 中智能指针和普通胖指针的区 别。</li>
</ol>
</div>
</details>
<details id="admonition-智能指针和结构体有什么区别" class="admonition info">
<summary class="admonition-title">
<p>智能指针和结构体有什么区别</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-智能指针和结构体有什么区别"></a></p>
</summary>
<div>
<ol>
<li>String用结构体定义，其实就是Vec<u8></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>和普通的结构体不同的是，<a href="https://doc.rust-lang.org/src/alloc/string.rs.html#2301-2316">String 实现了 Deref 和 DerefMut</a>，这使得它在解引用的时
候，会得到 &amp;str</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl ops::Deref for String {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;str {
        unsafe { str::from_utf8_unchecked(&amp;self.vec) }
    }
}

impl ops::DerefMut for String {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut str {
        unsafe { str::from_utf8_unchecked_mut(&amp;mut *self.vec) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>另外，由于在堆上分配了数据，String 还需要为其分配的资源做相应的回收。而 String 内部使用了
Vec，所以它可以<a href="https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#2710-2720">依赖 Vec 的能力来释放堆内存</a></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>unsafe impl&lt;#[may_dangle] T, A: Allocator&gt; Drop for Vec&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // use drop for [T]
            // use a raw slice to refer to the elements of the vector as weakest necessary type;
            // could avoid questions of validity in certain cases
            ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))
        }
        // RawVec handles deallocation
    }
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-在-rust-中凡是需要做资源回收的数据结构且实现了-derefderefmutdrop都是智能指针" class="admonition info">
<summary class="admonition-title">
<p>在 Rust 中，凡是需要做资源回收的数据结构，且实现了 Deref/DerefMut/Drop，都是智能指针。</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-在-rust-中凡是需要做资源回收的数据结构且实现了-derefderefmutdrop都是智能指针"></a></p>
</summary>
<div>
<p>按照这个定义，除了 String，还有很多智能指针，比如：</p>
<ol>
<li>
<p>用于在堆上 分配内存的 Box<T> 和 Vec<T></p>
</li>
<li>
<p>用于引用计数的 Rc<T> 和 Arc<T> </p>
</li>
<li>
<p>很多其他数据结 构，如 PathBuf、Cow&lt;’a, B&gt;、MutexGuard<T>、RwLockReadGuard<T> 和 RwLockWriteGuard 等也是智能指针。</p>
</li>
</ol>
</div>
</details>
<h2 id="box-在堆上分配内存"><a class="header" href="#box-在堆上分配内存">Box<T>: 在堆上分配内存</a></h2>
<details id="admonition-从cc得到box灵感" class="admonition info">
<summary class="admonition-title">
<p>从c/c++得到Box<T>灵感</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-从cc得到box灵感"></a></p>
</summary>
<div>
<p>我们先看 Box<T>，它是 Rust 中最基本的在堆上分配内存的方式，绝大多数其它包含堆内 存分配的数据类型，内部都是通过 Box<T> 完成的，比如 Vec<T>。</p>
<p>为什么有 Box<T> 的设计，我们得先回忆一下在 C 语言中，堆内存是怎么分配的。</p>
<ol>
<li>
<p>C 需要使用 malloc/calloc/realloc/free 来处理内存的分配，很多时候，被分配出来的内存 在函数调用中来来回回使用，导致谁应该负责释放这件事情很难确定，给开发者造成了极 大的心智负担。</p>
</li>
<li>
<p>C++ 在此基础上改进了一下，提供了一个智能指针  unique_ptr，可以在指针退出作用 域的时候释放堆内存，这样保证了堆内存的单一所有权。这个 unique_ptr 就是 Rust 的 Box<T> 的前身。</p>
</li>
</ol>
<hr />
<p><a href="https://doc.rust-lang.org/src/core/ptr/unique.rs.html#36-44">Box<T> 的定义</a>里，内部就是一个 Unique<T> 用于致敬 C++，Unique<T> 是
一个私有的数据结构，我们不能直接使用，它包裹了一个 *const T 指针，并唯一拥有这个 指针。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Unique&lt;T: ?Sized&gt; {
    pointer: *const T,
    // NOTE: this marker has no consequences for variance, but is necessary
    // for dropck to understand that we logically own a `T`.
    //
    // For details, see:
    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data
    _marker: PhantomData&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-堆上分配内存的-box-其实有一个缺省的泛型参数-a" class="admonition info">
<summary class="admonition-title">
<p>堆上分配内存的 Box<T> 其实有一个缺省的泛型参数 A</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-堆上分配内存的-box-其实有一个缺省的泛型参数-a"></a></p>
</summary>
<div>
<p>设计内存分配器的目的除了保证正确性之外，就是为了有效地利用剩余内存，并控制内存 在分配和释放过程中产生的碎片的数量。
在多核环境下，它还要能够高效地处理并发请 求。（如果你对通用内存分配器感兴趣，可以看参考资料） 堆上分配内存的 Box<T></p>
<p>其实有一个缺省的泛型参数 A，就需要满足 <a href="https://doc.rust-lang.org/std/alloc/trait.Allocator.html">Allocator trait</a>， 并且默认是 Global：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub struct Box&lt;T: ?Sized, A: Allocator = Global&gt;(Unique&lt;T&gt;, A);
<span class="boring">}
</span></code></pre></pre>
<hr />
<p>Allocator trait 提供很多方法：</p>
<ol>
<li>
<p>allocate 是主要方法，用于分配内存，对应 C 的 malloc/calloc；</p>
</li>
<li>
<p>deallocate，用于释放内存，对应 C 的 free；</p>
</li>
<li>
<p>还有 grow / shrink，用来扩大或缩小堆上已分配的内存，对应 C 的 realloc。</p>
</li>
</ol>
</div>
</details>
<details id="admonition-替换默认的内存分配器" class="admonition info">
<summary class="admonition-title">
<p>替换默认的内存分配器</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-替换默认的内存分配器"></a></p>
</summary>
<div>
<p>如果你想替换默认的内存分配器，可以使用 #[global_allocator] 标记宏，定义你自己的全局分配器。下面的代码展示了如何在 Rust
下使用<a href="https://crates.io/crates/jemallocator">jemalloc</a>:</p>
<pre><pre class="playground"><code class="language-rust">
use jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

fn main() {}
</code></pre></pre>
</div>
</details>
<h3 id="实现内存分配器"><a class="header" href="#实现内存分配器">实现内存分配器</a></h3>
<details id="admonition-内存分配器" class="admonition info">
<summary class="admonition-title">
<p>内存分配器</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-内存分配器"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::alloc::{GlobalAlloc, Layout, System};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        let data = System.alloc(layout);
        eprintln!(&quot;ALLOC: {:p}, size {}&quot;, data, layout.size());
        data
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        eprintln!(&quot;FREE: {:p}, size {}&quot;, ptr, layout.size());
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;

#[allow(dead_code)]
struct Matrix {
    // 使用不规则的数字如 505 可以让 dbg! 的打印很容易分辨出来
    data: [u8; 505],
}

impl Default for Matrix {
    fn default() -&gt; Self {
        Self { data: [0; 505] }
    }
}

fn main() {
    // 在这句执行之前已经有一些内存分配和释放
    let data = Box::new(Matrix::default());
    println!(
        &quot;!!! allocated memory: {:p}, len: {}&quot;,
        &amp;*data,
        std::mem::size_of::&lt;Matrix&gt;()
    );

    // data 在这里 drop，可以在打印中看到 FREE
    // 之后还有很多其它内存被释放
}
</code></pre></pre>
<hr />
<ol>
<li>这里 MyAllocator 就用 System allocator，然后加 eprintln!()，和我 们常用的 println!() 不同的是，eprintln!() 将数据打印到 stderr</li>
<li>注意这里不能使用 println!() 。因为 stdout 会打印到一个由 Mutex 互斥锁保护的共享全 局 buffer 中，这个过程中会涉及内存的分配，分配的内存又会触发 println!()，最终造成 程序崩溃。而
eprintln! 直接打印到 stderr，不会 buffer。</li>
<li>在使用 Box 分配堆内存的时候要注意，Box::new() 是一个函数，所以传入它的数据会出现 在栈上，再移动到堆上。所以，如果我们的 Matrix 结构不是 505 个字节，是一个非常大 的结构，就有可能出问题。</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">// #![feature(dropck_eyepatch)]

// struct MyBox&lt;T&gt;(Box&lt;T&gt;);

// unsafe impl&lt;#[may_dangle] T&gt; Drop for MyBox&lt;T&gt; {
//     fn drop(&amp;mut self) {
//         todo!();
//     }
// }

fn main() {
    // 在堆上分配 16M 内存，但它会现在栈上出现，再移动到堆上
    let boxed = Box::new([0u8; 1 &lt;&lt; 24]);
    println!(&quot;len: {}&quot;, boxed.len());
}
</code></pre></pre>
<ul>
<li><code>cargo run --bin box</code>或者在 playground 里运行，直接栈溢出 stack overflow</li>
<li>本地使用 “cargo run –bin box —release” 编译成 release 代码运行，会正常执行！</li>
</ul>
<blockquote>
<p>这是因为 “cargo run” 或者在 playground 下运行，默认是 debug build，它不会做任 何 inline 的优化，而 Box::new() 的实现就一行代码，并注明了要 inline，在 release 模式
下，这个函数调用会被优化掉, 本质是编译器自动调用下列方式:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(not(no_global_oom_handling))]
#[inline(always)]
#[doc(alias = &quot;alloc&quot;)]
#[doc(alias = &quot;malloc&quot;)]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub fn new(x: T) -&gt; Self {
    box x
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这里的关键字 box是 Rust 内部的关键字，用户代码无法调用，它只出现在 Rust 代码中，用于分配堆内存，box 关键字在编译时，会使用内存分配器 分配内存。</p>
</blockquote>
</div>
</details>
<h3 id="内存如何释放"><a class="header" href="#内存如何释放">内存如何释放</a></h3>
<details id="admonition-box默认实现的drop-trait" class="admonition info">
<summary class="admonition-title">
<p>Box<T>默认实现的Drop trait</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-box默认实现的drop-trait"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
unsafe impl&lt;#[may_dangle] T: ?Sized, A: Allocator&gt; Drop for Box&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        // FIXME: Do nothing, drop is currently performed by compiler.
    }
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-先稳定接口再迭代稳定实现" class="admonition info">
<summary class="admonition-title">
<p>先稳定接口，再迭代稳定实现</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-先稳定接口再迭代稳定实现"></a></p>
</summary>
<div>
<p>目前 drop trait 什么都没有做，编译器会自动插入 deallocate 的代码。这是 Rust 语 言的一种策略：在具体实现还没有稳定下来之前，我先把接口稳定，实现随着之后的迭代 慢慢稳定。</p>
</div>
</details>
<h2 id="cowa-b-写时拷贝"><a class="header" href="#cowa-b-写时拷贝">Cow&lt;’a, B&gt;： 写时拷贝</a></h2>
<div id="admonition-写时复制copy-on-write有异曲同工之妙" class="admonition info">
<div class="admonition-title">
<p>写时复制（Copy-on-write）有异曲同工之妙</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-写时复制copy-on-write有异曲同工之妙"></a></p>
</div>
<div>
<p>Cow 是 Rust 下用于提供写时克隆（Clone-on-Write）的一个智能指针，它跟虚拟内存管 理的写时复制（Copy-on-write）有异曲同工之妙：</p>
<blockquote>
<p>包裹一个只读借用，但如果调用者需 要所有权或者需要修改内容，那么它会 clone 借用的数据</p>
</blockquote>
</div>
</div>
<h3 id="定义"><a class="header" href="#定义">定义</a></h3>
<div id="admonition-cow定义" class="admonition info">
<div class="admonition-title">
<p>Cow定义</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-cow定义"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub enum Cow&lt;'a, B&gt; where B: 'a + ToOwned + ?Sized {
    Borrowed(&amp;'a B),
    Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>它是一个 enum，可以包含一个对类型 B 的只读引用，或者包含对类型 B 的拥有所有权的 数据。</p>
</blockquote>
</div>
</div>
<h3 id="两个traittoownedborrowed"><a class="header" href="#两个traittoownedborrowed">两个trait：ToOwned、Borrowed</a></h3>
<div id="admonition-cow定义用到两个traittoowned和borrowed" class="admonition info">
<div class="admonition-title">
<p>Cow定义用到两个trait：ToOwned和Borrowed</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-cow定义用到两个traittoowned和borrowed"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait ToOwned {
    type Owned: Borrow&lt;Self&gt;;
    #[must_use = &quot;cloning is often expensive and is not expected to have side effects&quot;]
    fn to_owned(&amp;self) -&gt; Self::Owned;

    fn clone_into(&amp;self, target: &amp;mut Self::Owned) { ... }
}

pub trait Borrow&lt;Borrowed&gt; where Borrowed: ?Sized {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>它是一个 enum，可以包含一个对类型 B 的只读引用，或者包含对类型 B 的拥有所有权的 数据。</p>
</blockquote>
</div>
</div>
<h3 id="toowned"><a class="header" href="#toowned">ToOwned</a></h3>
<div id="admonition-type-owned-borrow" class="admonition info">
<div class="admonition-title">
<p>type Owned: Borrow<Self></p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-type-owned-borrow"></a></p>
</div>
<div>
<ol>
<li>首先，type Owned: Borrow<Self> 是一个带有关联类型的 trait. 这里 Owned 是关联类型，需要使用者定义.</li>
<li>这里 Owned 不能是任意类型，它必须满足 Borrow<T> trait</li>
<li><a href="https://doc.rust-lang.org/src/alloc/str.rs.html#215-227">参考str对ToOwned trait的实现</a>：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl ToOwned for str {
    type Owned = String;
    #[inline]
    fn to_owned(&amp;self) -&gt; String {
        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }
    }

    fn clone_into(&amp;self, target: &amp;mut String) {
        let mut b = mem::take(target).into_bytes();
        self.as_bytes().clone_into(&amp;mut b);
        *target = unsafe { String::from_utf8_unchecked(b) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol start="4">
<li>可以看到关联类型 Owned 被定义为 String，而根据要求，String 必须定义 Borrow，那这里 Borrow 里的泛型变量 T 是谁呢？</li>
<li>ToOwned 要求是 Borrow，而此刻实现 ToOwned 的主体是 str，所以 Borrow 是 Borrow，也就是说 String 要实现 Borrow</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl Borrow&lt;str&gt; for String {
    #[inline]
    fn borrow(&amp;self) -&gt; &amp;str {
        &amp;self[..]
    }
}
<span class="boring">}
</span></code></pre></pre>
</div>
</div>
<div id="admonition-cow-和-toowned--borrow-之间的关系示意图" class="admonition info">
<div class="admonition-title">
<p>Cow 和 ToOwned / Borrow<T> 之间的关系示意图</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-cow-和-toowned--borrow-之间的关系示意图"></a></p>
</div>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/15%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F-4781304.jpg" alt="type Owned: Borrow&lt;Self&gt; " /></p>
</div>
</div>
<h3 id="匹配分发"><a class="header" href="#匹配分发">匹配分发</a></h3>
<div id="admonition-为何-borrow-要定义成一个泛型-trait-呢" class="admonition info">
<div class="admonition-title">
<p>为何 Borrow 要定义成一个泛型 trait 呢？</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-为何-borrow-要定义成一个泛型-trait-呢"></a></p>
</div>
<div>
<ol>
<li>例子1：String不同借用方式</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use std::borrow::Borrow;

fn main() {
    let s = &quot;hello world!&quot;.to_owned();

    // 这里必须声明类型，因为 String 有多个 Borrow&lt;T&gt; 实现
    // 借用为 &amp;String
    let r1: &amp;String = s.borrow();
    // 借用为 &amp;str
    let r2: &amp;str = s.borrow();

    println!(&quot;r1: {:p}, r2: {:p}&quot;, r1, r2);
}
</code></pre></pre>
<blockquote>
<p>String 可以被借用为 &amp;String，也可以被借用为 &amp;str</p>
</blockquote>
<hr />
<ol start="2">
<li>例子2：Cow不同解引用方式</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;B: ?Sized + ToOwned&gt; Deref for Cow&lt;'_, B&gt; {
    type Target = B;

    fn deref(&amp;self) -&gt; &amp;B {
        match *self {
            Borrowed(borrowed) =&gt; borrowed,
            Owned(ref owned) =&gt; owned.borrow(),
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<hr />
<p>实现的原理很简单，根据 self 是 Borrowed 还是 Owned，我们分别取其内容，生成引 用：</p>
<ol>
<li>
<p>对于 Borrowed，直接就是引用；</p>
</li>
<li>
<p>对于 Owned，调用其 borrow() 方法，获得引用。</p>
</li>
</ol>
</div>
</div>
<div id="admonition-匹配分发使用match匹配实现静态动态分发之外的第三种分发" class="admonition info">
<div class="admonition-title">
<p>匹配分发：使用match匹配实现静态、动态分发之外的第三种分发</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-匹配分发使用match匹配实现静态动态分发之外的第三种分发"></a></p>
</div>
<div>
<p>虽然 Cow 是一个 enum，但是通过 Deref 的实现，我们可以获得统一的 体验.
比如 Cow<str>，使用的感觉和 &amp;str / String 是基本一致的。
注意，这种根据 enum 的不同状态来进行统一分发的方法是第三种分发手段，另外还可以使用泛型参数 做静态分发和使用 trait object 做动态分发</p>
</div>
</div>
<h3 id="cow在需要时才进行内存分配拷贝"><a class="header" href="#cow在需要时才进行内存分配拷贝">Cow在需要时才进行内存分配拷贝</a></h3>
<div id="admonition-写时拷贝" class="admonition info">
<div class="admonition-title">
<p>写时拷贝</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-写时拷贝"></a></p>
</div>
<div>
<p>那么 Cow 有什么用呢？</p>
<ol>
<li>显然，它可以在需要的时候才进行内存的分配和拷贝，在很多应用 场合，它可以大大提升系统的效率。</li>
<li>如果 Cow&lt;’a, B&gt; 中的 Owned 数据类型是一个需要 在堆上分配内存的类型，如 String、Vec<T> 等，还能减少堆内存分配的次数。 </li>
<li>相对于栈内存的分配释放来说，堆内存的分配和释放效率要低很多，其内部还 涉及系统调用和锁，减少不必要的堆内存分配是提升系统效率的关键手段。</li>
<li>而 Rust 的 Cow&lt;’a, B&gt;，在帮助你达成这个效果的同时，使用体验还非常简单舒服。</li>
</ol>
</div>
</div>
<details id="admonition-举例使用cow进行url解析" class="admonition info">
<summary class="admonition-title">
<p>举例使用Cow进行URL解析</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-举例使用cow进行url解析"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::borrow::Cow;

use url::Url;
fn main() {
    let url = Url::parse(&quot;https://tyr.com/rust?page=1024&amp;sort=desc&amp;extra=hello%20world&quot;).unwrap();
    let mut pairs = url.query_pairs();

    assert_eq!(pairs.count(), 3);

    let (mut k, v) = pairs.next().unwrap();
    // 因为 k, v 都是 Cow&lt;str&gt; 他们用起来感觉和 &amp;str 或者 String 一样
    // 此刻，他们都是 Borrowed
    println!(&quot;key: {}, v: {}&quot;, k, v);
    // 当修改发生时，k 变成 Owned
    k.to_mut().push_str(&quot;_lala&quot;);

    print_pairs((k, v));

    print_pairs(pairs.next().unwrap());
    print_pairs(pairs.next().unwrap());
}

fn print_pairs(pair: (Cow&lt;str&gt;, Cow&lt;str&gt;)) {
    println!(&quot;key: {}, value: {}&quot;, show_cow(pair.0), show_cow(pair.1));
}

fn show_cow(cow: Cow&lt;str&gt;) -&gt; String {
    match cow {
        Cow::Borrowed(v) =&gt; format!(&quot;Borrowed {}&quot;, v),
        Cow::Owned(v) =&gt; format!(&quot;Owned {}&quot;, v),
    }
}
</code></pre></pre>
<hr />
<blockquote>
<p>在解析 URL 的时候，我们经常需要将 querystring 中的参数，提取成 KV pair 来进一步使 用。
绝大多数语言中，提取出来的 KV 都是新的字符串，在每秒钟处理几十 k 甚至上百 k 请求的系统中，你可以想象这会带来多少次堆内存的分配。 
但在 Rust 中，我们可以用 Cow 类型轻松高效处理它，在读取 URL 的过程中：</p>
</blockquote>
<ol>
<li>每解析出一个 key 或者 value，我们可以用一个 &amp;str 指向 URL 中相应的位置，然后用 Cow 封装它 </li>
<li>而当解析出来的内容不能直接使用，需要 decode 时，比如 “hello%20world”，我们 可以生成一个解析后的 String，同样用 Cow 封装它。</li>
</ol>
</div>
</details>
<details id="admonition-举例serde使用cow进行序列化反序列化" class="admonition info">
<summary class="admonition-title">
<p>举例serde使用Cow进行序列化/反序列化</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-举例serde使用cow进行序列化反序列化"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use serde::Deserialize;
use std::borrow::Cow;

#[allow(dead_code)]
#[derive(Debug, Deserialize)]
struct User&lt;'input&gt; {
    #[serde(borrow)]
    name: Cow&lt;'input, str&gt;,
    age: u8,
}

fn main() {
    let input = r#&quot;{ &quot;name&quot;: &quot;Tyr&quot;, &quot;age&quot;: 18 }&quot;#;
    let user: User = serde_json::from_str(input).unwrap();

    match user.name {
        Cow::Borrowed(x) =&gt; println!(&quot;borrowed {}&quot;, x),
        Cow::Owned(x) =&gt; println!(&quot;owned {}&quot;, x),
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="mutexguard-数据加锁"><a class="header" href="#mutexguard-数据加锁">MutexGuard<T>： 数据加锁</a></h2>
<h3 id="mutexguard与stringboxcowa-b的对比"><a class="header" href="#mutexguard与stringboxcowa-b的对比">MutexGuard与String、Box<T>、Cow&lt;’a, B&gt;的对比</a></h3>
<details id="admonition-derefdrop" class="admonition info">
<summary class="admonition-title">
<p>Deref+Drop</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-derefdrop"></a></p>
</summary>
<div>
<p>String、Box<T>、Cow&lt;’a, B&gt; 等智能指针，都是通过 Deref 来提 供良好的用户体验， 
MutexGuard<T> 是另外一类很有意思的智能指针：</p>
<ol>
<li>它不但通过 Deref 提供良好的用户体验</li>
<li>还通过 Drop trait 来确保，使用到的内存以外的资源在退出 时进行释放。</li>
</ol>
</div>
</details>
<h3 id="使用mutexlock获取"><a class="header" href="#使用mutexlock获取">使用Mutex::lock获取</a></h3>
<details id="admonition-mutexguard这个结构是在调用-mutexlock-时生成的" class="admonition info">
<summary class="admonition-title">
<p>MutexGuard这个结构是在调用 Mutex::lock 时生成的</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-mutexguard这个结构是在调用-mutexlock-时生成的"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
    unsafe {
        self.inner.raw_lock();
        MutexGuard::new(self)
    }
}
</code></pre></pre>
<hr />
<p><a href="https://doc.rust-lang.org/src/std/sync/mutex.rs.html#279-284">rust文档</a></p>
<ol>
<li>首先，它会取得锁资源，如果拿不到，会在这里等待；</li>
<li>如果拿到了，会把 Mutex 结构的引 用传递给 MutexGuard。</li>
</ol>
</div>
</details>
<h3 id="定义与derefdrop-trait实现"><a class="header" href="#定义与derefdrop-trait实现">定义与Deref、Drop trait实现</a></h3>
<details id="admonition-mutexguard-的定义以及它的-deref-和-drop-的实现" class="admonition info">
<summary class="admonition-title">
<p>MutexGuard 的定义以及它的 Deref 和 Drop 的实现</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-mutexguard-的定义以及它的-deref-和-drop-的实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
// 这里用 must_use，当你得到了却不使用 MutexGuard 时会报警
#[must_use = &quot;if unused the Mutex will immediately unlock&quot;]
pub struct MutexGuard&lt;'a, T: ?Sized + 'a&gt; {
    lock: &amp;'a Mutex&lt;T&gt;,
    poison: poison::Guard,
}

impl&lt;T: ?Sized&gt; Deref for MutexGuard&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        unsafe { &amp;*self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; DerefMut for MutexGuard&lt;'_, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        unsafe { &amp;mut *self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    #[inline]
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.poison.done(&amp;self.poison);
            self.lock.inner.raw_unlock();
        }
    }
}
</code></pre></pre>
<hr />
<p>从代码中可以看到:</p>
<ol>
<li>当 MutexGuard 结束时，Mutex 会做 unlock</li>
<li>这样用户在使用 Mutex 时，可以不必关心何时释放这个互斥锁。</li>
<li>因为无论你在调用栈上怎样传递 MutexGuard ，哪怕在错误处理流程上提前退出，Rust 有所有权机制，可以确保只要 MutexGuard 离开作用域，锁就会被释放</li>
</ol>
</div>
</details>
<h3 id="使用mutex_mutexguard的例子"><a class="header" href="#使用mutex_mutexguard的例子">使用Mutex_MutexGuard的例子</a></h3>
<details id="admonition-mutex--mutexguard-example" class="admonition info">
<summary class="admonition-title">
<p>Mutex &amp; MutexGuard example</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-mutex--mutexguard-example"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use lazy_static::lazy_static;
use std::borrow::Cow;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

// lazy_static 宏可以生成复杂的 static 对象
lazy_static! {
    // 一般情况下 Mutex 和 Arc 一起在多线程环境下提供对共享内存的使用
    // 如果你把 Mutex 声明成 static，其生命周期是静态的，不需要 Arc
    static ref METRICS: Mutex&lt;HashMap&lt;Cow&lt;'static, str&gt;, usize&gt;&gt; =
        Mutex::new(HashMap::new());
}

fn main() {
    // 用 Arc 来提供并发环境下的共享所有权（使用引用计数）
    let metrics: Arc&lt;Mutex&lt;HashMap&lt;Cow&lt;'static, str&gt;, usize&gt;&gt;&gt; =
        Arc::new(Mutex::new(HashMap::new()));
    for _ in 0..32 {
        let m = metrics.clone();
        thread::spawn(move || {
            let mut g = m.lock().unwrap();
            // 此时只有拿到 MutexGuard 的线程可以访问 HashMap
            let data = &amp;mut *g;
            // Cow 实现了很多数据结构的 From trait，所以我们可以用 &quot;hello&quot;.into() 生成 Cow
            let entry = data.entry(&quot;hello&quot;.into()).or_insert(0);
            *entry += 1;
            // MutexGuard 被 Drop，锁被释放
        });
    }

    thread::sleep(Duration::from_millis(100));

    println!(&quot;metrics: {:?}&quot;, metrics.lock().unwrap());
}
</code></pre></pre>
<hr />
<blockquote>
<p>在解析 URL 的时候，我们经常需要将 querystring 中的参数，提取成 KV pair 来进一步使 用。
绝大多数语言中，提取出来的 KV 都是新的字符串，在每秒钟处理几十 k 甚至上百 k 请求的系统中，你可以想象这会带来多少次堆内存的分配。 
但在 Rust 中，我们可以用 Cow 类型轻松高效处理它，在读取 URL 的过程中：</p>
</blockquote>
<ol>
<li>每解析出一个 key 或者 value，我们可以用一个 &amp;str 指向 URL 中相应的位置，然后用 Cow 封装它 </li>
<li>而当解析出来的内容不能直接使用，需要 decode 时，比如 “hello%20world”，我们 可以生成一个解析后的 String，同样用 Cow 封装它。</li>
</ol>
</div>
</details>
<details id="admonition-你可以把-mutexguard-的引用传给另一个线程使用但你无法把-mutexguard-整个移动到另一个线程" class="admonition info">
<summary class="admonition-title">
<p>你可以把 MutexGuard 的引用传给另一个线程使用，但你无法把 MutexGuard 整个移动到另一个线程</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-你可以把-mutexguard-的引用传给另一个线程使用但你无法把-mutexguard-整个移动到另一个线程"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::sync::Mutex;

fn main() {
    //
    let m = Mutex::new(Mutex::new(1));
    let g = m.lock().unwrap();
    {
        rayon::join(
            || {
                let mut g1 = g.lock().unwrap();
                *g1 += 1;
                println!(&quot;Thread 1: {:?}&quot;, *g1);
            },
            || {
                let mut g1 = g.lock().unwrap();
                *g1 += 1;
                println!(&quot;Thread 1: {:?}&quot;, *g1);
            },
        );
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-mutexguard-的智能指针有很多用途" class="admonition info">
<summary class="admonition-title">
<p>MutexGuard 的智能指针有很多用途</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-mutexguard-的智能指针有很多用途"></a></p>
</summary>
<div>
<ul>
<li>r2d2类似实现一个数据库连接池：<a href="https://github.com/sfackler/r2d2/blob/master/src/lib.rs#L611-L638">源码</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;M&gt; Drop for PooledConnection&lt;M&gt;
where
    M: ManageConnection,
{
    fn drop(&amp;mut self) {
        self.pool.put_back(self.checkout, self.conn.take().unwrap());
    }
}

impl&lt;M&gt; Deref for PooledConnection&lt;M&gt;
where
    M: ManageConnection,
{
    type Target = M::Connection;

    fn deref(&amp;self) -&gt; &amp;M::Connection {
        &amp;self.conn.as_ref().unwrap().conn
    }
}

impl&lt;M&gt; DerefMut for PooledConnection&lt;M&gt;
where
    M: ManageConnection,
{
    fn deref_mut(&amp;mut self) -&gt; &amp;mut M::Connection {
        &amp;mut self.conn.as_mut().unwrap().conn
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>类似 MutexGuard 的智能指针有很多用途。比如要创建一个连接池，你可以在 Drop trait 中，回收 checkout 出来的连接，将其再放回连接池。</li>
</ul>
</div>
</details>
<h2 id="自定义智能指针"><a class="header" href="#自定义智能指针">自定义智能指针</a></h2>
<details id="admonition-mystring结构示意图" class="admonition info">
<summary class="admonition-title">
<p>MyString结构示意图</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-mystring结构示意图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/15%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%99%E4%BA%9B%E6%B5%93%E7%9C%89%E5%A4%A7%E7%9C%BC%E7%9A%84%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E9%83%BD%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F-4783668.jpg" alt="MyString" /></p>
</div>
</details>
<details id="admonition-mystring实现代码" class="admonition info">
<summary class="admonition-title">
<p>MyString实现代码</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-mystring实现代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">use std::{fmt, ops::Deref, str};

const MINI_STRING_MAX_LEN: usize = 30;

// MyString 里，String 有 3 个 word，供 24 字节，所以它以 8 字节对齐
// 所以 enum 的 tag + padding 最少 8 字节，整个结构占 32 字节。
// MiniString 可以最多有 30 字节（再加上 1 字节长度和 1字节 tag），就是 32 字节.
struct MiniString {
    len: u8,
    data: [u8; MINI_STRING_MAX_LEN],
}

impl MiniString {
    // 这里 new 接口不暴露出去，保证传入的 v 的字节长度小于等于 30
    fn new(v: impl AsRef&lt;str&gt;) -&gt; Self {
        let bytes = v.as_ref().as_bytes();
        // 我们在拷贝内容时一定要要使用字符串的字节长度
        let len = bytes.len();
        let mut data = [0u8; MINI_STRING_MAX_LEN];
        data[..len].copy_from_slice(bytes);
        Self {
            len: len as u8,
            data,
        }
    }
}

impl Deref for MiniString {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        // 由于生成 MiniString 的接口是隐藏的，它只能来自字符串，所以下面这行是安全的
        str::from_utf8(&amp;self.data[..self.len as usize]).unwrap()
        // 也可以直接用 unsafe 版本
        // unsafe { str::from_utf8_unchecked(&amp;self.data[..self.len as usize]) }
    }
}

impl fmt::Debug for MiniString {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        // 这里由于实现了 Deref trait，可以直接得到一个 &amp;str 输出
        write!(f, &quot;{}&quot;, self.deref())
    }
}

#[derive(Debug)]
enum MyString {
    Inline(MiniString),
    Standard(String),
}

// 实现 Deref 接口对两种不同的场景统一得到 &amp;str
impl Deref for MyString {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        match *self {
            MyString::Inline(ref v) =&gt; v.deref(),
            MyString::Standard(ref v) =&gt; v.deref(),
        }
    }
}

// impl From&lt;&amp;str&gt; for MyString {
//     fn from(s: &amp;str) -&gt; Self {
//         match s.len() &gt; MINI_STRING_MAX_LEN {
//             true =&gt; Self::Standard(s.to_owned()),
//             _ =&gt; Self::Inline(MiniString::new(s)),
//         }
//     }
// }

// impl From&lt;String&gt; for MyString {
//     fn from(s: String) -&gt; Self {
//         match s.len() &gt; MINI_STRING_MAX_LEN {
//             true =&gt; Self::Standard(s),
//             _ =&gt; Self::Inline(MiniString::new(s)),
//         }
//     }
// }

impl&lt;T&gt; From&lt;T&gt; for MyString
where
    T: AsRef&lt;str&gt;,
{
    fn from(s: T) -&gt; Self {
        match s.as_ref().len() &gt; MINI_STRING_MAX_LEN {
            true =&gt; Self::Standard(s.as_ref().to_owned()),
            _ =&gt; Self::Inline(MiniString::new(s)),
        }
    }
}

impl fmt::Display for MyString {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.deref())
    }
}

impl MyString {
    pub fn push_str(&amp;mut self, s: &amp;str) {
        match *self {
            MyString::Inline(ref mut v) =&gt; {
                let len = v.len as usize;
                let len1 = s.len();
                if len + len1 &gt; MINI_STRING_MAX_LEN {
                    let mut owned = v.deref().to_string();
                    owned.push_str(s);
                    *self = MyString::Standard(owned);
                } else {
                    let total = len + len1;
                    v.data[len..len + len1].copy_from_slice(s.as_bytes());
                    v.len = total as u8;
                }
            }
            MyString::Standard(ref mut v) =&gt; v.push_str(s),
        }
    }
}

fn main() {
    let len1 = std::mem::size_of::&lt;MyString&gt;();
    let len2 = std::mem::size_of::&lt;MiniString&gt;();
    println!(&quot;Len: MyString {}, MiniString {}&quot;, len1, len2);

    let s1: MyString = &quot;hello world&quot;.into();
    let s2: MyString = &quot;这是一个超过了三十个字节的很长很长的字符串&quot;.into();

    // debug 输出
    println!(&quot;s1: {:?}, s2: {:?}&quot;, s1, s2);
    // display 输出
    println!(
        &quot;s1: {}({} bytes, {} chars), s2: {}({} bytes, {} chars)&quot;,
        s1,
        s1.len(),
        s1.chars().count(),
        s2,
        s2.len(),
        s2.chars().count()
    );

    // MyString 可以使用一切 &amp;str 接口，感谢 Rust 的自动 Deref
    assert!(s1.ends_with(&quot;world&quot;));
    assert!(s2.starts_with('这'));

    let s = String::from(&quot;这是一个超过了三十个字节的很长很长的字符串&quot;);
    println!(&quot;s: {:p}&quot;, &amp;*s);
    // From&lt;T: AsRef&lt;str&gt;&gt; 的实现会导致额外的复制
    let s3: MyString = s.into();
    println!(&quot;s3: {:p}&quot;, &amp;*s3);

    let mut s4: MyString = &quot;Hello Tyr! &quot;.into();
    println!(&quot;s4: {:?}&quot;, s4);
    s4.push_str(&quot;这是一个超过了三十个字节的很长很长的字符串&quot;);
    println!(&quot;s4: {:?}&quot;, s4);
}
</code></pre></pre>
<hr />
<p>为了让 MyString 表现行为和 &amp;str 一致:</p>
<ol>
<li>我们可以通过实现 Deref trait 让 MyString 可以被解引用成 &amp;str。</li>
<li>除此之外，还可以实现 Debug/Display 和 From<T> trait，让 MyString 使用起来更方便。</li>
<li>这个简单实现的 MyString，不管它内部的数据是纯栈上的 MiniString 版本，还是包含堆 上内存的 String 版本，使用的体验和 &amp;str 都一致，仅仅牺牲了一点点效率和内存，就可
以让小容量的字符串，可以高效地存储在栈上并且自如地使用。</li>
<li><a href="https://github.com/bodil/smartstring">smartstring</a> 的第三方库实现类似功能，还做了优化。</li>
</ol>
</div>
</details>
<h1 id="二集合容器"><a class="header" href="#二集合容器">二、集合容器</a></h1>
<h2 id="对容器进行定义"><a class="header" href="#对容器进行定义">对容器进行定义</a></h2>
<details id="admonition-容器数据结构如何理解" class="admonition tip">
<summary class="admonition-title">
<p>容器数据结构如何理解</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-容器数据结构如何理解"></a></p>
</summary>
<div>
<p>提到容器，很可能你首先会想到的就是数组、列表这些可以遍历的容器，但其实只要把某 种特定的数据封装在某个数据结构中，这个数据结构就是一个容器。比如 Option<T>，它 是一个包裹了 T 存在或不存在的容器，而 Cow 是一个封装了内部数据 B 或被借用或拥有 所有权的容器。</p>
</div>
</details>
<h2 id="对集合容器进行定义"><a class="header" href="#对集合容器进行定义">对集合容器进行定义</a></h2>
<details id="admonition-把拥有相同类型对数据放在一起统一处理" class="admonition tip">
<summary class="admonition-title">
<p>把拥有相同类型对数据放在一起，统一处理</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-把拥有相同类型对数据放在一起统一处理"></a></p>
</summary>
<div>
<p>集合容器，顾名思义，就是把一系列拥有相同类型的数据放在一起，统一处理，比如：</p>
<ol>
<li>
<p>我们熟悉的字符串 String、数组 [T; n]、列表 Vec<T> 和哈希表 HashMap&lt;K, V&gt; 等；</p>
</li>
<li>
<p>虽然到处在使用，但还并不熟悉的切片 slice；</p>
</li>
<li>
<p>在其他语言中使用过，但在 Rust 中还没有用过的循环缓冲区 VecDeque<T>、双向列 表 LinkedList<T> 等。</p>
</li>
</ol>
<blockquote>
<p>这些集合容器有很多共性，比如可以被遍历、可以进行 map-reduce 操作、可以从一种类 型转换成另一种类型等等。</p>
</blockquote>
</div>
</details>
<h2 id="切片"><a class="header" href="#切片">切片</a></h2>
<details id="admonition-切片到底是什么" class="admonition tip">
<summary class="admonition-title">
<p>切片到底是什么</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-切片到底是什么"></a></p>
</summary>
<div>
<p>在 Rust 里，切片是描述一组属于同一类型、长度不确定的、在内存中连续存放的数据结 构，用 [T] 来表述。因为长度不确定，所以切片是个 DST（Dynamically Sized Type）。</p>
<p>切片一般只出现在数据结构的定义中，不能直接访问，在使用中主要用以下形式：</p>
<ul>
<li>
<p>&amp;[T]：表示一个只读的切片引用。</p>
</li>
<li>
<p>&amp;mut [T]：表示一个可写的切片引用。</p>
</li>
<li>
<p>Box&lt;[T]&gt;：一个在堆上分配的切片。</p>
</li>
</ul>
</div>
</details>
<details id="admonition-切片与数据的关系" class="admonition tip">
<summary class="admonition-title">
<p>切片与数据的关系</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-切片与数据的关系"></a></p>
</summary>
<div>
<h2 id="怎么理解切片呢我打个比方切片之于具体的数据结构就像数据库中的视图之于表-你可以把它看成一种工具让我们可以统一访问行为相同结构类似但有些许差异的类-型"><a class="header" href="#怎么理解切片呢我打个比方切片之于具体的数据结构就像数据库中的视图之于表-你可以把它看成一种工具让我们可以统一访问行为相同结构类似但有些许差异的类-型">怎么理解切片呢？我打个比方，切片之于具体的数据结构，就像数据库中的视图之于表。 你可以把它看成一种工具，让我们可以统一访问行为相同、结构类似但有些许差异的类 型。</a></h2>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let arr = [1, 2, 3, 4, 5];
    let vec = vec![1, 2, 3, 4, 5];
    let s1 = &amp;arr[1..3];
    let s2 = &amp;vec[1..3];
    println!(&quot;s1: {:?}, s2: {:?}&quot;, s1, s2);

    // &amp;[T] 和 &amp;[T] 是否相等取决于长度和内容是否相等
    assert_eq!(s1, s2);
    // &amp;[T] 可以和 Vec&lt;T&gt;/[T;n] 比较，也会看长度和内容
    assert_eq!(&amp;arr[..], vec);
    assert_eq!(&amp;vec[..], arr);
}
</code></pre></pre>
<ol>
<li>对于 array 和 vector，虽然是不同的数据结构，一个放在栈上，一个放在堆上，但它们的 切片是类似的；</li>
<li>而且对于相同内容数据的相同切片，比如 &amp;arr[1…3] 和 &amp;vec[1…3]，这 两者是等价的。</li>
<li>除此之外，切片和对应的数据结构也可以直接比较，这是因为它们之间实 现了 PartialEq trait
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4785008.jpg" alt="切片与具体数据的关系" /></li>
</ol>
</div>
</details>
<h3 id="array-vs-vector"><a class="header" href="#array-vs-vector">array vs vector</a></h3>
<details id="admonition-array和vector的区别与联系" class="admonition info">
<summary class="admonition-title">
<p>array和vector的区别与联系</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-array和vector的区别与联系"></a></p>
</summary>
<div>
<p>对于 array 和 vector，虽然是不同的数据结构：</p>
<ul>
<li>一个放在栈上</li>
<li>一个放在堆上</li>
</ul>
<blockquote>
<p>但它们的切片是类似的, 而且对于相同内容数据的相同切片</p>
</blockquote>
<ul>
<li>比如 &amp;arr[1…3] 和 &amp;vec[1…3]，这两者是等价的。</li>
<li>除此之外，切片和对应的数据结构也可以直接比较，这是因为它们之间实现了 PartialEq trait（源码参考资料）。</li>
</ul>
<blockquote>
<p>下图比较清晰地呈现了切片和数据之间的关系：
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4866674.jpg" alt="切片和数据之间的关系" /></p>
</blockquote>
</div>
</details>
<h3 id="vec-和-t"><a class="header" href="#vec-和-t">Vec<T> 和 &amp;[T]</a></h3>
<details id="admonition-t与vect关系" class="admonition tip">
<summary class="admonition-title">
<p>&amp;[T]与&amp;Vec[T]关系</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-t与vect关系"></a></p>
</summary>
<div>
<p>![&amp;[T]和&amp;Vec[T]](https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4785147.jpg)</p>
</div>
</details>
<h3 id="解引用"><a class="header" href="#解引用">解引用</a></h3>
<details id="admonition-支持切片的具体数据类型可以根据需要解引用转换成切片类型" class="admonition info">
<summary class="admonition-title">
<p>支持切片的具体数据类型可以根据需要解引用转换成切片类型</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-支持切片的具体数据类型可以根据需要解引用转换成切片类型"></a></p>
</summary>
<div>
<p>在使用的时候，支持切片的具体数据类型，你可以根据需要，解引用转换成切片类型。</p>
<ul>
<li>比如 Vec<T> 和 [T; n] 会转化成为 &amp;[T]，这是因为 Vec<T> 实现了 Deref trait，而 array 内建了到 &amp;[T] 的解引用。</li>
<li>我们可以写一段代码验证这一行为（代码）：</li>
</ul>
<hr />
<pre><pre class="playground"><code class="language-rust  editable">
use std::fmt;
fn main() {
    let v = vec![1, 2, 3, 4];

    // Vec 实现了 Deref，&amp;Vec&lt;T&gt; 会被自动解引用为 &amp;[T]，符合接口定义
    print_slice(&amp;v);
    // 直接是 &amp;[T]，符合接口定义
    print_slice(&amp;v[..]);

    // &amp;Vec&lt;T&gt; 支持 AsRef&lt;[T]&gt;
    print_slice1(&amp;v);
    // &amp;[T] 支持 AsRef&lt;[T]&gt;
    print_slice1(&amp;v[..]);
    // Vec&lt;T&gt; 也支持 AsRef&lt;[T]&gt;
    print_slice1(v);

    let arr = [1, 2, 3, 4];
    // 数组虽没有实现 Deref，但它的解引用就是 &amp;[T]
    print_slice(&amp;arr);
    print_slice(&amp;arr[..]);
    print_slice1(&amp;arr);
    print_slice1(&amp;arr[..]);
    print_slice1(arr);
}

// 注意下面的泛型函数的使用
fn print_slice&lt;T: fmt::Debug&gt;(s: &amp;[T]) {
    println!(&quot;{:?}&quot;, s);
}

fn print_slice1&lt;T, U&gt;(s: T)
where
    T: AsRef&lt;[U]&gt;,
    U: fmt::Debug,
{
    println!(&quot;{:?}&quot;, s.as_ref());
}
</code></pre></pre>
<hr />
<blockquote>
<p>这也就意味着，通过解引用，这几个和切片有关的数据结构都会获得切片的所有能力，包括：binary_search、chunks、concat、contains、start_with、end_with、group_by、iter、join、sort、split、swap 等一系列丰富的功能，</p>
</blockquote>
</div>
</details>
<h3 id="切片和迭代器-iterator"><a class="header" href="#切片和迭代器-iterator">切片和迭代器 Iterator</a></h3>
<details id="admonition-迭代器可以说是切片的孪生兄弟" class="admonition info">
<summary class="admonition-title">
<p>迭代器可以说是切片的孪生兄弟</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-迭代器可以说是切片的孪生兄弟"></a></p>
</summary>
<div>
<p>迭代器可以说是切片的孪生兄弟。切片是集合数据的视图，而迭代器定义了对集合数据的各种各样的访问操作。</p>
<p>Iterator trait 有大量的方法，但绝大多数情况下，只需要定义它的关联类型 Item 和 next() 方法。</p>
<ul>
<li>Item 定义了每次我们从迭代器中取出的数据类型；</li>
<li>next() 是从迭代器里取下一个值的方法。当一个迭代器的 next() 方法返回 None 时，表明迭代器中没有数据了。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[must_use = &quot;iterators are lazy and do nothing unless consumed&quot;]
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    // 大量缺省的方法，包括 size_hint, count, chain, zip, map, 
    // filter, for_each, skip, take_while, flat_map, flatten
    // collect, partition 等
    ... 
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-对-vec-使用-iter-方法并进行各种-map--filter--take-操作" class="admonition info">
<summary class="admonition-title">
<p>对 Vec<T> 使用 iter() 方法，并进行各种 map / filter / take 操作</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-对-vec-使用-iter-方法并进行各种-map--filter--take-操作"></a></p>
</summary>
<div>
<p>一个例子：对 Vec<T> 使用 iter() 方法，并进行各种 map / filter / take 操作。在函数式编程语言中，这样的写法很常见，代码的可读性很强。Rust 也支持这种写法（代码）：</p>
<pre><pre class="playground"><code class="language-rust">
fn main() {
    // 这里 Vec&lt;T&gt; 在调用 iter() 时被解引用成 &amp;[T]，所以可以访问 iter()
    let result = vec![1, 2, 3, 4]
        .iter()
        .map(|v| v * v)
        .filter(|v| *v &lt; 16)
        .take(1)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;{:?}&quot;, result);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-rust的迭代器是个懒接口这是如何实现的" class="admonition info">
<summary class="admonition-title">
<p>Rust的迭代器是个懒接口，这是如何实现的？</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-rust的迭代器是个懒接口这是如何实现的"></a></p>
</summary>
<div>
<p>需要注意的是 Rust 下的迭代器是个懒接口（lazy interface），也就是说这段代码直到运行到 collect 时才真正开始执行，之前的部分不过是在不断地生成新的结构，来累积处理逻辑而已。你可能好奇，这是怎么做到的呢？</p>
<p>原来，Iterator 大部分方法都返回一个实现了 Iterator 的数据结构，所以可以这样一路链式下去，在 Rust 标准库中，这些数据结构被称为 <a href="https://doc.rust-lang.org/src/core/iter/adapters/mod.rs.html">Iterator Adapter</a>。比如上面的 map 方法，它返回 Map 结构，而 Map 结构实现了 <a href="https://doc.rust-lang.org/src/core/iter/adapters/map.rs.html#93-133">Iterator（源码）</a>。
整个过程是这样的（链接均为源码资料）：</p>
<ol>
<li>在 collect() 执行的时候，它<a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1744-1749">实际试图使用 FromIterator 从迭代器中构建一个集合类型</a>，这会不断调用 next() 获取下一个数据；</li>
<li>此时的 Iterator 是 Take，Take 调自己的 next()，也就是它会<a href="https://doc.rust-lang.org/src/core/iter/adapters/take.rs.html#34-41">调用 Filter 的 next()</a>；</li>
<li>Filter 的 next() 实际上<a href="https://time.geekbang.org/column/article/422975">调用自己内部的 iter 的 find()</a>，此时内部的 iter 是 Map，find() 会使用 <a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2312-2325">try_fold()</a>，它会<a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2382-2406">继续调用 next()</a>，也就是 Map 的 next()；</li>
<li>Map 的 next() 会<a href="https://time.geekbang.org/column/article/422975">调用其内部的 iter 取 next() 然后执行 map 函数</a>。而此时内部的 iter 来自 Vec<i32>。</li>
</ol>
<p>所以，只有在 collect() 时，才触发代码一层层调用下去，并且调用会根据需要随时结束。这段代码中我们使用了 take(1)，整个调用链循环一次，就能满足 take(1) 以及所有中间过程的要求，所以它只会循环一次。</p>
</div>
</details>
<details id="admonition-rust的函数式编程写法性能如何" class="admonition info">
<summary class="admonition-title">
<p>Rust的函数式编程写法性能如何？</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-rust的函数式编程写法性能如何"></a></p>
</summary>
<div>
<p>你可能会有疑惑：这种函数式编程的写法，代码是漂亮了，然而这么多无谓的函数调用，性能肯定很差吧？毕竟，函数式编程语言的一大恶名就是性能差。</p>
<p>这个你完全不用担心， Rust 大量使用了 inline 等优化技巧，这样非常清晰友好的表达方式，性能和 C 语言的 for 循环差别不大。</p>
</div>
</details>
<details id="admonition-rust的iterator除了标准库还有itertools提供更多功能" class="admonition info">
<summary class="admonition-title">
<p>Rust的iterator除了标准库，还有itertools提供更多功能</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-rust的iterator除了标准库还有itertools提供更多功能"></a></p>
</summary>
<div>
<p>如果标准库中的功能还不能满足你的需求，你可以看看 itertools，它是和 Python 下 itertools 同名且功能类似的工具，提供了大量额外的 adapter。可以看一个简单的例子（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use itertools::Itertools;

fn main() {
    let err_str = &quot;bad happened&quot;;
    let input = vec![Ok(21), Err(err_str), Ok(7)];
    let it = input
        .into_iter()
        .filter_map_ok(|i| if i &gt; 10 { Some(i * 2) } else { None });
    // 结果应该是：vec![Ok(42), Err(err_str)]
    println!(&quot;{:?}&quot;, it.collect::&lt;Vec&lt;_&gt;&gt;());
}
</code></pre></pre>
<p>在实际开发中，我们可能从一组 Future 中汇聚出一组结果，里面有成功执行的结果，也有失败的错误信息。如果想对成功的结果进一步做 filter/map，那么标准库就无法帮忙了，就需要用 itertools 里的 filter_map_ok()。</p>
</div>
</details>
<h3 id="特殊的切片str"><a class="header" href="#特殊的切片str">特殊的切片：&amp;str</a></h3>
<details id="admonition-stringstring和str的区别与联系" class="admonition info">
<summary class="admonition-title">
<p>String、&amp;String和&amp;str的区别与联系</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-stringstring和str的区别与联系"></a></p>
</summary>
<div>
<p>我们来看一种特殊的切片：&amp;str。之前讲过，String 是一个特殊的 Vec<u8>，所以在 String 上做切片，也是一个特殊的结构 &amp;str。</p>
<p>对于 String、&amp;String、&amp;str，很多人也经常分不清它们的区别，我们在之前的一篇加餐中简单聊了这个问题，在上一讲智能指针中，也对比过 String 和 &amp;str。对于 &amp;String 和 &amp;str，如果你理解了上文中 &amp;Vec<T> 和 &amp;[T] 的区别，那么它们也是一样的：
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867212.jpg" alt="&amp;String和&amp;str" /></p>
</div>
</details>
<details id="admonition-string在解引用时会转换成str" class="admonition info">
<summary class="admonition-title">
<p>String在解引用时会转换成&amp;str</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-string在解引用时会转换成str"></a></p>
</summary>
<div>
<p>String 在解引用时，会转换成 &amp;str。可以用下面的代码验证（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::fmt;
fn main() {
    let s = String::from(&quot;hello&quot;);
    // &amp;String 会被解引用成 &amp;str
    print_slice(&amp;s);
    // &amp;s[..] 和 s.as_str() 一样，都会得到 &amp;str
    print_slice(&amp;s[..]);

    // String 支持 AsRef&lt;str&gt;
    print_slice1(&amp;s);
    print_slice1(&amp;s[..]);
    print_slice1(s.clone());

    // String 也实现了 AsRef&lt;[u8]&gt;，所以下面的代码成立
    // 打印出来是 [104, 101, 108, 108, 111]
    print_slice2(&amp;s);
    print_slice2(&amp;s[..]);
    print_slice2(s);
}

fn print_slice(s: &amp;str) {
    println!(&quot;{:?}&quot;, s);
}

fn print_slice1&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
    println!(&quot;{:?}&quot;, s.as_ref());
}

fn print_slice2&lt;T, U&gt;(s: T)
where
    T: AsRef&lt;[U]&gt;,
    U: fmt::Debug,
{
    println!(&quot;{:?}&quot;, s.as_ref());
}
</code></pre></pre>
</div>
</details>
<details id="admonition-字符的列表和字符串有什么关系和区别" class="admonition info">
<summary class="admonition-title">
<p>字符的列表和字符串有什么关系和区别</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-字符的列表和字符串有什么关系和区别"></a></p>
</summary>
<div>
<p>那么字符的列表和字符串有什么关系和区别？我们直接写一段代码来看看：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::iter::FromIterator;

fn main() {
    let arr = ['h', 'e', 'l', 'l', 'o'];
    let vec = vec!['h', 'e', 'l', 'l', 'o'];
    let s = String::from(&quot;hello&quot;);
    let s1 = &amp;arr[1..3];
    let s2 = &amp;vec[1..3];
    // &amp;str 本身就是一个特殊的 slice
    let s3 = &amp;s[1..3];
    println!(&quot;s1: {:?}, s2: {:?}, s3: {:?}&quot;, s1, s2, s3);

    // &amp;[char] 和 &amp;[char] 是否相等取决于长度和内容是否相等
    assert_eq!(s1, s2);
    // &amp;[char] 和 &amp;str 不能直接对比，我们把 s3 变成 Vec&lt;char&gt;
    assert_eq!(s2, s3.chars().collect::&lt;Vec&lt;_&gt;&gt;());
    // &amp;[char] 可以通过迭代器转换成 String，String 和 &amp;str 可以直接对比
    assert_eq!(String::from_iter(s2), s3);
}
</code></pre></pre>
<hr />
<blockquote>
<p>可以看到，字符列表可以通过迭代器转换成 String，String 也可以通过 chars() 函数转换成字符列表，如果不转换，二者不能比较。</p>
</blockquote>
<hr />
<p>下图把数组、列表、字符串以及它们的切片放在一起比较，可以更好地理解它们的区别：
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867332.jpg" alt="数组、列表、字符串和各自的切片" /></p>
</div>
</details>
<h3 id="boxt"><a class="header" href="#boxt">Box&lt;[T]&gt;</a></h3>
<details id="admonition-box和vect对比" class="admonition info">
<summary class="admonition-title">
<p>Box&lt;[T]&gt;和Vec<T>&amp;[T]对比</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-box和vect对比"></a></p>
</summary>
<div>
<p>切片主要有三种使用方式：</p>
<ul>
<li>切片的只读引用 &amp;[T]</li>
<li>切片的可变引用 &amp;mut [T]: 和&amp;[T]类似</li>
<li>Box&lt;[T]&gt;</li>
</ul>
<p>现在我们来看看 Box&lt;[T]&gt;。</p>
<p>Box&lt;[T]&gt; 是一个比较有意思的存在，它和 Vec<T> 有一点点差别：</p>
<ul>
<li>Vec<T> 有额外的 capacity，可以增长；</li>
<li>而 Box&lt;[T]&gt; 一旦生成就固定下来，没有 capacity，也无法增长。</li>
</ul>
<p>Box&lt;[T]&gt; 和切片的引用 &amp;[T] 也很类似：</p>
<ol>
<li>它们都是在栈上有一个包含长度的胖指针，指向存储数据的内存位置。</li>
<li>区别是：Box&lt;[T]&gt; 只会指向堆，&amp;[T] 指向的位置可以是栈也可以是堆；</li>
<li>此外，Box&lt;[T]&gt; 对数据具有所有权，而 &amp;[T] 只是一个借用。</li>
</ol>
<hr />
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867436.jpg" alt="" /></p>
</div>
</details>
<details id="admonition-那么如何产生-box-呢" class="admonition info">
<summary class="admonition-title">
<p>那么如何产生 Box&lt;[T]&gt; 呢？</p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-那么如何产生-box-呢"></a></p>
</summary>
<div>
<p>那么如何产生 Box&lt;[T]&gt; 呢？
目前可用的接口就只有一个：从已有的 Vec<T> 中转换。我们看代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::ops::Deref;

fn main() {
    let mut v1 = vec![1, 2, 3, 4];
    v1.push(5);
    println!(&quot;cap should be 8: {}&quot;, v1.capacity());

    // 从 Vec&lt;T&gt; 转换成 Box&lt;[T]&gt;，此时会丢弃多余的 capacity
    let b1 = v1.into_boxed_slice();
    let mut b2 = b1.clone();

    let v2 = b1.into_vec();
    println!(&quot;cap should be exactly 5: {}&quot;, v2.capacity());

    assert!(b2.deref() == v2);

    // Box&lt;[T]&gt; 可以更改其内部数据，但无法 push
    b2[0] = 2;
    // b2.push(6);
    println!(&quot;b2: {:?}&quot;, b2);

    // 注意 Box&lt;[T]&gt; 和 Box&lt;[T; n]&gt; 并不相同
    let b3 = Box::new([2, 2, 3, 4, 5]);
    println!(&quot;b3: {:?}&quot;, b3);

    // b2 和 b3 相等，但 b3.deref() 和 v2 无法比较
    assert!(b2 == b3);
    // assert!(b3.deref() == v2);
}
</code></pre></pre>
<hr />
<p>运行代码可以看到:</p>
<ol>
<li>Vec<T> 可以通过 into_boxed_slice() 转换成 Box&lt;[T]&gt;</li>
<li>Box&lt;[T]&gt; 也可以通过 into_vec() 转换回 Vec<T>。</li>
</ol>
<p>这两个转换都是很轻量的转换，只是变换一下结构，不涉及数据的拷贝。</p>
<p>区别是:</p>
<ol>
<li>当 Vec<T> 转换成 Box&lt;[T]&gt; 时，没有使用到的容量就会被丢弃，所以整体占用的内存可能会降低。</li>
<li>而且 Box&lt;[T]&gt; 有一个很好的特性是，不像 Box&lt;[T;n]&gt; 那样在编译时就要确定大小，它可以在运行期生成，以后大小不会再改变。</li>
</ol>
<p>所以，当我们需要在堆上创建固定大小的集合数据，且不希望自动增长，那么，可以先创建 Vec<T>，再转换成 Box&lt;[T]&gt;。</p>
<blockquote>
<p>tokio 在提供 broadcast channel 时，就使用了 Box&lt;[T]&gt; 这个特性，你感兴趣的话，可以自己看看<a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/sync/broadcast.rs#L447">源码</a>。</p>
</blockquote>
</div>
</details>
<h3 id="常用切片对比图"><a class="header" href="#常用切片对比图">常用切片对比图</a></h3>
<div id="admonition-strtnvectmutt的区别与联系图" class="admonition info">
<div class="admonition-title">
<p>&amp;str、[T;n]、Vec<T>、&amp;[T]、&amp;mut[T]的区别与联系图 </p>
<p><a class="admonition-anchor-link" href="3_data_structure.html#admonition-strtnvectmutt的区别与联系图"></a></p>
</div>
<div>
<p>下图描述了切片和数组 [T;n]、列表 Vec<T>、切片引用 &amp;[T] /&amp;mut [T]，以及在堆上分配的切片 Box&lt;[T]&gt; 之间的关系。</p>
<blockquote>
<p>建议花些时间理解这张图，也可以用相同的方式去总结学到的其他有关联的数据结构。</p>
</blockquote>
<hr />
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867546.jpg" alt="" /></p>
</div>
</div>
<h2 id="哈希表"><a class="header" href="#哈希表">哈希表</a></h2>
<h3 id="hashmap数据结构"><a class="header" href="#hashmap数据结构">HashMap数据结构</a></h3>
<h3 id="hashmap基本使用方法"><a class="header" href="#hashmap基本使用方法">HashMap基本使用方法</a></h3>
<h3 id="hashmap内存布局"><a class="header" href="#hashmap内存布局">HashMap内存布局</a></h3>
<h3 id="ctrl表"><a class="header" href="#ctrl表">ctrl表</a></h3>
<h1 id="三错误处理"><a class="header" href="#三错误处理">三、错误处理</a></h1>
<h2 id="错误处理主流方法"><a class="header" href="#错误处理主流方法">错误处理主流方法</a></h2>
<h2 id="rust如何处理错误"><a class="header" href="#rust如何处理错误">Rust如何处理错误</a></h2>
<h1 id="四闭包结构"><a class="header" href="#四闭包结构">四、闭包结构</a></h1>
<h2 id="闭包定义"><a class="header" href="#闭包定义">闭包定义</a></h2>
<h2 id="闭包本质"><a class="header" href="#闭包本质">闭包本质</a></h2>
<h2 id="闭包设计"><a class="header" href="#闭包设计">闭包设计</a></h2>
<h2 id="rust闭包类型"><a class="header" href="#rust闭包类型">Rust闭包类型</a></h2>
<h2 id="闭包使用场景"><a class="header" href="#闭包使用场景">闭包使用场景</a></h2>
<div style="break-before: page; page-break-before: always;"></div><style>.extended-markdown-table {
    display: grid;
}

.extended-markdown-table > div {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 3px 20px;
    border-bottom: 1px solid var(--table-border-color);
    border-right: 1px solid var(--table-border-color);
}

.extended-markdown-table > div.extended-markdown-left-border {
    border-left: 1px solid var(--table-border-color);
}

.extended-markdown-table > div.extended-markdown-header {
    text-align: center;
    background: var(--table-header-bg);
    border-bottom: 1px solid var(--table-header-bg);
    border-right: 1px solid var(--table-header-bg);
    font-weight: bold;
}

.extended-markdown-table > div.extended-markdown-header.extended-markdown-left-border {
    border-left: 1px solid var(--table-header-bg);
}
</style>
<h1 id="iv-宏编程"><a class="header" href="#iv-宏编程">IV 宏编程</a></h1>
<!--ts-->
<ul>
<li><a href="4_macros.html#iv-%E5%AE%8F%E7%BC%96%E7%A8%8B">IV 宏编程</a>
<ul>
<li><a href="4_macros.html#%E8%B5%84%E6%96%99">资料</a></li>
<li><a href="4_macros.html#%E5%AE%8F%E7%9A%84%E5%88%86%E7%B1%BB">宏的分类</a>
<ul>
<li><a href="4_macros.html#%E4%BD%BF%E7%94%A8%E6%B3%B3%E9%81%93%E5%9B%BE">使用泳道图</a></li>
<li><a href="4_macros.html#%E8%A1%A8%E6%A0%BC">表格</a></li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%9A%84%E7%BC%BA%E9%99%B7%E8%80%8C%E5%90%8E%E6%9C%89%E4%BA%86%E8%BF%87%E7%A8%8B%E5%AE%8F">声明宏的缺陷，而后有了过程宏</a></li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8Fdeclarative-macros-macro_rulesbang">声明宏(declarative macros): macro_rules!(bang)</a></li>
<li><a href="4_macros.html#%E8%BF%87%E7%A8%8B%E5%AE%8F%E6%B7%B1%E5%BA%A6%E5%AE%9A%E5%88%B6%E4%B8%8E%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81">过程宏：深度定制与生成代码</a>
<ul>
<li><a href="4_macros.html#%E5%87%BD%E6%95%B0%E5%AE%8F">函数宏</a></li>
<li><a href="4_macros.html#%E5%B1%9E%E6%80%A7%E5%AE%8F">属性宏</a></li>
<li><a href="4_macros.html#%E6%B4%BE%E7%94%9F%E5%AE%8F">派生宏</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F">声明宏</a>
<ul>
<li><a href="4_macros.html#rust%E5%B8%B8%E7%94%A8%E5%A3%B0%E6%98%8E%E5%AE%8F">Rust常用声明宏</a>
<ul>
<li><a href="4_macros.html#println">println!</a></li>
<li><a href="4_macros.html#writeln">writeln!</a></li>
<li><a href="4_macros.html#eprintln">eprintln!</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E7%A4%BA%E4%BE%8B">示例</a>
<ul>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%A4%BA%E6%84%8F%E5%9B%BE">声明宏示意图</a></li>
<li><a href="4_macros.html#macro_rules%E5%AE%9A%E4%B9%89">macro_rules!定义</a></li>
<li><a href="4_macros.html#%E4%BD%BF%E7%94%A8">使用</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%94%A8%E5%88%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B">声明宏用到的参数类型</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E8%BF%87%E7%A8%8B%E5%AE%8F%E6%89%8B%E5%B7%A5%E5%AE%9A%E4%B9%89%E5%9B%BE">过程宏手工定义图</a>
<ul>
<li><a href="4_macros.html#cargotoml%E6%B7%BB%E5%8A%A0proc-macro%E5%A3%B0%E6%98%8E">Cargo.toml添加proc-macro声明</a></li>
</ul>
</li>
<li>[过程函数宏: #[proc_macro]](#过程函数宏-proc_macro)
<ul>
<li><a href="4_macros.html#srclibrs%E5%AE%9A%E4%B9%89%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E5%AE%8F">src/lib.rs:定义过程函数宏</a></li>
<li><a href="4_macros.html#examplesqueryrs%E4%BD%BF%E7%94%A8">examples/query.rs:使用</a></li>
</ul>
</li>
<li>[过程派生宏: /#[proc_macro_devive(DeriveMacroName)]](#过程派生宏-proc_macro_devivederivemacroname)
<ul>
<li><a href="4_macros.html#%E5%B8%B8%E7%94%A8%E6%B4%BE%E7%94%9F%E5%AE%8F">常用派生宏</a>
<ul>
<li>[#[derive(Debug)]](#derivedebug)</li>
</ul>
</li>
<li><a href="4_macros.html#%E5%8E%9F%E5%A7%8B%E5%AE%9E%E7%8E%B0builder%E6%A8%A1%E5%BC%8F">原始实现builder模式</a>
<ul>
<li><a href="4_macros.html#%E6%83%B3%E5%88%B0%E8%BE%BE%E5%88%B0%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E7%9A%84%E6%95%88%E6%9E%9C">想到达到链式调用的效果</a></li>
<li><a href="4_macros.html#%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E5%AE%9A%E4%B9%89">可以这样定义</a></li>
<li><a href="4_macros.html#%E4%BD%86%E6%98%AF%E6%9C%89%E7%82%B9%E7%B9%81%E7%90%90%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9F%E5%AE%8F%E6%B4%BE%E7%94%9F%E5%87%BA%E8%BF%99%E4%BA%9B%E4%BB%A3%E7%A0%81">但是有点繁琐，可以使用派生宏派生出这些代码</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E6%B4%BE%E7%94%9F%E5%AE%8F%E6%80%9D%E8%B7%AF">派生宏思路</a>
<ul>
<li><a href="4_macros.html#%E8%A6%81%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88">要生成的代码模版</a></li>
<li><a href="4_macros.html#%E6%9E%84%E5%BB%BA%E5%AF%B9%E5%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">构建对应数据结构</a></li>
<li><a href="4_macros.html#srclibrs-%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9F%E5%AE%8F%E4%BB%8Etokenstream%E6%8A%BD%E5%8F%96%E5%87%BA%E6%83%B3%E8%A6%81%E7%9A%84%E4%BF%A1%E6%81%AF">src/lib.rs: 使用派生宏从TokenStream抽取出想要的信息</a></li>
<li><a href="4_macros.html#examplesraw_commandrs-%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%B4%BE%E7%94%9F%E5%AE%8F%E6%8A%BD%E5%8F%96">examples/raw_command.rs: 使用这个派生宏抽取</a></li>
<li><a href="4_macros.html#%E8%BF%90%E8%A1%8C%E6%9F%A5%E7%9C%8B%E8%8E%B7%E5%8F%96%E7%9A%84tokenstream">运行，查看获取的TokenStream</a></li>
<li><a href="4_macros.html#srcraw_builderrs-%E4%BD%BF%E7%94%A8anyhow%E4%B8%8Easkama%E6%8A%BD%E5%8F%96tokenstream%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF">src/raw_builder.rs: 使用anyhow与askama抽取TokenStream中的信息</a></li>
<li><a href="4_macros.html#templatesbuilderj2-%E4%B8%8A%E9%9D%A2askama%E7%94%A8%E5%88%B0%E7%9A%84jinja2%E6%A8%A1%E7%89%88">templates/builder.j2: 上面askama用到的jinja2模版</a></li>
<li><a href="4_macros.html#srcraw_builderrs-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%BA%94%E6%8A%BD%E5%8F%96%E6%96%B9%E6%B3%95">src/raw_builder.rs: 实现对应抽取方法</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E4%BD%BF%E7%94%A8synquote%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E6%A8%A1%E7%89%88">使用syn/quote可以不用自己定义模版</a></li>
</ul>
</li>
<li><a href="4_macros.html#%E8%BF%87%E7%A8%8B%E5%B1%9E%E6%80%A7%E5%AE%8F-proc_macro_derivemacro_name-attributesattr_name">过程属性宏: proc_macro_derive(macro_name, attributes(attr_name))</a>
<ul>
<li><a href="4_macros.html#%E4%BD%BF%E7%94%A8synquote%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AE%8F">使用syn/quote定义属性宏</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Oct  4 07:24:33 UTC 2022 -->
<!--te-->
<h2 id="资料"><a class="header" href="#资料">资料</a></h2>
<ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html">宏 - Rust 程序设计语言 简体中文版</a></li>
<li><a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/reference/macros-by-example.html">Macros By Example - The Rust Reference</a></li>
</ul>
<h2 id="宏的分类"><a class="header" href="#宏的分类">宏的分类</a></h2>
<h3 id="使用泳道图"><a class="header" href="#使用泳道图">使用泳道图</a></h3>
<figure><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="2887px" preserveAspectRatio="none" style="width:943px;height:2887px;background:#FFFFFF;" version="1.1" viewBox="0 0 943 2887" width="943px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="42.5938" id="_title" style="stroke:none;stroke-width:1.0;" width="192" x="374" y="15"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="98" x="421" y="32.9951">两类四种宏对比</text><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="182" x="379" y="49.292">（具体内容看详细版泳道图）</text><rect fill="none" height="20.9531" style="stroke:none;stroke-width:1.0;" width="910" x="15" y="66.3389"/><ellipse cx="128.5" cy="320.167" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="131" x="63" y="350.167"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="107" x="77" y="371.3057">基于TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="73" y="385.2744">定义过程函数宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="88.5" y="418.1045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="98.5" y="439.2432">打开过程宏</text><ellipse cx="128.5" cy="699.9482" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="215" x="21" y="729.9482"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="191" x="35" y="751.0869">手工抽取TokenStream定义派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="86.5" y="783.917"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="100.5" y="805.0557">打开过程宏</text><ellipse cx="128.5" cy="1461.167" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="193" x="32" y="1491.167"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="169" x="46" y="1512.3057">syn/quote抽取TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="42" y="1526.2744">为DeriveInput定义派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="86.5" y="1559.1045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="100.5" y="1580.2432">打开过程宏</text><ellipse cx="128.5" cy="2126.5107" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="47.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="193" x="32" y="2156.5107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="169" x="46" y="2177.6494">syn/quote抽取TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="42" y="2191.6182">为DeriveInput定义属性宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="84" x="86.5" y="2224.4482"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="100.5" y="2245.5869">打开过程宏</text><line style="stroke:#000000;stroke-width:1.5;" x1="15" x2="15" y1="66.3389" y2="2875.667"/><rect fill="#FAEBD7" height="2809.3281" style="stroke:#FAEBD7;stroke-width:1.0;" width="318" x="240" y="66.3389"/><rect fill="#F1F1F1" height="85.875" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="307" x="246" y="837.8857"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="287" x="256" y="859.0244">使用anyhow与askama抽取TokenStream中的信息</text><line style="stroke:#181818;stroke-width:1.0;" x1="246" x2="553" y1="866.8545" y2="866.8545"/><line style="stroke:#181818;stroke-width:1.0;" x1="246" x2="553" y1="868.8545" y2="868.8545"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="182" x="256" y="882.9932">1. 分别定义BuilderContext和Fd</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="228" x="256" y="896.9619">2. BuilderContext处理jinja模版数据结构</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="105" x="256" y="910.9307">3. Fd描述每个field</text><rect fill="#AAAAAA" height="75.875" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="145" x="327" y="943.7607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="125" x="337" y="964.8994">templates/builder.j2</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="4" x="337" y="978.8682"> </text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="116" x="337" y="992.8369">编写与tokenstream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="93" x="337" y="1006.8057">对应的jinja2模版</text><rect fill="#F1F1F1" height="169.6875" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="227" x="286" y="1039.6357"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="296" y="1060.7744">实现对应抽取方法</text><line style="stroke:#181818;stroke-width:1.0;" x1="286" x2="513" y1="1068.6045" y2="1068.6045"/><line style="stroke:#181818;stroke-width:1.0;" x1="286" x2="513" y1="1070.6045" y2="1070.6045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="194" x="296" y="1084.7432">1. Fd实现new方法处理TokenTree</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="191" x="296" y="1098.7119">2. BuilderContext实现下列方法：</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="37" x="296" y="1112.6807">- new:</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="175" x="328" y="1126.6494">从 TokenStream 中提取信息，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="119" x="328" y="1140.6182">构建 BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="54" x="296" y="1154.5869">- render:</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="165" x="328" y="1168.5557">把jinja2模版渲染成字符串代码</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="142" x="328" y="1182.5244">&gt; render里面用到split和</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="127" x="344" y="1196.4932">get_struct_fields方法</text><rect fill="#F1F1F1" height="57.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="273" x="263" y="1613.0732"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="253" x="273" y="1634.2119">使用syn与quote抽取 TokenStream中的信息</text><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="1642.042" y2="1642.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="1644.042" y2="1644.042"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="182" x="273" y="1658.1807">1. 同样定义BuilderContext和Fd</text><rect fill="#F1F1F1" height="183.6563" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="219" x="290" y="1691.0107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108" x="300" y="1712.1494">不需要自己手动定义</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132" x="300" y="1726.1182">抽取模版，直接实现方法</text><line style="stroke:#181818;stroke-width:1.0;" x1="290" x2="509" y1="1733.9482" y2="1733.9482"/><line style="stroke:#181818;stroke-width:1.0;" x1="290" x2="509" y1="1735.9482" y2="1735.9482"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="191" x="300" y="1750.0869">1. 比起手动方式，BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="162" x="316" y="1764.0557">和Fd还需要实现From Trait。</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="187" x="300" y="1778.0244">2. 接着Fd就不需要再处理，主要在</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="91" x="316" y="1791.9932">BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="179" x="300" y="1805.9619">3. BuilderContext实现下列方法</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="124" x="316" y="1819.9307">- render: 用到quote!</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="183" x="316" y="1833.8994">- gen_optionized_fields(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="135" x="316" y="1847.8682">- gen_methods(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="128" x="316" y="1861.8369">- gen_assigns(&amp;self)</text><rect fill="#F1F1F1" height="71.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="273" x="263" y="2278.417"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="253" x="273" y="2299.5557">使用syn与quote抽取 TokenStream中的信息</text><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="2307.3857" y2="2307.3857"/><line style="stroke:#181818;stroke-width:1.0;" x1="263" x2="536" y1="2309.3857" y2="2309.3857"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="199" x="273" y="2323.5244">1. 定义Opts、Fd、BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="240" x="273" y="2337.4932">2. 比起派生宏，多了Opts用于捕获Fd的属性</text><rect fill="#F1F1F1" height="155.7188" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="250" x="274.5" y="2370.3232"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="284.5" y="2391.4619">不需要自己手动定</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132" x="284.5" y="2405.4307">抽取模版，直接实现方法</text><line style="stroke:#181818;stroke-width:1.0;" x1="274.5" x2="524.5" y1="2413.2607" y2="2413.2607"/><line style="stroke:#181818;stroke-width:1.0;" x1="274.5" x2="524.5" y1="2415.2607" y2="2415.2607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="230" x="284.5" y="2429.3994">1. 和派生宏一样，给Fd、BuilderContext</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="150" x="300.5" y="2443.3682">和Fd还需要实现From Trait</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="215" x="284.5" y="2457.3369">2. BuilderContext同样实现下列方法：</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="124" x="300.5" y="2471.3057">- render: 用到quote!</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="183" x="300.5" y="2485.2744">- gen_optionized_fields(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="135" x="300.5" y="2499.2432">- gen_methods(&amp;self)</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="128" x="300.5" y="2513.2119">- gen_assigns(&amp;self)</text><line style="stroke:#000000;stroke-width:1.5;" x1="240" x2="240" y1="66.3389" y2="2875.667"/><ellipse cx="652" cy="102.292" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="612" y="132.292"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="622" y="153.4307">定义声明宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="612" y="472.0732"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="622" y="493.2119">定义过程宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="600" y="1229.3232"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="610" y="1250.4619">定义过程派生宏</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="600" y="1894.667"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="610" y="1915.8057">定义过程派生宏</text><rect fill="#F1F1F1" height="151.75" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="176" x="564" y="2546.042"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="574" y="2567.1807">定义过程派生宏</text><line style="stroke:#181818;stroke-width:1.0;" x1="564" x2="740" y1="2575.0107" y2="2575.0107"/><line style="stroke:#181818;stroke-width:1.0;" x1="564" x2="740" y1="2577.0107" y2="2577.0107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="574" y="2591.1494">和派生宏不同的是</text><line style="stroke:#181818;stroke-width:1.0;" x1="564" x2="740" y1="2598.9795" y2="2598.9795"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72" x="574" y="2615.1182">这里多了一个</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="155" x="574" y="2629.0869">attributes(builder) 属性，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="96" x="574" y="2643.0557">这是告诉编译器，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108" x="574" y="2657.0244">请允许代码中出现的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="12" x="574" y="2670.9932">1.</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="87" x="590" y="2670.9932">[builder(...)]，</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="156" x="574" y="2684.9619">它是我这个宏认识并要处理的</text><line style="stroke:#000000;stroke-width:1.5;" x1="558" x2="558" y1="66.3389" y2="2875.667"/><rect fill="#F1F1F1" height="71.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="127" x="771" y="186.2607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="781" y="207.3994">使用声明宏</text><line style="stroke:#181818;stroke-width:1.0;" x1="771" x2="898" y1="215.2295" y2="215.2295"/><line style="stroke:#181818;stroke-width:1.0;" x1="771" x2="898" y1="217.2295" y2="217.2295"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="107" x="781" y="231.3682">没有TokenStream</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="48" x="781" y="245.3369">难以调试</text><ellipse cx="834.5" cy="289.167" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="289.167" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="794.5" y="526.042"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="804.5" y="547.1807">使用过程宏</text><rect fill="#F1F1F1" height="57.9375" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="163" x="753" y="580.0107"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="763" y="601.1494">Terminal</text><line style="stroke:#181818;stroke-width:1.0;" x1="753" x2="916" y1="608.9795" y2="608.9795"/><line style="stroke:#181818;stroke-width:1.0;" x1="753" x2="916" y1="610.9795" y2="610.9795"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="143" x="763" y="625.1182">查看打印的TokenStream</text><ellipse cx="834.5" cy="668.9482" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="668.9482" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="782.5" y="1283.292"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="792.5" y="1304.4307">使用派生宏抽取</text><rect fill="#F1F1F1" height="61.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="103" x="783" y="1337.2607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="793" y="1358.3994">Terminal</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="793" y="1372.3682">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="83" x="793" y="1386.3369">TokenStream</text><ellipse cx="834.5" cy="1430.167" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="1430.167" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="782.5" y="1948.6357"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="792.5" y="1969.7744">使用派生宏抽取</text><rect fill="#F1F1F1" height="61.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="91" x="789" y="2002.6045"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="799" y="2023.7432">Terminal</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="799" y="2037.7119">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="71" x="799" y="2051.6807">DeriveInput</text><ellipse cx="834.5" cy="2095.5107" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="2095.5107" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104" x="782.5" y="2717.792"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84" x="792.5" y="2738.9307">使用派生宏抽取</text><rect fill="#F1F1F1" height="61.9063" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="91" x="789" y="2771.7607"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="53" x="799" y="2792.8994">Terminal</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="799" y="2806.8682">查看打印的</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="71" x="799" y="2820.8369">DeriveInput</text><ellipse cx="834.5" cy="2864.667" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1.0;"/><ellipse cx="834.5" cy="2864.667" fill="#222222" rx="6" ry="6" style="stroke:#111111;stroke-width:1.0;"/><line style="stroke:#000000;stroke-width:1.5;" x1="745" x2="745" y1="66.3389" y2="2875.667"/><line style="stroke:#000000;stroke-width:1.5;" x1="923" x2="923" y1="66.3389" y2="2875.667"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="330.167" y2="350.167"/><polygon fill="#181818" points="124.5,340.167,128.5,350.167,132.5,340.167,128.5,344.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="398.1045" y2="418.1045"/><polygon fill="#181818" points="124.5,408.1045,128.5,418.1045,132.5,408.1045,128.5,412.1045" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="709.9482" y2="729.9482"/><polygon fill="#181818" points="124.5,719.9482,128.5,729.9482,132.5,719.9482,128.5,723.9482" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="763.917" y2="783.917"/><polygon fill="#181818" points="124.5,773.917,128.5,783.917,132.5,773.917,128.5,777.917" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="1471.167" y2="1491.167"/><polygon fill="#181818" points="124.5,1481.167,128.5,1491.167,132.5,1481.167,128.5,1485.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="1539.1045" y2="1559.1045"/><polygon fill="#181818" points="124.5,1549.1045,128.5,1559.1045,132.5,1549.1045,128.5,1553.1045" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="2136.5107" y2="2156.5107"/><polygon fill="#181818" points="124.5,2146.5107,128.5,2156.5107,132.5,2146.5107,128.5,2150.5107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="2204.4482" y2="2224.4482"/><polygon fill="#181818" points="124.5,2214.4482,128.5,2224.4482,132.5,2214.4482,128.5,2218.4482" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="923.7607" y2="943.7607"/><polygon fill="#181818" points="395.5,933.7607,399.5,943.7607,403.5,933.7607,399.5,937.7607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1019.6357" y2="1039.6357"/><polygon fill="#181818" points="395.5,1029.6357,399.5,1039.6357,403.5,1029.6357,399.5,1033.6357" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1671.0107" y2="1691.0107"/><polygon fill="#181818" points="395.5,1681.0107,399.5,1691.0107,403.5,1681.0107,399.5,1685.0107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="2350.3232" y2="2370.3232"/><polygon fill="#181818" points="395.5,2360.3232,399.5,2370.3232,403.5,2360.3232,399.5,2364.3232" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="112.292" y2="132.292"/><polygon fill="#181818" points="648,122.292,652,132.292,656,122.292,652,126.292" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="258.167" y2="278.167"/><polygon fill="#181818" points="830.5,268.167,834.5,278.167,838.5,268.167,834.5,272.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="560.0107" y2="580.0107"/><polygon fill="#181818" points="830.5,570.0107,834.5,580.0107,838.5,570.0107,834.5,574.0107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="637.9482" y2="657.9482"/><polygon fill="#181818" points="830.5,647.9482,834.5,657.9482,838.5,647.9482,834.5,651.9482" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1317.2607" y2="1337.2607"/><polygon fill="#181818" points="830.5,1327.2607,834.5,1337.2607,838.5,1327.2607,834.5,1331.2607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1399.167" y2="1419.167"/><polygon fill="#181818" points="830.5,1409.167,834.5,1419.167,838.5,1409.167,834.5,1413.167" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1982.6045" y2="2002.6045"/><polygon fill="#181818" points="830.5,1992.6045,834.5,2002.6045,838.5,1992.6045,834.5,1996.6045" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2064.5107" y2="2084.5107"/><polygon fill="#181818" points="830.5,2074.5107,834.5,2084.5107,838.5,2074.5107,834.5,2078.5107" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2751.7607" y2="2771.7607"/><polygon fill="#181818" points="830.5,2761.7607,834.5,2771.7607,838.5,2761.7607,834.5,2765.7607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2833.667" y2="2853.667"/><polygon fill="#181818" points="830.5,2843.667,834.5,2853.667,838.5,2843.667,834.5,2847.667" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="166.2607" y2="171.2607"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="171.2607" y2="171.2607"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="171.2607" y2="186.2607"/><polygon fill="#181818" points="830.5,176.2607,834.5,186.2607,838.5,176.2607,834.5,180.2607" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="452.0732" y2="457.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="652" y1="457.0732" y2="457.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="457.0732" y2="472.0732"/><polygon fill="#181818" points="648,462.0732,652,472.0732,656,462.0732,652,466.0732" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="506.042" y2="511.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="511.042" y2="511.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="511.042" y2="526.042"/><polygon fill="#181818" points="830.5,516.042,834.5,526.042,838.5,516.042,834.5,520.042" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="817.8857" y2="822.8857"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="399.5" y1="822.8857" y2="822.8857"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="822.8857" y2="837.8857"/><polygon fill="#181818" points="395.5,827.8857,399.5,837.8857,403.5,827.8857,399.5,831.8857" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1209.3232" y2="1214.3232"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="652" y1="1214.3232" y2="1214.3232"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1214.3232" y2="1229.3232"/><polygon fill="#181818" points="648,1219.3232,652,1229.3232,656,1219.3232,652,1223.3232" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1263.292" y2="1268.292"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="1268.292" y2="1268.292"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1268.292" y2="1283.292"/><polygon fill="#181818" points="830.5,1273.292,834.5,1283.292,838.5,1273.292,834.5,1277.292" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="1593.0732" y2="1598.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="399.5" y1="1598.0732" y2="1598.0732"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1598.0732" y2="1613.0732"/><polygon fill="#181818" points="395.5,1603.0732,399.5,1613.0732,403.5,1603.0732,399.5,1607.0732" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="1874.667" y2="1879.667"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="652" y1="1879.667" y2="1879.667"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1879.667" y2="1894.667"/><polygon fill="#181818" points="648,1884.667,652,1894.667,656,1884.667,652,1888.667" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="1928.6357" y2="1933.6357"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="1933.6357" y2="1933.6357"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="1933.6357" y2="1948.6357"/><polygon fill="#181818" points="830.5,1938.6357,834.5,1948.6357,838.5,1938.6357,834.5,1942.6357" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="128.5" y1="2258.417" y2="2263.417"/><line style="stroke:#181818;stroke-width:1.0;" x1="128.5" x2="399.5" y1="2263.417" y2="2263.417"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="2263.417" y2="2278.417"/><polygon fill="#181818" points="395.5,2268.417,399.5,2278.417,403.5,2268.417,399.5,2272.417" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="399.5" y1="2526.042" y2="2531.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="399.5" x2="652" y1="2531.042" y2="2531.042"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="2531.042" y2="2546.042"/><polygon fill="#181818" points="648,2536.042,652,2546.042,656,2536.042,652,2540.042" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="652" y1="2697.792" y2="2702.792"/><line style="stroke:#181818;stroke-width:1.0;" x1="652" x2="834.5" y1="2702.792" y2="2702.792"/><line style="stroke:#181818;stroke-width:1.0;" x1="834.5" x2="834.5" y1="2702.792" y2="2717.792"/><polygon fill="#181818" points="830.5,2707.792,834.5,2717.792,838.5,2707.792,834.5,2711.792" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="99" x="81" y="83.0469">Cargo.toml</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="281" x="261.5" y="83.0469">src/&lt;对应抽取字段与方法定义&gt;.rs</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="74" x="617.5" y="83.0469">src/lib.rs</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="162" x="756" y="83.0469">examples/调用代码</text></g></svg></figure>
<h3 id="表格"><a class="header" href="#表格">表格</a></h3>
<div class="extended-markdown-table"><div class="extended-markdown-header extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 1; grid-row-end: 2">Macros</div><div class="extended-markdown-header" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2">Define</div><div class="extended-markdown-header" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2">Usage</div><div class="extended-markdown-header" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 1; grid-row-end: 2">note</div><div class="extended-markdown-header" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 1; grid-row-end: 2">Example</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 2; grid-row-end: 3">Declarative Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 2; grid-row-end: 3">#[macro_export]/macro_rules! macro_name{}</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 2; grid-row-end: 3">macro_name!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 2; grid-row-end: 3"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 2; grid-row-end: 3">println!</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 3; grid-row-end: 4">Function Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 3; grid-row-end: 4">#[proc_macros]/pub fn macro_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 3; grid-row-end: 4">macro_name!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 3; grid-row-end: 4">advanced declarative macro</div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 3; grid-row-end: 4"></div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 4; grid-row-end: 5">Derive Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 4; grid-row-end: 5">#[proc_macros_derive(DeriveMacroName)]/pub  fn other_fn_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 4; grid-row-end: 5">DeriveMacroName!()</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 4; grid-row-end: 5"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 4; grid-row-end: 5">#[derive(Debug)]</div><div class="extended-markdown-left-border" style="grid-column-start: 1; grid-column-end: 2; grid-row-start: 5; grid-row-end: 6">Attritubte Macro</div><div class="" style="grid-column-start: 2; grid-column-end: 3; grid-row-start: 5; grid-row-end: 6">#[proc_macros_derive(AttributeMacroName, attributes(attr_name))]/pub  fn other_fn_name</div><div class="" style="grid-column-start: 3; grid-column-end: 4; grid-row-start: 5; grid-row-end: 6">Only Diff with DeriveMacro when define struct</div><div class="" style="grid-column-start: 4; grid-column-end: 5; grid-row-start: 5; grid-row-end: 6"></div><div class="" style="grid-column-start: 5; grid-column-end: 6; grid-row-start: 5; grid-row-end: 6"></div></div>
<h3 id="声明宏的缺陷而后有了过程宏"><a class="header" href="#声明宏的缺陷而后有了过程宏">声明宏的缺陷，而后有了过程宏</a></h3>
<ul>
<li><a href="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/#limitationsofdeclarativemacros">Macros in Rust: A tutorial with examples - LogRocket Blog</a></li>
</ul>
<div id="admonition-为什么过程宏和声明宏那么像" class="admonition tip">
<div class="admonition-title">
<p>为什么过程宏和声明宏那么像</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-为什么过程宏和声明宏那么像"></a></p>
</div>
<div>
<blockquote>
<p>过程宏的缺陷</p>
</blockquote>
<ol>
<li>缺乏对宏自动完成和扩展的支持 </li>
<li>调试声明性宏很困难 </li>
<li>修改能力有限 </li>
<li>较大的二进制文件 </li>
<li>更长的编译时间（这适用于声明性宏和过程宏）</li>
</ol>
<blockquote>
<p>过程宏是语法树级别的转换
过程宏是宏的更高级版本。过程宏允许你扩展现有的 Rust 语法。它接受任意输入并返回有效的 Rust 代码。 
过程宏是将 TokenStream 作为输入并返回另一个 Token Stream 的函数。过程宏操作输入 TokenStream 以产生输出流。</p>
</blockquote>
</div>
</div>
<h3 id="声明宏declarative-macros-macro_rulesbang"><a class="header" href="#声明宏declarative-macros-macro_rulesbang">声明宏(declarative macros): macro_rules!(bang)</a></h3>
<blockquote>
<p>对代码模版做简单替换
声明宏可以用 macro_rules! 来描述, 如果重复性的代码无法用函数来封装，那么声明宏就是一个好的选择</p>
</blockquote>
<h3 id="过程宏深度定制与生成代码"><a class="header" href="#过程宏深度定制与生成代码">过程宏：深度定制与生成代码</a></h3>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Za411q7LQ">Rust 过程宏(1): 如何硬生生解析和手写过程宏</a></li>
</ul>
<blockquote>
<p>主要以如何使用 function-like macro 在不依赖于 syn / quote 的情况下，把 Json Schema 在编译期转换成 Rust struct。主要目的是让大家熟悉基本的处理 TokenStream 的思路</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Fu411m7W7">Rust 过程宏(2): 使用 syn/quote 撰写过程宏</a></li>
</ul>
<blockquote>
<p>主要通过一个 derive Builder 宏，来展示使用 syn/quote 如何开发过程宏。</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV1dr4y1v74n">Rust 过程宏(3): 使用 darling 处理 attributes</a></li>
</ul>
<blockquote>
<p>做个收尾，对上一讲的 derive macro 支持 attributes。 我们可以直接解析 attributes 相关的 TokenStream，也可以使用 darling 这个很方便的库，直接把 attributes 像
Clap/Structopts 那样收集到一个数据结构中，然后再进一步处理。</p>
</blockquote>
<div id="admonition-总结" class="admonition info">
<div class="admonition-title">
<p>总结</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-总结"></a></p>
</div>
<div>
<p>这三讲的内容虽然简单，但足以应付大家绝大多数宏编程的需求。
其实我们现在对 syn 库的使用还只是一个皮毛，我们还没有深入
去撰写自己的数据结构去实现 Parse trait，像 DeriveInput 
那样可以直接把 TokenStream 转换成我们想要的东西。</p>
<p>大家感兴趣的话，可以自行去看 syn 库的文档。</p>
</div>
</div>
<h4 id="函数宏"><a class="header" href="#函数宏">函数宏</a></h4>
<p>看起来像函数的宏，但在编译期进行处理.</p>
<blockquote>
<p>sqlx 用函数宏来处理SQL query、tokio使用属性宏 #[tokio::main] 来引入 runtime。
它们可以帮助目标代码的实现逻辑变得更加简单， 但一般除非特别必要，否则并不推荐写。
并没有特定的使用场景</p>
</blockquote>
<h4 id="属性宏"><a class="header" href="#属性宏">属性宏</a></h4>
<p>可以在其他代码块上添加属性，为代码块提供更多功能。</p>
<h4 id="派生宏"><a class="header" href="#派生宏">派生宏</a></h4>
<p>为 derive属性添加新的功能。这是我们平时使用最多的宏，比如 #[derive(Debug)].</p>
<blockquote>
<p>如果你定义的 trait 别人实现起来有固定的模式可循，那么可以考虑为其构建派生宏</p>
</blockquote>
<h2 id="声明宏"><a class="header" href="#声明宏">声明宏</a></h2>
<h3 id="rust常用声明宏"><a class="header" href="#rust常用声明宏">Rust常用声明宏</a></h3>
<h4 id="println"><a class="header" href="#println">println!</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.println.html">println in std - Rust</a></li>
<li><a href="https://blog.csdn.net/jiangjkd/article/details/120994956">Rust声明宏println剖析_一线coder的博客-CSDN博客_rust 声明宏</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
#[allow_internal_unstable(print_internals, format_args_nl)]
macro_rules! println {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ({
        $crate::io::_print($crate::format_args_nl!($($arg)*));
    })
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="writeln"><a class="header" href="#writeln">writeln!</a></h4>
<blockquote>
<p>可以将内容输入到指定文件</p>
</blockquote>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.writeln.html">writeln in std - Rust</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/148945862">rust入门笔记—翻译rust write！宏 - 知乎</a></li>
</ul>
<pre><code class="language-shell">cargo run --example raw_command &gt; examples/raw_command_output.txt
</code></pre>
<h4 id="eprintln"><a class="header" href="#eprintln">eprintln!</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.eprintln.html">eprintln in std - Rust</a></li>
</ul>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<h4 id="声明宏示意图"><a class="header" href="#声明宏示意图">声明宏示意图</a></h4>
<figure><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="633px" preserveAspectRatio="none" style="width:474px;height:633px;background:#FFFFFF;" version="1.1" viewBox="0 0 474 633" width="474px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="26.2969" id="_title" style="stroke:none;stroke-width:1.0;" width="136" x="167.5" y="15"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="126" x="172.5" y="32.9951">声明宏定义使用流程</text><ellipse cx="51" cy="57.2969" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1.0;"/><path d="M101,77.2969 L101,389.9531 L462,389.9531 L462,87.2969 L452,77.2969 L101,77.2969 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M452,77.2969 L452,87.2969 L462,87.2969 L452,77.2969 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="12" x="107" y="94.3638">1.</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="99" x="123" y="94.3638">[macro_export]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="149" x="107" y="109.4966">macro_rules! my_vec {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="299" x="123" y="124.6294">// 没带任何参数的 my_vec，我们创建一个空的 vec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="324" x="123" y="139.7622">// 注意，由于宏要在调用的地方展开，我们无法预测调用</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="316" x="123" y="154.895">// 者的环境是否已经 做了相关的 use，所以我们使用的</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="194" x="123" y="170.0278">// 代码最好带着完整的命名空间。</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="48" x="123" y="185.1606">() =&gt; {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="125" x="139" y="200.2935">std::vec::Vec::new()</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="12" x="123" y="215.4263">};</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="162" x="123" y="230.5591">// 处理 my_vec![1, 2, 3, 4]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="133" x="123" y="245.6919">($($el:expr),*) =&gt; ({</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="139" y="260.8247">let mut v = std::vec::Vec::new();</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="100" x="139" y="275.9575">$(v.push($el);)*</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="7" x="139" y="291.0903">v</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="17" x="123" y="306.2231">});</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="138" x="123" y="321.356">// 处理 my_vec![0; 10]</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="155" x="123" y="336.4888">($el:expr; $n:expr) =&gt; {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="180" x="139" y="351.6216">std::vec::from_elem($el, $n)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="123" y="366.7544">}</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="107" y="381.8872">}</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="11" y="216.6406"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="21" y="237.7793">定义声明宏</text><path d="M101,399.9531 L101,621.8125 L318,621.8125 L318,409.9531 L308,399.9531 L101,399.9531 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M308,399.9531 L308,409.9531 L318,409.9531 L308,399.9531 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="70" x="107" y="417.02">fn main() {</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="144" x="123" y="432.1528">let mut v = my_vec![];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="64" x="123" y="447.2856">v.push(1);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="159" x="123" y="462.4185">// 调用时可以使用 [], (), {}</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="177" x="123" y="477.5513">let _v = my_vec!(1, 2, 3, 4);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="177" x="123" y="492.6841">let _v = my_vec![1, 2, 3, 4];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="180" x="123" y="507.8169">let v = my_vec! {1, 2, 3, 4};</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="522.9497">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="4" x="107" y="538.0825"> </text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="553.2153">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="123" y="568.3481">//</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="146" x="123" y="583.481">let v = my_vec![1; 10];</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="123" y="598.6138">println!("{:?}", v);</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8" x="107" y="613.7466">}</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="11" y="493.8984"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="21" y="515.0371">使用声明宏</text><line style="stroke:#181818;stroke-width:1.0;" x1="51" x2="51" y1="67.2969" y2="216.6406"/><polygon fill="#181818" points="47,206.6406,51,216.6406,55,206.6406,51,210.6406" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="51" x2="51" y1="250.6094" y2="493.8984"/><polygon fill="#181818" points="47,483.8984,51,493.8984,55,483.8984,51,487.8984" style="stroke:#181818;stroke-width:1.0;"/></g></svg></figure>
<h4 id="macro_rules定义"><a class="header" href="#macro_rules定义">macro_rules!定义</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">#[macro_export]
macro_rules! my_vec {
    // 没带任何参数的 my_vec，我们创建一个空的 vec
    // 注意，由于宏要在调用的地方展开，我们无法预测调用
    // 者的环境是否已经 做了相关的 use，所以我们使用的
    // 代码最好带着完整的命名空间。
    () =&gt; {
        std::vec::Vec::new()
    };
    // 处理 my_vec![1, 2, 3, 4]
    ($($el:expr),*) =&gt; ({
        let mut v = std::vec::Vec::new();
        $(v.push($el);)*
        v
    });
    // 处理 my_vec![0; 10]
    ($el:expr; $n:expr) =&gt; {
        std::vec::from_elem($el, $n)
    }
}
</code></pre></pre>
<div id="admonition-elexpr-" class="admonition info">
<div class="admonition-title">
<p>$($el:expr), *)</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-elexpr-"></a></p>
</div>
<div>
<ol>
<li>在声明宏中，条件捕获的参数使用 $ 开头的标识符来声明。</li>
<li>每个参数都需要提供类型，这里<code>expr</code>代表表达式，所以 $el:expr 是说把匹配到的表达式命名为 $el。</li>
<li>$(…),* 告诉编译器可以匹配任意多个以逗号分隔的表达式，然后捕获到的每一个表达式可以用 $el 来访问。</li>
<li>由于匹配的时候匹配到一个 $(…)* （我们可以不管分隔符），在执行的代码块中，我们也要相应地使用 $(…)* 展开。</li>
<li>所以这句 $(v.push($el);)* 相当于匹配出多少个 $el就展开多少句 push 语句。</li>
</ol>
</div>
</div>
<h4 id="使用-2"><a class="header" href="#使用-2">使用</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let mut v = my_vec![];
    v.push(1);
    // 调用时可以使用 [], (), {}
    let _v = my_vec!(1, 2, 3, 4);
    let _v = my_vec![1, 2, 3, 4];
    let v = my_vec! {1, 2, 3, 4};
    println!(&quot;{:?}&quot;, v);

    println!(&quot;{:?}&quot;, v);
    //
    let v = my_vec![1; 10];
    println!(&quot;{:?}&quot;, v);
}
</code></pre></pre>
<h3 id="声明宏用到的参数类型"><a class="header" href="#声明宏用到的参数类型">声明宏用到的参数类型</a></h3>
<div id="admonition-类型列表" class="admonition info">
<div class="admonition-title">
<p>类型列表</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-类型列表"></a></p>
</div>
<div>
<ol>
<li>item，比如一个函数、结构体、模块等。 </li>
<li>block，代码块。比如一系列由花括号包裹的表达式和语句。 </li>
<li>stmt，语句。比如一个赋值语句。 </li>
<li>pat，模式。 </li>
<li>expr，表达式。刚才的例子使用过了。 </li>
<li>ty，类型。比如 Vec。 </li>
<li>ident，标识符。比如一个变量名。 </li>
<li>path，路径。比如：foo、::std::mem::replace、transmute::&lt;_, int&gt;。 </li>
<li>meta，元数据。一般是在 #[…] 和 #![…] 属性内部的数据。 </li>
<li>tt，单个的 token 树。 </li>
<li>vis，可能为空的一个 Visibility 修饰符。比如 pub、pub(crate)</li>
</ol>
</div>
</div>
<h2 id="过程宏手工定义图"><a class="header" href="#过程宏手工定义图">过程宏手工定义图</a></h2>
<blockquote>
<p>过程宏要比声明宏要复杂很多，不过无论是哪一种过程宏，本质都是一样的，都涉及要把 <code>输入的 TokenStream</code> 处理成<code>输出的 TokenStream</code>。</p>
</blockquote>
<h3 id="cargotoml添加proc-macro声明"><a class="header" href="#cargotoml添加proc-macro声明">Cargo.toml添加proc-macro声明</a></h3>
<blockquote>
<p>这样，编译器才允许你使用 #[proc_macro] 相关的宏。</p>
</blockquote>
<pre><code class="language-toml  editable">[lib]
proc-macro = true
</code></pre>
<h2 id="过程函数宏-proc_macro"><a class="header" href="#过程函数宏-proc_macro">过程函数宏: #[proc_macro]</a></h2>
<blockquote>
<p>和macro_rules! 功能类似，但更为强大。</p>
</blockquote>
<h3 id="srclibrs定义过程函数宏"><a class="header" href="#srclibrs定义过程函数宏">src/lib.rs:定义过程函数宏</a></h3>
<blockquote>
<p>可以看到，都是处理TokenStream</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">mod builder;
mod builder_with_attr;
mod raw_builder;

use proc_macro::TokenStream;
use raw_builder::BuilderContext;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro]
pub fn query(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    &quot;fn hello() { println!(\&quot;Hello world!\&quot;); }&quot;
        .parse()
        .unwrap()
}

#[proc_macro_derive(RawBuilder)]
pub fn derive_raw_builder(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    BuilderContext::render(input).unwrap().parse().unwrap()
}

#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    println!(&quot;{:#?}&quot;, input);
    builder::BuilderContext::from(input).render().into()
}

#[proc_macro_derive(BuilderWithAttr, attributes(builder))]
pub fn derive_builder_with_attr(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    println!(&quot;{:#?}&quot;, input);
    builder_with_attr::BuilderContext::from(input)
        .render()
        .into()
}
</code></pre></pre>
<div id="admonition-tokenstream" class="admonition info">
<div class="admonition-title">
<p>TokenStream</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-tokenstream"></a></p>
</div>
<div>
<p>使用者可以通过 query!(…) 来调用。我们打印传入的 TokenStream，
然后把一段包含在字符串中的代码解析成 TokenStream 返回。</p>
<p>这里可以非常方便地用字符串的 parse() 方法来获得 TokenStream，
是因为 TokenStream 实现了  FromStr trait。</p>
</div>
</div>
<h3 id="examplesqueryrs使用"><a class="header" href="#examplesqueryrs使用">examples/query.rs:使用</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">use macros::query;

fn main() {
    // query!(SELECT * FROM users WHERE age &gt; 10);
    query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id);
    hello()
}
</code></pre></pre>
<ol>
<li>.parse().unwrap(): 字符串自动转为TokenStream类型</li>
</ol>
<pre><code class="language-shell">cargo run --example query &gt; examples/query_output.txt
</code></pre>
<pre><code class="language-shell">TokenStream [
    Ident {
        ident: &quot;SELECT&quot;,
        span: #0 bytes(94..100),
    },
    Punct {
        ch: '*',
        spacing: Alone,
        span: #0 bytes(101..102),
    },
    Ident {
        ident: &quot;FROM&quot;,
        span: #0 bytes(103..107),
    },
    Ident {
        ident: &quot;users&quot;,
        span: #0 bytes(108..113),
    },
    Ident {
        ident: &quot;u&quot;,
        span: #0 bytes(114..115),
    },
    Ident {
        ident: &quot;JOIN&quot;,
        span: #0 bytes(116..120),
    },
    Group {
        delimiter: Parenthesis,
        stream: TokenStream [
            Ident {
                ident: &quot;SELECT&quot;,
                span: #0 bytes(122..128),
            },
            Punct {
                ch: '*',
                spacing: Alone,
                span: #0 bytes(129..130),
            },
            Ident {
                ident: &quot;from&quot;,
                span: #0 bytes(131..135),
            },
            Ident {
                ident: &quot;profiles&quot;,
                span: #0 bytes(136..144),
            },
            Ident {
                ident: &quot;p&quot;,
                span: #0 bytes(145..146),
            },
        ],
        span: #0 bytes(121..147),
    },
    Ident {
        ident: &quot;WHERE&quot;,
        span: #0 bytes(148..153),
    },
    Ident {
        ident: &quot;u&quot;,
        span: #0 bytes(154..155),
    },
    Punct {
        ch: '.',
        spacing: Alone,
        span: #0 bytes(155..156),
    },
    Ident {
        ident: &quot;id&quot;,
        span: #0 bytes(156..158),
    },
    Punct {
        ch: '=',
        spacing: Alone,
        span: #0 bytes(159..160),
    },
    Ident {
        ident: &quot;p&quot;,
        span: #0 bytes(161..162),
    },
    Punct {
        ch: '.',
        spacing: Alone,
        span: #0 bytes(162..163),
    },
    Ident {
        ident: &quot;id&quot;,
        span: #0 bytes(163..165),
    },
]
Hello world!
</code></pre>
<div id="admonition-tokenstream是一个iterator里面包含一系列的tokentree" class="admonition tip">
<div class="admonition-title">
<p>TokenStream是一个Iterator，里面包含一系列的TokenTree</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-tokenstream是一个iterator里面包含一系列的tokentree"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TokenTree {
    // 组，如果代码中包含括号，比如{} [] &lt;&gt; () ，那么内部的内容会被分析成一个Group（组）
    Group(Group), 
    // 标识符
    Ident(Ident),
    // 标点符号 
    Punct(Punct),
    // 字面量 
    Literal(Literal), 
}
<span class="boring">}
</span></code></pre></pre>
</div>
</div>
<div id="admonition-group-example" class="admonition info">
<div class="admonition-title">
<p>Group Example</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-group-example"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust">use macros::query;

fn main() {
    // query!(SELECT * FROM users WHERE age &gt; 10);
    query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id);
    hello()
}
</code></pre></pre>
</div>
</div>
<h2 id="过程派生宏-proc_macro_devivederivemacroname"><a class="header" href="#过程派生宏-proc_macro_devivederivemacroname">过程派生宏: /#[proc_macro_devive(DeriveMacroName)]</a></h2>
<blockquote>
<p>用于结构体（struct）、枚举（enum）、联合（union）类型，可为其实现函数或特征（Trait）</p>
</blockquote>
<h3 id="常用派生宏"><a class="header" href="#常用派生宏">常用派生宏</a></h3>
<h4 id="derivedebug"><a class="header" href="#derivedebug">#[derive(Debug)]</a></h4>
<h3 id="原始实现builder模式"><a class="header" href="#原始实现builder模式">原始实现builder模式</a></h3>
<h4 id="想到达到链式调用的效果"><a class="header" href="#想到达到链式调用的效果">想到达到链式调用的效果</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .current_dir(&quot;..&quot;.to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
    println!(&quot;{:?}&quot;, command);
}
</code></pre></pre>
<h4 id="可以这样定义"><a class="header" href="#可以这样定义">可以这样定义</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 这是command.rs的派生宏实现的代码样子
#[allow(dead_code)]
#[derive(Debug)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}

#[derive(Debug, Default)]
pub struct CommandBuilder {
    executable: Option&lt;String&gt;,
    args: Option&lt;Vec&lt;String&gt;&gt;,
    env: Option&lt;Vec&lt;String&gt;&gt;,
    current_dir: Option&lt;String&gt;,
}

impl Command {
    pub fn builder() -&gt; CommandBuilder {
        Default::default()
    }
}

impl CommandBuilder {
    pub fn executable(mut self, v: String) -&gt; Self {
        self.executable = Some(v.to_owned());
        self
    }

    pub fn args(mut self, v: Vec&lt;String&gt;) -&gt; Self {
        self.args = Some(v.to_owned());
        self
    }

    pub fn env(mut self, v: Vec&lt;String&gt;) -&gt; Self {
        self.env = Some(v.to_owned());
        self
    }

    pub fn current_dir(mut self, v: String) -&gt; Self {
        self.current_dir = Some(v.to_owned());
        self
    }

    pub fn build(mut self) -&gt; Result&lt;Command, &amp;'static str&gt; {
        Ok(Command {
            executable: self.executable.take().ok_or(&quot;executable must be set&quot;)?,
            args: self.args.take().ok_or(&quot;args must be set&quot;)?,
            env: self.env.take().ok_or(&quot;env must be set&quot;)?,
            current_dir: self.current_dir.take(),
        })
    }
</code></pre></pre>
<h4 id="但是有点繁琐可以使用派生宏派生出这些代码"><a class="header" href="#但是有点繁琐可以使用派生宏派生出这些代码">但是有点繁琐，可以使用派生宏派生出这些代码</a></h4>
<h3 id="派生宏思路"><a class="header" href="#派生宏思路">派生宏思路</a></h3>
<h4 id="要生成的代码模版"><a class="header" href="#要生成的代码模版">要生成的代码模版</a></h4>
<p>把输入的 TokenStream 抽取出来，也就是把在 struct 的定义内部，每个域的名字及其类型都抽出来，然后生成对应的方法代码。</p>
<pre><pre class="playground"><code class="language-rust  editable">impl {{ name }} {
    pub fn builder() -&gt; {{ builder_name }} {
        Default::default()
    }
}

#[derive(Debug, Default)]
pub struct {{ builder_name }} {
    {% for field in fields %}
        {{ field.name }}: Option&lt;{{ field.ty }}&gt;,
    {% endfor %}
}

impl {{ builder_name }} {
    {% for field in fields %}
    pub fn {{ field.name }}(mut self, v: impl Into&lt;{{ field.ty }}&gt;) -&gt; {{ builder_name }} {
        self.{{ field.name }} = Some(v.into());
        self
    }
    {% endfor %}

    pub fn build(self) -&gt; Result&lt;{{ name }}, &amp;'static str&gt; {
        Ok({{ name }} {
            {% for field in fields %}
                {% if field.optional %}
                {{ field.name }}: self.{{ field.name }},
                {% else %}
                {{ field.name }}: self.{{ field.name }}.ok_or(&quot;Build failed: missing {{ field.name }}&quot;)?,
                {% endif %}
            {% endfor %}
        })
    }
}
</code></pre></pre>
<ol>
<li>7-12: 这里的 fileds / builder_name 是我们要传入的参数，每个 field 还需要 name 和 ty 两个 属性，分别对应 field 的名字和类型</li>
<li>25-26: 对于原本是 Option<T> 类型的域，要避免生成 Option<Option>，我们需要把是否是 Option 单独抽取出来，如果是 Option<T>，那么 ty 就是 T。所以，field 还需要一个属 性
optional。</li>
</ol>
<h4 id="构建对应数据结构"><a class="header" href="#构建对应数据结构">构建对应数据结构</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">/// 处理 jinja 模板的数据结构，在模板中我们使用了 name / builder_name / fields
#[derive(Template)]
#[template(path = &quot;builder.j2&quot;, escape = &quot;none&quot;)]
pub struct BuilderContext {
    name: String,
    builder_name: String,
    fields: Vec&lt;Fd&gt;,
}
</code></pre></pre>
<h4 id="srclibrs-使用派生宏从tokenstream抽取出想要的信息"><a class="header" href="#srclibrs-使用派生宏从tokenstream抽取出想要的信息">src/lib.rs: 使用派生宏从TokenStream抽取出想要的信息</a></h4>
<blockquote>
<p>对于 derive macro，要使用 proce_macro_derive 这个宏。我们把这个 derive macro 命名为 Builder。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">#[proc_macro_derive(RawBuilder)]
pub fn derive_raw_builder(input: TokenStream) -&gt; TokenStream {
    // 只有修改代码之后再次编译才会执行
    println!(&quot;{:#?}&quot;, input);
    BuilderContext::render(input).unwrap().parse().unwrap()
}
</code></pre></pre>
<h4 id="examplesraw_commandrs-使用这个派生宏抽取"><a class="header" href="#examplesraw_commandrs-使用这个派生宏抽取">examples/raw_command.rs: 使用这个派生宏抽取</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">use macros::RawBuilder;

#[allow(dead_code)]
#[derive(Debug, RawBuilder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}

fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .env(vec![])
        .current_dir(&quot;..&quot;.to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
    println!(&quot;{:?}&quot;, command);
}
</code></pre></pre>
<h4 id="运行查看获取的tokenstream"><a class="header" href="#运行查看获取的tokenstream">运行，查看获取的TokenStream</a></h4>
<pre><code class="language-shell">cargo run --example raw_command &gt; examples/raw_command_output.txt
</code></pre>
<pre><code class="language-shell">TokenStream [
    Punct {
        ch: '#',
        spacing: Alone,
        span: #0 bytes(25..26),
    },
    Group {
        delimiter: Bracket,
        stream: TokenStream [
            Ident {
                ident: &quot;allow&quot;,
                span: #0 bytes(27..32),
            },
            Group {
                delimiter: Parenthesis,
                stream: TokenStream [
                    Ident {
                        ident: &quot;dead_code&quot;,
                        span: #0 bytes(33..42),
                    },
                ],
                span: #0 bytes(32..43),
            },
        ],
        span: #0 bytes(26..44),
    },
    Ident {
        ident: &quot;pub&quot;,
        span: #0 bytes(74..77),
    },
    Ident {
        ident: &quot;struct&quot;,
        span: #0 bytes(78..84),
    },
    Ident {
        ident: &quot;Command&quot;,
        span: #0 bytes(85..92),
    },
    Group {
        delimiter: Brace,
        stream: TokenStream [
            Ident {
                ident: &quot;executable&quot;,
                span: #0 bytes(99..109),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(109..110),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(111..117),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(117..118),
            },
            Ident {
                ident: &quot;args&quot;,
                span: #0 bytes(123..127),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(127..128),
            },
            Ident {
                ident: &quot;Vec&quot;,
                span: #0 bytes(129..132),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(132..133),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(133..139),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(139..140),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(140..141),
            },
            Ident {
                ident: &quot;env&quot;,
                span: #0 bytes(146..149),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(149..150),
            },
            Ident {
                ident: &quot;Vec&quot;,
                span: #0 bytes(151..154),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(154..155),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(155..161),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(161..162),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(162..163),
            },
            Ident {
                ident: &quot;current_dir&quot;,
                span: #0 bytes(168..179),
            },
            Punct {
                ch: ':',
                spacing: Alone,
                span: #0 bytes(179..180),
            },
            Ident {
                ident: &quot;Option&quot;,
                span: #0 bytes(181..187),
            },
            Punct {
                ch: '&lt;',
                spacing: Alone,
                span: #0 bytes(187..188),
            },
            Ident {
                ident: &quot;String&quot;,
                span: #0 bytes(188..194),
            },
            Punct {
                ch: '&gt;',
                spacing: Joint,
                span: #0 bytes(194..195),
            },
            Punct {
                ch: ',',
                spacing: Alone,
                span: #0 bytes(195..196),
            },
        ],
        span: #0 bytes(93..198),
    },
]
Command { executable: &quot;cargo&quot;, args: [&quot;build&quot;, &quot;--release&quot;], env: [], current_dir: Some(&quot;..&quot;) }
</code></pre>
<div id="admonition-打印信息说明" class="admonition info">
<div class="admonition-title">
<p>打印信息说明</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-打印信息说明"></a></p>
</div>
<div>
<ol>
<li>
<p>首先有一个 Group，包含了 #[allow(dead_code)] 属性的信息。因为我们现在拿到 的 derive 下的信息，所以所有不属于 #[derive(…)] 的属性，都会被放入 TokenStream 中。</p>
</li>
<li>
<p>之后是 pub / struct / Command 三个 ident。</p>
</li>
<li>
<p>随后又是一个 Group，包含了每个 field 的信息。我们看到，field 之间用逗号这个 Punct 分隔，field 的名字和类型又是通过冒号这个 Punct 分隔。而类型，可能是一个 Ident，如 String，或者一系列 Ident / Punct，如 Vec / &lt; / String / &gt;。</p>
</li>
</ol>
</div>
</div>
<h4 id="srcraw_builderrs-使用anyhow与askama抽取tokenstream中的信息"><a class="header" href="#srcraw_builderrs-使用anyhow与askama抽取tokenstream中的信息">src/raw_builder.rs: 使用anyhow与askama抽取TokenStream中的信息</a></h4>
<blockquote>
<p>我们要做的就是，把这个 TokenStream 中的 struct 名字，以及每个 field 的名字和类型拿出来。
如果类型是 Option<T>，那么把 T 拿出来，把 optional 设置为 true。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">use anyhow::Result;
use askama::Template;
use proc_macro::{Ident, TokenStream, TokenTree};
use std::collections::VecDeque;

/// 处理 jinja 模板的数据结构，在模板中我们使用了 name / builder_name / fields
#[derive(Template)]
#[template(path = &quot;builder.j2&quot;, escape = &quot;none&quot;)]
pub struct BuilderContext {
    name: String,
    builder_name: String,
    fields: Vec&lt;Fd&gt;,
}

/// 描述 struct 的每个 field
#[derive(Debug, Default)]
struct Fd {
    name: String,
    ty: String,
    optional: bool,
}
</code></pre></pre>
<h4 id="templatesbuilderj2-上面askama用到的jinja2模版"><a class="header" href="#templatesbuilderj2-上面askama用到的jinja2模版">templates/builder.j2: 上面askama用到的jinja2模版</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">impl {{ name }} {
    pub fn builder() -&gt; {{ builder_name }} {
        Default::default()
    }
}

#[derive(Debug, Default)]
pub struct {{ builder_name }} {
    {% for field in fields %}
        {{ field.name }}: Option&lt;{{ field.ty }}&gt;,
    {% endfor %}
}

impl {{ builder_name }} {
    {% for field in fields %}
    pub fn {{ field.name }}(mut self, v: impl Into&lt;{{ field.ty }}&gt;) -&gt; {{ builder_name }} {
        self.{{ field.name }} = Some(v.into());
        self
    }
    {% endfor %}

    pub fn build(self) -&gt; Result&lt;{{ name }}, &amp;'static str&gt; {
        Ok({{ name }} {
            {% for field in fields %}
                {% if field.optional %}
                {{ field.name }}: self.{{ field.name }},
                {% else %}
                {{ field.name }}: self.{{ field.name }}.ok_or(&quot;Build failed: missing {{ field.name }}&quot;)?,
                {% endif %}
            {% endfor %}
        })
    }
}
</code></pre></pre>
<h4 id="srcraw_builderrs-实现对应抽取方法"><a class="header" href="#srcraw_builderrs-实现对应抽取方法">src/raw_builder.rs: 实现对应抽取方法</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">impl Fd {
    /// name 和 field 都是通过冒号 Punct 切分出来的 TokenTree 切片
    pub fn new(name: &amp;[TokenTree], ty: &amp;[TokenTree]) -&gt; Self {
        // 把类似 Ident(&quot;Option&quot;), Punct('&lt;'), Ident(&quot;String&quot;), Punct('&gt;) 的 ty
        // 收集成一个 String 列表，如 vec![&quot;Option&quot;, &quot;&lt;&quot;, &quot;String&quot;, &quot;&gt;&quot;]
        let ty = ty
            .iter()
            .map(|v| match v {
                TokenTree::Ident(n) =&gt; n.to_string(),
                TokenTree::Punct(p) =&gt; p.as_char().to_string(),
                e =&gt; panic!(&quot;Expect ident, got {:?}&quot;, e),
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();
        // 冒号前最后一个 TokenTree 是 field 的名字
        // 比如：executable: String,
        // 注意这里不应该用 name[0]，因为有可能是 pub executable: String
        // 甚至，带 attributes 的 field，
        // 比如：#[builder(hello = world)] pub executable: String
        match name.last() {
            Some(TokenTree::Ident(name)) =&gt; {
                // 如果 ty 第 0 项是 Option，那么从第二项取到倒数第一项
                // 取完后上面的例子中的 ty 会变成 [&quot;String&quot;]，optiona = true
                let (ty, optional) = if ty[0].as_str() == &quot;Option&quot; {
                    (&amp;ty[2..ty.len() - 1], true)
                } else {
                    (&amp;ty[..], false)
                };
                Self {
                    name: name.to_string(),
                    ty: ty.join(&quot;&quot;), // 把 ty join 成字符串
                    optional,
                }
            }
            e =&gt; panic!(&quot;Expect ident, got {:?}&quot;, e),
        }
    }
}

impl BuilderContext {
    /// 从 TokenStream 中提取信息，构建 BuilderContext
    fn new(input: TokenStream) -&gt; Self {
        let (name, input) = split(input);
        let fields = get_struct_fields(input);
        Self {
            builder_name: format!(&quot;{}Builder&quot;, name),
            name: name.to_string(),
            fields,
        }
    }

    /// 把模板渲染成字符串代码
    pub fn render(input: TokenStream) -&gt; Result&lt;String&gt; {
        let template = Self::new(input);
        Ok(template.render()?)
    }
}

/// 把 TokenStream 分出 struct 的名字，和包含 fields 的 TokenStream
fn split(input: TokenStream) -&gt; (Ident, TokenStream) {
    let mut input = input.into_iter().collect::&lt;VecDeque&lt;_&gt;&gt;();
    // 一直往后找，找到 struct 停下来
    while let Some(item) = input.pop_front() {
        if let TokenTree::Ident(v) = item {
            if v.to_string() == &quot;struct&quot; {
                break;
            }
        }
    }

    // struct 后面，应该是 struct name
    let ident;
    if let Some(TokenTree::Ident(v)) = input.pop_front() {
        ident = v;
    } else {
        panic!(&quot;Didn't find struct name&quot;);
    }

    // struct 后面可能还有若干 TokenTree，我们不管，一路找到第一个 Group
    let mut group = None;
    for item in input {
        if let TokenTree::Group(g) = item {
            group = Some(g);
            break;
        }
    }

    (ident, group.expect(&quot;Didn't find field group&quot;).stream())
}

/// 从包含 fields 的 TokenStream 中切出来一个个 Fd
fn get_struct_fields(input: TokenStream) -&gt; Vec&lt;Fd&gt; {
    let input = input.into_iter().collect::&lt;Vec&lt;_&gt;&gt;();
    input
        .split(|v| match v {
            // 先用 ',' 切出来一个个包含 field 所有信息的 &amp;[TokenTree]
            TokenTree::Punct(p) =&gt; p.as_char() == ',',
            _ =&gt; false,
        })
        .map(|tokens| {
            tokens
                .split(|v| match v {
                    // 再用 ':' 把 &amp;[TokenTree] 切成 [&amp;[TokenTree], &amp;[TokenTree]]
                    // 它们分别对应名字和类型
                    TokenTree::Punct(p) =&gt; p.as_char() == ':',
                    _ =&gt; false,
                })
                .collect::&lt;Vec&lt;_&gt;&gt;()
        })
        // 正常情况下，应该得到 [&amp;[TokenTree], &amp;[TokenTree]]，对于切出来长度不为 2 的统统过滤掉
        .filter(|tokens| tokens.len() == 2)
        // 使用 Fd::new 创建出每个 Fd
        .map(|tokens| Fd::new(tokens[0], tokens[1]))
        .collect()
}
</code></pre></pre>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-tip"></a></p>
</div>
<div>
<p>可以对着打印出来的 TokenStream 和刚才的分析进行理解。
核心的就是 get_struct_fields() 方法，如果觉得难懂，
可以想想如果要把一个 a=1,b=2 的字符串切成 [[a, 1], [b, 2]] 该怎么做，就很容易理解了。</p>
</div>
</div>
<h3 id="使用synquote可以不用自己定义模版"><a class="header" href="#使用synquote可以不用自己定义模版">使用syn/quote可以不用自己定义模版</a></h3>
<blockquote>
<p>详见上方对比图</p>
</blockquote>
<h2 id="过程属性宏-proc_macro_derivemacro_name-attributesattr_name"><a class="header" href="#过程属性宏-proc_macro_derivemacro_name-attributesattr_name">过程属性宏: proc_macro_derive(macro_name, attributes(attr_name))</a></h2>
<blockquote>
<p>用于属性宏， 用在结构体、字段、函数等地方，为其指定属性等功能, 类似python的计算属性</p>
</blockquote>
<div id="admonition-定义结构体时在某个字段上方使用对应attr_name" class="admonition tip">
<div class="admonition-title">
<p>定义结构体时在某个字段上方使用对应attr_name</p>
<p><a class="admonition-anchor-link" href="4_macros.html#admonition-定义结构体时在某个字段上方使用对应attr_name"></a></p>
</div>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(dead_code)]
#[derive(Debug, BuilderWithAttr)]
pub struct Command {
    executable: String,
    #[builder(each = &quot;arg&quot;)]
    args: Vec&lt;String&gt;,
    #[builder(each = &quot;env&quot;, default = &quot;vec![]&quot;)]
    env: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</div>
</div>
<h3 id="使用synquote定义属性宏"><a class="header" href="#使用synquote定义属性宏">使用syn/quote定义属性宏</a></h3>
<blockquote>
<p>详见上方对比图</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v-并发与异步"><a class="header" href="#v-并发与异步">V 并发与异步</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vi-混合编程"><a class="header" href="#vi-混合编程">VI 混合编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kv-server设计与实现"><a class="header" href="#kv-server设计与实现">KV Server设计与实现</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构建自己的类axum异步web框架"><a class="header" href="#构建自己的类axum异步web框架">构建自己的类axum异步Web框架</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checklist"><a class="header" href="#checklist">Checklist</a></h1>

            </main>

            <!--            <script src="https://utteranc.es/client.js"-->
            <!--                    repo="RustMagazine/rust_magazine_2022"-->
            <!--                    issue-term="title"-->
            <!--                    theme="github-light"-->
            <!--                    crossorigin="anonymous"-->
            <!--                    async></script>-->

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->


                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">

    </nav>

</div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/mermaid/mermaid.min.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid-init.js"></script>
    <script type="text/javascript" src="assets/smart-anchor.js"></script>
    <script type="text/javascript" src="assets/pagetoc/sidebar.js"></script>

        <script type="text/javascript">
            window.addEventListener('load', function () {
                MathJax.Hub.Register.StartupHook('End', function () {
                    window.setTimeout(window.print, 100);
                });
            });
        </script>
</body>
</html>
