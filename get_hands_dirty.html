<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>get hands dirty - Anatomy In First Rust Programming Class 🦀</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust编程第一课的代码为例进行基础代码分析">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="md-favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/pagetoc/pagetoc_style.css">
        <link rel="stylesheet" href="assets/css/mdbook-admonish.css">

        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="anatomy_logic.html"><strong aria-hidden="true">1.</strong> 源码阅读逻辑</a></li><li class="chapter-item expanded "><a href="get_hands_dirty.html" class="active"><strong aria-hidden="true">2.</strong> get hands dirty</a></li><li class="chapter-item expanded "><a href="intro_gdb_lldb.html"><strong aria-hidden="true">3.</strong> gdb/lldb调试或查看内存结构</a></li><li class="chapter-item expanded affix "><a href="checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Anatomy In First Rust Programming Class 🦀</h1>
            <h4 class="menu-bar"><a href="https://kuanhsiaokuo.github.io/think-tool-kit/">保持批判，有所取舍，知行合一, 方见真我</a> -- 练武不练功
                到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/geektime-tyr-rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="get-hands-dirty"><a class="header" href="#get-hands-dirty">get hands dirty</a></h1>
<!--ts-->
<ul>
<li><a href="#get-hands-dirty">get hands dirty</a>
<ul>
<li><a href="#httpie%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90">httpie源码剖析</a>
<ul>
<li><a href="#example%E7%9A%84%E4%BD%BF%E7%94%A8">example的使用</a>
<ul>
<li><a href="#cargotoml">Cargo.toml</a></li>
</ul>
</li>
<li><a href="#step1%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90">Step1：指令解析</a>
* <a href="#%E8%A6%81%E7%82%B9%E8%AF%B4%E6%98%8E">要点说明</a>
* <a href="#clapparser">clap::Parser</a></li>
<li><a href="#step2%E6%B7%BB%E5%8A%A0%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E4%B8%8E%E9%94%AE%E5%80%BC%E5%AF%B9%E6%94%B9%E9%80%A0">Step2：添加参数验证与键值对改造</a>
<ul>
<li><a href="#%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81">参数验证</a></li>
<li><a href="#%E9%94%AE%E5%80%BC%E5%AF%B9%E6%94%B9%E9%80%A0">键值对改造</a></li>
</ul>
</li>
<li><a href="#step3%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%94%B9%E9%80%A0">Step3：异步请求改造</a></li>
<li><a href="#step4-%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E6%89%93%E5%8D%B0">Step4: 语法高亮打印</a></li>
<li><a href="#step5-%E6%B7%BB%E5%8A%A0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">Step5: 添加单元测试</a></li>
</ul>
</li>
<li><a href="#thumbor%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1">thumbor图片服务</a>
<ul>
<li><a href="#abiproto">abi.proto</a></li>
<li><a href="#buildrs">build.rs</a></li>
<li><a href="#%E5%85%B3%E4%BA%8Erust%E7%9A%84%E6%A8%A1%E5%9D%97">关于rust的模块</a></li>
<li><a href="#mod%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB">mod文件定义与实现分离</a></li>
<li><a href="#pb%E6%A8%A1%E5%9D%97">pb模块</a>
<ul>
<li><a href="#pbmodrs%E5%A3%B0%E6%98%8E%E6%A8%A1%E5%9D%97">pb/mod.rs声明模块</a></li>
<li><a href="#pbabirs%E9%87%8C%E9%9D%A2%E8%BF%98%E6%9C%89%E5%AD%90%E6%A8%A1%E5%9D%97">pb/abi.rs里面还有子模块</a></li>
<li><a href="#pbabirs%E5%8F%A6%E5%A4%96%E5%AE%9A%E4%B9%89%E4%BA%86specdata%E9%87%8C%E9%9D%A2%E7%9A%84%E5%90%84%E4%B8%AA%E5%85%83%E7%B4%A0%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%9D%97mod">pb/abi.rs另外定义了spec::Data里面的各个元素结构体/嵌套模块mod</a></li>
<li><a href="#pbabirs%E6%9C%89%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%BB%93%E6%9E%84%E4%BD%93">pb/abi.rs有个特殊结构体</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB">定义与实现分离</a>
<ul>
<li><a href="#imagespec">ImageSpec</a></li>
<li><a href="#filter%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0">Filter的定义与实现</a></li>
<li><a href="#samplefilter">SampleFilter</a></li>
<li><a href="#spec">Spec</a></li>
</ul>
</li>
<li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li>
</ul>
</li>
<li><a href="#engine%E6%A8%A1%E5%9D%97">engine模块</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Wed Sep 21 03:32:43 UTC 2022 -->
<!--te-->
<h2 id="httpie源码剖析"><a class="header" href="#httpie源码剖析">httpie源码剖析</a></h2>
<h3 id="example的使用"><a class="header" href="#example的使用">example的使用</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html?highlight=%5B%5Bexample%5D%5D#examples">Cargo Targets &gt;&gt; Examples - The Cargo Book</a></li>
</ul>
<h4 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h4>
<pre><code class="language-toml">[package]
name = &quot;httpie&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[[example]]
name = &quot;cli&quot;

[[example]]
name = &quot;cli_verify&quot;

[[example]]
name = &quot;cli_get&quot;

[dependencies]
anyhow = &quot;1&quot; # 错误处理
clap = { version = &quot;3&quot;, features = [&quot;derive&quot;] } # 命令行解析
colored = &quot;2&quot; # 命令终端多彩显示
jsonxf = &quot;1.1&quot; # JSON pretty print 格式化
mime = &quot;0.3&quot; # 处理 mime 类型
# reqwest 默认使用 openssl，有些 linux 用户如果没有安装好 openssl 会无法编译，这里我改成了使用 rustls
reqwest = { version = &quot;0.11&quot;, default-features = false, features = [&quot;json&quot;, &quot;rustls-tls&quot;] } # HTTP 客户端
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] } # 异步处理库
syntect = &quot;4&quot;
</code></pre>
<pre><code class="language-toml">[[example]]
name = &quot;cli&quot;

[[example]]
name = &quot;cli_verify&quot;

[[example]]
name = &quot;cli_get&quot;
</code></pre>
<div id="admonition-example使用" class="admonition tip">
<div class="admonition-title">
<p>example使用</p>
<p><a class="admonition-anchor-link" href="#admonition-example使用"></a></p>
</div>
<div>
<ol>
<li>示例代码放在根目录的examples文件夹，与src同级</li>
</ol>
<pre><code class="language-shell">tree -L 2                                                                                                       ─╯
.
├── Cargo.toml
├── examples
│   ├── cli.rs
│   ├── cli_get.rs
│   └── cli_verify.rs
└── src
    └── main.rs

2 directories, 5 files
</code></pre>
<ol start="2">
<li>执行指令</li>
</ol>
<pre><code class="language-shell">cargo run --example &lt;example-name-in-cargo&gt;
cargo run --example cli
cargo run --example cli_get
cargo run --example cli_verify
</code></pre>
<ol start="3">
<li>使用示例</li>
</ol>
<pre><code class="language-shell">cargo run --example cli                                                                                                                                                                                                                ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli`
httpie 1.0
Tyr Chen &lt;tyr@chen.com&gt;
A naive httpie implementation with Rust, can you imagine how easy it is?

USAGE:
    cli &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    get     feed get with an url and we will retrieve the response for you
    help    Print this message or the help of the given subcommand(s)
    post    feed post with an url and optional key=value pairs. We will post the data as JSON,
                and retrieve the response for you
</code></pre>
<ul>
<li>Run a binary or example of the local package</li>
<li>SUBCOMMANDS来自代码中的注释</li>
</ul>
</div>
</div>
<h3 id="step1指令解析"><a class="header" href="#step1指令解析">Step1：指令解析</a></h3>
<pre><pre class="playground"><code class="language-rust">use clap::Parser;

// 定义 httpie 的 CLI 的主入口，它包含若干个子命令
// 下面 /// 的注释是文档，clap 会将其作为 CLI 的帮助

/// A naive httpie implementation with Rust, can you imagine how easy it is?
#[derive(Parser, Debug)]
#[clap(version = &quot;1.0&quot;, author = &quot;Tyr Chen &lt;tyr@chen.com&gt;&quot;)]
struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

// 子命令分别对应不同的 HTTP 方法，目前只支持 get / post
#[derive(Parser, Debug)]
enum SubCommand {
    Get(Get),
    Post(Post),
    // 我们暂且不支持其它 HTTP 方法
}

// get 子命令

/// feed get with an url and we will retrieve the response for you
#[derive(Parser, Debug)]
struct Get {
    /// HTTP 请求的 URL
    url: String,
}

// post 子命令。需要输入一个 url，和若干个可选的 key=value，用于提供 json body

/// feed post with an url and optional key=value pairs. We will post the data
/// as JSON, and retrieve the response for you
#[derive(Parser, Debug)]
struct Post {
    /// HTTP 请求的 URL
    url: String,
    /// HTTP 请求的 body
    body: Vec&lt;String&gt;,
}

fn main() {
    let opts: Opts = Opts::parse();
    let opt_subcmd: SubCommand = opts.subcmd;
    // println!(&quot;{:?}&quot;, opts);
    println!(&quot;{:?}&quot;, opt_subcmd);
    // println!(&quot;{:?}&quot;, opts.subcmd);
    // 这里就可以看出，结构体的内在元素使用&quot;.&quot;来获取
    // println!(&quot;{:?}&quot;, opts::subcmd);
}
</code></pre></pre>
<h5 id="要点说明"><a class="header" href="#要点说明">要点说明</a></h5>
<h6 id="clapparser"><a class="header" href="#clapparser">clap::Parser</a></h6>
<div id="admonition-clapparser" class="admonition info">
<div class="admonition-title">
<p>clap::Parser</p>
<p><a class="admonition-anchor-link" href="#admonition-clapparser"></a></p>
</div>
<div>
<ul>
<li><a href="https://github.com/clap-rs/clap">clap-rs/clap: A full featured, fast Command Line Argument Parser for Rust</a></li>
<li><a href="https://docs.rs/clap/latest/clap/">clap - Rust</a></li>
<li><a href="https://docs.rs/clap/latest/clap/parser/index.html">clap::parser - Rust</a></li>
</ul>
</div>
</div>
<ol>
<li>clap的parser派生宏会自动实现parse方法来接收指令参数</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

// 子命令分别对应不同的 HTTP 方法，目前只支持 get / post
#[derive(Parser, Debug)]
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let opts: Opts = Opts::parse();
    let opt_subcmd: SubCommand = opts.subcmd;
    // println!(&quot;{:?}&quot;, opts);
</code></pre></pre>
<ol start="2">
<li>运行效果</li>
</ol>
<pre><code class="language-shell">cargo run --example cli get http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                                ─╯
   Compiling httpie v0.1.0 (/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/04_httpie)
    Finished dev [unoptimized + debuginfo] target(s) in 2.31s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli get 'http://jsonplaceholder.typicode.com/posts/2'`
Opts { subcmd: Get(Get { url: &quot;http://jsonplaceholder.typicode.com/posts/2&quot; }) }
</code></pre>
<pre><code class="language-shell">cargo run --example cli post http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                               ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli post 'http://jsonplaceholder.typicode.com/posts/2'`
Opts { subcmd: Post(Post { url: &quot;http://jsonplaceholder.typicode.com/posts/2&quot;, body: [] }) }
</code></pre>
<pre><code class="language-shell">cargo run --example cli delete http://jsonplaceholder.typicode.com/posts/2                                                                                                                                                             ─╯
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `/Users/kuanhsiaokuo/Developer/spare_projects/rust_lab/geektime-rust/geektime_rust_codes/target/debug/examples/cli delete 'http://jsonplaceholder.typicode.com/posts/2'`
error: Found argument 'delete' which wasn't expected, or isn't valid in this context

USAGE:
    cli &lt;SUBCOMMAND&gt;

For more information try --help

</code></pre>
<ul>
<li>opts的获取：自动以空格分隔，根据<subcommand>模式匹配，之后的参数依次赋值给<subcommand> struct里面的元素</li>
</ul>
<h3 id="step2添加参数验证与键值对改造"><a class="header" href="#step2添加参数验证与键值对改造">Step2：添加参数验证与键值对改造</a></h3>
<h4 id="参数验证"><a class="header" href="#参数验证">参数验证</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// feed get with an url and we will retrieve the response for you
#[derive(Parser, Debug)]
struct Get {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
}

// post 子命令。需要输入一个 url，和若干个可选的 key=value，用于提供 json body

/// feed post with an url and optional key=value pairs. We will post the data
/// as JSON, and retrieve the response for you
#[derive(Parser, Debug)]
struct Post {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
    /// HTTP 请求的 body
    #[clap(parse(try_from_str=parse_kv_pair))]
    body: Vec&lt;KvPair&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>clap 允许你为每个解析出来的值添加自定义的解析函数，我们这里定义了parse_url和parse_kv_pair检查一下。</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 因为我们为 KvPair 实现了 FromStr，这里可以直接 s.parse() 得到 KvPair
fn parse_kv_pair(s: &amp;str) -&gt; Result&lt;KvPair&gt; {
    s.parse()
}
fn parse_url(s: &amp;str) -&gt; Result&lt;String&gt; {
    // 这里我们仅仅检查一下 URL 是否合法
    let _url: Url = s.parse()?;

    Ok(s.into())
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>clap 允许你为每个解析出来的值添加自定义的解析函数，我们这里定义了个parse_url检查一下。</li>
</ol>
<h4 id="键值对改造"><a class="header" href="#键值对改造">键值对改造</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 命令行中的 key=value 可以通过 parse_kv_pair 解析成 KvPair 结构
#[allow(dead_code)]
#[derive(Debug)]
struct KvPair {
    k: String,
    v: String,
}

/// 当我们实现 FromStr trait 后，可以用 str.parse() 方法将字符串解析成 KvPair
impl FromStr for KvPair {
    type Err = anyhow::Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        // 使用 = 进行 split，这会得到一个迭代器
        let mut split = s.split('=');
        let err = || anyhow!(format!(&quot;Failed to parse {}&quot;, s));
        Ok(Self {
            // 从迭代器中取第一个结果作为 key，迭代器返回 Some(T)/None
            // 我们将其转换成 Ok(T)/Err(E)，然后用 ? 处理错误
            k: (split.next().ok_or_else(err)?).to_string(),
            // 从迭代器中取第二个结果作为 value
            v: (split.next().ok_or_else(err)?).to_string(),
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="step3异步请求改造"><a class="header" href="#step3异步请求改造">Step3：异步请求改造</a></h3>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let opts: Opts = Opts::parse();
    // 生成一个
    let client = Client::new();
    match opts.subcmd {
        SubCommand::Get(ref args) =&gt; get(client, args).await?,
        SubCommand::Post(ref args) =&gt; post(client, args).await?,
    };

    Ok(())
}

async fn get(client: Client, args: &amp;Get) -&gt; Result&lt;()&gt; {
    let resp = client.get(&amp;args.url).send().await?;
    println!(&quot;{:?}&quot;, resp.text().await?);
    Ok(())
}

async fn post(client: Client, args: &amp;Post) -&gt; Result&lt;()&gt; {
    let mut body = HashMap::new();
    for pair in args.body.iter() {
        body.insert(&amp;pair.k, &amp;pair.v);
    }
    let resp = client.post(&amp;args.url).json(&amp;body).send().await?;
    println!(&quot;{:?}&quot;, resp.text().await?);
    Ok(())
}
</code></pre></pre>
<h3 id="step4-语法高亮打印"><a class="header" href="#step4-语法高亮打印">Step4: 语法高亮打印</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 打印服务器版本号 + 状态码
fn print_status(resp: &amp;Response) {
    let status = format!(&quot;{:?} {}&quot;, resp.version(), resp.status()).blue();
    println!(&quot;{}\n&quot;, status);
}

// 打印服务器返回的 HTTP header
fn print_headers(resp: &amp;Response) {
    for (name, value) in resp.headers() {
        println!(&quot;{}: {:?}&quot;, name.to_string().green(), value);
    }

    println!();
}

/// 打印服务器返回的 HTTP body
fn print_body(m: Option&lt;Mime&gt;, body: &amp;str) {
    match m {
        // 对于 &quot;application/json&quot; 我们 pretty print
        Some(v) if v == mime::APPLICATION_JSON =&gt; print_syntect(body, &quot;json&quot;),
        Some(v) if v == mime::TEXT_HTML =&gt; print_syntect(body, &quot;html&quot;),

        // 其它 mime type，我们就直接输出
        _ =&gt; println!(&quot;{}&quot;, body),
    }
}

/// 打印整个响应
async fn print_resp(resp: Response) -&gt; Result&lt;()&gt; {
    print_status(&amp;resp);
    print_headers(&amp;resp);
    let mime = get_content_type(&amp;resp);
    let body = resp.text().await?;
    print_body(mime, &amp;body);
    Ok(())
}

/// 将服务器返回的 content-type 解析成 Mime 类型
fn get_content_type(resp: &amp;Response) -&gt; Option&lt;Mime&gt; {
    resp.headers()
        .get(header::CONTENT_TYPE)
        .map(|v| v.to_str().unwrap().parse().unwrap())
}

fn print_syntect(s: &amp;str, ext: &amp;str) {
    // Load these once at the start of your program
    let ps = SyntaxSet::load_defaults_newlines();
    let ts = ThemeSet::load_defaults();
    let syntax = ps.find_syntax_by_extension(ext).unwrap();
    let mut h = HighlightLines::new(syntax, &amp;ts.themes[&quot;base16-ocean.dark&quot;]);
    for line in LinesWithEndings::from(s) {
        let ranges: Vec&lt;(Style, &amp;str)&gt; = h.highlight(line, &amp;ps);
        let escaped = as_24_bit_terminal_escaped(&amp;ranges[..], true);
        print!(&quot;{}&quot;, escaped);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">/// 程序的入口函数，因为在 http 请求时我们使用了异步处理，所以这里引入 tokio
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let opts: Opts = Opts::parse();
    let mut headers = header::HeaderMap::new();
    // 为我们的 http 客户端添加一些缺省的 HTTP 头
    headers.insert(&quot;X-POWERED-BY&quot;, &quot;Rust&quot;.parse()?);
    headers.insert(header::USER_AGENT, &quot;Rust Httpie&quot;.parse()?);
    let client = Client::builder()
        .default_headers(headers)
        .build()?;
    let result = match opts.subcmd {
        SubCommand::Get(ref args) =&gt; get(client, args).await?,
        SubCommand::Post(ref args) =&gt; post(client, args).await?,
    };

    Ok(result)
}
</code></pre></pre>
<h3 id="step5-添加单元测试"><a class="header" href="#step5-添加单元测试">Step5: 添加单元测试</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 仅在 cargo test 时才编译
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_url_works() {
        assert!(parse_url(&quot;abc&quot;).is_err());
        assert!(parse_url(&quot;http://abc.xyz&quot;).is_ok());
        assert!(parse_url(&quot;https://httpbin.org/post&quot;).is_ok());
    }

    #[test]
    fn parse_kv_pair_works() {
        assert!(parse_kv_pair(&quot;a&quot;).is_err());
        assert_eq!(
            parse_kv_pair(&quot;a=1&quot;).unwrap(),
            KvPair {
                k: &quot;a&quot;.into(),
                v: &quot;1&quot;.into(),
            }
        );

        assert_eq!(
            parse_kv_pair(&quot;b=&quot;).unwrap(),
            KvPair {
                k: &quot;b&quot;.into(),
                v: &quot;&quot;.into(),
            }
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="thumbor图片服务"><a class="header" href="#thumbor图片服务">thumbor图片服务</a></h2>
<h3 id="abiproto"><a class="header" href="#abiproto">abi.proto</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>syntax = &quot;proto3&quot;;

package abi;

// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
message ImageSpec { repeated Spec specs = 1; }

// 处理图片改变大小
message Resize {
  uint32 width = 1;
  uint32 height = 2;

  enum ResizeType {
    NORMAL = 0;
    SEAM_CARVE = 1;
  }

  ResizeType rtype = 3;

  enum SampleFilter {
    UNDEFINED = 0;
    NEAREST = 1;
    TRIANGLE = 2;
    CATMULL_ROM = 3;
    GAUSSIAN = 4;
    LANCZOS3 = 5;
  }

  SampleFilter filter = 4;
}

// 处理图片截取
message Crop {
  uint32 x1 = 1;
  uint32 y1 = 2;
  uint32 x2 = 3;
  uint32 y2 = 4;
}

// 处理水平翻转
message Fliph {}
// 处理垂直翻转
message Flipv {}
// 处理对比度
message Contrast { float contrast = 1; }
// 处理滤镜
message Filter {
  enum Filter {
    UNSPECIFIED = 0;
    OCEANIC = 1;
    ISLANDS = 2;
    MARINE = 3;
    // more: https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html
  }
  Filter filter = 1;
}

// 处理水印
message Watermark {
  uint32 x = 1;
  uint32 y = 2;
}

// 一个 spec 可以包含上述的处理方式之一
message Spec {
  oneof data {
    Resize resize = 1;
    Crop crop = 2;
    Flipv flipv = 3;
    Fliph fliph = 4;
    Contrast contrast = 5;
    Filter filter = 6;
    Watermark watermark = 7;
  }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="buildrs"><a class="header" href="#buildrs">build.rs</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::process::Command;

fn main() {
    // 在编译时可选择检查环境变量。
    let build_enabled = option_env!(&quot;BUILD_PROTO&quot;)
        .map(|v| v == &quot;1&quot;)
        .unwrap_or(false);
    // 如果没有找到环境变量的对应值，就直接return，不再进行后续编译
    if !build_enabled {
        println!(&quot;=== Skipped compiling protos ===&quot;);
        return;
    }
    // 使用 prost_build 把 abi.proto 编译到 src/pb 目录下
    prost_build::Config::new()
        .out_dir(&quot;src/pb&quot;)
        .compile_protos(&amp;[&quot;abi.proto&quot;], &amp;[&quot;.&quot;])
        .unwrap();
    Command::new(&quot;cargo&quot;)
        .args(&amp;[&quot;fmt&quot;, &quot;--&quot;, &quot;src/*.rs&quot;])
        .status()
        .expect(&quot;cargo fmt failed&quot;);
}
</code></pre></pre>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.option_env.html">option_env in std - Rust</a></li>
</ul>
<blockquote>
<p>在编译时可选择检查环境变量。</p>
</blockquote>
<h3 id="关于rust的模块"><a class="header" href="#关于rust的模块">关于rust的模块</a></h3>
<blockquote>
<p>可以参考这篇：<a href="https://zhuanlan.zhihu.com/p/443926839">Rust 模块系统理解 - 知乎</a></p>
</blockquote>
<ol>
<li>mod(mod.rs或mod关键字)将代码分为多个逻辑模块，并管理这些模块的可见性（public / private）。</li>
<li>模块是项（item）的集合，项可以是：函数，结构体，trait，impl块，甚至其它模块。</li>
<li>一个目录下的所有代码，可以通过 mod.rs 声明</li>
<li>Rust模块有三种形式:
<ul>
<li>mod.rs: 一个目录下的所有代码，可以通过 mod.rs 声明</li>
<li>文件/目录即模块：编译器的机制决定，除了mod.rs外，每一个文件和目录都是一个模块。不允许只分拆文件，但是不声明mod，我们通常使用pub use，在父空间直接调用子空间的函数。</li>
<li>mod关键字: 在文件内部分拆模块</li>
</ul>
</li>
<li>Rust编译器只接受一个源文件，输出一个crate</li>
<li>每一个crate都有一个匿名的根命名空间，命名空间可以无限嵌套</li>
<li>“mod mod-name { … }“ 将大括号中的代码置于命名空间mod-name之下</li>
<li>“use mod-name1::mod-name2;“ 可以打开命名空间，减少无休止的::操作符</li>
<li>“mod mod-name;“ 可以指导编译器将多个文件组装成一个文件</li>
<li>“pub use mod-nam1::mod-name2::item-name;“
语句可以将mod-name2下的item-name提升到这条语句所在的空间，item-name通常是函数或者结构体。Rust社区通常用这个方法来缩短库API的命名空间深度
编译器规定use语句一定要在mod语句之前</li>
</ol>
<h3 id="mod文件定义与实现分离"><a class="header" href="#mod文件定义与实现分离">mod文件定义与实现分离</a></h3>
<p>在rust中，一般会在模块的mod.rs文件中对供外部使用的项进行实现, 项可以是：函数，结构体，trait，impl块，甚至其它模块.
这样有个好处，高内聚，可以在代码增长时，将变动局限在服务提供者内部，对外提供的api不变，不会造成破坏性更新。</p>
<h3 id="pb模块"><a class="header" href="#pb模块">pb模块</a></h3>
<h4 id="pbmodrs声明模块"><a class="header" href="#pbmodrs声明模块">pb/mod.rs声明模块</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod abi; // 声明 abi.rs
pub use abi::*;
<span class="boring">}
</span></code></pre></pre>
<h4 id="pbabirs里面还有子模块"><a class="header" href="#pbabirs里面还有子模块">pb/abi.rs里面还有子模块</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Nested message and enum types in `Spec`.
pub mod spec {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = &quot;1&quot;)]
        Resize(super::Resize),
        #[prost(message, tag = &quot;2&quot;)]
        Crop(super::Crop),
        #[prost(message, tag = &quot;3&quot;)]
        Flipv(super::Flipv),
        #[prost(message, tag = &quot;4&quot;)]
        Fliph(super::Fliph),
        #[prost(message, tag = &quot;5&quot;)]
        Contrast(super::Contrast),
        #[prost(message, tag = &quot;6&quot;)]
        Filter(super::Filter),
        #[prost(message, tag = &quot;7&quot;)]
        Watermark(super::Watermark),
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="pbabirs另外定义了specdata里面的各个元素结构体嵌套模块mod"><a class="header" href="#pbabirs另外定义了specdata里面的各个元素结构体嵌套模块mod">pb/abi.rs另外定义了spec::Data里面的各个元素结构体/嵌套模块mod</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSpec {
    #[prost(message, repeated, tag = &quot;1&quot;)]
    pub specs: ::prost::alloc::vec::Vec&lt;Spec&gt;,
}
/// 处理图片改变大小
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resize {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub width: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub height: u32,
    #[prost(enumeration = &quot;resize::ResizeType&quot;, tag = &quot;3&quot;)]
    pub rtype: i32,
    #[prost(enumeration = &quot;resize::SampleFilter&quot;, tag = &quot;4&quot;)]
    pub filter: i32,
}
/// Nested message and enum types in `Resize`.
pub mod resize {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResizeType {
        Normal = 0,
        SeamCarve = 1,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SampleFilter {
        Undefined = 0,
        Nearest = 1,
        Triangle = 2,
        CatmullRom = 3,
        Gaussian = 4,
        Lanczos3 = 5,
    }
}
/// 处理图片截取
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Crop {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub x1: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub y1: u32,
    #[prost(uint32, tag = &quot;3&quot;)]
    pub x2: u32,
    #[prost(uint32, tag = &quot;4&quot;)]
    pub y2: u32,
}
/// 处理水平翻转
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fliph {}
/// 处理垂直翻转
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Flipv {}
/// 处理对比度
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contrast {
    #[prost(float, tag = &quot;1&quot;)]
    pub contrast: f32,
}
/// 处理滤镜
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filter {
    #[prost(enumeration = &quot;filter::Filter&quot;, tag = &quot;1&quot;)]
    pub filter: i32,
}
/// Nested message and enum types in `Filter`.
pub mod filter {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Filter {
        Unspecified = 0,
        Oceanic = 1,
        Islands = 2,
        /// more: &lt;https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html&gt;
        Marine = 3,
    }
}
/// 处理水印
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Watermark {
    #[prost(uint32, tag = &quot;1&quot;)]
    pub x: u32,
    #[prost(uint32, tag = &quot;2&quot;)]
    pub y: u32,
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="pbabirs有个特殊结构体"><a class="header" href="#pbabirs有个特殊结构体">pb/abi.rs有个特殊结构体</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 一个 spec 可以包含上述的处理方式之一
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    #[prost(oneof = &quot;spec::Data&quot;, tags = &quot;1, 2, 3, 4, 5, 6, 7&quot;)]
    pub data: ::core::option::Option&lt;spec::Data&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="定义与实现分离"><a class="header" href="#定义与实现分离">定义与实现分离</a></h4>
<h5 id="imagespec"><a class="header" href="#imagespec">ImageSpec</a></h5>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSpec {
    #[prost(message, repeated, tag = &quot;1&quot;)]
    pub specs: ::prost::alloc::vec::Vec&lt;Spec&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ImageSpec {
    pub fn new(specs: Vec&lt;Spec&gt;) -&gt; Self {
        Self { specs }
    }
}

// 让 ImageSpec 可以生成一个字符串
impl From&lt;&amp;ImageSpec&gt; for String {
    fn from(image_spec: &amp;ImageSpec) -&gt; Self {
        let data = image_spec.encode_to_vec();
        encode_config(data, URL_SAFE_NO_PAD)
    }
}

// 让 ImageSpec 可以通过一个字符串创建。比如 s.parse().unwrap()
impl TryFrom&lt;&amp;str&gt; for ImageSpec {
    type Error = anyhow::Error;

    fn try_from(value: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {
        let data = decode_config(value, URL_SAFE_NO_PAD)?;
        Ok(ImageSpec::decode(&amp;data[..])?)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="filter的定义与实现"><a class="header" href="#filter的定义与实现">Filter的定义与实现</a></h5>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Nested message and enum types in `Filter`.
pub mod filter {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Filter {
        Unspecified = 0,
        Oceanic = 1,
        Islands = 2,
        /// more: &lt;https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html&gt;
        Marine = 3,
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 辅助函数，photon_rs 相应的方法里需要字符串
impl filter::Filter {
    pub fn to_str(self) -&gt; Option&lt;&amp;'static str&gt; {
        match self {
            filter::Filter::Unspecified =&gt; None,
            filter::Filter::Oceanic =&gt; Some(&quot;oceanic&quot;),
            filter::Filter::Islands =&gt; Some(&quot;islands&quot;),
            filter::Filter::Marine =&gt; Some(&quot;marine&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="samplefilter"><a class="header" href="#samplefilter">SampleFilter</a></h5>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Nested message and enum types in `Resize`.
pub mod resize {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResizeType {
        Normal = 0,
        SeamCarve = 1,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SampleFilter {
        Undefined = 0,
        Nearest = 1,
        Triangle = 2,
        CatmullRom = 3,
        Gaussian = 4,
        Lanczos3 = 5,
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;resize::SampleFilter&gt; for SamplingFilter {
    fn from(v: resize::SampleFilter) -&gt; Self {
        match v {
            resize::SampleFilter::Undefined =&gt; SamplingFilter::Nearest,
            resize::SampleFilter::Nearest =&gt; SamplingFilter::Nearest,
            resize::SampleFilter::Triangle =&gt; SamplingFilter::Triangle,
            resize::SampleFilter::CatmullRom =&gt; SamplingFilter::CatmullRom,
            resize::SampleFilter::Gaussian =&gt; SamplingFilter::Gaussian,
            resize::SampleFilter::Lanczos3 =&gt; SamplingFilter::Lanczos3,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="spec"><a class="header" href="#spec">Spec</a></h5>
<ul>
<li>pb/abi.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 一个 spec 可以包含上述的处理方式之一
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    #[prost(oneof = &quot;spec::Data&quot;, tags = &quot;1, 2, 3, 4, 5, 6, 7&quot;)]
    pub data: ::core::option::Option&lt;spec::Data&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>pb/mod.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 提供一些辅助函数，让创建一个 spec 的过程简单一些
impl Spec {
    pub fn new_resize_seam_carve(width: u32, height: u32) -&gt; Self {
        Self {
            data: Some(spec::Data::Resize(Resize {
                width,
                height,
                rtype: resize::ResizeType::SeamCarve as i32,
                filter: resize::SampleFilter::Undefined as i32,
            })),
        }
    }

    pub fn new_resize(width: u32, height: u32, filter: resize::SampleFilter) -&gt; Self {
        Self {
            data: Some(spec::Data::Resize(Resize {
                width,
                height,
                rtype: resize::ResizeType::Normal as i32,
                filter: filter as i32,
            })),
        }
    }

    pub fn new_filter(filter: filter::Filter) -&gt; Self {
        Self {
            data: Some(spec::Data::Filter(Filter {
                filter: filter as i32,
            })),
        }
    }

    pub fn new_watermark(x: u32, y: u32) -&gt; Self {
        Self {
            data: Some(spec::Data::Watermark(Watermark { x, y })),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::borrow::Borrow;

    #[test]
    fn encoded_spec_could_be_decoded() {
        let spec1 = Spec::new_resize(600, 600, resize::SampleFilter::CatmullRom);
        let spec2 = Spec::new_filter(filter::Filter::Marine);
        let image_spec = ImageSpec::new(vec![spec1, spec2]);
        let s: String = image_spec.borrow().into();
        assert_eq!(image_spec, s.as_str().try_into().unwrap());
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="engine模块"><a class="header" href="#engine模块">engine模块</a></h3>

            </main>

            <!--            <script src="https://utteranc.es/client.js"-->
            <!--                    repo="RustMagazine/rust_magazine_2022"-->
            <!--                    issue-term="title"-->
            <!--                    theme="github-light"-->
            <!--                    crossorigin="anonymous"-->
            <!--                    async></script>-->

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                    <a rel="prev" href="anatomy_logic.html" class="mobile-nav-chapters previous"
                       title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="intro_gdb_lldb.html" class="mobile-nav-chapters next"
                       title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="anatomy_logic.html" class="nav-chapters previous" title="Previous chapter"
               aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="intro_gdb_lldb.html" class="nav-chapters next" title="Next chapter"
               aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
    </nav>

</div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/mermaid/mermaid.min.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid-init.js"></script>
    <script type="text/javascript" src="assets/smart-anchor.js"></script>
    <script type="text/javascript" src="assets/pagetoc/sidebar.js"></script>

</body>
</html>
