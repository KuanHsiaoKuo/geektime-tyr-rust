<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>实现并验证协议层 - Anatomy In First Rust Programming Class 🦀</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust编程第一课的代码为例进行基础代码分析">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="md-favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/pagetoc/pagetoc_style.css">
        <link rel="stylesheet" href="assets/css/mdbook-admonish.css">

        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="anatomy_logic.html"><strong aria-hidden="true">1.</strong> 源码阅读逻辑</a></li><li class="chapter-item expanded "><a href="intro_gdb_lldb.html"><strong aria-hidden="true">2.</strong> gdb/lldb调试或查看内存结构</a></li><li class="chapter-item expanded "><a href="get_hands_dirty.html"><strong aria-hidden="true">3.</strong> get hands dirty</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="httpie.html"><strong aria-hidden="true">3.1.</strong> httpie</a></li><li class="chapter-item expanded "><a href="rgrep.html"><strong aria-hidden="true">3.2.</strong> rgrep</a></li><li class="chapter-item expanded "><a href="thumbor.html"><strong aria-hidden="true">3.3.</strong> thumbor</a></li><li class="chapter-item expanded "><a href="queryer.html"><strong aria-hidden="true">3.4.</strong> queryer</a></li></ol></li><li class="chapter-item expanded "><a href="rust_cores.html"><strong aria-hidden="true">4.</strong> Rust核心深入</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_stack_heap_ownership_lifetime_memory.html"><strong aria-hidden="true">4.1.</strong> I. 从栈堆、所有权、生命周期开始内存管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="1_1_stack_heap.html"><strong aria-hidden="true">4.1.1.</strong> 从堆栈开始</a></li><li class="chapter-item "><a href="1_2_programming_basic_concepts.html"><strong aria-hidden="true">4.1.2.</strong> 四大编程基础概念</a></li><li class="chapter-item "><a href="1_3_ownership.html"><strong aria-hidden="true">4.1.3.</strong> 所有权</a></li><li class="chapter-item "><a href="1_4_lifetime.html"><strong aria-hidden="true">4.1.4.</strong> 生命周期</a></li><li class="chapter-item "><a href="1_5_go_through.html"><strong aria-hidden="true">4.1.5.</strong> 从创建到消亡</a></li></ol></li><li class="chapter-item expanded "><a href="2_type_system.html"><strong aria-hidden="true">4.2.</strong> II. 类型系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2_1_type_details.html"><strong aria-hidden="true">4.2.1.</strong> 类型系统特点</a></li><li class="chapter-item "><a href="2_2_generic.html"><strong aria-hidden="true">4.2.2.</strong> 泛型</a></li><li class="chapter-item "><a href="2_3_trait.html"><strong aria-hidden="true">4.2.3.</strong> trait</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2_3_0_trait_overview.html"><strong aria-hidden="true">4.2.3.1.</strong> trait概览</a></li><li class="chapter-item "><a href="2_3_1_trait_impl.html"><strong aria-hidden="true">4.2.3.2.</strong> Trait Impl</a></li><li class="chapter-item "><a href="2_3_2_trait_object.html"><strong aria-hidden="true">4.2.3.3.</strong> Trait Object</a></li><li class="chapter-item "><a href="2_3_3_trait_frequently.html"><strong aria-hidden="true">4.2.3.4.</strong> 常用trait</a></li><li class="chapter-item "><a href="2_3_4_trait_design.html"><strong aria-hidden="true">4.2.3.5.</strong> Trait设计</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="3_data_structure.html"><strong aria-hidden="true">4.3.</strong> III. 数据结构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="3_1_smart_pointer.html"><strong aria-hidden="true">4.3.1.</strong> 智能指针</a></li><li class="chapter-item "><a href="3_2_containers.html"><strong aria-hidden="true">4.3.2.</strong> 集合容器</a></li><li class="chapter-item "><a href="3_3_error_handling.html"><strong aria-hidden="true">4.3.3.</strong> 错误处理</a></li><li class="chapter-item "><a href="3_4_closure.html"><strong aria-hidden="true">4.3.4.</strong> 闭包</a></li></ol></li><li class="chapter-item expanded "><a href="4_macros.html"><strong aria-hidden="true">4.4.</strong> IV. 宏编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="4_1_macros_classify.html"><strong aria-hidden="true">4.4.1.</strong> 宏分类</a></li><li class="chapter-item "><a href="4_2_declarative_macros.html"><strong aria-hidden="true">4.4.2.</strong> 声明宏</a></li><li class="chapter-item "><a href="4_3_procedural_macros.html"><strong aria-hidden="true">4.4.3.</strong> 过程宏</a></li></ol></li><li class="chapter-item expanded "><a href="5_concurrency_async.html"><strong aria-hidden="true">4.5.</strong> V. 并发与异步</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="5_1_concurrency_primitives.html"><strong aria-hidden="true">4.5.1.</strong> 并发原语(Concurrency Primitives)</a></li><li class="chapter-item "><a href="5_2_future_async_await.html"><strong aria-hidden="true">4.5.2.</strong> 异步：Future/Async/Await</a></li><li class="chapter-item "><a href="5_3_deepin_async_await.html"><strong aria-hidden="true">4.5.3.</strong> 深入async/await</a></li></ol></li><li class="chapter-item expanded "><a href="6_unsafe_ffi.html"><strong aria-hidden="true">4.6.</strong> VI. 混合编程</a></li></ol></li><li class="chapter-item expanded "><a href="kv_server_design.html"><strong aria-hidden="true">5.</strong> kv server设计与实现</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kv1_basic.html"><strong aria-hidden="true">5.1.</strong> 基本流程</a></li><li class="chapter-item expanded "><a href="kv2_protocols.html" class="active"><strong aria-hidden="true">5.2.</strong> 实现并验证协议层</a></li><li class="chapter-item expanded "><a href="kv3_advanced_traits.html"><strong aria-hidden="true">5.3.</strong> 高级trait改造</a></li><li class="chapter-item expanded "><a href="kv4_network.html"><strong aria-hidden="true">5.4.</strong> 网络处理</a></li><li class="chapter-item expanded "><a href="kv5_network_security.html"><strong aria-hidden="true">5.5.</strong> 网络安全</a></li><li class="chapter-item expanded "><a href="kv6_async_refactor.html"><strong aria-hidden="true">5.6.</strong> 异步改造</a></li><li class="chapter-item expanded "><a href="kv7_big_refactor.html"><strong aria-hidden="true">5.7.</strong> 重大重构</a></li><li class="chapter-item expanded "><a href="kv8_config_ci_cd.html"><strong aria-hidden="true">5.8.</strong> 配置、测试、监控、CI/CD</a></li></ol></li><li class="chapter-item expanded "><a href="custom_axum_async_web_framework.html"><strong aria-hidden="true">6.</strong> 构建自己的类axum异步Web框架</a></li><li class="chapter-item expanded affix "><a href="checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Anatomy In First Rust Programming Class 🦀</h1>
            <h4 class="menu-bar"><a href="https://kuanhsiaokuo.github.io/think-tool-kit/">保持批判，有所取舍，知行合一, 方见真我</a> -- 练武不练功
                到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/geektime-tyr-rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="二实现并验证协议层"><a class="header" href="#二实现并验证协议层">二、实现并验证协议层</a></h1>
<!--ts-->
<ul>
<li><a href="#%E4%BA%8C%E5%AE%9E%E7%8E%B0%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%8D%8F%E8%AE%AE%E5%B1%82">二、实现并验证协议层</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96">创建项目，添加依赖</a></li>
<li><a href="#protobuf%E5%A4%84%E7%90%86">protobuf处理</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%B9%B6%E9%AA%8C%E8%AF%81-storage-trait">实现并验证 Storage trait</a>
<ul>
<li><a href="#%E6%9E%84%E5%BB%BAmemtable">构建MemTable</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95">测试</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%B9%B6%E9%AA%8C%E8%AF%81-commandservice-trait">实现并验证 CommandService trait</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%86%99">为什么要这么写？</a></li>
<li><a href="#%E5%9C%A8-srcpbmodrs-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E5%A4%96%E5%9B%B4%E9%80%BB%E8%BE%91">在 src/pb/mod.rs 中添加相关的外围逻辑</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E5%90%8E%E7%9A%84%E6%8B%BC%E5%9B%BEservice-%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0">最后的拼图：Service 结构的实现</a>
<ul>
<li><a href="#%E5%9B%B4%E7%BB%95%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95">围绕接口测试</a></li>
<li><a href="#%E7%BB%A7%E7%BB%AD%E5%86%99%E4%BB%A3%E7%A0%81">继续写代码</a></li>
</ul>
</li>
<li><a href="#%E6%96%B0%E7%9A%84-server">新的 server</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C">运行</a></li>
<li><a href="#%E5%88%9D%E6%AD%A5%E6%84%9F%E5%8F%97rust%E6%92%B0%E5%86%99%E4%BB%A3%E7%A0%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">初步感受Rust撰写代码最佳实践</a></li>
<li><a href="#%E4%B8%BA%E5%89%A9%E4%B8%8B6%E4%B8%AA%E5%91%BD%E4%BB%A4%E6%9E%84%E5%BB%BA%E6%B5%8B%E8%AF%95%E5%B9%B6%E5%AE%9E%E7%8E%B0">为剩下6个命令构建测试并实现</a></li>
<li><a href="#%E8%80%83%E8%99%91%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91">考虑用线程池处理并发</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Oct 18 14:01:46 UTC 2022 -->
<!--te-->
<p>还是按照上一讲定义接口的顺序来一个一个测试：首先我们来构建协议层。</p>
<h2 id="创建项目添加依赖"><a class="header" href="#创建项目添加依赖">创建项目，添加依赖</a></h2>
<details id="admonition-笔记" class="admonition note">
<summary class="admonition-title">
<p>笔记：</p>
<p><a class="admonition-anchor-link" href="#admonition-笔记"></a></p>
</summary>
<div>
<ol>
<li>先创建一个项目：cargo new kv –lib</li>
<li>进入到项目目录，在 Cargo.toml 中添加依赖：</li>
</ol>
<pre><code class="language-toml">[package]
name = &quot;kv&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
bytes = &quot;1&quot; # 高效处理网络 buffer 的库
prost = &quot;0.8&quot; # 处理 protobuf 的代码
tracing = &quot;0.1&quot; # 日志处理

[dev-dependencies]
anyhow = &quot;1&quot; # 错误处理
async-prost = &quot;0.2.1&quot; # 支持把 protobuf 封装成 TCP frame
futures = &quot;0.3&quot; # 提供 Stream trait
tokio = { version = &quot;1&quot;, features = [&quot;rt&quot;, &quot;rt-multi-thread&quot;, &quot;io-util&quot;, &quot;macros&quot;, &quot;net&quot; ] } # 异步网络库
tracing-subscriber = &quot;0.2&quot; # 日志处理

[build-dependencies]
prost-build = &quot;0.8&quot; # 编译 protobuf
</code></pre>
</div>
</details>
<h2 id="protobuf处理"><a class="header" href="#protobuf处理">protobuf处理</a></h2>
<p>然后在项目根目录下创建 abi.proto，把上文中 protobuf 的代码放进去。</p>
<details id="admonition-在根目录下再创建-buildrs" class="admonition note">
<summary class="admonition-title">
<p>在根目录下，再创建 build.rs</p>
<p><a class="admonition-anchor-link" href="#admonition-在根目录下再创建-buildrs"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
fn main() {
    let mut config = prost_build::Config::new();
    config.bytes(&amp;[&quot;.&quot;]);
    config.type_attribute(&quot;.&quot;, &quot;#[derive(PartialOrd)]&quot;);
    config
        .out_dir(&quot;src/pb&quot;)
        .compile_protos(&amp;[&quot;abi.proto&quot;], &amp;[&quot;.&quot;])
        .unwrap();
}
</code></pre></pre>
<ol>
<li>这里我们为编译出来的代码额外添加了一些属性。比如为 protobuf 的 bytes 类型生成 Bytes 而非缺省的 Vec<u8>，为所有类型加入 PartialOrd 派生宏。</li>
<li>关于 prost-build 的扩展，你可以看<a href="https://docs.rs/prost-build/0.8.0/prost_build/struct.Config.html">文档</a>。</li>
</ol>
</div>
</details>
<blockquote>
<p>记得创建 src/pb 目录，否则编不过。</p>
</blockquote>
<p>现在，在项目根目录下做 cargo build 会生成 src/pb/abi.rs 文件，里面包含所有 protobuf 定义的消息的 Rust 数据结构。</p>
<details id="admonition-我们创建-srcpbmodrs引入-abirs并做一些基本的类型转换" class="admonition note">
<summary class="admonition-title">
<p>我们创建 src/pb/mod.rs，引入 abi.rs，并做一些基本的类型转换</p>
<p><a class="admonition-anchor-link" href="#admonition-我们创建-srcpbmodrs引入-abirs并做一些基本的类型转换"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
pub mod abi;

use abi::{command_request::RequestData, *};

impl CommandRequest {
    /// 创建 HSET 命令
    pub fn new_hset(table: impl Into&lt;String&gt;, key: impl Into&lt;String&gt;, value: Value) -&gt; Self {
        Self {
            request_data: Some(RequestData::Hset(Hset {
                table: table.into(),
                pair: Some(Kvpair::new(key, value)),
            })),
        }
    }
}

impl Kvpair {
    /// 创建一个新的 kv pair
    pub fn new(key: impl Into&lt;String&gt;, value: Value) -&gt; Self {
        Self {
            key: key.into(),
            value: Some(value),
        }
    }
}

/// 从 String 转换成 Value
impl From&lt;String&gt; for Value {
    fn from(s: String) -&gt; Self {
        Self {
            value: Some(value::Value::String(s)),
        }
    }
}

/// 从 &amp;str 转换成 Value
impl From&lt;&amp;str&gt; for Value {
    fn from(s: &amp;str) -&gt; Self {
        Self {
            value: Some(value::Value::String(s.into())),
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-最后在-srclibrs-中引入-pb-模块" class="admonition note">
<summary class="admonition-title">
<p>最后，在 src/lib.rs 中，引入 pb 模块 </p>
<p><a class="admonition-anchor-link" href="#admonition-最后在-srclibrs-中引入-pb-模块"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">mod pb;

pub use pb::abi::*;
</code></pre></pre>
</div>
</details>
<p>这样，我们就有了能把 KV server 最基本的 protobuf 接口运转起来的代码。</p>
<details id="admonition-使用示例examples" class="admonition example">
<summary class="admonition-title">
<p>使用示例：examples</p>
<p><a class="admonition-anchor-link" href="#admonition-使用示例examples"></a></p>
</summary>
<div>
<p>在根目录下创建 examples，这样可以写一些代码测试客户端和服务器之间的协议。</p>
<ol>
<li>我们可以先创建一个 examples/client.rs 文件，写入如下代码：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use async_prost::AsyncProstStream;
use futures::prelude::*;
use kv::{CommandRequest, CommandResponse};
use tokio::net::TcpStream;
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();

    let addr = &quot;127.0.0.1:9527&quot;;
    // 连接服务器
    let stream = TcpStream::connect(addr).await?;

    // 使用 AsyncProstStream 来处理 TCP Frame
    let mut client =
        AsyncProstStream::&lt;_, CommandResponse, CommandRequest, _&gt;::from(stream).for_async();

    // 生成一个 HSET 命令
    let cmd = CommandRequest::new_hset(&quot;table1&quot;, &quot;hello&quot;, &quot;world&quot;.into());

    // 发送 HSET 命令
    client.send(cmd).await?;
    if let Some(Ok(data)) = client.next().await {
        info!(&quot;Got response {:?}&quot;, data);
    }

    Ok(())
}
</code></pre></pre>
<p>这段代码连接服务器的 9527 端口，发送一个 HSET 命令出去，然后等待服务器的响应。</p>
<ol start="2">
<li>同样的，我们创建一个 examples/dummy_server.rs 文件，写入代码：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use async_prost::AsyncProstStream;
use futures::prelude::*;
use kv::{CommandRequest, CommandResponse};
use tokio::net::TcpListener;
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();
    let addr = &quot;127.0.0.1:9527&quot;;
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Start listening on {}&quot;, addr);
    loop {
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Client {:?} connected&quot;, addr);
        tokio::spawn(async move {
            let mut stream =
                AsyncProstStream::&lt;_, CommandRequest, CommandResponse, _&gt;::from(stream).for_async();
            while let Some(Ok(msg)) = stream.next().await {
                info!(&quot;Got a new command: {:?}&quot;, msg);
                // 创建一个 404 response 返回给客户端
                let mut resp = CommandResponse::default();
                resp.status = 404;
                resp.message = &quot;Not found&quot;.to_string();
                stream.send(resp).await.unwrap();
            }
            info!(&quot;Client {:?} disconnected&quot;, addr);
        });
    }
}
</code></pre></pre>
</div>
</details>
<p>在这段代码里，服务器监听 9527 端口，对任何客户端的请求，一律返回 status = 404，message 是 “Not found” 的响应。</p>
<p>如果你对这两段代码中的异步和网络处理半懂不懂，没关系，你先把代码抄下来运行。今天的内容跟网络无关，你重点看处理流程就行。未来会讲到网络和异步处理的。</p>
<details id="admonition-运行测试" class="admonition success">
<summary class="admonition-title">
<p>运行测试 </p>
<p><a class="admonition-anchor-link" href="#admonition-运行测试"></a></p>
</summary>
<div>
<p>我们可以打开一个命令行窗口，运行：</p>
<pre><code class="language-shell">RUST_LOG=info cargo run --example dummy_server --quiet。
</code></pre>
<p>然后在另一个命令行窗口，运行：</p>
<pre><pre class="playground"><code class="language-rust  editable">RUST_LOG=info cargo run --example client --quiet
</code></pre></pre>
<p>此时，服务器和客户端都收到了彼此的请求和响应，协议层看上去运作良好。一旦验证通过，就你可以进入下一步，因为协议层的其它代码都只是工作量而已，在之后需要的时候可以慢慢实现。</p>
</div>
</details>
<h2 id="实现并验证-storage-trait"><a class="header" href="#实现并验证-storage-trait">实现并验证 Storage trait</a></h2>
<p>接下来构建 Storage trait。</p>
<p>我们上一讲谈到了如何使用嵌套的支持并发的 im-memory HashMap 来实现 storage trait。由于 Arc&lt;RwLock&lt;HashMap&lt;K, V&gt;&gt;&gt; 这样的支持并发的 HashMap 是一个刚需，Rust
生态有很多相关的 crate 支持，这里我们可以使用 dashmap 创建一个 MemTable 结构，来实现 Storage trait。</p>
<details id="admonition-实现" class="admonition note">
<summary class="admonition-title">
<p>实现 </p>
<p><a class="admonition-anchor-link" href="#admonition-实现"></a></p>
</summary>
<div>
<ol>
<li>先创建 src/storage 目录</li>
<li>然后创建 src/storage/mod.rs，把刚才讨论的 trait 代码放进去后</li>
<li>在 src/lib.rs 中引入 “mod storage”。此时会发现一个错误：并未定义 KvError。</li>
<li>创建 src/error.rs，使用<a href="https://github.com/dtolnay/thiserror">thiserror</a>的派生宏自定义错误类型，然后填入：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::Value;
use thiserror::Error;

#[derive(Error, Debug, PartialEq)]
pub enum KvError {
    #[error(&quot;Not found for table: {0}, key: {1}&quot;)]
    NotFound(String, String),

    #[error(&quot;Cannot parse command: `{0}`&quot;)]
    InvalidCommand(String),
    #[error(&quot;Cannot convert value {:0} to {1}&quot;)]
    ConvertError(Value, &amp;'static str),
    #[error(&quot;Cannot process command {0} with table: {1}, key: {2}. Error: {}&quot;)]
    StorageError(&amp;'static str, String, String, String),

    #[error(&quot;Failed to encode protobuf message&quot;)]
    EncodeError(#[from] prost::EncodeError),
    #[error(&quot;Failed to decode protobuf message&quot;)]
    DecodeError(#[from] prost::DecodeError),

    #[error(&quot;Internal error: {0}&quot;)]
    Internal(String),
}
</code></pre></pre>
<p>这些 error 的定义其实是在实现过程中逐步添加的，但为了讲解方便，先一次性添加。对于 Storage 的实现，我们只关心 StorageError，其它的 error 定义未来会用到。</p>
<ol start="5">
<li>同样，在 src/lib.rs 下引入 mod error，现在 src/lib.rs 是这个样子的：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
mod error;
mod pb;
mod storage;

pub use error::KvError;
pub use pb::abi::*;
pub use storage::*;
</code></pre></pre>
<p>src/storage/mod.rs 是这个样子的：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::{KvError, Kvpair, Value};

/// 对存储的抽象，我们不关心数据存在哪儿，但需要定义外界如何和存储打交道
pub trait Storage {
    /// 从一个 HashTable 里获取一个 key 的 value
    fn get(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;
    /// 从一个 HashTable 里设置一个 key 的 value，返回旧的 value
    fn set(&amp;self, table: &amp;str, key: String, value: Value) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;
    /// 查看 HashTable 中是否有 key
    fn contains(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;bool, KvError&gt;;
    /// 从 HashTable 中删除一个 key
    fn del(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;
    /// 遍历 HashTable，返回所有 kv pair（这个接口不好）
    fn get_all(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;Kvpair&gt;, KvError&gt;;
    /// 遍历 HashTable，返回 kv pair 的 Iterator
    fn get_iter(&amp;self, table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt;;
}
</code></pre></pre>
</div>
</details>
<details id="admonition-成功-通过-storage-trait-已经大概知道-memtable-怎么用所以可以先写段测试体验一下" class="admonition success">
<summary class="admonition-title">
<p>成功： 通过 Storage trait 已经大概知道 MemTable 怎么用，所以可以先写段测试体验一下 </p>
<p><a class="admonition-anchor-link" href="#admonition-成功-通过-storage-trait-已经大概知道-memtable-怎么用所以可以先写段测试体验一下"></a></p>
</summary>
<div>
<p>代码目前没有编译错误，可以在这个文件末尾添加测试代码，尝试使用这些接口了，当然，我们还没有构建 MemTable，但通过 Storage trait 已经大概知道 MemTable 怎么用，所以可以先写段测试体验一下：</p>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn memtable_basic_interface_should_work() {
        let store = MemTable::new();
        test_basi_interface(store);
    }

    #[test]
    fn memtable_get_all_should_work() {
        let store = MemTable::new();
        test_get_all(store);
    }

    fn test_basi_interface(store: impl Storage) {
        // 第一次 set 会创建 table，插入 key 并返回 None（之前没值）
        let v = store.set(&quot;t1&quot;, &quot;hello&quot;.into(), &quot;world&quot;.into());
        assert!(v.unwrap().is_none());
        // 再次 set 同样的 key 会更新，并返回之前的值
        let v1 = store.set(&quot;t1&quot;, &quot;hello&quot;.into(), &quot;world1&quot;.into());
        assert_eq!(v1, Ok(Some(&quot;world&quot;.into())));

        // get 存在的 key 会得到最新的值
        let v = store.get(&quot;t1&quot;, &quot;hello&quot;);
        assert_eq!(v, Ok(Some(&quot;world1&quot;.into())));

        // get 不存在的 key 或者 table 会得到 None
        assert_eq!(Ok(None), store.get(&quot;t1&quot;, &quot;hello1&quot;));
        assert!(store.get(&quot;t2&quot;, &quot;hello1&quot;).unwrap().is_none());

        // contains 纯在的 key 返回 true，否则 false
        assert_eq!(store.contains(&quot;t1&quot;, &quot;hello&quot;), Ok(true));
        assert_eq!(store.contains(&quot;t1&quot;, &quot;hello1&quot;), Ok(false));
        assert_eq!(store.contains(&quot;t2&quot;, &quot;hello&quot;), Ok(false));

        // del 存在的 key 返回之前的值
        let v = store.del(&quot;t1&quot;, &quot;hello&quot;);
        assert_eq!(v, Ok(Some(&quot;world1&quot;.into())));

        // del 不存在的 key 或 table 返回 None
        assert_eq!(Ok(None), store.del(&quot;t1&quot;, &quot;hello1&quot;));
        assert_eq!(Ok(None), store.del(&quot;t2&quot;, &quot;hello&quot;));
    }

    fn test_get_all(store: impl Storage) {
        store.set(&quot;t2&quot;, &quot;k1&quot;.into(), &quot;v1&quot;.into()).unwrap();
        store.set(&quot;t2&quot;, &quot;k2&quot;.into(), &quot;v2&quot;.into()).unwrap();
        let mut data = store.get_all(&quot;t2&quot;).unwrap();
        data.sort_by(|a, b| a.partial_cmp(b).unwrap());
        assert_eq!(
            data,
            vec![
                Kvpair::new(&quot;k1&quot;, &quot;v1&quot;.into()),
                Kvpair::new(&quot;k2&quot;, &quot;v2&quot;.into())
            ]
        )
    }

    fn test_get_iter(store: impl Storage) {
        store.set(&quot;t2&quot;, &quot;k1&quot;.into(), &quot;v1&quot;.into()).unwrap();
        store.set(&quot;t2&quot;, &quot;k2&quot;.into(), &quot;v2&quot;.into()).unwrap();
        let mut data: Vec&lt;_&gt; = store.get_iter(&quot;t2&quot;).unwrap().collect();
        data.sort_by(|a, b| a.partial_cmp(b).unwrap());
        assert_eq!(
            data,
            vec![
                Kvpair::new(&quot;k1&quot;, &quot;v1&quot;.into()),
                Kvpair::new(&quot;k2&quot;, &quot;v2&quot;.into())
            ]
        )
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-这种在写实现之前写单元测试是标准的-tddtest-driven-development方式" class="admonition quote">
<summary class="admonition-title">
<p>这种在写实现之前写单元测试，是标准的 TDD（Test-Driven Development）方式。 </p>
<p><a class="admonition-anchor-link" href="#admonition-这种在写实现之前写单元测试是标准的-tddtest-driven-development方式"></a></p>
</summary>
<div>
<p>这种在写实现之前写单元测试，是标准的 TDD（Test-Driven Development）方式。</p>
<p>我个人不是 TDD 的狂热粉丝，但会在构建完 trait 后，为这个 trait 撰写测试代码，因为写测试代码是个很好的验证接口是否好用的时机。毕竟我们不希望实现 trait 之后，才发现 trait 的定义有瑕疵，需要修改，这个时候改动的代价就比较大了。</p>
<p>所以，当 trait 推敲完毕，就可以开始写使用 trait 的测试代码了。在使用过程中仔细感受，如果写测试用例时用得不舒服，或者为了使用它需要做很多繁琐的操作，那么可以重新审视 trait 的设计。</p>
<p>你如果仔细看单元测试的代码，就会发现我始终秉持测试 trait 接口的思想。尽管在测试中需要一个实际的数据结构进行 trait 方法的测试，但核心的测试代码都用的泛型函数，让这些代码只跟 trait 相关。</p>
<p>这样:</p>
<ul>
<li>一来可以避免某个具体 trait 实现的干扰</li>
<li>二来在之后想加入更多 trait 实现时，可以共享测试代码。</li>
<li>比如未来想支持 DiskTable，那么只消加几个测试例，调用已有的泛型函数即可。</li>
</ul>
</div>
</details>
<p>好，搞定测试，确认 trait 设计没有什么问题之后，我们来写具体实现。</p>
<h3 id="构建memtable"><a class="header" href="#构建memtable">构建MemTable</a></h3>
<details id="admonition-可以创建-srcstoragememoryrs-来构建-memtable" class="admonition note">
<summary class="admonition-title">
<p>可以创建 src/storage/memory.rs 来构建 MemTable： </p>
<p><a class="admonition-anchor-link" href="#admonition-可以创建-srcstoragememoryrs-来构建-memtable"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::{KvError, Kvpair, Storage, Value};
use dashmap::{mapref::one::Ref, DashMap};

/// 使用 DashMap 构建的 MemTable，实现了 Storage trait
#[derive(Clone, Debug, Default)]
pub struct MemTable {
    tables: DashMap&lt;String, DashMap&lt;String, Value&gt;&gt;,
}

impl MemTable {
    /// 创建一个缺省的 MemTable
    pub fn new() -&gt; Self {
        Self::default()
    }

    /// 如果名为 name 的 hash table 不存在，则创建，否则返回
    fn get_or_create_table(&amp;self, name: &amp;str) -&gt; Ref&lt;String, DashMap&lt;String, Value&gt;&gt; {
        match self.tables.get(name) {
            Some(table) =&gt; table,
            None =&gt; {
                let entry = self.tables.entry(name.into()).or_default();
                entry.downgrade()
            }
        }
    }
}

impl Storage for MemTable {
    fn get(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {
        let table = self.get_or_create_table(table);
        Ok(table.get(key).map(|v| v.value().clone()))
    }

    fn set(&amp;self, table: &amp;str, key: String, value: Value) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {
        let table = self.get_or_create_table(table);
        Ok(table.insert(key, value))
    }

    fn contains(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;bool, KvError&gt; {
        let table = self.get_or_create_table(table);
        Ok(table.contains_key(key))
    }

    fn del(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {
        let table = self.get_or_create_table(table);
        Ok(table.remove(key).map(|(_k, v)| v))
    }

    fn get_all(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;Kvpair&gt;, KvError&gt; {
        let table = self.get_or_create_table(table);
        Ok(table
            .iter()
            .map(|v| Kvpair::new(v.key(), v.value().clone()))
            .collect())
    }

    fn get_iter(&amp;self, _table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt; {
        todo!()
    }
}
</code></pre></pre>
<ol>
<li>
<p>除了 get_iter() 外，这个实现代码非常简单，相信你看一下 dashmap 的文档，也能很快写出来。</p>
</li>
<li>
<p>get_iter() 写起来稍微有些难度，我们先放下不表，后面讲。</p>
</li>
<li>
<p>如果你对此感兴趣，想挑战一下，欢迎尝试。</p>
</li>
</ol>
</div>
</details>
<p>实现完成之后，我们可以测试它是否符合预期。</p>
<details id="admonition-警告-要在-srcstoragemodrs-开头添加代码" class="admonition warning">
<summary class="admonition-title">
<p>警告⚠️： 要在 src/storage/mod.rs 开头添加代码 </p>
<p><a class="admonition-anchor-link" href="#admonition-警告-要在-srcstoragemodrs-开头添加代码"></a></p>
</summary>
<div>
<p>注意现在 src/storage/memory.rs 还没有被添加，所以 cargo 并不会编译它。要在 src/storage/mod.rs 开头添加代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">mod memory;

pub use memory::MemTable;
</code></pre></pre>
<p>这样代码就可以编译通过了。因为还没有实现 get_iter 方法，所以这个测试需要被注释掉：</p>
<pre><pre class="playground"><code class="language-rust  editable">// #[test]

// fn memtable_iter_should_work() {

// let store = MemTable::new();

// test_get_iter(store);

// }
</code></pre></pre>
</div>
</details>
<h3 id="测试"><a class="header" href="#测试">测试</a></h3>
<details id="admonition-如果你运行-cargo-test-可以看到测试都通过了" class="admonition success">
<summary class="admonition-title">
<p>如果你运行 cargo test ，可以看到测试都通过了：</p>
<p><a class="admonition-anchor-link" href="#admonition-如果你运行-cargo-test-可以看到测试都通过了"></a></p>
</summary>
<div>
<pre><code class="language-shell">\&gt; cargo test

Compiling kv v0.1.0 (/Users/tchen/projects/mycode/rust/geek-time-rust-resources/21/kv)

Finished test [unoptimized + debuginfo] target(s) in 1.95s

Running unittests (/Users/tchen/.target/debug/deps/kv-8d746b0f387a5271)

running 2 tests

test storage::tests::memtable_basic_interface_should_work ... ok

test storage::tests::memtable_get_all_should_work ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in0.00s

Doc-tests kv

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in0.00s
</code></pre>
</div>
</details>
<h2 id="实现并验证-commandservice-trait"><a class="header" href="#实现并验证-commandservice-trait">实现并验证 CommandService trait</a></h2>
<details id="admonition-笔记-storage-trait-我们就算基本验证通过了现在再来验证-commandservice" class="admonition note">
<summary class="admonition-title">
<p>笔记： Storage trait 我们就算基本验证通过了，现在再来验证 CommandService </p>
<p><a class="admonition-anchor-link" href="#admonition-笔记-storage-trait-我们就算基本验证通过了现在再来验证-commandservice"></a></p>
</summary>
<div>
<p>Storage trait 我们就算基本验证通过了，现在再来验证 CommandService。</p>
<ol>
<li>我们创建 src/service 目录</li>
<li>以及 src/service/mod.rs </li>
<li>和 src/service/command_service.rs 文件</li>
<li>并在 src/service/mod.rs 写入：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::*;

mod command_service;

/// 对 Command 的处理的抽象
pub trait CommandService {
    /// 处理 Command，返回 Response
    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse;
}
</code></pre></pre>
<ol start="5">
<li>
<p>然后，在 src/service/command_service.rs 中，我们可以先写一些测试</p>
<p>为了简单起见，就列 HSET、HGET、HGETALL 三个命令：</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::*;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::command_request::RequestData;

    #[test]
    fn hset_should_work() {
        let store = MemTable::new();
        let cmd = CommandRequest::new_hset(&quot;t1&quot;, &quot;hello&quot;, &quot;world&quot;.into());
        let res = dispatch(cmd.clone(), &amp;store);
        assert_res_ok(res, &amp;[Value::default()], &amp;[]);

        let res = dispatch(cmd, &amp;store);
        assert_res_ok(res, &amp;[&quot;world&quot;.into()], &amp;[]);
    }

    #[test]
    fn hget_should_work() {
        let store = MemTable::new();
        let cmd = CommandRequest::new_hset(&quot;score&quot;, &quot;u1&quot;, 10.into());
        dispatch(cmd, &amp;store);
        let cmd = CommandRequest::new_hget(&quot;score&quot;, &quot;u1&quot;);
        let res = dispatch(cmd, &amp;store);
        assert_res_ok(res, &amp;[10.into()], &amp;[]);
    }

    #[test]
    fn hget_with_non_exist_key_should_return_404() {
        let store = MemTable::new();
        let cmd = CommandRequest::new_hget(&quot;score&quot;, &quot;u1&quot;);
        let res = dispatch(cmd, &amp;store);
        assert_res_error(res, 404, &quot;Not found&quot;);
    }

    #[test]
    fn hgetall_should_work() {
        let store = MemTable::new();
        let cmds = vec![
            CommandRequest::new_hset(&quot;score&quot;, &quot;u1&quot;, 10.into()),
            CommandRequest::new_hset(&quot;score&quot;, &quot;u2&quot;, 8.into()),
            CommandRequest::new_hset(&quot;score&quot;, &quot;u3&quot;, 11.into()),
            CommandRequest::new_hset(&quot;score&quot;, &quot;u1&quot;, 6.into()),
        ];
        for cmd in cmds {
            dispatch(cmd, &amp;store);
        }

        let cmd = CommandRequest::new_hgetall(&quot;score&quot;);
        let res = dispatch(cmd, &amp;store);
        let pairs = &amp;[
            Kvpair::new(&quot;u1&quot;, 6.into()),
            Kvpair::new(&quot;u2&quot;, 8.into()),
            Kvpair::new(&quot;u3&quot;, 11.into()),
        ];
        assert_res_ok(res, &amp;[], pairs);
    }

    // 从 Request 中得到 Response，目前处理 HGET/HGETALL/HSET
    fn dispatch(cmd: CommandRequest, store: &amp;impl Storage) -&gt; CommandResponse {
        match cmd.request_data.unwrap() {
            RequestData::Hget(v) =&gt; v.execute(store),
            RequestData::Hgetall(v) =&gt; v.execute(store),
            RequestData::Hset(v) =&gt; v.execute(store),
            _ =&gt; todo!(),
        }
    }

    // 测试成功返回的结果
    fn assert_res_ok(mut res: CommandResponse, values: &amp;[Value], pairs: &amp;[Kvpair]) {
        res.pairs.sort_by(|a, b| a.partial_cmp(b).unwrap());
        assert_eq!(res.status, 200);
        assert_eq!(res.message, &quot;&quot;);
        assert_eq!(res.values, values);
        assert_eq!(res.pairs, pairs);
    }

    // 测试失败返回的结果
    fn assert_res_error(res: CommandResponse, code: u32, msg: &amp;str) {
        assert_eq!(res.status, code);
        assert!(res.message.contains(msg));
        assert_eq!(res.values, &amp;[]);
        assert_eq!(res.pairs, &amp;[]);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-这些测试的作用就是验证产品需求比如" class="admonition tip">
<summary class="admonition-title">
<p>这些测试的作用就是验证产品需求，比如</p>
<p><a class="admonition-anchor-link" href="#admonition-这些测试的作用就是验证产品需求比如"></a></p>
</summary>
<div>
<blockquote>
<p>这些测试的作用就是验证产品需求，比如：</p>
</blockquote>
<ul>
<li>
<p>HSET 成功返回上一次的值（这和 Redis 略有不同，Redis 返回表示多少 key 受影响的一个整数）</p>
</li>
<li>
<p>HGET 返回 Value</p>
</li>
<li>
<p>HGETALL 返回一组无序的 Kvpair</p>
</li>
</ul>
</div>
</details>
<details id="admonition-目前这些测试是无法编译通过的因为里面使用了一些未定义的方法" class="admonition failure">
<summary class="admonition-title">
<p>目前这些测试是无法编译通过的，因为里面使用了一些未定义的方法</p>
<p><a class="admonition-anchor-link" href="#admonition-目前这些测试是无法编译通过的因为里面使用了一些未定义的方法"></a></p>
</summary>
<div>
<blockquote>
<p>目前这些测试是无法编译通过的，因为里面使用了一些未定义的方法，比如</p>
</blockquote>
<ul>
<li>10.into()：想把整数 10 转换成一个 Value</li>
<li>CommandRequest::new_hgetall(“score”)：想生成一个 HGETALL 命令。</li>
</ul>
</div>
</details>
<h3 id="为什么要这么写"><a class="header" href="#为什么要这么写">为什么要这么写？</a></h3>
<details id="admonition-因为如果是-commandservice-接口的使用者自然希望使用这个接口的时候调用的整体感觉非常简单明了" class="admonition abstract">
<summary class="admonition-title">
<p>因为如果是 CommandService 接口的使用者，自然希望使用这个接口的时候，调用的整体感觉非常简单明了 </p>
<p><a class="admonition-anchor-link" href="#admonition-因为如果是-commandservice-接口的使用者自然希望使用这个接口的时候调用的整体感觉非常简单明了"></a></p>
</summary>
<div>
<p>因为如果是 CommandService 接口的使用者，自然希望使用这个接口的时候，调用的整体感觉非常简单明了。</p>
<p>如果接口期待一个 Value，但在上下文中拿到的是 10、“hello” 这样的值，那我们作为设计者就要考虑为 Value 实现 From<T>，这样调用的时候最方便。同样的，对于生成 CommandRequest 这个数据结构，也可以添加一些辅助函数，来让调用更清晰。</p>
<blockquote>
<p>到现在为止我们写了两轮测试了，相信你对测试代码的作用有大概理解。我们来总结一下：</p>
</blockquote>
<ol>
<li>验证并帮助接口迭代</li>
<li>验证产品需求</li>
<li>通过使用核心逻辑，帮助我们更好地思考外围逻辑并反推其实现</li>
</ol>
<blockquote>
<p>前两点是最基本的，也是很多人对 TDD 的理解，其实还有更重要的也就是第三点。除了前面的辅助函数外，我们在测试代码中还看到了 dispatch 函数，它目前用来辅助测试。但紧接着你会发现，这样的辅助函数，可以合并到核心代码中。这才是“测试驱动开发”的实质。</p>
</blockquote>
</div>
</details>
<h3 id="在-srcpbmodrs-中添加相关的外围逻辑"><a class="header" href="#在-srcpbmodrs-中添加相关的外围逻辑">在 src/pb/mod.rs 中添加相关的外围逻辑</a></h3>
<details id="admonition-笔记好根据测试我们需要在-srcpbmodrs-中添加相关的外围逻辑" class="admonition note">
<summary class="admonition-title">
<p>笔记：好，根据测试，我们需要在 src/pb/mod.rs 中添加相关的外围逻辑</p>
<p><a class="admonition-anchor-link" href="#admonition-笔记好根据测试我们需要在-srcpbmodrs-中添加相关的外围逻辑"></a></p>
</summary>
<div>
<ol>
<li>首先是 CommandRequest 的一些方法，之前写了 new_hset，现在再加入 new_hget 和 new_hgetall：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
impl CommandRequest {
    /// 创建 HGET 命令
    pub fn new_hget(table: impl Into&lt;String&gt;, key: impl Into&lt;String&gt;) -&gt; Self {
        Self {
            request_data: Some(RequestData::Hget(Hget {
                table: table.into(),
                key: key.into(),
            })),
        }
    }

    /// 创建 HGETALL 命令
    pub fn new_hgetall(table: impl Into&lt;String&gt;) -&gt; Self {
        Self {
            request_data: Some(RequestData::Hgetall(Hgetall {
                table: table.into(),
            })),
        }
    }

    /// 创建 HSET 命令
    pub fn new_hset(table: impl Into&lt;String&gt;, key: impl Into&lt;String&gt;, value: Value) -&gt; Self {
        Self {
            request_data: Some(RequestData::Hset(Hset {
                table: table.into(),
                pair: Some(Kvpair::new(key, value)),
            })),
        }
    }
}
</code></pre></pre>
<ol start="2">
<li>然后写对 Value 的 From<i64> 的实现：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
/// 从 i64转换成 Value
impl From&lt;i64&gt; for Value {
    fn from(i: i64) -&gt; Self {
        Self {
            value: Some(value::Value::Integer(i)),
        }
    }
}
</code></pre></pre>
<ol start="3">
<li>测试代码目前就可以编译通过了，然而测试显然会失败，因为还没有做具体的实现。我们在 src/service/command_service.rs 下添加 trait 的实现代码：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
impl CommandService for Hget {
    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {
        match store.get(&amp;self.table, &amp;self.key) {
            Ok(Some(v)) =&gt; v.into(),
            Ok(None) =&gt; KvError::NotFound(self.table, self.key).into(),
            Err(e) =&gt; e.into(),
        }
    }
}

impl CommandService for Hgetall {
    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {
        match store.get_all(&amp;self.table) {
            Ok(v) =&gt; v.into(),
            Err(e) =&gt; e.into(),
        }
    }
}

impl CommandService for Hset {
    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {
        match self.pair {
            Some(v) =&gt; match store.set(&amp;self.table, v.key, v.value.unwrap_or_default()) {
                Ok(Some(v)) =&gt; v.into(),
                Ok(None) =&gt; Value::default().into(),
                Err(e) =&gt; e.into(),
            },
            None =&gt; Value::default().into(),
        }
    }
}
</code></pre></pre>
<blockquote>
<p>这自然会引发更多的编译错误，因为我们很多地方都是用了 into() 方法，却没有实现相应的转换，比如，Value 到 CommandResponse 的转换、KvError 到 CommandResponse 的转换、Vec<Kvpair> 到 CommandResponse 的转换等等。</p>
</blockquote>
<ol start="4">
<li>所以在 src/pb/mod.rs 里继续补上相应的外围逻辑：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
/// 从 Value 转换成 CommandResponse
impl From&lt;Value&gt; for CommandResponse {
    fn from(v: Value) -&gt; Self {
        Self {
            status: StatusCode::OK.as_u16() as _,
            values: vec![v],
            ..Default::default()
        }
    }
}

/// 从 Vec&lt;Kvpair&gt; 转换成 CommandResponse
impl From&lt;Vec&lt;Kvpair&gt;&gt; for CommandResponse {
    fn from(v: Vec&lt;Kvpair&gt;) -&gt; Self {
        Self {
            status: StatusCode::OK.as_u16() as _,
            pairs: v,
            ..Default::default()
        }
    }
}

/// 从 KvError 转换成 CommandResponse
impl From&lt;KvError&gt; for CommandResponse {
    fn from(e: KvError) -&gt; Self {
        let mut result = Self {
            status: StatusCode::INTERNAL_SERVER_ERROR.as_u16() as _,
            message: e.to_string(),
            values: vec![],
            pairs: vec![],
        };

        match e {
            KvError::NotFound(_, _) =&gt; result.status = StatusCode::NOT_FOUND.as_u16() as _,
            KvError::InvalidCommand(_) =&gt; result.status = StatusCode::BAD_REQUEST.as_u16() as _,
            _ =&gt; {}
        }

        result
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-into和struct绕过孤儿原则" class="admonition quote">
<summary class="admonition-title">
<p>into()和struct绕过孤儿原则 </p>
<p><a class="admonition-anchor-link" href="#admonition-into和struct绕过孤儿原则"></a></p>
</summary>
<div>
<p>从前面写接口到这里具体实现，不知道你是否感受到了这样一种模式：</p>
<ul>
<li>在 Rust 下，但凡出现两个数据结构 v1 到 v2 的转换，你都可以先以 v1.into() 来表示这个逻辑，继续往下写代码</li>
<li>之后再去补 From<T> 的实现</li>
<li>如果 v1 和 v2 都不是你定义的数据结构，那么你需要把其中之一用 struct 包装一下，来绕过之前提到的孤儿规则。</li>
</ul>
</div>
</details>
<blockquote>
<p>现在代码应该可以编译通过并测试通过了，你可以 cargo test 测试一下。</p>
</blockquote>
<h2 id="最后的拼图service-结构的实现"><a class="header" href="#最后的拼图service-结构的实现">最后的拼图：Service 结构的实现</a></h2>
<p>好，所有的接口，包括客户端 / 服务器的协议接口、Storage trait 和 CommandService trait 都验证好了，接下来就是考虑如何用一个数据结构把所有这些东西串联起来。</p>
<details id="admonition-笔记-依旧从使用者的角度来看如何调用它为此我们在-srcservicemodrs-里添加如下的测试代码" class="admonition note">
<summary class="admonition-title">
<p>笔记： 依旧从使用者的角度来看如何调用它。为此，我们在 src/service/mod.rs 里添加如下的测试代码：</p>
<p><a class="admonition-anchor-link" href="#admonition-笔记-依旧从使用者的角度来看如何调用它为此我们在-srcservicemodrs-里添加如下的测试代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
#[cfg(test)]
mod tests {
    use super::*;
    use crate::{MemTable, Value};

    #[test]
    fn service_should_works() {
        // 我们需要一个 service 结构至少包含 Storage
        let service = Service::new(MemTable::default());

        // service 可以运行在多线程环境下，它的 clone 应该是轻量级的
        let cloned = service.clone();

        // 创建一个线程，在 table t1 中写入 k1, v1
        let handle = thread::spawn(move || {
            let res = cloned.execute(CommandRequest::new_hset(&quot;t1&quot;, &quot;k1&quot;, &quot;v1&quot;.into()));
            assert_res_ok(res, &amp;[Value::default()], &amp;[]);
        });
        handle.join().unwrap();

        // 在当前线程下读取 table t1 的 k1，应该返回 v1
        let res = service.execute(CommandRequest::new_hget(&quot;t1&quot;, &quot;k1&quot;));
        assert_res_ok(res, &amp;[&quot;v1&quot;.into()], &amp;[]);
    }
}

#[cfg(test)]
use crate::{Kvpair, Value};

// 测试成功返回的结果
#[cfg(test)]
pub fn assert_res_ok(mut res: CommandResponse, values: &amp;[Value], pairs: &amp;[Kvpair]) {
    res.pairs.sort_by(|a, b| a.partial_cmp(b).unwrap());
    assert_eq!(res.status, 200);
    assert_eq!(res.message, &quot;&quot;);
    assert_eq!(res.values, values);
    assert_eq!(res.pairs, pairs);
}

// 测试失败返回的结果
#[cfg(test)]
pub fn assert_res_error(res: CommandResponse, code: u32, msg: &amp;str) {
    assert_eq!(res.status, code);
    assert!(res.message.contains(msg));
    assert_eq!(res.values, &amp;[]);
    assert_eq!(res.pairs, &amp;[]);
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>注意，这里的 assert_res_ok() 和 assert_res_error() 是从 src/service/command_service.rs 中挪过来的。在开发的过程中，不光产品代码需要不断重构，测试代码也需要重构来贯彻
DRY 思想。</p>
</blockquote>
<h3 id="围绕接口测试"><a class="header" href="#围绕接口测试">围绕接口测试</a></h3>
<details id="admonition-提示那什么样的测试代码是稳定的测试接口的代码是稳定的" class="admonition tip">
<summary class="admonition-title">
<p>提示：那什么样的测试代码是稳定的？测试接口的代码是稳定的。</p>
<p><a class="admonition-anchor-link" href="#admonition-提示那什么样的测试代码是稳定的测试接口的代码是稳定的"></a></p>
</summary>
<div>
<p>我见过很多生产环境的代码，产品功能部分还说得过去，但测试代码像是个粪坑，经年累月地 copy/paste 使其臭气熏天，每个开发者在添加新功能的时候，都掩着鼻子往里扔一坨走人，使得维护难度越来越高，每次需求变动，都涉及一大坨测试代码的变动，这样非常不好。</p>
<p>测试代码的质量也要和产品代码的质量同等要求。好的开发者写的测试代码的可读性也是非常强的。你可以对比上面写的三段测试代码多多感受。</p>
<p>在撰写测试的时候，我们要特别注意：测试代码要围绕着系统稳定的部分，也就是接口，来测试，而尽可能少地测试实现。这是我对这么多年工作中血淋淋的教训的深刻总结。</p>
<p>因为产品代码和测试代码，两者总需要一个是相对稳定的，既然产品代码会不断地根据需求变动，测试代码就必然需要稳定一些。</p>
<p>那什么样的测试代码是稳定的？测试接口的代码是稳定的。只要接口不变，无论具体实现如何变化，哪怕今天引入一个新的算法，明天重写实现，测试代码依旧能够凛然不动，做好产品质量的看门狗。</p>
</div>
</details>
<h3 id="继续写代码"><a class="header" href="#继续写代码">继续写代码</a></h3>
<p>好，我们回来写代码。在这段测试中，已经敲定了 Service 这个数据结构的使用蓝图，它可以跨线程，可以调用 execute 来执行某个 CommandRequest 命令，返回 CommandResponse。</p>
<details id="admonition-根据这些想法在-srcservicemodrs-里添加-service-的声明和实现" class="admonition note">
<summary class="admonition-title">
<p>根据这些想法，在 src/service/mod.rs 里添加 Service 的声明和实现：</p>
<p><a class="admonition-anchor-link" href="#admonition-根据这些想法在-srcservicemodrs-里添加-service-的声明和实现"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
/// Service 数据结构
pub struct Service&lt;Store = MemTable&gt; {
    inner: Arc&lt;ServiceInner&lt;Store&gt;&gt;,
}

impl&lt;Store&gt; Clone for Service&lt;Store&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self {
      inner: Arc::clone(&amp;self.inner),
        }
    }
}

/// Service 内部数据结构
pub struct ServiceInner&lt;Store&gt; {
    store: Store,
}

impl&lt;Store: Storage&gt; Service&lt;Store&gt; {
    pub fn new(store: Store) -&gt; Self {
        Self {
            inner: Arc::new(ServiceInner { store }),
        }
    }

    pub fn execute(&amp;self, cmd: CommandRequest) -&gt; CommandResponse {
        debug!(&quot;Got request: {:?}&quot;, cmd);
        // TODO: 发送 on_received 事件
        let res = dispatch(cmd, &amp;self.inner.store);
        debug!(&quot;Executed response: {:?}&quot;, res);
        // TODO: 发送 on_executed 事件

        res
    }
}

// 从 Request 中得到 Response，目前处理 HGET/HGETALL/HSET
pub fn dispatch(cmd: CommandRequest, store: &amp;impl Storage) -&gt; CommandResponse {
    match cmd.request_data {
        Some(RequestData::Hget(param)) =&gt; param.execute(store),
        Some(RequestData::Hgetall(param)) =&gt; param.execute(store),
        Some(RequestData::Hset(param)) =&gt; param.execute(store),
        None =&gt; KvError::InvalidCommand(&quot;Request has no data&quot;.into()).into(),
        _ =&gt; KvError::Internal(&quot;Not implemented&quot;.into()).into(),
    }
}
</code></pre></pre>
<blockquote>
<p>这段代码有几个地方值得注意：</p>
</blockquote>
<ul>
<li>
<p>首先 Service 结构内部有一个 ServiceInner 存放实际的数据结构，Service 只是用 Arc 包裹了 ServiceInner。这也是 Rust 的一个惯例，把需要在多线程下 clone 的主体和其内部结构分开，这样代码逻辑更加清晰。</p>
</li>
<li>
<p>execute() 方法目前就是调用了 dispatch，但它未来潜在可以做一些事件分发。这样处理体现了 SRP（Single Responsibility Principle）原则。</p>
</li>
<li>
<p>dispatch 其实就是把测试代码的 dispatch 逻辑移动过来改动了一下。</p>
</li>
</ul>
<blockquote>
<p>再一次，我们重构了测试代码，把它的辅助函数变成了产品代码的一部分。现在，你可以运行 cargo test 测试一下，如果代码无法编译，可能是缺一些 use 代码，比如：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">
use crate::{
    command_request::RequestData, CommandRequest, CommandResponse, KvError, MemTable, Storage,
};
use std::sync::Arc;
use tracing::debug;
</code></pre></pre>
</div>
</details>
<h2 id="新的-server"><a class="header" href="#新的-server">新的 server</a></h2>
<details id="admonition-现在处理逻辑已经都完成了可以写个新的-example-测试服务器代码" class="admonition note">
<summary class="admonition-title">
<p>现在处理逻辑已经都完成了，可以写个新的 example 测试服务器代码。 </p>
<p><a class="admonition-anchor-link" href="#admonition-现在处理逻辑已经都完成了可以写个新的-example-测试服务器代码"></a></p>
</summary>
<div>
<ol>
<li>把之前的 examples/dummy_server.rs 复制一份，成为 examples/server.rs，然后引入 Service，主要的改动就三句：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
// main 函数开头，初始化 service
let service: Service = Service::new(MemTable::new());
// tokio::spawn 之前，复制一份 service
let svc = service.clone();
// while loop 中，使用 svc 来执行 cmd
let res = svc.execute(cmd);
</code></pre></pre>
<ol start="2">
<li>你可以试着自己修改。完整的代码如下：</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">
use anyhow::Result;
use async_prost::AsyncProstStream;
use futures::prelude::*;
use kv::{CommandRequest, CommandResponse, MemTable, Service};
use tokio::net::TcpListener;
use tracing::info;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();
    let service: Service = Service::new(MemTable::new());
    let addr = &quot;127.0.0.1:9527&quot;;
    let listener = TcpListener::bind(addr).await?;
    info!(&quot;Start listening on {}&quot;, addr);
    loop {
        let (stream, addr) = listener.accept().await?;
        info!(&quot;Client {:?} connected&quot;, addr);
        let svc = service.clone();
        tokio::spawn(async move {
            let mut stream =
                AsyncProstStream::&lt;_, CommandRequest, CommandResponse, _&gt;::from(stream).for_async();
            while let Some(Ok(cmd)) = stream.next().await {
                let res = svc.execute(cmd);
                stream.send(res).await.unwrap();
            }
            info!(&quot;Client {:?} disconnected&quot;, addr);
        });
    }
}
</code></pre></pre>
</div>
</details>
<h2 id="运行"><a class="header" href="#运行">运行</a></h2>
<details id="admonition-使用两个窗口分别模拟服务端与客户端" class="admonition success">
<summary class="admonition-title">
<p>使用两个窗口分别模拟服务端与客户端 </p>
<p><a class="admonition-anchor-link" href="#admonition-使用两个窗口分别模拟服务端与客户端"></a></p>
</summary>
<div>
<p>完成之后，打开一个命令行窗口，运行：</p>
<pre><pre class="playground"><code class="language-rust  editable">RUST_LOG=info cargo run --example server --quiet
</code></pre></pre>
<p>然后在另一个命令行窗口，运行：</p>
<pre><pre class="playground"><code class="language-rust  editable">RUST_LOG=info cargo run --example server --quiet
</code></pre></pre>
</div>
</details>
<p>此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。</p>
<p>我们的 KV server 第一版的基本功能就完工了！当然，目前还只处理了 3 个命令，剩下 6 个需要你自己完成。</p>
<h2 id="初步感受rust撰写代码最佳实践"><a class="header" href="#初步感受rust撰写代码最佳实践">初步感受Rust撰写代码最佳实践</a></h2>
<details id="admonition-有两点我们一定要认真领会" class="admonition quote">
<summary class="admonition-title">
<p>有两点我们一定要认真领会 </p>
<p><a class="admonition-anchor-link" href="#admonition-有两点我们一定要认真领会"></a></p>
</summary>
<div>
<p>KV server 并不是一个很难的项目，但想要把它写好，并不简单。如果你跟着讲解一步步走下来，可以感受到一个有潜在生产环境质量的 Rust 项目应该如何开发。在这两讲内容中，有两点我们一定要认真领会。</p>
<ol>
<li>
<p>你要对需求有一个清晰的把握，找出其中不稳定的部分（variant）和比较稳定的部分（invariant）。在 KV server 中，不稳定的部分是，对各种新的命令的支持，以及对不同的 storage 的支持。所以需要构建接口来消弭不稳定的因素，让不稳定的部分可以用一种稳定的方式来管理。</p>
</li>
<li>
<p>代码和测试可以围绕着接口螺旋前进，使用 TDD 可以帮助我们进行这种螺旋式的迭代。在一个设计良好的系统中：接口是稳定的，测试接口的代码是稳定的，实现可以是不稳定的。在迭代开发的过程中，我们要不断地重构，让测试代码和产品代码都往最优的方向发展。</p>
</li>
</ol>
<p>纵观我们写的 KV server，包括测试在内，你很难发现有函数或者方法超过 50 行，代码可读性非常强，几乎不需要注释，就可以理解。另外因为都是用接口做的交互，未来维护和添加新的功能，也基本上满足 OCP 原则，除了 dispatch 函数需要很小的修改外，其它新的代码都是在实现一些接口而已。</p>
<blockquote>
<p>相信你能初步感受到在 Rust 下撰写代码的最佳实践。如果你之前用其他语言，已经采用了类似的最佳实践，那么可以感受一下同样的实践在 Rust 下使用的那种优雅；如果你之前由于种种原因，写的是类似之前意大利面条似的代码，那在开发 Rust 程序时，你可以试着接纳这种更优雅的开发方式。</p>
</blockquote>
<p>毕竟，现在我们手中有了更先进的武器，就可以用更先进的打法。</p>
</div>
</details>
<h2 id="为剩下6个命令构建测试并实现"><a class="header" href="#为剩下6个命令构建测试并实现">为剩下6个命令构建测试并实现</a></h2>
<p>为剩下 6 个命令 HMGET、HMSET、HDEL、HMDEL、HEXIST、HMEXIST 构建测试，并实现它们。在测试和实现过程中，你也许需要添加更多的 From<T> 的实现。</p>
<h2 id="考虑用线程池处理并发"><a class="header" href="#考虑用线程池处理并发">考虑用线程池处理并发</a></h2>
<p>虽然我们的 KV server 使用了 concurrent hashmap 来处理并发，但这并不一定是最好的选择。</p>
<p>我们也可以创建一个线程池，每个线程有自己的 HashMap。当 HGET/HSET 等命令来临时，可以对 key 做个哈希，然后分派到 “拥有” 那个 key
的线程，这样，可以避免在处理的时候加锁，提高系统的吞吐。你可以想想如果用这种方式处理，该怎么做。</p>

            </main>

            <!--            <script src="https://utteranc.es/client.js"-->
            <!--                    repo="RustMagazine/rust_magazine_2022"-->
            <!--                    issue-term="title"-->
            <!--                    theme="github-light"-->
            <!--                    crossorigin="anonymous"-->
            <!--                    async></script>-->

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                    <a rel="prev" href="kv1_basic.html" class="mobile-nav-chapters previous"
                       title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="kv3_advanced_traits.html" class="mobile-nav-chapters next"
                       title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="kv1_basic.html" class="nav-chapters previous" title="Previous chapter"
               aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="kv3_advanced_traits.html" class="nav-chapters next" title="Next chapter"
               aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
    </nav>

</div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/mermaid/mermaid.min.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid-init.js"></script>
    <script type="text/javascript" src="assets/smart-anchor.js"></script>
    <script type="text/javascript" src="assets/pagetoc/sidebar.js"></script>

</body>
</html>
