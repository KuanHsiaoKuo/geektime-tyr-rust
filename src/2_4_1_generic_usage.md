# 参数多态：泛型使用

<!--ts-->
* [参数多态：泛型使用](#参数多态泛型使用)
   * [逐步约束：把决策交给使用者](#逐步约束把决策交给使用者)
   * [三种使用场景](#三种使用场景)
      * [延迟绑定](#延迟绑定)
      * [额外类型](#额外类型)
      * [多个实现](#多个实现)
   * [单态化](#单态化)
      * [优劣](#优劣)
   * [返回值携带泛型参数](#返回值携带泛型参数)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Fri Oct 21 08:28:56 UTC 2022 -->

<!--te-->

## 逐步约束：把决策交给使用者

~~~admonish info title='在不同的实现下逐步添加约束' collapsible=true
```rust, editable
{{#include ../geektime_rust_codes/12_type_system/src/reader.rs}}
```
~~~

## 三种使用场景

### 延迟绑定

### 额外类型

### 多个实现

## 单态化

~~~admonish info title='编译时展开泛型参数单态化' collapsible=true
> 对于泛型函数，Rust 会进行单态化（Monomorphization）处理，也就是在编译时，把所有用到的泛型函数的泛型参数展开，生成若干个函数。
> 所以，下方的 id() 编译后会得到 一个处理后的多个版本
----
```rust, editable
{{#include ../geektime_rust_codes/12_type_system/src/id.rs}}
```
~~~

~~~admonish info title='单态化的优劣' collapsible=true

1. 单态化的好处是:

- 泛型函数的调用是静态分派（static dispatch） 在编译时就一一对应
- 既保有多态的灵活性，又没有任何效率的损失，和普通函数调用一样高效。

2. 坏处：编译慢、文件大、丢失泛型信息。这反过来又是动态分派的好处

- 但是对比刚才编译会展开的代码也能很清楚看出来，单态化有很明显的坏处
- 就是编译速度很慢，一个泛型函数，编译器需要找到所有用到的不同类型，一个个编译
- 所以 Rust 编译代码的速度总被人吐槽，这和单态化脱不开干系（另一个重要因素是宏）。
- 同时，这样编出来的二进制会比较大，因为泛型函数的二进制代码实际存在 N 份。
- 还有一个可能你不怎么注意的问题：因为单态化，代码以二进制分发会损失泛型的信息。
- 如果我写了一个库，提供了如上的 id() 函数，使用这个库的开发者如果拿到的是二进制
- 那么这个二进制中必须带有原始的泛型函数，才能正确调用。但单态化之后，原本的泛型信息就被丢弃了。
~~~

### 优劣

## 返回值携带泛型参数
