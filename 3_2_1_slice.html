<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>切片 - Anatomy In First Rust Programming Class 🦀</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust编程第一课的代码为例进行基础代码分析">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="md-favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/pagetoc/pagetoc_style.css">
        <link rel="stylesheet" href="assets/css/mdbook-admonish.css">

        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="anatomy_logic.html"><strong aria-hidden="true">1.</strong> 源码阅读逻辑</a></li><li class="chapter-item expanded "><a href="intro_gdb_lldb.html"><strong aria-hidden="true">2.</strong> gdb/lldb调试或查看内存结构</a></li><li class="chapter-item expanded "><a href="get_hands_dirty.html"><strong aria-hidden="true">3.</strong> get hands dirty</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="httpie.html"><strong aria-hidden="true">3.1.</strong> httpie</a></li><li class="chapter-item expanded "><a href="rgrep.html"><strong aria-hidden="true">3.2.</strong> rgrep</a></li><li class="chapter-item expanded "><a href="thumbor.html"><strong aria-hidden="true">3.3.</strong> thumbor</a></li><li class="chapter-item expanded "><a href="queryer.html"><strong aria-hidden="true">3.4.</strong> queryer</a></li></ol></li><li class="chapter-item expanded "><a href="rust_cores.html"><strong aria-hidden="true">4.</strong> Rust核心深入</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_stack_heap_ownership_lifetime_memory.html"><strong aria-hidden="true">4.1.</strong> I. 从栈堆、所有权、生命周期开始内存管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_1_stack_heap.html"><strong aria-hidden="true">4.1.1.</strong> 从堆栈开始</a></li><li class="chapter-item expanded "><a href="1_2_programming_basic_concepts.html"><strong aria-hidden="true">4.1.2.</strong> 四大编程基础概念</a></li><li class="chapter-item expanded "><a href="1_3_ownership.html"><strong aria-hidden="true">4.1.3.</strong> 所有权</a></li><li class="chapter-item expanded "><a href="1_4_lifetime.html"><strong aria-hidden="true">4.1.4.</strong> 生命周期</a></li><li class="chapter-item expanded "><a href="1_5_go_through.html"><strong aria-hidden="true">4.1.5.</strong> 从创建到消亡</a></li></ol></li><li class="chapter-item expanded "><a href="2_type_system.html"><strong aria-hidden="true">4.2.</strong> II. 类型系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2_1_type_details.html"><strong aria-hidden="true">4.2.1.</strong> 类型系统特点</a></li><li class="chapter-item expanded "><a href="2_2_generic_overview.html"><strong aria-hidden="true">4.2.2.</strong> 泛型概览：就像函数</a></li><li class="chapter-item expanded "><a href="2_3_trait_overview.html"><strong aria-hidden="true">4.2.3.</strong> trait概览</a></li><li class="chapter-item expanded "><a href="2_4_0_three_polymorphics.html"><strong aria-hidden="true">4.2.4.</strong> 三种多态形式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2_4_1_generic_usage.html"><strong aria-hidden="true">4.2.4.1.</strong> Generics: &lt;&gt;</a></li><li class="chapter-item "><a href="2_4_2_trait_impl.html"><strong aria-hidden="true">4.2.4.2.</strong> Trait impl/bound: self</a></li><li class="chapter-item "><a href="2_4_3_trait_object.html"><strong aria-hidden="true">4.2.4.3.</strong> Trait object: &self</a></li><li class="chapter-item "><a href="2_4_4_comprehensive_polymorphics.html"><strong aria-hidden="true">4.2.4.4.</strong> 复杂多态综合使用实例</a></li></ol></li><li class="chapter-item expanded "><a href="2_5_trait_frequently.html"><strong aria-hidden="true">4.2.5.</strong> 常用trait</a></li><li class="chapter-item expanded "><a href="2_6_trait_design.html"><strong aria-hidden="true">4.2.6.</strong> Trait设计</a></li></ol></li><li class="chapter-item expanded "><a href="3_data_structure.html"><strong aria-hidden="true">4.3.</strong> III. 数据结构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3_1_smart_pointer.html"><strong aria-hidden="true">4.3.1.</strong> 智能指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="3_1_1_box.html"><strong aria-hidden="true">4.3.1.1.</strong> Box</a></li><li class="chapter-item "><a href="3_1_2_cow.html"><strong aria-hidden="true">4.3.1.2.</strong> Cow&lt;'a, B&gt;</a></li><li class="chapter-item "><a href="3_1_3_mutex_guard.html"><strong aria-hidden="true">4.3.1.3.</strong> MutexGuard&lt;'_, T&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="3_2_containers.html"><strong aria-hidden="true">4.3.2.</strong> 集合容器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3_2_1_slice.html" class="active"><strong aria-hidden="true">4.3.2.1.</strong> 切片</a></li><li class="chapter-item "><a href="3_2_2_hashmap.html"><strong aria-hidden="true">4.3.2.2.</strong> 哈希表</a></li></ol></li><li class="chapter-item expanded "><a href="3_3_error_handling.html"><strong aria-hidden="true">4.3.3.</strong> 错误处理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="3_3_1_error_content.html"><strong aria-hidden="true">4.3.3.1.</strong> 错误处理内容和主流方法</a></li><li class="chapter-item "><a href="3_3_2_rust_error_handling.html"><strong aria-hidden="true">4.3.3.2.</strong> Rust如何处理错误: ?/unwarp/expect</a></li></ol></li><li class="chapter-item expanded "><a href="3_4_closure.html"><strong aria-hidden="true">4.3.4.</strong> 闭包</a></li></ol></li><li class="chapter-item expanded "><a href="4_macros.html"><strong aria-hidden="true">4.4.</strong> IV. 宏编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4_1_macros_classify.html"><strong aria-hidden="true">4.4.1.</strong> 宏分类</a></li><li class="chapter-item expanded "><a href="4_2_declarative_macros.html"><strong aria-hidden="true">4.4.2.</strong> 声明宏</a></li><li class="chapter-item expanded "><a href="4_3_procedural_macros.html"><strong aria-hidden="true">4.4.3.</strong> 过程宏</a></li></ol></li><li class="chapter-item expanded "><a href="5_concurrency_async.html"><strong aria-hidden="true">4.5.</strong> V. 并发与异步</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5_1_concurrency_primitives.html"><strong aria-hidden="true">4.5.1.</strong> 并发原语(Concurrency Primitives)</a></li><li class="chapter-item expanded "><a href="5_2_future_async_await.html"><strong aria-hidden="true">4.5.2.</strong> 异步：Future/Async/Await</a></li><li class="chapter-item expanded "><a href="5_3_deepin_async_await.html"><strong aria-hidden="true">4.5.3.</strong> 深入async/await</a></li></ol></li><li class="chapter-item expanded "><a href="6_unsafe_ffi.html"><strong aria-hidden="true">4.6.</strong> VI. 混合编程</a></li></ol></li><li class="chapter-item expanded "><a href="kv_server_design.html"><strong aria-hidden="true">5.</strong> kv server设计与实现</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kv1_basic.html"><strong aria-hidden="true">5.1.</strong> 基本流程</a></li><li class="chapter-item expanded "><a href="kv2_protocols.html"><strong aria-hidden="true">5.2.</strong> 实现并验证协议层</a></li><li class="chapter-item expanded "><a href="kv3_advanced_traits.html"><strong aria-hidden="true">5.3.</strong> 高级trait改造</a></li><li class="chapter-item expanded "><a href="kv4_network.html"><strong aria-hidden="true">5.4.</strong> 网络处理</a></li><li class="chapter-item expanded "><a href="kv5_network_security.html"><strong aria-hidden="true">5.5.</strong> 网络安全</a></li><li class="chapter-item expanded "><a href="kv6_async_refactor.html"><strong aria-hidden="true">5.6.</strong> 异步改造</a></li><li class="chapter-item expanded "><a href="kv7_big_refactor.html"><strong aria-hidden="true">5.7.</strong> 重大重构</a></li><li class="chapter-item expanded "><a href="kv8_config_ci_cd.html"><strong aria-hidden="true">5.8.</strong> 配置、测试、监控、CI/CD</a></li></ol></li><li class="chapter-item expanded "><a href="custom_axum_async_web_framework.html"><strong aria-hidden="true">6.</strong> 构建自己的类axum异步Web框架</a></li><li class="chapter-item expanded affix "><a href="checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Anatomy In First Rust Programming Class 🦀</h1>
            <h4 class="menu-bar"><a href="https://kuanhsiaokuo.github.io/think-tool-kit/">保持批判，有所取舍，知行合一, 方见真我</a> -- 练武不练功
                到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/geektime-tyr-rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="切片"><a class="header" href="#切片">切片</a></h1>
<!--ts-->
<ul>
<li><a href="#%E5%88%87%E7%89%87">切片</a>
<ul>
<li><a href="#%E5%88%87%E7%89%87%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88">切片到底是什么</a>
<ul>
<li><a href="#%E5%88%87%E7%89%87%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E7%82%B9">切片的三个特点</a></li>
<li><a href="#%E5%88%87%E7%89%87%E7%9A%84%E4%B8%89%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F">切片的三种访问方式</a></li>
<li><a href="#%E5%88%87%E7%89%87%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B3%E7%B3%BB">切片与数据的关系</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%88%87%E7%89%87%E5%AF%B9%E6%AF%94%E5%9B%BE">常用切片对比图</a></li>
</ul>
</li>
<li><a href="#array-vs-vector">array vs vector</a></li>
<li>[Vec&lt;T&gt; 和 &amp;[T]](#vect-和-t)</li>
<li><a href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%BD%AC%E4%B8%BA%E5%88%87%E7%89%87%E7%B1%BB%E5%9E%8B">解引用：转为切片类型</a></li>
<li><a href="#%E5%88%87%E7%89%87%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator">切片和迭代器 Iterator</a></li>
<li><a href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%88%87%E7%89%87str">特殊的切片：&amp;str</a></li>
<li>[Box&lt;[T]&gt;](#boxt)</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Sun Oct 23 06:38:27 UTC 2022 -->
<!--te-->
<h2 id="切片到底是什么"><a class="header" href="#切片到底是什么">切片到底是什么</a></h2>
<h3 id="切片的三个特点"><a class="header" href="#切片的三个特点">切片的三个特点</a></h3>
<details id="admonition-1-同一类型长度不确定的在内存中连续存放的数据结构" class="admonition tip">
<summary class="admonition-title">
<ol>
<li>同一类型、长度不确定的、在内存中连续存放的数据结构</li>
</ol>
<p><a class="admonition-anchor-link" href="#admonition-1-同一类型长度不确定的在内存中连续存放的数据结构"></a></p>
</summary>
<div>
<p>在 Rust 里，切片是描述一组属于同一类型、长度不确定的、在内存中连续存放的数据结 构，用 [T] 来表述。因为长度不确定，所以切片是个 DST（Dynamically Sized Type）。</p>
</div>
</details>
<h3 id="切片的三种访问方式"><a class="header" href="#切片的三种访问方式">切片的三种访问方式</a></h3>
<details id="admonition-2-切片不能直接访问需要通过引用访问有三种访问方式" class="admonition tip">
<summary class="admonition-title">
<ol start="2">
<li>切片不能直接访问，需要通过引用访问。有三种访问方式：</li>
</ol>
<p><a class="admonition-anchor-link" href="#admonition-2-切片不能直接访问需要通过引用访问有三种访问方式"></a></p>
</summary>
<div>
<p>切片一般只出现在数据结构的定义中，不能直接访问，在使用中主要用以下形式：</p>
<ul>
<li>
<p>&amp;[T]：表示一个只读的切片引用。</p>
</li>
<li>
<p>&amp;mut [T]：表示一个可写的切片引用。</p>
</li>
<li>
<p>Box&lt;[T]&gt;：一个在堆上分配的切片。</p>
</li>
</ul>
</div>
</details>
<h3 id="切片与数据的关系"><a class="header" href="#切片与数据的关系">切片与数据的关系</a></h3>
<blockquote>
<p>怎么理解切片呢？我打个比方，切片之于具体的数据结构，就像数据库中的视图之于表。
你可以把它看成一种工具，让我们可以统一访问行为相同、结构类似但有些许差异的类 型。</p>
</blockquote>
<details id="admonition-3-举例切片与数据的关系" class="admonition tip">
<summary class="admonition-title">
<ol start="3">
<li>举例切片与数据的关系</li>
</ol>
<p><a class="admonition-anchor-link" href="#admonition-3-举例切片与数据的关系"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let arr = [1, 2, 3, 4, 5];
    let vec = vec![1, 2, 3, 4, 5];
    let s1 = &amp;arr[1..3];
    let s2 = &amp;vec[1..3];
    println!(&quot;s1: {:?}, s2: {:?}&quot;, s1, s2);

    // &amp;[T] 和 &amp;[T] 是否相等取决于长度和内容是否相等
    assert_eq!(s1, s2);
    // &amp;[T] 可以和 Vec&lt;T&gt;/[T;n] 比较，也会看长度和内容
    assert_eq!(&amp;arr[..], vec);
    assert_eq!(&amp;vec[..], arr);
}
</code></pre></pre>
<ol>
<li>对于 array 和 vector，虽然是不同的数据结构，一个放在栈上，一个放在堆上，但它们的 切片是类似的；</li>
<li>而且对于相同内容数据的相同切片，比如 &amp;arr[1…3] 和 &amp;vec[1…3]，这 两者是等价的。</li>
<li>除此之外，切片和对应的数据结构也可以直接比较，这是因为它们之间实 现了 PartialEq trait</li>
</ol>
</div>
</details>
<details id="admonition-31-切片与数据的关系图" class="admonition tip">
<summary class="admonition-title">
<p>3.1 切片与数据的关系图</p>
<p><a class="admonition-anchor-link" href="#admonition-31-切片与数据的关系图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4785008.jpg" alt="切片与具体数据的关系" /></p>
</div>
</details>
<h3 id="常用切片对比图"><a class="header" href="#常用切片对比图">常用切片对比图</a></h3>
<p>下图描述了切片和数组 [T;n]、列表 Vec<T>、切片引用 &amp;[T] /&amp;mut [T]，以及在堆上分配的切片 Box&lt;[T]&gt; 之间的关系。</p>
<blockquote>
<p>建议花些时间理解这张图，也可以用相同的方式去总结学到的其他有关联的数据结构。</p>
</blockquote>
<details id="admonition-strtnvectmutt的区别与联系图" class="admonition info">
<summary class="admonition-title">
<p>&amp;str、[T;n]、Vec<T>、&amp;[T]、&amp;mut[T]的区别与联系图 </p>
<p><a class="admonition-anchor-link" href="#admonition-strtnvectmutt的区别与联系图"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867546.jpg" alt="" /></p>
</div>
</details>
<h2 id="array-vs-vector"><a class="header" href="#array-vs-vector">array vs vector</a></h2>
<details id="admonition-接前面的例子再次说明array和vector的区别与联系" class="admonition info">
<summary class="admonition-title">
<p>接前面的例子，再次说明array和vector的区别与联系</p>
<p><a class="admonition-anchor-link" href="#admonition-接前面的例子再次说明array和vector的区别与联系"></a></p>
</summary>
<div>
<p>对于 array 和 vector，虽然是不同的数据结构：</p>
<ul>
<li>一个放在栈上</li>
<li>一个放在堆上</li>
</ul>
<blockquote>
<p>但它们的切片是类似的, 而且对于相同内容数据的相同切片</p>
</blockquote>
<ul>
<li>比如 &amp;arr[1…3] 和 &amp;vec[1…3]，这两者是等价的。</li>
<li>除此之外，切片和对应的数据结构也可以直接比较，这是因为它们之间实现了 PartialEq trait（源码参考资料）。</li>
</ul>
<blockquote>
<p>下图比较清晰地呈现了切片和数据之间的关系：
<img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4866674.jpg" alt="切片和数据之间的关系" /></p>
</blockquote>
</div>
</details>
<h2 id="vect-和-t"><a class="header" href="#vect-和-t">Vec&lt;T&gt; 和 &amp;[T]</a></h2>
<details id="admonition-t与vect关系" class="admonition tip">
<summary class="admonition-title">
<p>&amp;[T]与&amp;Vec[T]关系</p>
<p><a class="admonition-anchor-link" href="#admonition-t与vect关系"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4785147.jpg" alt="二者关系图" /></p>
</div>
</details>
<h2 id="解引用转为切片类型"><a class="header" href="#解引用转为切片类型">解引用：转为切片类型</a></h2>
<blockquote>
<p>在使用的时候，支持切片的具体数据类型，你可以根据需要，解引用转换成切片类型。</p>
</blockquote>
<ul>
<li>比如 Vec<T> 和 [T; n] 会转化成为 &amp;[T]，这是因为 Vec<T> 实现了 Deref trait，而 array 内建了到 &amp;[T] 的解引用。</li>
</ul>
<details id="admonition-derefasref我们可以写一段代码验证这一行为代码" class="admonition info">
<summary class="admonition-title">
<p>Deref、&amp;、AsRef：我们可以写一段代码验证这一行为（代码）</p>
<p><a class="admonition-anchor-link" href="#admonition-derefasref我们可以写一段代码验证这一行为代码"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">
use std::fmt;
fn main() {
    let v = vec![1, 2, 3, 4];

    // Vec 实现了 Deref，&amp;Vec&lt;T&gt; 会被自动解引用为 &amp;[T]，符合接口定义
    print_slice(&amp;v);
    // 直接是 &amp;[T]，符合接口定义
    print_slice(&amp;v[..]);

    // &amp;Vec&lt;T&gt; 支持 AsRef&lt;[T]&gt;
    print_slice1(&amp;v);
    // &amp;[T] 支持 AsRef&lt;[T]&gt;
    print_slice1(&amp;v[..]);
    // Vec&lt;T&gt; 也支持 AsRef&lt;[T]&gt;
    print_slice1(v);

    let arr = [1, 2, 3, 4];
    // 数组虽没有实现 Deref，但它的解引用就是 &amp;[T]
    print_slice(&amp;arr);
    print_slice(&amp;arr[..]);
    print_slice1(&amp;arr);
    print_slice1(&amp;arr[..]);
    print_slice1(arr);
}

// 注意下面的泛型函数的使用
fn print_slice&lt;T: fmt::Debug&gt;(s: &amp;[T]) {
    println!(&quot;{:?}&quot;, s);
}

fn print_slice1&lt;T, U&gt;(s: T)
where
    T: AsRef&lt;[U]&gt;,
    U: fmt::Debug,
{
    println!(&quot;{:?}&quot;, s.as_ref());
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p>这也就意味着，通过解引用，这几个和切片有关的数据结构都会获得切片的所有能力，包括下列丰富的功能：</p>
</blockquote>
<ul>
<li>binary_search</li>
<li>chunks</li>
<li>concat</li>
<li>contains</li>
<li>start_with</li>
<li>end_with</li>
<li>group_by</li>
<li>iter</li>
<li>join</li>
<li>sort</li>
<li>split</li>
<li>swap</li>
</ul>
<h2 id="切片和迭代器-iterator"><a class="header" href="#切片和迭代器-iterator">切片和迭代器 Iterator</a></h2>
<details id="admonition-迭代器可以说是切片的孪生兄弟" class="admonition info">
<summary class="admonition-title">
<p>迭代器可以说是切片的孪生兄弟</p>
<p><a class="admonition-anchor-link" href="#admonition-迭代器可以说是切片的孪生兄弟"></a></p>
</summary>
<div>
<p>迭代器可以说是切片的孪生兄弟:</p>
<ul>
<li>切片是集合数据的视图</li>
<li>而迭代器定义了对集合数据的各种各样的访问操作。</li>
</ul>
</div>
</details>
<details id="admonition-iterator-trait-有大量的方法但绝大多数情况下只需要定义它的关联类型-item-和-next-方法" class="admonition info">
<summary class="admonition-title">
<p>Iterator trait 有大量的方法，但绝大多数情况下，只需要定义它的关联类型 Item 和 next() 方法。</p>
<p><a class="admonition-anchor-link" href="#admonition-iterator-trait-有大量的方法但绝大多数情况下只需要定义它的关联类型-item-和-next-方法"></a></p>
</summary>
<div>
<ul>
<li>Item 定义了每次我们从迭代器中取出的数据类型；</li>
<li>next() 是从迭代器里取下一个值的方法。当一个迭代器的 next() 方法返回 None 时，表明迭代器中没有数据了。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[must_use = &quot;iterators are lazy and do nothing unless consumed&quot;]
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    // 大量缺省的方法，包括 size_hint, count, chain, zip, map, 
    // filter, for_each, skip, take_while, flat_map, flatten
    // collect, partition 等
    ... 
}
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-一个例子对切片类型vec-使用-iter-方法并进行各种-map--filter--take-操作" class="admonition info">
<summary class="admonition-title">
<p>一个例子：对切片类型Vec<T> 使用 iter() 方法，并进行各种 map / filter / take 操作</p>
<p><a class="admonition-anchor-link" href="#admonition-一个例子对切片类型vec-使用-iter-方法并进行各种-map--filter--take-操作"></a></p>
</summary>
<div>
<blockquote>
<p>在函数式编程语言中，这样的写法很常见，代码的可读性很强。Rust 也支持这种写法（代码）：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
fn main() {
    // 这里 Vec&lt;T&gt; 在调用 iter() 时被解引用成 &amp;[T]，所以可以访问 iter()
    let result = vec![1, 2, 3, 4]
        .iter()
        .map(|v| v * v)
        .filter(|v| *v &lt; 16)
        .take(1)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;{:?}&quot;, result);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-rust的迭代器是个懒接口这是如何实现的" class="admonition question">
<summary class="admonition-title">
<p>Rust的迭代器是个懒接口，这是如何实现的？</p>
<p><a class="admonition-anchor-link" href="#admonition-rust的迭代器是个懒接口这是如何实现的"></a></p>
</summary>
<div>
<p>需要注意的是 Rust 下的迭代器是个懒接口（lazy interface）:</p>
<ol>
<li>也就是说这段代码直到运行到 collect 时才真正开始执行</li>
<li>之前的部分不过是在不断地生成新的结构，来累积处理逻辑而已。</li>
</ol>
<p>你可能好奇，这是怎么做到的呢？</p>
<p>原来，Iterator 大部分方法都返回一个实现了 Iterator 的数据结构，所以可以这样一路链式下去.</p>
<p>在 Rust 标准库中，这些数据结构被称为 <a href="https://doc.rust-lang.org/src/core/iter/adapters/mod.rs.html">Iterator Adapter</a>。</p>
<p>比如上面的 map 方法，它返回 Map 结构，而 Map 结构实现了 <a href="https://doc.rust-lang.org/src/core/iter/adapters/map.rs.html#93-133">Iterator（源码）</a>。</p>
<p>整个过程是这样的（链接均为源码资料）：</p>
<ol>
<li>在 collect() 执行的时候，它<a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1744-1749">实际试图使用 FromIterator 从迭代器中构建一个集合类型</a>，这会不断调用 next() 获取下一个数据；</li>
<li>此时的 Iterator 是 Take，Take 调自己的 next()，也就是它会<a href="https://doc.rust-lang.org/src/core/iter/adapters/take.rs.html#34-41">调用 Filter 的 next()</a>；</li>
<li>Filter 的 next() 实际上<a href="https://time.geekbang.org/column/article/422975">调用自己内部的 iter 的 find()</a>，此时内部的 iter 是 Map，find() 会使用 <a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2312-2325">try_fold()</a>，它会<a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2382-2406">继续调用 next()</a>，也就是 Map 的 next()；</li>
<li>Map 的 next() 会<a href="https://time.geekbang.org/column/article/422975">调用其内部的 iter 取 next() 然后执行 map 函数</a>。而此时内部的 iter 来自 Vec<i32>。</li>
</ol>
<p>所以，只有在 collect() 时，才触发代码一层层调用下去，并且调用会根据需要随时结束。这段代码中我们使用了 take(1)，整个调用链循环一次，就能满足 take(1) 以及所有中间过程的要求，所以它只会循环一次。</p>
</div>
</details>
<details id="admonition-rust的函数式编程写法性能如何" class="admonition question">
<summary class="admonition-title">
<p>Rust的函数式编程写法性能如何？</p>
<p><a class="admonition-anchor-link" href="#admonition-rust的函数式编程写法性能如何"></a></p>
</summary>
<div>
<p>你可能会有疑惑：这种函数式编程的写法，代码是漂亮了，然而这么多无谓的函数调用，性能肯定很差吧？毕竟，函数式编程语言的一大恶名就是性能差。</p>
<p>这个你完全不用担心， Rust 大量使用了 inline 等优化技巧，这样非常清晰友好的表达方式，性能和 C 语言的 for 循环差别不大。</p>
</div>
</details>
<details id="admonition-与python类似rust的iterator除了标准库还有itertools提供更多功能" class="admonition info">
<summary class="admonition-title">
<p>与Python类似，Rust的iterator除了标准库，还有itertools提供更多功能</p>
<p><a class="admonition-anchor-link" href="#admonition-与python类似rust的iterator除了标准库还有itertools提供更多功能"></a></p>
</summary>
<div>
<p>如果标准库中的功能还不能满足你的需求，你可以看看 itertools，它是和 Python 下 itertools 同名且功能类似的工具，提供了大量额外的 adapter。可以看一个简单的例子（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use itertools::Itertools;

fn main() {
    let err_str = &quot;bad happened&quot;;
    let input = vec![Ok(21), Err(err_str), Ok(7)];
    let it = input
        .into_iter()
        .filter_map_ok(|i| if i &gt; 10 { Some(i * 2) } else { None });
    // 结果应该是：vec![Ok(42), Err(err_str)]
    println!(&quot;{:?}&quot;, it.collect::&lt;Vec&lt;_&gt;&gt;());
}
</code></pre></pre>
<p>在实际开发中，我们可能从一组 Future 中汇聚出一组结果，里面有成功执行的结果，也有失败的错误信息。</p>
<p>如果想对成功的结果进一步做 filter/map，那么标准库就无法帮忙了，就需要用 itertools 里的 filter_map_ok()。</p>
</div>
</details>
<h2 id="特殊的切片str"><a class="header" href="#特殊的切片str">特殊的切片：&amp;str</a></h2>
<details id="admonition-stringstring和str的区别与联系" class="admonition info">
<summary class="admonition-title">
<p>String、&amp;String和&amp;str的区别与联系</p>
<p><a class="admonition-anchor-link" href="#admonition-stringstring和str的区别与联系"></a></p>
</summary>
<div>
<p>我们来看一种特殊的切片：&amp;str。之前讲过，String 是一个特殊的 Vec<u8>，所以在 String 上做切片，也是一个特殊的结构 &amp;str。</p>
<p>对于 String、&amp;String、&amp;str，很多人也经常分不清它们的区别.</p>
<p>在&amp;str。对于 &amp;String 和 &amp;str，如果你理解了上文中 &amp;Vec<T> 和 &amp;[T] 的区别，那么它们也是一样的：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867212.jpg" alt="&amp;String和&amp;str" /></p>
</div>
</details>
<details id="admonition-string在解引用时会转换成str" class="admonition info">
<summary class="admonition-title">
<p>String在解引用时会转换成&amp;str</p>
<p><a class="admonition-anchor-link" href="#admonition-string在解引用时会转换成str"></a></p>
</summary>
<div>
<p>可以用下面的代码验证（代码）：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::fmt;
fn main() {
    let s = String::from(&quot;hello&quot;);
    // &amp;String 会被解引用成 &amp;str
    print_slice(&amp;s);
    // &amp;s[..] 和 s.as_str() 一样，都会得到 &amp;str
    print_slice(&amp;s[..]);

    // String 支持 AsRef&lt;str&gt;
    print_slice1(&amp;s);
    print_slice1(&amp;s[..]);
    print_slice1(s.clone());

    // String 也实现了 AsRef&lt;[u8]&gt;，所以下面的代码成立
    // 打印出来是 [104, 101, 108, 108, 111]
    print_slice2(&amp;s);
    print_slice2(&amp;s[..]);
    print_slice2(s);
}

fn print_slice(s: &amp;str) {
    println!(&quot;{:?}&quot;, s);
}

fn print_slice1&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
    println!(&quot;{:?}&quot;, s.as_ref());
}

fn print_slice2&lt;T, U&gt;(s: T)
where
    T: AsRef&lt;[U]&gt;,
    U: fmt::Debug,
{
    println!(&quot;{:?}&quot;, s.as_ref());
}
</code></pre></pre>
</div>
</details>
<details id="admonition-字符的列表array和字符串string有什么关系和区别" class="admonition question">
<summary class="admonition-title">
<p>字符的列表array和字符串String有什么关系和区别</p>
<p><a class="admonition-anchor-link" href="#admonition-字符的列表array和字符串string有什么关系和区别"></a></p>
</summary>
<div>
<p>我们直接写一段代码来看看：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::iter::FromIterator;

fn main() {
    let arr = ['h', 'e', 'l', 'l', 'o'];
    let vec = vec!['h', 'e', 'l', 'l', 'o'];
    let s = String::from(&quot;hello&quot;);
    let s1 = &amp;arr[1..3];
    let s2 = &amp;vec[1..3];
    // &amp;str 本身就是一个特殊的 slice
    let s3 = &amp;s[1..3];
    println!(&quot;s1: {:?}, s2: {:?}, s3: {:?}&quot;, s1, s2, s3);

    // &amp;[char] 和 &amp;[char] 是否相等取决于长度和内容是否相等
    assert_eq!(s1, s2);
    // &amp;[char] 和 &amp;str 不能直接对比，我们把 s3 变成 Vec&lt;char&gt;
    assert_eq!(s2, s3.chars().collect::&lt;Vec&lt;_&gt;&gt;());
    // &amp;[char] 可以通过迭代器转换成 String，String 和 &amp;str 可以直接对比
    assert_eq!(String::from_iter(s2), s3);
}
</code></pre></pre>
<blockquote>
<p>可以看到，字符列表可以通过迭代器转换成 String，String 也可以通过 chars() 函数转换成字符列表，如果不转换，二者不能比较。</p>
</blockquote>
</div>
</details>
<details id="admonition-下图把数组列表字符串以及它们的切片放在一起比较可以更好地理解它们的区别" class="admonition info">
<summary class="admonition-title">
<p>下图把数组、列表、字符串以及它们的切片放在一起比较，可以更好地理解它们的区别：</p>
<p><a class="admonition-anchor-link" href="#admonition-下图把数组列表字符串以及它们的切片放在一起比较可以更好地理解它们的区别"></a></p>
</summary>
<div>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867332.jpg" alt="数组、列表、字符串和各自的切片" /></p>
</div>
</details>
<h2 id="boxt"><a class="header" href="#boxt">Box&lt;[T]&gt;</a></h2>
<details id="admonition-box和vect对比" class="admonition info">
<summary class="admonition-title">
<p>Box&lt;[T]&gt;和Vec<T>&amp;[T]对比</p>
<p><a class="admonition-anchor-link" href="#admonition-box和vect对比"></a></p>
</summary>
<div>
<p>切片主要有三种使用方式：</p>
<ul>
<li>切片的只读引用 &amp;[T]</li>
<li>切片的可变引用 &amp;mut [T]: 和&amp;[T]类似</li>
<li>Box&lt;[T]&gt;</li>
</ul>
<p>现在我们来看看 Box&lt;[T]&gt;。</p>
<p>Box&lt;[T]&gt; 是一个比较有意思的存在，它和 Vec<T> 有一点点差别：</p>
<ul>
<li>Vec<T> 有额外的 capacity，可以增长；</li>
<li>而 Box&lt;[T]&gt; 一旦生成就固定下来，没有 capacity，也无法增长。</li>
</ul>
<p>Box&lt;[T]&gt; 和切片的引用 &amp;[T] 也很类似：</p>
<ol>
<li>它们都是在栈上有一个包含长度的胖指针，指向存储数据的内存位置。</li>
<li>区别是：Box&lt;[T]&gt; 只会指向堆，&amp;[T] 指向的位置可以是栈也可以是堆；</li>
<li>此外，Box&lt;[T]&gt; 对数据具有所有权，而 &amp;[T] 只是一个借用。</li>
</ol>
<hr />
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/16%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AVecT%E3%80%81%5BT%5D%E3%80%81Box%5BT%5D%20%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B9%88%EF%BC%9F-4867436.jpg" alt="" /></p>
</div>
</details>
<details id="admonition-那么如何产生-box-呢" class="admonition question">
<summary class="admonition-title">
<p>那么如何产生 Box&lt;[T]&gt; 呢？</p>
<p><a class="admonition-anchor-link" href="#admonition-那么如何产生-box-呢"></a></p>
</summary>
<div>
<blockquote>
<p>目前可用的接口就只有一个：从已有的 Vec<T> 中转换。</p>
</blockquote>
<p>我们看代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">
use std::ops::Deref;

fn main() {
    let mut v1 = vec![1, 2, 3, 4];
    v1.push(5);
    println!(&quot;cap should be 8: {}&quot;, v1.capacity());

    // 从 Vec&lt;T&gt; 转换成 Box&lt;[T]&gt;，此时会丢弃多余的 capacity
    let b1 = v1.into_boxed_slice();
    let mut b2 = b1.clone();

    let v2 = b1.into_vec();
    println!(&quot;cap should be exactly 5: {}&quot;, v2.capacity());

    assert!(b2.deref() == v2);

    // Box&lt;[T]&gt; 可以更改其内部数据，但无法 push
    b2[0] = 2;
    // b2.push(6);
    println!(&quot;b2: {:?}&quot;, b2);

    // 注意 Box&lt;[T]&gt; 和 Box&lt;[T; n]&gt; 并不相同
    let b3 = Box::new([2, 2, 3, 4, 5]);
    println!(&quot;b3: {:?}&quot;, b3);

    // b2 和 b3 相等，但 b3.deref() 和 v2 无法比较
    assert!(b2 == b3);
    // assert!(b3.deref() == v2);
}
</code></pre></pre>
<hr />
<blockquote>
<p>运行代码可以看到:</p>
</blockquote>
<ol>
<li>Vec<T> 可以通过 into_boxed_slice() 转换成 Box&lt;[T]&gt;</li>
<li>Box&lt;[T]&gt; 也可以通过 into_vec() 转换回 Vec<T>。</li>
</ol>
<blockquote>
<p>这两个转换都是很轻量的转换，只是变换一下结构，不涉及数据的拷贝。</p>
</blockquote>
<p>区别是:</p>
<ol>
<li>当 Vec<T> 转换成 Box&lt;[T]&gt; 时，没有使用到的容量就会被丢弃，所以整体占用的内存可能会降低。</li>
<li>而且 Box&lt;[T]&gt; 有一个很好的特性是，不像 Box&lt;[T;n]&gt; 那样在编译时就要确定大小，它可以在运行期生成，以后大小不会再改变。</li>
</ol>
<p>所以，当我们需要在堆上创建固定大小的集合数据，且不希望自动增长，那么，可以先创建 Vec<T>，再转换成 Box&lt;[T]&gt;。</p>
<blockquote>
<p>tokio 在提供 broadcast channel 时，就使用了 Box&lt;[T]&gt; 这个特性，你感兴趣的话，可以自己看看<a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/sync/broadcast.rs#L447">源码</a>。</p>
</blockquote>
</div>
</details>

            </main>

            <!--            <script src="https://utteranc.es/client.js"-->
            <!--                    repo="RustMagazine/rust_magazine_2022"-->
            <!--                    issue-term="title"-->
            <!--                    theme="github-light"-->
            <!--                    crossorigin="anonymous"-->
            <!--                    async></script>-->

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                    <a rel="prev" href="3_2_containers.html" class="mobile-nav-chapters previous"
                       title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="3_2_2_hashmap.html" class="mobile-nav-chapters next"
                       title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="3_2_containers.html" class="nav-chapters previous" title="Previous chapter"
               aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="3_2_2_hashmap.html" class="nav-chapters next" title="Next chapter"
               aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
    </nav>

</div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/mermaid/mermaid.min.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid-init.js"></script>
    <script type="text/javascript" src="assets/smart-anchor.js"></script>
    <script type="text/javascript" src="assets/pagetoc/sidebar.js"></script>

</body>
</html>
